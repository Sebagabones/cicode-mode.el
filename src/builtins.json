{
    "_objectcallmethod": {
        "doc": "Calls a specific method for an ActiveX object. (See the documentation for your ActiveX object for details on methods and properties.)\nFor example:\nis not allowed because the return value of a function cannot be modified. The following should be used instead:",
        "example": "//Calculate a value and pass to ActiveX control\n_ObjectCallMethod(hControl, \"DoSomething\", CalcValue());\n\nINT nMyValue;\n//Calculate Value\nnMyValue = CalcValue();\n//Pass Value to ActiveX control\n_ObjectCallMethod(hControl, \"DoSomething\", nMyValue);",
        "name": "_ObjectCallMethod",
        "params": [
            {
                "paramdescription": "The handle for the object (as returned by the ObjectByName() function).",
                "paramname": "hObject"
            },
            {
                "paramdescription": "The name of the method.",
                "paramname": "sMethod"
            },
            {
                "paramdescription": "A variable length parameter list of method arguments. The variables will be passed however you enter them, and will then be coerced into appropriate automation types. Likewise, any values modified by the automation call will be written back - with appropriate coercion - into the passed Cicode variable.",
                "paramname": "vParameters"
            }
        ],
        "returnType": "The return value from the method - if successful, otherwise an error code is returned.",
        "syntax": "_ObjectCallMethod(hObject, sMethod, vParameters)"
    },
    "_objectgetproperty": {
        "doc": "Gets a specific property of an ActiveX object.",
        "example": "No example found",
        "name": "_ObjectGetProperty",
        "params": [
            {
                "paramdescription": "The handle for the object (as returned by the ObjectByName() function).",
                "paramname": "hObject"
            },
            {
                "paramdescription": "The name of the property you want to get.",
                "paramname": "sProperty"
            }
        ],
        "returnType": "The value of the property - if successful, otherwise error code is returned.",
        "syntax": "_ObjectGetProperty(hObject, sProperty)"
    },
    "_objectsetproperty": {
        "doc": "Sets a specific property of an ActiveX object.",
        "example": "No example found",
        "name": "_ObjectSetProperty",
        "params": [
            {
                "paramdescription": "The handle for the object (as returned by the ObjectByName() function).",
                "paramname": "hObject"
            },
            {
                "paramdescription": "The name of the property you want to set.",
                "paramname": "sProperty"
            },
            {
                "paramdescription": "The value to which the property will be set. This value can be of any data type. Appropriate coercion will take place when creating the equivalent automation parameter.",
                "paramname": "vValue"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "_ObjectSetProperty(hObject, sProperty, vValue)"
    },
    "abs": {
        "doc": "Calculates the absolute (positive) value of a number. The absolute value of a number is the number without its sign.",
        "example": "Variable=Abs(-67);\n! Sets Variable to 67.\nVariable=Abs(67);\n! Sets Variable to 67.",
        "name": "Abs",
        "params": [
            {
                "paramdescription": "Any number.",
                "paramname": "Number"
            }
        ],
        "returnType": "The absolute (positive) value of Number.",
        "syntax": "Abs(Number)"
    },
    "acccontrol": {
        "doc": "Controls accumulators, for example, motor run hours. You can reset the values of Run Time, Totalizer Inc, and No. of Starts (defined in the Accumulator database), re-read these values from the I/O device, or flush pending writes of these values to the I/O device.",
        "example": "! Reset all accumulator variables for accumulator \"MCC123\".\nAccControl(\"MCC123\", 3, \"ClusterXYZ\");",
        "name": "AccControl",
        "params": [
            {
                "paramdescription": "The name of the accumulator or a mask for the names of accumulators. You can use the following wildcards:\n* matches all following characters, for example, \"Motor*\" matches all accumulators starting with the word \"Motor\"\n? matches any single character, for example, \"Motor?10\" matches \"MotorA10\" and \"MotorB10\"\nThis argument can be prefixed by the name of the cluster for example ClusterName.AccumulatorName.",
                "paramname": "sName"
            },
            {
                "paramdescription": "The mode of the control:\n1 - Reset Run Time and Totalizer value\n2 - Reset No. of Starts\n3 - Reset Run Time, Totalizer value, and No. of Starts\n4 - Flush pending writes to the I/O device\n5 - Re-read Run Time, Totalizer value, and No. of Starts from the I/O device",
                "paramname": "nMode"
            },
            {
                "paramdescription": "Name of the cluster in which the accumulator resides. This is optional if you have one cluster or are resolving the reports server via the current cluster context. The argument is enclosed in quotation marks \"\".",
                "paramname": "sClusterName"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "AccControl(sName, nMode [, sClusterName] )"
    },
    "accumbrowseclose": {
        "doc": "The AccumBrowseClose function terminates an active data browse session and cleans up all resources associated with the session.\nThis function is a non-blocking function. It does not block the calling Cicode task.",
        "example": "No example found",
        "name": "AccumBrowseClose",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by a AccumBrowseOpen call.",
                "paramname": "iSession"
            }
        ],
        "returnType": "0 (zero) if the accumulator browse session exists, otherwise an error code is returned.",
        "syntax": "AccumBrowseClose(iSession)"
    },
    "accumbrowsefirst": {
        "doc": "The AccumBrowseFirst function places the data browse cursor at the first record.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "AccumBrowseFirst",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by a AccumBrowseOpen call.",
                "paramname": "iSession"
            }
        ],
        "returnType": "0 (zero) if the accumulator browse session exists, otherwise an error code is returned.",
        "syntax": "AccumBrowseFirst(iSession)"
    },
    "accumbrowsegetfield": {
        "doc": "The AccumBrowseGetField function retrieves the value of the specified field from the record the data browse cursor is currently referencing.\nThis function is a non-blocking function. It does not block the calling Cicode task.",
        "example": "STRING fieldValue = \"\";\nSTRING fieldName = \"TYPE\";\nINT errorCode = 0;\n...\nfieldValue = AccumBrowseGetField(iSession, sFieldName);\nIF fieldValue <> \"\" THEN\n    // Successful case\nELSE\n    // Function returned an error\nEND\n...",
        "name": "AccumBrowseGetField",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by aAccumBrowseOpen call.",
                "paramname": "Session"
            },
            {
                "paramdescription": "The name of the field that references the value to be returned.Supported fields are:\nSee Browse Function Field Reference for information about fields.",
                "paramname": "FieldName"
            }
        ],
        "returnType": "The value of the specified field as a string. An empty string may or may not be an indication that an error has been detected. The last error should be checked in this instance to determine if an error has actually occurred.",
        "syntax": "STRING AccumBrowseGetField(LONG Session, STRING FieldName)"
    },
    "accumbrowsenext": {
        "doc": "The AccumBrowseNext function moves the data browse cursor forward one record. If you call this function after you have reached the end of the records, error412 is returned (Databrowse session EOF).\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "AccumBrowseNext",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by a AccumBrowseOpen call.",
                "paramname": "iSession"
            }
        ],
        "returnType": "0 (zero) if the accumulator browse session exists, otherwise an error code is returned.",
        "syntax": "AccumBrowseNext(iSession)"
    },
    "accumbrowsenumrecords": {
        "doc": "The AccumBrowseNumRecords function returns the number of records that match the filter criteria.\nThis function is a non-blocking function. It does not block the calling Cicode task.",
        "example": "INT numRecords = 0;\n...\nnumRecords = AccumBrowseNumRecords(iSession);\nIF numRecords <> 0 THEN\n    // Have records\nELSE\n    // No records\nEND\n...",
        "name": "AccumBrowseNumRecords",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by a AccumBrowseOpen call.",
                "paramname": "iSession"
            }
        ],
        "returnType": "The number of records that have matched the filter criteria. A value of 0 denotes that no records have matched. A value of -1 denotes that the browse session is unable to provide a fixed number. This may be the case if the data being browsed changed during the browse session.",
        "syntax": "AccumBrowseNumRecords(iSession)"
    },
    "accumbrowseopen": {
        "doc": "The AccumBrowseOpen function initiates a new browse session and returns a handle to the new session that can be used in subsequent data browse function calls.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "INT iSession;\n...\niSession = AccumBrowseOpen(\"NAME=ABC*\", \"NAME,AREA\",\n\"ClusterA,ClusterB\");\nIF iSession <> -1 THEN\n    // Successful case\nELSE\n    // Function returned an error\nEND\n...",
        "name": "AccumBrowseOpen",
        "params": [
            {
                "paramdescription": "A filter expression specifying the records to return duringthe browse. An empty string indicates that all records will bereturned. Where a fieldname is not specified in the filter, it isassumed to be tagname. For example, the filter \"AAA\" isequivalent to \"name=AAA\".\nThe following regular expressions are supported: *expr, expr*, and *expr*. To specify an exclusion filtering condition, use the NOT keyword after the = operator. ",
                "paramname": "Filter"
            },
            {
                "paramdescription": "Specifies via a comma delimited string the columns to bereturned during the browse. An empty string indicates thatthe server will return all available columns. Supported fieldsare:\nAREA, CLUSTER, EQUIPMENT, NAME, PRIV, RUNNING, STARTS, TOTALISER, TRIGGER, VALUE.\nSee Browse Function Field Reference for information about fields.",
                "paramname": "Fields"
            },
            {
                "paramdescription": "An optional parameter that specifies via a comma delimitedstring the subset of the clusters to browse. An empty stringindicates that the connected clusters will be browsed.",
                "paramname": "Clusters"
            }
        ],
        "returnType": "Returns an integer handle to the browse session. Returns -1 when an error is detected.",
        "syntax": "INT AccumBrowseOpen( STRING Filter, STRING Fields [, STRING Clusters] )"
    },
    "accumbrowseprev": {
        "doc": "The AccumBrowsePrev function moves the data browse cursor back one record.  If you call this function after you have reached the beginning of the records, error 412 is returned (Databrowse session EOF).\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "AccumBrowsePrev",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by a AccumBrowseOpen call.",
                "paramname": "iSession"
            }
        ],
        "returnType": "0 (zero) if the accumulator browse session exists, otherwise an error code is returned.",
        "syntax": "AccumBrowsePrev(iSession)"
    },
    "alarmack_ciref": {
        "doc": "Acknowledges alarms. You can acknowledge the alarm where the cursor is positioned, one or more alarm lists on the active page, a whole category of alarms, or alarms of a particular priority.\nThis command takes the currently logged in user into account. In other words, only the alarms that the user can see are acknowledged.\nYou would normally call this function from a keyboard command. No action is taken if the specified alarms have already been acknowledged.\nIf this function is not called from a foreground task, it becomes a blocking function.",
        "example": "No example found",
        "name": "AlarmAck_CIREF",
        "params": [
            {
                "paramdescription": "The type of acknowledgment:\n0 - Acknowledge a single alarm.\nSet Value to the AN where the alarm is displayed.\nIf Value is set to 0, the current cursor position will be used.\n1 - Acknowledge a page of alarms. An alarm page can contain more than one alarm list:\nSet Value to the AN where the alarm list is displayed.\nSet Value to 0 to acknowledge the (displayed) alarm list (on the active page) where the cursor is positioned.\nSet Value to -1 to acknowledge all (displayed) alarm lists on the active page.This only applies to alarm lists created using AlarmDsp (and not those created using AlarmDspLast).\n2 - Acknowledge a category of alarms:\nSet Value to the alarm category (0 to 16375) of the alarms to be acknowledged. Please be aware that Alarm category 0 indicates all categories; alarm category 255 indicates hardware alarms.\nSet Value to the group number to acknowledge a group of categories.\n3 - Acknowledge alarms of a specific priority.\nSet Value to the alarm priority (0-255) of the alarms to be acknowledged. Alarm priority 0 indicates all priorities.Hardware alarms are not affected by priority.Set Value to the group handle to acknowledge a group of alarms of different priorities.",
                "paramname": "Mode"
            },
            {
                "paramdescription": "Used with Mode 1 and 2 to specify which alarms toacknowledge.",
                "paramname": "Value"
            },
            {
                "paramdescription": "Used with Mode 2 or 3 to specify the name of the cluster inwhich the alarms being acknowledged reside. This argumentis optional if the client is connected to only one clustercontaining an Alarm Server or are resolving the alarm servervia the current cluster context.\nThis argument is not required where:\nthe mode is 2 and the value is 255 (hardware alarm category).\nThis argument is enclosed in quotation marks \"\".",
                "paramname": "sClusterName"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code will return",
        "syntax": "INT AlarmAck(INT Mode, INT Value [, STRING ClusterName])"
    },
    "alarmackrec": {
        "doc": "Acknowledges alarms by record number on both the primary and standby alarm servers. This function can be called from alarm server or client and should not be used with a MsgRPC() call to the alarm server.\nThis is a blocking function. If the function is called from a foreground task that is unable to block, an error will be returned.",
        "example": "/* Acknowledge all unacknowledged (Type 1) alarms of the specified \nalarm category. */\nFUNCTION\nAutoAccept(INT Category)\n    INT Current;\n    INT Next;\n    Current=AlarmFirstCatRec(Category,1);\n    WHILE Current<>-1 DO\n        Next=AlarmNextCatRec(Current,Category,1);\n        AlarmAckRec(Current);\n        Current=Next;\n    END\nEND",
        "name": "AlarmAckRec",
        "params": [
            {
                "paramdescription": "The alarm record number, returned from any of the following alarm functions:\nTo store this value, use data type Int in Cicode or Long for variable tags (Long needs 4 bytes).",
                "paramname": "Record"
            },
            {
                "paramdescription": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\".",
                "paramname": "ClusterName"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "INT AlarmAckRec(LONG Record [, STRING ClusterName] )"
    },
    "alarmacktag": {
        "doc": "Acknowledge a specified alarm.\nIf this function is not called from a foreground task, it becomes a blocking function.  ",
        "example": "No example found",
        "name": "AlarmAckTag",
        "params": [
            {
                "paramdescription": "A string that identifies the alarm to acknowledge. It can be one of the following:\nAn alarm tag — for example, \"Fire1\"\nAn alarm equipment item — for example, \"Motor1.AlarmFire\"\nSpecify an empty string (\" \") to match all alarm tags.",
                "paramname": "Tag"
            },
            {
                "paramdescription": "The cluster where the tag resides",
                "paramname": "ClusterName"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code will return",
        "syntax": "INT AlarmAckTag(STRING Tag,  [, STRING ClusterName])"
    },
    "alarmactive_ciref": {
        "doc": "Determines if any alarms are active in the user's area. Call this function from the Page Strings database, to display an alarm message at a specified AN on a graphics page. You can specify the type of alarms, for example, active hardware alarms or disabled non-hardware alarms.",
        "example": "No example found",
        "name": "AlarmActive_CIREF",
        "params": [
            {
                "paramdescription": "The type of alarms to check:\nNon-hardware alarms\n0 - Active alarms\n1 - Unacknowledged alarms, ON and OFF\n2 - Highest priority unacknowledged alarm\n3 - Disabled alarms\nHardware alarms\n5 - Active alarms\n6 - Unacknowledged alarms, ON and OFF",
                "paramname": "nType"
            },
            {
                "paramdescription": "The name of the cluster to check for active alarms. If this argument is blank or empty, the function will check the connected clusters.",
                "paramname": "sClusterName"
            }
        ],
        "returnType": "N/A or missing",
        "syntax": "AlarmActive(Type [, sClusterName] )"
    },
    "alarmcatgetformat": {
        "doc": "Returns the display format string of the specified alarm category.",
        "example": "sFormat = AlarmCatGetFormat(0, 0);\n! sFormat is assigned to the format string as defined in the Alarm Format field of the Alarm Categories form for category 0 in your project.",
        "name": "AlarmCatGetFormat",
        "params": [
            {
                "paramdescription": "The alarm category.",
                "paramname": "Category"
            },
            {
                "paramdescription": "The type of display format string:\n0 - Alarm format. Default value.\n1 - Summary format.\n2 - SOE format\nThe display format string of the specified category. If the alarm category is not specifically defined or it has no format string specified in your project, the format string of category 0 will be returned.",
                "paramname": "Type"
            }
        ],
        "returnType": "The display format string of the specified category. If the alarm category is not specifically defined or it has no format string specified in your project, the format string of category 0 will be returned.",
        "syntax": "STRING AlarmCatGetFormat(INT Category [, INT Type] )"
    },
    "alarmclear": {
        "doc": "Clears an acknowledged (and off) alarm from the active alarm list. You can clear the alarm where the cursor is positioned, one or more alarm lists on the active page, a whole category of alarms, or alarms of a particular priority.\nIf you set the [Alarm]AckHold parameter to 1, alarms that go off and have been acknowledged are not removed from the active list until this function is called.",
        "example": "No example found",
        "name": "AlarmClear",
        "params": [
            {
                "paramdescription": "The type of clear:\n0 - Clear a single alarm where the cursor is positioned:\nSet Value to 0 (zero) - it is not used.\n1 - Clear a page of alarms. AN alarm page can contain more than one alarm list:\nSet Value to the AN where the alarm list is displayed.\nSet Value to 0 to clear the (displayed) alarm list (on the active page) where the cursor is positioned.\nSet Value to -1 to clear every (displayed) alarm list on the active page.\n2 - Clear a category of alarms:\nSet Value to the alarm category (0 to 16375) of the alarms to clear. Please be aware that alarm category 0 indicates all categories; alarm category 255 indicates hardware alarms.\nSet Value to the group number to clear a group of categories.\n3 - Clear alarms of a specific priority.\nSet Value to the alarm priority (0-255) of the alarms to be cleared.\nAlarm priority 0 indicates all priorities. Hardware alarms are not affected by priority. Set Value to the group handle to clear a group of alarms of different priorities.",
                "paramname": "Mode"
            },
            {
                "paramdescription": "Used with Mode 1 or 2 to specify which alarms to clear.",
                "paramname": "Value"
            },
            {
                "paramdescription": "Used with Mode 2 or 3 to specify the name of the cluster in which the alarms being cleared reside. This argument is optional if the client is connected to only one cluster containing an Alarm Server or you are resolving the alarm server via the current cluster context.\nThis argument is not required where:\nthe mode is 2 and the value is 255 (hardware alarm category).\nThis argument is enclosed in quotation marks \"\".",
                "paramname": "ClusterName"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "AlarmClear(Mode, Value [, ClusterName] )"
    },
    "alarmclearrec": {
        "doc": "Clears an alarm by its record number on both the Primary and Standby Alarms Servers. This function can be called from Alarm Server or Client. \nThis function should not be used with a MsgRPC() call to the Alarm Server.",
        "example": "No example found",
        "name": "AlarmClearRec",
        "params": [
            {
                "paramdescription": "The alarm record number, returned from any of the following alarm functions:\nAlarmFirstCatRec() or AlarmNextCatRec() - used to search for a record by alarm category, area, and type (acknowledged, disabled, etc.).\nAlarmFirstPriRec() or AlarmNextPriRec() - used to search for a record by alarm priority, area, and type (acknowledged, disabled, etc.).\nAlarmFirstTagRec() or AlarmNextTagRec() - used to search for a record by alarm tag, name, and description. \nAlarmGetDsp() - used to find the record that is displayed at a specified AN, for either an alarm list or alarm summary entry. Set the sField argument in AlarmGetDsp() to \"RecNo\". \nTo store this value, use data type Int in Cicode or Long for variable tags (Long needs 4 bytes).",
                "paramname": "Record"
            },
            {
                "paramdescription": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\".",
                "paramname": "ClusterName"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "AlarmClearRec(Record [, ClusterName] )"
    },
    "alarmcleartag": {
        "doc": "Clears alarms by Tag on both the Primary and Standby Alarms Servers. \nIf this function is not called from a foreground task, it becomes a blocking function.  ",
        "example": "No example found",
        "name": "AlarmClearTag",
        "params": [
            {
                "paramdescription": "A string that identifies the alarm to acknowledge. It can be one of the following:\nAn alarm tag — for example, \"Fire1\"\nAn alarm equipment item — for example, \"Motor1.AlarmFire\"\nSpecify an empty string (\" \") to match all alarm tags.",
                "paramname": "Tag"
            },
            {
                "paramdescription": "The cluster where the tag resides,",
                "paramname": "ClusterName"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "INT AlarmClearTag(STRING Tag,  [, STRING ClusterName])"
    },
    "alarmcomment": {
        "doc": "Allows an operator to add a comment to a selected alarm summary or SOE entry during runtime. You would normally call this function from a keyboard command.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "AlarmComment",
        "params": [
            {
                "paramdescription": "The comment to add to the alarm summary entry or SOE entry. Currently for the Alarm summary page the maximum length of a comment is 128 characters. The maximum length for a comment on the SOE page is 244 characters. If you exceed the maximum length it will be truncated and an ellipsis appended.",
                "paramname": "Comment"
            },
            {
                "paramdescription": "An animation identifier. Enter the value of the AN where the alarm is displayed. If AN is not specified, the default value will be 0, which means the current cursor position will be used.",
                "paramname": "AN"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "INT AlarmComment(STRING Comment[,INT An])"
    },
    "alarmcommentrecid": {
        "doc": "Allows an operator to add a comment to a selected alarm summary or SOE entry during runtime. You would normally call this function from a keyboard command.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "AlarmCommentRecID",
        "params": [
            {
                "paramdescription": "The comment to add to the alarm summary entry or SOE entry. Currently for the Alarm summary page the maximum length of a comment is 128 characters. The maximum length for a comment on the SOE page is 244 characters. If you exceed the maximum length it will be truncated and an ellipsis appended.",
                "paramname": "Comment"
            },
            {
                "paramdescription": "Can be the value: \nfrom the SOE record’s \"RECORDID\" field. OR\nfrom the Summary record’s \"SUMMARYID\" field.",
                "paramname": "RecID"
            },
            {
                "paramdescription": "Following are the nListType values for SOE or Alarm Summary lists.\n 10 - All summary alarms 15 - Sequence of events with configuration events filtered out 16 - Sequence of events with configuration events ",
                "paramname": "nListType"
            },
            {
                "paramdescription": "Specifies the cluster context for the alarms displayed in the list.",
                "paramname": "sCluster"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "INT AlarmCommentRecID(sComment, sRecID, nListType, sCluster)"
    },
    "alarmcount": {
        "doc": "Counts the available alarms for the selected filter criteria. \nAlarm counts  will display and update at different rates depending on how extensively they are used in your system. Consider the number of counts being used on pages, combined with the number of clients using those pages at any one time. The number of configured alarms will also contribute to the alarm count update rate. For example on a system with 50,000 configured alarms and 10 clients displaying a page with 100 alarm counts, the alarm count update rate will be degraded.\nThis function is a blocking function if CachedMode is set to zero (0).",
        "example": "INT  iRet, iErr;     // return values\nINT  iCountWhile=0;  // loop counter\n\n\n// counts all unacknowledged alarms, ON and OFF, default non-blocking cicode\niRet = AlarmCount(1);\niErr = IsError();    //check error code\n\n//  repeat the above non-blocking function\nINT  iCountWhile=0;  // loop counter\nWHILE  (iRet = 0) AND (iErr = 0) AND (iCountWhile < 10) DO\n\tSleepMS(100);\n\tiRet = AlarmCount(1);\n\tiErr = IsError();\n\tiCountWhile = iCountWhile + 1;\nEND\n\n// counts all disabled alarms, default non-blocking cicode\niRet = AlarmCount(3);\niErr = IsError();\n\n// repeat this non-blocking function as shown above (see while loop)\n// counts all unacknowledged alarms with category 10 – non-blocking cicode\niRet = AlarmCount(1,\"Category=10\",1,1);\niErr = IsError();\n\n// repeat this non-blocking function as shown above (see while loop)\n// counts all unacknowledged alarms with category 10 – blocking cicode\niRet = AlarmCount(1,\"Category=10\",1,0);\nIF  iRet = -1 THEN\n    iErr = IsError();    // get error code)\nEND",
        "name": "AlarmCount",
        "params": [
            {
                "paramdescription": "The type of alarms to display:\nNon-hardware alarms\nHardware alarms\nAlarm General\nIf you omit the Type, the default is 1.",
                "paramname": "nType"
            },
            {
                "paramdescription": "A filter name OR filter text\nSee the topic Implementing Alarm Filters Using Cicode in the main Plant SCADA help for more information about filter syntax.",
                "paramname": "FilterCriteria"
            },
            {
                "paramdescription": "Optional length of time (in seconds) that the count will remain in memory. Default is 30 seconds.",
                "paramname": "KeepAliveSeconds"
            },
            {
                "paramdescription": "Optional flag that causes the current cached value to be supplied even when the value is being refreshed. This makes the function non-blocking. If the property has not yet been cached, an error is set.\n0 - Do not force cached read. Cicode is blocking\n1 - Force cached read. Cicode is non-blocking\nDefault value is 1 (true).\nA count in memory will be accessed when its filter criteria matches a subsequent filter criteria and the count’s \"KeepAliveSeconds\" period will be extended.\nA count will stay in the cache for 'at least' the duration specified by \"KeepAliveSeconds\", and may stay in the cache for an unspecified period of time before being discarded.\nThe period set for an existing count will be overridden in the event a longer duration is set using 'KeepAliveSeconds\". \nA count that is added to the cache is not immediately available for reading, so a foreground call to AlarmCount that causes a new count to be added will return a value of -1 and an error of 345 (Data not ready).",
                "paramname": "CachedMode"
            }
        ],
        "returnType": "Returns counted alarms for the selected filter criteria. Returns -1 when an error is detected.",
        "syntax": "LONG AlarmCount(INT Type [, STRING FilterCriteria [, LONG KeepAliveSeconds [, INT CachedMode]]])"
    },
    "alarmcountequipment": {
        "doc": "Counts the available alarms for specified equipment and referenced equipment in conjunction with the selected filter criteria.",
        "example": "// counts all unacknowledged alarms, ON and OFF (default non-blocking Cicode) in Plant.Area.Room* equipment and any lower-level equipment.\niRet = AlarmCountEquipment(1, \"Plant.Area.Room\");\n\n// counts all disabled alarms (default non-blocking Cicode) in any lower-level equipment from Plant.Area.\niRet = AlarmCountEquipment(3, \"Plant.Area.\");\n\n// counts all unacknowledged alarms in Plant.Area.Room*, Plant.Area.Flat* equipment and any lower-level equipment with category 10 (non-blocking Cicode)\niRet = AlarmCountEquipment(1, \"Plant.Area.Room, Plant.Area.Flat\", \"Category=10\", 1, 1);\n\n// counts all unacknowledged alarms in Plant.Area.Room.*, Plant.Area.Flat.* equipment and any lower-level equipment with category 10 (non-blocking Cicode). \n// Note that Plant.Area.Room and Plat.Area.Flat equipment themselves do not count as a period is given at the end of each expression.\niRet = AlarmCountEquipment(1, \"Plant.Area.Room., Plant.Area.Flat.\", \"Category=10\", 1, 1);\n\n\t\t\t\t\t",
        "name": "AlarmCountEquipment",
        "params": [
            {
                "paramdescription": "The type of alarms to display:\nNon-hardware alarms\n0 - All active alarms, that is Types 1 and 2\n1 - All unacknowledged alarms, ON and OFF\n2 - All acknowledged ON alarms\n3 - All disabled alarms\n4 - All configured (non-hardware) alarms, that is Types 0 to 3, plus acknowledged OFF alarms.\nHardware alarms\n5 - All active alarms, that is Types 6 and 7\n6 - All unacknowledged alarms, ON and OFF\n7 - All acknowledged ON alarms\n8 - All disabled alarms\n9 - All configured alarms, that is Types 5 to 8\nAlarm General\n11 - All ON alarms\n12 - All OFF alarms\n13 - All ON hardware alarms\n14 - All OFF hardware alarms\n17 - All unacknowledged ON alarms\n18 - All unacknowledged OFF alarms\nIf you omit the Type, the default is 1.",
                "paramname": "nType"
            },
            {
                "paramdescription": " A comma-separated list of equipment names or categories (RefCat) to filter alarms prior to applying the other filter specified on the FilterCriteria argument. This field has been extended to support wildcards, and hence accept partial filter strings.",
                "paramname": "EquipmentFilter"
            },
            {
                "paramdescription": " Expression has been extended to allow:\n “EQUIPMENT=XYZ” (this may have an asterisk as the last character, which is interpreted as a wildcard). This restricts the result to only those equipment that match this filter. Multiple “EQUIPMENT=” elements are treated as having an “OR” condition. This filter is evaluated on the client.\n “REFCAT=XYZ” (this may have an asterisk as the first and/or last character, these are interpreted as wildcards).This restricts the result to only those equipment that match this filter, however, this filter is applied after any equipment filters and reference expansions have taken place. Multiple “REFCAT=” elements are treated as having an “OR” condition, and these in turn are treated as having an “AND” condition with the “EQUIPMENT=” elements. This filter is evaluated on the client.\n“PAGE=XYZ” (this is an exact literal match only).This restricts the result to only those equipment that match this filter. This filter cannot be combined with other equipment filter elements. This filter is evaluated on the server.\nWhat this means is:\n “XYZ” is equivalent to “EQUIPMENT=XYZ*”\n “PAGE=PageXYZ” includes all the equipment that have “PageXYZ” in the PAGE field in the Equipment table.",
                "paramname": "Filtering using an equipment name or category (RefCat)"
            },
            {
                "paramdescription": "A filter name OR filter text.\nSee the topic Implementing Alarm Filters Using Cicode in the main Plant SCADA help for more information about filter syntax.",
                "paramname": "FilterCriteria"
            },
            {
                "paramdescription": "Optional length of time (in seconds) that the count will remain in memory. Default is 30 seconds.",
                "paramname": "KeepAliveSeconds"
            },
            {
                "paramdescription": "Optional flag that causes the current cached value to be supplied even when the value is being refreshed. This makes the function non-blocking. If the property has not yet been cached, an error is set.\n0 - Do not force cached read. Cicode is blocking\n1 - Force cached read. Cicode is non-blocking\nDefault value is 1 (true).\nA count in memory will be accessed when its filter criteria matches a subsequent filter criteria and the count’s \"KeepAliveSeconds\" period will be extended.\nA count will stay in the cache for 'at least' the duration specified by \"KeepAliveSeconds\", and may stay in the cache for an unspecified period of time before being discarded.\nThe period set for an existing count will be overridden in the event a longer duration is set using 'KeepAliveSeconds\". \nA count that is added to the cache is not immediately available for reading, so a foreground call to AlarmCount that causes a new count to be added will return a value of -1 and an error of 345 (Data not ready).",
                "paramname": "CachedMode"
            },
            {
                "paramdescription": "0 - Do not include alarms belonging to referenced equipment in Alarm Count for current equipment\n1 - Include alarms belonging to referenced equipment in Alarm Count for current equipment. This is set by default.",
                "paramname": "IncludingReference"
            }
        ],
        "returnType": "Returns counted alarms for the selected filter criteria. Returns -1 when an error is detected.",
        "syntax": "LONG AlarmCountEquipment(INT Type [,STRING EquipmentFilter, [STRING FilterCriteria [, LONG KeepAliveSeconds [, INT CachedMode, [INT IncludingReference]]]]])"
    },
    "alarmcountlist": {
        "doc": "Counts the available alarms for the selected filter criteria.",
        "example": "// counts all listed alarms on the slected alarm page  \nINT  iRet, iErr;      // return values\niRet = AlarmCountList(21);    \nIF   iRet = -1 THEN\n     iErr = IsError();    // get error code)\nEND\n\t\t\t\t",
        "name": "AlarmCountList",
        "params": [
            {
                "paramdescription": "An animation identifier of an alarm list.",
                "paramname": "AN"
            }
        ],
        "returnType": "Returns counted alarms for the selected filter criteria. Returns -1 when an error is detected.",
        "syntax": "LONG AlarmCountList(INT AN)"
    },
    "alarmdelete": {
        "doc": "Deletes alarm summary entries that are currently displayed. You can delete the alarm where the cursor is positioned, one or more alarm lists on the active page, a whole category of alarms, or alarms of a particular priority.\nYou would normally call this function from a keyboard command. \nIf this function is not called from a foreground task, it becomes a blocking function.\nAlarmDelete(Mode, Value [, ClusterName] )\nMode: \n0 - Delete a single alarm.\n1 - Delete a page of alarms. AN alarm page can contain more than one alarm list:\n2 - Delete a category of alarms.\n3 - Delete alarms of a specific priority.\nValue: \nClusterName: \n0 (zero) if successful, otherwise an error is returned.",
        "example": "No example found",
        "name": "AlarmDelete",
        "params": [
            {
                "paramdescription": "The type of deletion:\n0 - Delete a single alarm.\nSet Value to the AN where the alarm is displayed.\nIf Value is set to 0, the current cursor position will be used.\n1 - Delete a page of alarms. AN alarm page can contain more than one alarm list:\nSet Value to the AN where the alarm list is displayed. \nSet Value to 0 to delete the (displayed) alarm list (on the active page) where the cursor is positioned.\nSet Value to -1 to delete every (displayed) alarm list on the active page. \n2 - Delete a category of alarms.\nSet Value to the alarm category (0-16375) of the alarms to delete. Please be aware that alarm category 0 indicates all categories; alarm category 255 indicates hardware alarms.\nSet Value to the group number to delete a group of categories.\n3 - Delete alarms of a specific priority.\nSet Value to the alarm priority (0-255) of the alarms to be deleted.\nAlarm priority 0 indicates all priorities. Hardware alarms are not affected by priority. Set Value to the group handle to delete a group of alarms of different priorities.",
                "paramname": "Mode"
            },
            {
                "paramdescription": "Used with Mode 1 or 2 to specify which alarms to delete.",
                "paramname": "Value"
            },
            {
                "paramdescription": "Used with Mode 2 or 3 to specify the name of the cluster in which the alarms being deleted reside. This argument is optional if the client is connected to only one cluster containing an Alarm Server or you are resolving the alarm server via the current cluster context. This argument is enclosed in quotation marks \"\".",
                "paramname": "ClusterName"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "AlarmDelete(Mode, Value [, ClusterName] )"
    },
    "alarmdisable": {
        "doc": "Disables alarms. You can disable the alarm where the cursor is positioned, one or more alarm lists on the active page, a whole category of alarms, or alarms of a particular priority.\nYou would normally call this function from a keyboard command. No action is taken if the alarms are already disabled. Use the AlarmEnable() function to re-enable an alarm.\nAfter you disable an alarm, the behavior is determined by the [Alarm]DisplayDisable parameter for your system to choose between taking the alarm off scan or suppressing it from the active alarm display.\nIf this function is not called from a foreground task, it becomes a blocking function. ",
        "example": "No example found",
        "name": "AlarmDisable",
        "params": [
            {
                "paramdescription": "The type of disable:\n0 - Disable a single alarm.\nSet Value to the AN where the alarm is displayed.\nIf Value is set to 0, the current cursor position will be used. \n1 - Disable a page of alarms. An alarm page can contain more than one alarm list:\nSet Value to the AN where the alarm list is displayed.\nSet Value to 0 to disable the (displayed) alarm list (on the active page) where the cursor is positioned.\nSet Value to -1 to disable all (displayed) alarm lists on the active page. This only applies to alarm lists created using AlarmDsp (and not those created using AlarmDspLast).\n2 - Disable a category of alarms.\nSet Value to the alarm category (0-16375) of the alarms to be disabled. Please be aware that alarm category 0 indicates all categories; alarm category 255 indicates hardware alarms.\nSet Value to the group number to disable a group of categories.\n3 - Disable alarms of a specific priority.\nSet Value to the alarm priority (0-255) of the alarms to be disabled.\nAlarm priority 0 indicates all priorities. Hardware alarms are not affected by priority. Set Value to the group handle to disable a group of alarms of different priorities.",
                "paramname": "Mode"
            },
            {
                "paramdescription": "Used with Mode 1 and 2 to specify which alarms to disable.",
                "paramname": "Value"
            },
            {
                "paramdescription": "Used with Mode 2 or 3 to specify the name of the clusterwhere the alarms being disabled reside in. This argument isoptional if the client is connected to only one clustercontaining an alarm server, or if the alarm server is resolved via the current cluster context.\nThis argument is not required where:\nthe mode is 2 and the value is 255 (hardware alarm category).\nThis argument is enclosed in quotation marks \"\".",
                "paramname": "ClusterName"
            },
            {
                "paramdescription": "A date/time variable that indicates when the alarm will no longer be disabled. If this parameter is omitted or set to 0, the alarm will be disabled indefinitely.",
                "paramname": "EndTime"
            },
            {
                "paramdescription": "An optional comment limited to 200 characters explaining why the alarm is disabled. If the comment exceeds 200 characters, hardware error 274 (\"Invalid argument passed\") will be displayed.",
                "paramname": "Comment"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "INT AlarmDisable(INT Mode, INT Value [, STRING ClusterName [, INT EndTime [, STRING Comment]]] )"
    },
    "alarmdisablerec": {
        "doc": "Disables alarms by record number on both the Primary and Standby Alarms Servers. This function can be called from Alarm Server or Client and should not be used with a MsgRPC() call to the Alarm Server.\nThis is a blocking function. If the function is called from a foreground task that is unable to block, an error will be returned.",
        "example": "No example found",
        "name": "AlarmDisableRec",
        "params": [
            {
                "paramdescription": "The alarm record number, returned from any of the following alarm functions:\nTo store this value, use data type Int in Cicode or Long for variable tags (Long needs 4 bytes).",
                "paramname": "Record"
            },
            {
                "paramdescription": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\".",
                "paramname": "ClusterName"
            },
            {
                "paramdescription": "A date/time variable that indicates when the alarm will no longer be disabled. If this parameter is omitted or set to 0, the alarm will be disabled indefinitely.",
                "paramname": "EndTime"
            },
            {
                "paramdescription": "An optional comment limited to 200 characters explaining why the alarm is disabled. If the comment exceeds 200 characters, hardware error 274 (\"Invalid argument passed\") will be displayed.",
                "paramname": "Comment"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "INT AlarmDisableRec(LONG Record [, STRING ClusterName [, INT EndTime [, STRING Comment]]] )"
    },
    "alarmdisabletag": {
        "doc": "Disables alarms by Tag on both the Primary and Standby Alarms Servers. \nIf this function is not called from a foreground task, it becomes a blocking function.  ",
        "example": "No example found",
        "name": "AlarmDisableTag",
        "params": [
            {
                "paramdescription": "A string that identifies the alarm to acknowledge. It can be one of the following:\nAn alarm tag — for example, \"Fire1\"\nAn alarm equipment item — for example, \"Motor1.AlarmFire\"\nSpecify an empty string (\" \") to match all alarm tags.",
                "paramname": "Tag"
            },
            {
                "paramdescription": "The cluster where the tag resides.",
                "paramname": "ClusterName"
            },
            {
                "paramdescription": "A date/time variable that indicates when the alarm will no longer be disabled. If this parameter is omitted or set to 0, the alarm will be disabled indefinitely.",
                "paramname": "EndTime"
            },
            {
                "paramdescription": "An optional comment explaining why the alarm is disabledAn optional comment limited to 200 characters explaining why the alarm is disabled. If the comment exceeds 200 characters, hardware error 274 (\"Invalid argument passed\") will be displayed.",
                "paramname": "Comment"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "INT AlarmDisableTag(STRING Tag, [, STRING ClusterName] [, INT EndTime [, STRING Comment]]] )"
    },
    "alarmdsp": {
        "doc": "Displays an alarm list, starting at a specified AN and then on subsequent ANs. You specify the number of alarms to display, the type of alarms and the name of the cluster the alarms belong to, for example, active hardware alarms or disabled non-hardware alarms in cluster XYZ. Before you call this function, you need to first add animation points to the graphics page for each alarm to be displayed.\nIf you only need to display the standard alarm page, use the PageAlarm function - it uses this AlarmDsp() function to display alarms. If you need more control over the display of alarms you can use this function, but only to display alarms on the alarm page. Use the AlarmDspLast function to display alarms on another graphics page (it uses less memory).",
        "example": "No example found",
        "name": "AlarmDsp",
        "params": [
            {
                "paramdescription": "The AN where the first alarm is to display.",
                "paramname": "AN"
            },
            {
                "paramdescription": "The number of alarms to display.",
                "paramname": "Count"
            },
            {
                "paramdescription": "The type of alarms to display:\nNon-hardware alarms\n0 - All active alarms, that is Types 1 and 2\n1 - All unacknowledged alarms, ON and OFF\n2 - All acknowledged ON alarms\n3 - All disabled alarms\n4 - All configured (non-hardware) alarms, that is Types 0 to 3, plus acknowledged OFF alarms.\nHardware alarms\n5 - All active alarms, that is Types 6 and 7\n6 - All unacknowledged alarms, ON and OFF\n7 - All acknowledged ON alarms\n8 - All disabled alarms\n9 - All configured alarms, that is Types 5 to 8\nAlarm Summary\n10 - All summary alarms\n15 – Sequence of events with configuration events filtered out\n16 - Sequence of events\nAlarm General\n11 - All ON alarms\n12 - All OFF alarms\n13 - All ON hardware alarms\n14 - All OFF hardware alarms\n17 - All unacknowledged ON alarms\n18 - All unacknowledged OFF alarms\nIf you omit the Type, the default is 1.",
                "paramname": "nType"
            },
            {
                "paramdescription": "The cluster name to which the alarms belong. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\".\nIf the client is connected to only one cluster containing an Alarms Server then this argument is optional, the list returned will be limited to alarms within this cluster.\nIf the client is connected to clusters containing more than one Alarms Server then the Cluster Name needs to be specified. If a cluster name is not specified, alarms are returned for all clusters.",
                "paramname": "ClusterName"
            },
            {
                "paramdescription": "Makes call to Alarm Server to update the ALMCB but does not automatically perform the animation of the data when the result is returned.",
                "paramname": "NoDraw"
            },
            {
                "paramdescription": "",
                "paramname": "CallbackFunc"
            },
            {
                "paramdescription": "",
                "paramname": "Callback function to associate with the return of the ALMCB data from the Alarm Server."
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "INT AlarmDsp(INT AN, Count [, INT Type] [, STRING ClusterName] [, INT NoDraw] [, STRING CallbackFunc] )"
    },
    "alarmdspclusteradd": {
        "doc": "Adds a cluster to a client's alarm list. Alarms in the specified cluster (that correspond to the mode set in AlarmDsp) will be added to the alarm list at the AN number.",
        "example": "No example found",
        "name": "AlarmDspClusterAdd",
        "params": [
            {
                "paramdescription": "The AN used in the original AlarmDsp() call.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The name of the cluster to be used for this alarm list. The argument is enclosed in quotation marks (\"\").",
                "paramname": "sClusterName"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "AlarmDspClusterAdd(nAN, sClusterName)"
    },
    "alarmdspclusterinuse": {
        "doc": "Determines if a cluster is included in a client's alarm list.",
        "example": "No example found",
        "name": "AlarmDspClusterInUse",
        "params": [
            {
                "paramdescription": "The AN used in the original AlarmDsp() call.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The name of the cluster to query an alarm list for to determine if it's included. The argument is enclosed in quotation marks (\"\").",
                "paramname": "sClusterName"
            }
        ],
        "returnType": "Returns a Boolean value: True(1) if successful, otherwise False(0) is returned.",
        "syntax": "AlarmDspClusterInUse(nAN, sClusterName)"
    },
    "alarmdspclusterremove": {
        "doc": "Removes a cluster from a client's alarms list. Alarms for the specified cluster will be removed from the alarms list at the AN number. \nIf the cluster to be removed is the last cluster, the call will be unsuccessful.",
        "example": "No example found",
        "name": "AlarmDspClusterRemove",
        "params": [
            {
                "paramdescription": "The AN used in the original AlarmDsp() call.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The name of the cluster to remove from this alarm list. The argument is enclosed in quotation marks (\"\").",
                "paramname": "sClusterName"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "AlarmDspClusterRemove(nAN, sClusterName)"
    },
    "alarmdsplast": {
        "doc": "Displays the latest  alarms, at a specified AN with the cluster name. Use this function to display the last alarms. You can specify the number of alarms to display of a specified type, for example, active hardware alarms or disabled non-hardware alarms.",
        "example": "No example found",
        "name": "AlarmDspLast",
        "params": [
            {
                "paramdescription": "The AN where the last alarms are to be displayed.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The number of alarms to display. If you omit the Count, the default is 1.",
                "paramname": "Count"
            },
            {
                "paramdescription": "",
                "paramname": "nType"
            },
            {
                "paramdescription": "The type of alarms to display:\nNon-hardware alarms\n0 - All active alarms, that is Types 1 and 2\n1 - All unacknowledged alarms, ON and OFF\n2 - All acknowledged ON alarms\n3 - All disabled alarms\n4 - All configured (non-hardware) alarms, that is Types 0 to 3, plus acknowledged OFF alarms.\nHardware alarms\n5 - All active alarms, that is Types 6 and 7\n6 - All unacknowledged alarms, ON and OFF\n7 - All acknowledged ON alarms\n8 - All disabled alarms\n9 - All configured alarms, that is Types 5 to 8\nAlarm Summary\n10 - All summary alarms\n15 – Sequence of events with configuration events filtered out\n16 - Sequence of events\nAlarm General\n11 - All ON alarms\n12 - All OFF alarms\n13 - All ON hardware alarms\n14 - All OFF hardware alarms\n17 - All unacknowledged ON alarms\n18 - All unacknowledged OFF alarms\nIf you omit the Type, the default is 1.",
                "paramname": "nType"
            },
            {
                "paramdescription": "The cluster name to which the alarms belong. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\".\nIf a cluster name is not specified, alarms are returned for all clusters.",
                "paramname": "sClusterName"
            },
            {
                "paramdescription": "Makes call to Alarm Server to update the ALMCB but does not automatically perform the animation of the data when the result is returned.",
                "paramname": "iNoDraw"
            },
            {
                "paramdescription": "Callback function to associate with the return of the ALMCB data from the Alarm Server.",
                "paramname": "sCallbackFunc"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "AlarmDspLast(nAN [, nCount] [, nType] [, sClusterName] [, iNoDraw] [, sCallbackFunc] )"
    },
    "alarmdspnext": {
        "doc": "Displays the next page of alarms. This function pages down (scrolls) the alarms displayed by the AlarmDsp() function. You would normally call this function from a keyboard command.",
        "example": "No example found",
        "name": "AlarmDspNext",
        "params": [
            {
                "paramdescription": "The AN where the alarm list is displayed, or:\n-1 - Scroll every alarm list displayed on the page.\n0 - Scroll the alarm list where the cursor is positioned.\n0 (zero) if successful, otherwise an error code is returned.",
                "paramname": "AN"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "INT AlarmDspNext(INT AN)"
    },
    "alarmdspprev": {
        "doc": "Displays the previous page of alarms. This function pages up (scrolls) the alarms displayed by the AlarmDsp() function. You would normally call this function from a keyboard command.",
        "example": "No example found",
        "name": "AlarmDspPrev",
        "params": [
            {
                "paramdescription": "The AN where the alarm list is displayed, or:\n-1 - Scroll every alarm list displayed on the page.\n0 - Scroll the alarm list where the cursor is positioned.\n0 (zero) if successful, otherwise an error code is returned.",
                "paramname": "AN"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "INT AlarmDspPrev(INT AN)"
    },
    "alarmenable": {
        "doc": "Enables an alarm on the active alarm list. You can enable the alarm where the cursor is positioned, one or more alarm lists on the active page, a whole category of alarms, or alarms of a particular priority.\nNo action is taken if the alarms are already enabled. You would normally call this function from a keyboard command.\nIf this function is not called from a foreground task, it becomes a blocking function. ",
        "example": "No example found",
        "name": "AlarmEnable",
        "params": [
            {
                "paramdescription": "The type of enable:\n0 - Enable a single alarm where the cursor is positioned.\nSet Value to the AN where the alarm list is displayed.\n If Value is set to 0, the current cursor position will be used. \n1 - Enable a page of alarms. An alarm page can contain more than one alarm list:\nSet Value to the AN where the alarm list is displayed.\nSet Value to 0 to enable the (displayed) alarm list (on the active page) where the cursor is positioned.\nSet Value to -1 to enable all (displayed) alarm lists on the active page. This only applies to alarm lists created using AlarmDsp (and not those created using AlarmDspLast).\n2 - Enable a category of alarms.\nSet Value to the alarm category (0-16375) of the alarms to be enabled. Please be aware that alarm category 0 indicates all categories; alarm category 255 indicates hardware alarms.\nSet Value to the group number to enable a group of categories.\n3 - Enable alarms of a specific priority.\nSet Value to the alarm priority (0-255) of the alarms to be enabled.\nAlarm priority 0 indicates all priorities. Hardware alarms are not affected by priority. 3) Set Value to the group handle to enable a group of alarms of different priorities.",
                "paramname": "Mode"
            },
            {
                "paramdescription": "Used with Mode 0, 1 and 2 to specify which alarms to enable.",
                "paramname": "Value"
            },
            {
                "paramdescription": "Used with Mode 2 or 3 to specify the name of the clusterwhere the alarms being enabled reside in. This argument isoptional if the client is connected to only one clustercontaining an Alarm Server or are resolving the alarm servervia the current cluster context.\nThis argument is not required where:\nthe mode is 2 and the value is 255 (hardware alarm category).\nThis argument is enclosed in quotation marks \"\".",
                "paramname": "ClusterName"
            },
            {
                "paramdescription": "Forces acknowledgment of an alarm after it is enabled. The accepted values are:\n0 — (default) enforced acknowledgment will not be applied.\n1 — alarm will be acknowledged when enabled.",
                "paramname": "bAcknowledge"
            },
            {
                "paramdescription": "",
                "paramname": ""
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "INT AlarmEnable(INT Mode, INT Value [, STRING ClusterName [, INT bAcknowledge]] )"
    },
    "alarmenablerec": {
        "doc": "Enables alarms by record number on both the Primary and Standby Alarms Servers. This function can be called from Alarm Server or Client and should not be used with a MsgRPC() call to the Alarm Server.\nThis is a blocking function. If the function is called from a foreground task that is unable to block, an error will be returned.",
        "example": "No example found",
        "name": "AlarmEnableRec",
        "params": [
            {
                "paramdescription": "The alarm record number, returned from any of the following alarm functions:\nAlarmFirstCatRec() or AlarmNextCatRec() — used to search for a record by alarm category, area, and type (acknowledged, disabled, etc.).\nAlarmFirstPriRec() or AlarmNextPriRec() — used to search for a record by alarm priority, area, and type (acknowledged, disabled, etc.).\nAlarmFirstTagRec() or AlarmNextTagRec() — used to search for a record by alarm tag, name, and description.\nAlarmGetDsp() — used to find the record that is displayed at a specified AN, for either an alarm list or alarm summary entry. Set the sField argument in AlarmGetDsp() to \"RecNo\".\nTo store this value, use data type Int in Cicode or Long for variable tags (Long needs 4 bytes).",
                "paramname": "Record"
            },
            {
                "paramdescription": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\".",
                "paramname": "ClusterName"
            },
            {
                "paramdescription": "Forces acknowledgment of an alarm after it is enabled. The accepted values are:\n0 — (default) enforced acknowledgment will not be applied.\n1 — alarm will be acknowledged when enabled.",
                "paramname": "bAcknowledge"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "INT AlarmEnableRec(INT Record [, STRING ClusterName [, INT bAcknowledge]])"
    },
    "alarmenabletag": {
        "doc": "Enables alarms by Tag on both the Primary and Standby Alarms Servers. \nIf this function is not called from a foreground task, it becomes a blocking function.  ",
        "example": "No example found",
        "name": "AlarmEnableTag",
        "params": [
            {
                "paramdescription": "A string that identifies the alarm to acknowledge. It can be one of the following:\nAn alarm tag — for example, \"Fire1\"\nAn alarm equipment item — for example, \"Motor1.AlarmFire\"\nSpecify an empty string (\" \") to match all alarm tags.",
                "paramname": "Tag"
            },
            {
                "paramdescription": "The cluster where the tag resides,",
                "paramname": "ClusterName"
            },
            {
                "paramdescription": "Forces acknowledgment of an alarm after it is enabled. The accepted values are:\n0 — (default) enforced acknowledgment will not be applied.\n1 — alarm will be acknowledged when enabled.",
                "paramname": "bAcknowledge"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "INT AlarmEnableTag(STRING Tag [, STRING ClusterName [, INT bAcknowledge]])"
    },
    "alarmeventque_ciref": {
        "doc": "Opens the alarm event queue. The Alarms Server writes events into this queue as they are processed. These events include activated, reset, acknowledged, enabled and disabled alarms. To read events from this queue, use the QueRead() or QuePeek() functions. The data put into the queue is the alarm record identifier (into the Type field) and the alarm event format (into the Str field). The function puts every state change into the queue and Plant SCADA does not use this queue for anything.\nTo use this function, you need to enable the alarm event queue with the [Alarm]EventQue parameter. This parameter will tell the Alarms Server to start placing events into the queue. The [Alarm]EventFmt parameter defines the format of the data placed into the string field. You can enable the EventQue parameter without setting the event format so that the Alarms Server does not place a formatted string into the queue. \nEnabling this formatting feature can increase CPU loading and reduce performance of theAlarms Server as every alarm is formatted and placed in the queue. You shouldreconsider using this feature if a decrease in performance is noticeable.\nThe maximum length of each queue is controlled by the [Code]Queue parameter. You may need to adjust this parameter so as not to miss alarm events. When the queue is full, the Alarms Server will discard events.",
        "example": "No example found",
        "name": "AlarmEventQue_CIREF",
        "params": [],
        "returnType": "The handle of the alarm event queue, or -1 if the queue cannot be opened.",
        "syntax": "AlarmEventQue()"
    },
    "alarmfilterclose": {
        "doc": "This function removes the named filter from memory.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "// This example shows how to open and close the named filter \"Myfilter\"\n// nothing of interest is done with the filter in this example.\nINT nOpenModeOld = 0;\nINT nOpenModeNew = 1;\nINT nOpenModeAny = 2;\nINT nCloseModeManual = 0;\nINT nCloseModePageChanged = 1;\nINT nError;\nnError = AlarmFilterOpen(\"MyFilter\", nOpenModeNew, nCloseModeManual);\nIF nError = 0 THEN\n   nError = AlarmFilterClose(\"MyFilter\");\nEND",
        "name": "AlarmFilterClose",
        "params": [
            {
                "paramdescription": "Name of Filter",
                "paramname": "FilterName"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "INT AlarmFilterClose(STRING FilterName)"
    },
    "alarmfiltereditappend": {
        "doc": "The AlarmFilterEditAppend function takes a session handle and a filter expression as parameters. It appends the provided expression to the current filter session content without any validation. This does not apply to all filters on the list (see AlarmFilterEditCommit).",
        "example": "// This example shows how to update an edit session.\n// This example requires that the edit session hEdit exists.\n// This example shows how you would split the parts of the filter\n// to avoid an overflow error when handling strings.\t\t\t\t\nINT nError;\nnError = AlarmFilterEditSet(hEdit,\"Tag\");\nnError = AlarmFilterEditAppend(hEdit,\"=\");\t\t\t\nnError = AlarmFilterEditAppend(hEdit,\"Dig*\");\nnError = AlarmFilterEditCommit(hEdit);\nsRet = AlarmFilterEditFirst(iHndl); // Tag=Dig*;\n\t\t\t",
        "name": "AlarmFilterEditAppend",
        "params": [
            {
                "paramdescription": "Session handle for the historical list previously returned by the function AlarmFilterEditOpen().",
                "paramname": "Session"
            },
            {
                "paramdescription": "",
                "paramname": "FilterCriteria"
            },
            {
                "paramdescription": "See the topic Implementing Alarm Filters Using Cicode in the main Plant SCADA help for more information about filter syntax.\n0 (zero) if the alarm filter session exists, otherwise an error code is returned.",
                "paramname": "Filter expression as a string. For example:\"(Tag=A) OR (TAG=B)\""
            }
        ],
        "returnType": "0 (zero) if the alarm filter session exists, otherwise an error code is returned.",
        "syntax": "INT AlarmFilterEditAppend(INT hSession, STRING FilterCriteria)"
    },
    "alarmfiltereditappendequipment": {
        "doc": " Appends the provided expression that can include equipment names  to the current filter session content without  validation. ",
        "example": "// This example shows how to update an edit session.\n// This example requires that the edit session hEdit exists.\n// This example assumes that the ExampleEquipment has references to\n//   RefEquipment.RefItem1 and RefEquipment.RefItem2.\nINT nError;\nnError = AlarmFilterEditSet(hEdit, \"\");\nnError = AlarmFilterEditAppendEquipment(hEdit, \"EQUIPMENT=ExampleEquipment\", 1);\nnError = AlarmFilterEditCommit(hEdit);\nsRet = AlarmFilterEditFirst(hEdit); // \"((Cluster=Cluster1 AND Equipment=ExampleEquipment) OR (Cluster=Cluster1 AND Equipment=RefEquipment AND",
        "name": "AlarmFilterEditAppendEquipment",
        "params": [
            {
                "paramdescription": "Session handle for the historical list previously returned by the function AlarmFilterEditOpen(). ",
                "paramname": "hSession"
            },
            {
                "paramdescription": " A comma-separated list of equipment names to filter alarms prior to applying the other filter specified on the FilterCriteria argument. This field has been extended to support wildcards, and hence accept partial filter strings.\n Expression has been extended to allow:\n “EQUIPMENT=XYZ” (this may have an asterisk as the last character, this is interpreted as a wildcard)\nWhat this means is:\n “XYZ” becomes “EQUIPMENT=XYZ*”\n “EQUIPMENT=XYZ” stays as “EQUIPMENT=XYZ”",
                "paramname": "EquipmentFilter"
            },
            {
                "paramdescription": "0 - Do not include alarms belonging to referenced equipment in Filter\n1 - Include alarms belonging to referenced equipment in Filter",
                "paramname": "Ref"
            }
        ],
        "returnType": "0 (zero) if the alarm filter session exists, otherwise an error code is returned.",
        "syntax": "INT AlarmFilterEditAppendEquipment(INT hSession, STRING EquipmentFilter, STRING Ref)"
    },
    "alarmfiltereditclose": {
        "doc": "The AlmFilterEditClose function removes the session from the memory. The filter is not reset and is valid until a new filter is created and applied.\n",
        "example": "No example found",
        "name": "AlarmFilterEditClose",
        "params": [
            {
                "paramdescription": "Session handle for the historical list previously returned by the function AlarmFilterEditOpen().",
                "paramname": "Session"
            }
        ],
        "returnType": "0 (zero) if the alarm filter session exists, otherwise an error code is returned.",
        "syntax": "INT AlarmFilterEditClose(INT hSession)"
    },
    "alarmfiltereditcommit": {
        "doc": "The AlarmFilterEditCommit function takes a session handle as parameter. It validate the filter created in this session and, if valid, applies this filter to the list associated with the session.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "// This example requires that the edit session hEdit exists.\nINT nError;\nnError = AlarmFilterEditSet(hEdit,\"tag=Dig*;Category=1;\");\nnError = AlarmFilterEditCommit(hEdit);\n\t\t\t",
        "name": "AlarmFilterEditCommit",
        "params": [
            {
                "paramdescription": "Session handle for the historical list previously returned by the function AlarmFilterEditOpen().",
                "paramname": "Session"
            }
        ],
        "returnType": "0 (zero) if the alarm filter session exists, otherwise an error code is returned.",
        "syntax": "INT AlarmFilterEditCommit(INT hSession)"
    },
    "alarmfiltereditfirst": {
        "doc": "This function takes a session handle parameter.  It gets the first part of the filter. Each part is either:",
        "example": "No example found",
        "name": "AlarmFilterEditFirst",
        "params": [
            {
                "paramdescription": "Session handle for the historical list previously returned by the function AlarmFilterEditOpen().",
                "paramname": "Session"
            }
        ],
        "returnType": "First part of filter or if does not exist an empty string \"\".",
        "syntax": "STRING AlarmFilterEditFirst(INT hSession)"
    },
    "alarmfilteredithasfield": {
        "doc": "The AlarmFilterEditHasField function checks whether an alarm field name or any field in a set of field names is used in the filter specified in an alarm filter edit session.",
        "example": "No example found",
        "name": "AlarmFilterEditHasField",
        "params": [
            {
                "paramdescription": "Session handle for the historical list previously returned by the function AlarmFilterEditOpen().",
                "paramname": "Session"
            },
            {
                "paramdescription": "The alarm field name or names separated by comma (no space) to be checked if it is used in filter criteria.",
                "paramname": "sFieldName"
            }
        ],
        "returnType": "1 (TRUE) if the filter criteria is valid and alarm field name is used, otherwise 0 (FALSE) is returned.",
        "syntax": "INT AlarmFilterEditHasField(INT hSession, STRING sFieldName)"
    },
    "alarmfiltereditlast": {
        "doc": "This function takes a session handle parameter.  It gets the last part of the filter. Each part is either:",
        "example": "No example found",
        "name": "AlarmFilterEditLast",
        "params": [
            {
                "paramdescription": "Session handle for the historical list previously returned by the function AlarmFilterEditOpen().",
                "paramname": "Session"
            }
        ],
        "returnType": "First part of filter or if does not exist an empty string \"\".",
        "syntax": "STRING AlarmFilterEditLast(hSession)"
    },
    "alarmfiltereditnext": {
        "doc": "This function takes a session handle parameter.  It gets the next part of the filter. Each part is either:",
        "example": "No example found",
        "name": "AlarmFilterEditNext",
        "params": [
            {
                "paramdescription": "Session handle for the historical list previously returned by the function AlarmFilterEditOpen().",
                "paramname": "Session"
            }
        ],
        "returnType": "Next part of filter or if does not exist an empty string \"\".",
        "syntax": "INT AlarmFilterEditNext(INT hSession)"
    },
    "alarmfiltereditopen": {
        "doc": "The AlmFilterEditOpen function creates a session for the historical list (or lists) associated with the provided animation number (AN) or FilterName or all alarm lists displayed on the page via (-1) option. This session is initialised with the current filter applied on the lists.\nIt returns a session handle which will be used as parameter in all other functions to reference the session or -1 if the parameter is not a valid animation number or if this animation number is not linked to an historical list.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "iHndl = AlarmFilterEditOpen(iAN);\niRet = AlarmFilterEditSet(iHndl,\"Tag=Dig*;Category=1;Area=1;\");\niRet = AlarmFilterEditAppend(iHndl, \"Priority<20\");\nsRet = AlarmFilterEditFirst(iHndl);// Tag=Dig*;\nsRet = AlarmFilterEditNext(iHndl);// Category=1;\nsRet = AlarmFilterEditLast(iHndl);// Priority<20;\nsRet = AlarmFilterEditPrev(iHndl);// Area=1;\niRet = AlarmFilterEditClose(iHndl);",
        "name": "AlarmFilterEditOpen",
        "params": [
            {
                "paramdescription": "Name of Filter",
                "paramname": "FilterName"
            },
            {
                "paramdescription": "Animation Number, for example 21 or 11 ",
                "paramname": "AN"
            },
            {
                "paramdescription": "Change the display parameters of all alarm lists displayed on the page",
                "paramname": "-1"
            }
        ],
        "returnType": "Returns a session handle to the filter browse session. Returns -1 when an error is detected.",
        "syntax": "INT AlarmFilterEditOpen(STRING FilterName or INT AN or INT -1 [, INT AutoCloseMode])"
    },
    "alarmfiltereditprev": {
        "doc": "This function takes a session handle parameter.  It gets the previous part of the filter. Each part is either:",
        "example": "No example found",
        "name": "AlarmFilterEditPrev",
        "params": [
            {
                "paramdescription": "Session handle for the historical list previously returned by the function AlarmFilterEditOpen().",
                "paramname": "Session"
            }
        ],
        "returnType": "Previous part of filter or if does not exist an empty string \"\".",
        "syntax": "STRING AlarmFilterEditPrev(INT hSession )"
    },
    "alarmfiltereditset": {
        "doc": "The AlarmFilterEditSet function takes a session handle and a filter expression as parameters. It replaces the current filter session content by the provided expression without any validation. This does not apply to all filters on the list (see AlarmFilterEditCommit).",
        "example": "No example found",
        "name": "AlarmFilterEditSet",
        "params": [
            {
                "paramdescription": "Session handle for the historical list previously returned by the function AlarmFilterEditOpen().",
                "paramname": "Session"
            },
            {
                "paramdescription": "",
                "paramname": "FilterCriteria"
            },
            {
                "paramdescription": "See the topic Implementing Alarm Filters Using Cicode in the main Plant SCADA help for more information about filter syntax.\n Expression has been extended to allow:\n “REFCAT=XYZ” (this may have an asterisk as the first and/or last character, these are interpreted as wildcards)\n“PAGE=XYZ” (this is an exact literal match only)\nWhat this means is:\n “PAGE=PageXYZ” becomes “EQUIPMENT=…” that includes all the equipment that have “PageXYZ” in the PAGE field in the Equipment table “REFCAT=*XYZ*” becomes “EQUIPMENT=…” that includes all the equipment defined in the Equipment References table that matches the supplied pattern and the CATEGORY field in that table. This value MAY contain an asterisk as the first, and or the last character, but the content between any bounding asterisks is treated as literal including an asterisk.\n0 (zero) if the alarm filter session exists, otherwise an error code is returned.",
                "paramname": "Filter expression as a string. For example:\"(Tag=A) OR (TAG=B)\""
            }
        ],
        "returnType": "0 (zero) if the alarm filter session exists, otherwise an error code is returned.",
        "syntax": "INT AlarmFilterEditSet(INT hSession, STRING FilterCriteria)"
    },
    "alarmfilterform": {
        "doc": "Displays a form for specifying filtering criteria for either an alarm list or a named filter. This function uses the AlarmFilterEdit family of Cicode functions to set the filter.\nINT AlarmFilterForm(INT nIndex, INT nMode = 0, INT nDebug = 0, STRING nFilterSrc = \"-1\")\n1 if filter has been applied, 0 if filter has been cleared, or -1 if no change is made.",
        "example": "No example found",
        "name": "AlarmFilterForm",
        "params": [],
        "returnType": "1 if filter has been applied, 0 if filter has been cleared, or -1 if no change is made.",
        "syntax": "INT AlarmFilterForm(INT nIndex, INT nMode = 0, INT nDebug = 0, STRING nFilterSrc = \"-1\")"
    },
    "alarmfilteropen": {
        "doc": "This function creates a named filter. The filter is initialized with empty content (matches all alarms). If unable to open the named filter  an error code is returned.\nINT AlarmFilterOpen(STRING FilterName, INT OpenMode [, INT AutoCloseMode])\n0 (zero) if the filter was opened or created or an error if unsuccessful.",
        "example": "// This example shows how to open and close the named filter \"Myfilter\"\n// nothing of interest is done with the filter in this example.\nINT nOpenModeOld = 0;\nINT nOpenModeNew = 1;\nINT nOpenModeAny = 2;\nINT nCloseModeManual = 0;\nINT nCloseModePageChanged = 1;\nINT nError;\nnError = AlarmFilterOpen(\"MyFilter\", nOpenModeNew, nCloseModeManual);\nIF nError = 0 THEN\n   nError = AlarmFilterClose(\"MyFilter\");\nEND",
        "name": "AlarmFilterOpen",
        "params": [
            {
                "paramdescription": "Name of Filter",
                "paramname": "FilterName"
            },
            {
                "paramdescription": "The values for OpenMode are:\n0 - Open an existing named filter.\n1- Create a new named filter.\n2- Attempts to open an existing named filter. If the named filter does not exist, a new named filter is created.",
                "paramname": "OpenMode"
            },
            {
                "paramdescription": "Values for AutoCloseMode are bit flags. \nThe values for the bits are: \n0 bit - Will not automatically close filter. Use AlarmFilterClose.\n1 bit - When set, the named filter will be closed when the page is changed or otherwise closed.\n0 (zero) if the filter was opened or created or an error if unsuccessful.",
                "paramname": "AutoCloseMode"
            }
        ],
        "returnType": "0 (zero) if the filter was opened or created or an error if unsuccessful.",
        "syntax": "INT AlarmFilterOpen(STRING FilterName, INT OpenMode [, INT AutoCloseMode])"
    },
    "alarmfirstcatrec": {
        "doc": "Searches for the first occurrence of an alarm category and type. You can search all areas, the current area only, or specify an area to limit the search. \nThis function returns an alarm record identifier that you can use in other alarm functions, for example, to acknowledge, disable, or enable the alarm, or to get field data on that alarm. \nThis is a blocking function. If the function is called from a foreground task that is unable to block, the return value will be -1 and a hardware alarm set. Use IsError() to retrieve the error code.",
        "example": "No example found",
        "name": "AlarmFirstCatRec",
        "params": [
            {
                "paramdescription": "The alarm category or group number to match. Set Category to 0 (zero) to match all alarm categories.",
                "paramname": "Category"
            },
            {
                "paramdescription": "The type of alarms to display:\nNon-hardware alarms\n0 - All active alarms, that is Types 1 and 2\n1 - All unacknowledged alarms, ON and OFF\n2 - All acknowledged ON alarms\n3 - All disabled alarms\n4 - All configured (non-hardware) alarms, that is Types 0 to 3, plus acknowledged OFF alarms.\nAlarm General\n11 - All ON alarms\n12 - All OFF alarms\n17 - All unacknowledged ON alarms\n18 - All unacknowledged OFF alarms\nIf you omit the Type, the default is 1.",
                "paramname": "nType"
            },
            {
                "paramdescription": "The area in which to search for alarms. If you do not specify an area, or if you set Area to -1, only the current area will be searched.",
                "paramname": "Area"
            },
            {
                "paramdescription": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\".",
                "paramname": "ClusterName"
            }
        ],
        "returnType": "The alarm record identifier or -1 if no match is found.",
        "syntax": "LONG AlarmFirstCatRec(INT Category, INT Type [, INT Area] [, STRING ClusterName] )"
    },
    "alarmfirstprirec": {
        "doc": "Searches for the first occurrence of an alarm priority and type. You can search all areas, the current area only, or specify an area to limit the search. \nThis function returns an alarm record identifier that you can use in other alarm functions, for example, to acknowledge, disable, or enable the alarm, or to get field data on that alarm. \nThis is a blocking function. If the function is called from a foreground task that is unable to block, the return value will be -1 and a hardware alarm set. Use IsError() to retrieve the error code.",
        "example": "/* Acknowledge all unacknowledged (Type 1) alarms of the specified\nalarm priority. */\nFUNCTION\nAutoAccept(INT iPriority)\n\tINT iCurrent;\n\tINT iNext;\n\tiCurrent=AlarmFirstPriRec(iPriority,1,-1);\n\tWHILE iCurrent <>-1 DO\n\t\tiNext=AlarmNextPriRec(iCurrent,iPriority,1,-1);\n\t\tAlarmAckRec(iCurrent);\n\t\tiCurrent=iNext;\n\tEND\nEND",
        "name": "AlarmFirstPriRec",
        "params": [
            {
                "paramdescription": "The alarm Priority or group handle of a group of alarm priorities. Set Priority to 0 (zero) to match all alarm priorities.\nThe number of alarms to display.",
                "paramname": "Priority"
            },
            {
                "paramdescription": "The type of alarms to display:\nNon-hardware alarms\n0 - All active alarms, that is Types 1 and 2\n1 - All unacknowledged alarms, ON and OFF\n2 - All acknowledged ON alarms\n3 - All disabled alarms\n4 - All configured (non-hardware) alarms, that is Types 0 to 3, plus acknowledged OFF alarms.\nAlarm General\n11 - All ON alarms\n12 - All OFF alarms\n17 - All unacknowledged ON alarms\n18 - All unacknowledged OFF alarms\nIf you omit the Type, the default is 1.",
                "paramname": "nType"
            },
            {
                "paramdescription": "The area in which to search for alarms. If you do not specify an area, or if you set Area to -1, only the current area will be searched.",
                "paramname": "Area"
            },
            {
                "paramdescription": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\".",
                "paramname": "ClusterName"
            }
        ],
        "returnType": "The alarm record identifier or -1 if no match is found. If you do not specify an area, only alarms in the current area on the alarms server are searched.",
        "syntax": "LONG AlarmFirstPriRec(INT Priority, INT Type [, INT Area] [, STRING ClusterName] )"
    },
    "alarmfirsttagrec": {
        "doc": "Searches for the first occurrence of an alarm tag, name, and description. \nThis is a blocking function. If the function is called from a foreground task that is unable to block, the return value will be -1 and a hardware alarm set. Use IsError() to retrieve the error code.\nThis function returns an alarm record identifier that you can use in other alarm functions, for example, to acknowledge, disable, or enable the alarm, or to get field data on that alarm.\nFor complex filtering operations it is more efficient to use the alarm tag browse functions AlmBrowseOpen and AlmBrowseNext.",
        "example": "No example found",
        "name": "AlarmFirstTagRec",
        "params": [
            {
                "paramdescription": "A string that identifies the tag to be matched. It can be one of the following:\nAn alarm tag — for example, \"Fire1\"\nAn alarm equipment item — for example, \"Motor1.AlarmFire\"\nSpecify an empty string (\" \") to match all alarm tags.",
                "paramname": "Tag"
            },
            {
                "paramdescription": "The alarm name to be matched. Specify an empty string (\" \") to match all alarm names.",
                "paramname": "Name"
            },
            {
                "paramdescription": "The alarm description to be matched. Specify an empty string (\" \") to match all alarm descriptions.",
                "paramname": "Description"
            },
            {
                "paramdescription": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\".",
                "paramname": "ClusterName"
            }
        ],
        "returnType": "The alarm record identifier or -1 if no match is found.",
        "syntax": "LONG AlarmFirstTagRec(STRING Tag, STRING Name, STRING Description [, STRING ClusterName] )"
    },
    "alarmgetdelay": {
        "doc": "Gets the delay setting for the alarm the cursor is currently positioned over.",
        "example": "No example found",
        "name": "AlarmGetDelay",
        "params": [
            {
                "paramdescription": "The type of delay:\n0 - Delay (digital alarm/advancedalarm)\n1 - High high delay (analog alarm)\n2 - High delay (analog alarm)\n3 - Low delay (analog alarm)\n4 - Low low delay (analog alarm)\n5 - Deviation delay (analog alarm)",
                "paramname": "nType"
            }
        ],
        "returnType": "The alarm delay if successful, otherwise -1 is returned. Use IsError() to retrieve extended error information.",
        "syntax": "LONG AlarmGetDelay(Type)"
    },
    "alarmgetdelayrec": {
        "doc": "Gets the delay setting for an alarm via the alarm record number.\nThis is a blocking function. If the function is called from a foreground task that is unable to block, the return value will be -1 and a hardware alarm set. ",
        "example": "No example found",
        "name": "AlarmGetDelayRec",
        "params": [
            {
                "paramdescription": "The alarm record number, returned from any of the following alarm functions:",
                "paramname": "Record"
            },
            {
                "paramdescription": "The type of delay:",
                "paramname": "Type"
            },
            {
                "paramdescription": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\".",
                "paramname": "ClusterName"
            }
        ],
        "returnType": "The alarm delay if successful, otherwise -1 is returned. Use IsError() to retrieve extended error information.",
        "syntax": "LONG AlarmGetDelayRec(LONG Record, INT Type [, STRING ClusterName] )"
    },
    "alarmgetdsp": {
        "doc": "Gets field data from the alarm record that is displayed at the specified AN. You can use this function for  Alarm Pages, Sequence of Events pages, and Alarm Summary pages(an Alarm Page, SOE Page, and Alarm Summary needs to be displayed before this function can be used).\nYou can call this function on an Alarms Server or a client to get the contents of any field in the alarm record at that AN.\nYou can return the record number of the alarm record for use in other alarm functions, for example, to acknowledge, disable, or enable an alarm (on an Alarms Server).\nThe AlarmGetDsp() function does not support hardware alarms.\nIf this function is not called from a foreground task, it becomes a blocking function. ",
        "example": "! Display the tag and category for the alarm at the specified AN.\nFUNCTION\nAlarmData(INT AN)\n    STRING Category;\n    STRING Tag;\n    Category=AlarmGetDsp(AN,\"Category\");\n    Tag=AlarmGetDsp(AN,\"Tag\");\n    Prompt(\"Alarm \"+Tag+\" is Category \"+Category);\nEND",
        "name": "AlarmGetDsp",
        "params": [
            {
                "paramdescription": "AN number of an ALMCB Alarm record. Equal to AN where actual ALMCB resides + Offset into the list of ALMCB records.",
                "paramname": "AN"
            },
            {
                "paramdescription": "The name of the field from which the data is retrieved. The contents of the following fields can be retrieved when the Alarm Page isdisplayed:\nThe contents of the any of the above fields (except for State) and thefollowing fields can be retrieved when the Alarm Summary is displayed:\nThe following fields can be retrieved when the Alarm SOE is displayed:\nThe alarm field data (as a string) or empty string \"\".",
                "paramname": "Field"
            }
        ],
        "returnType": "The alarm field data (as a string) or empty string \"\".",
        "syntax": "STRING AlarmGetDsp(INT AN, STRING Field)"
    },
    "alarmgetfieldrec": {
        "doc": "Gets the contents of the specified field in the specified alarm record.\nThis is a blocking function. If the function is called from a foreground task that is unable to block, the return value will be -1 and a hardware alarm set. Use IsError() to retrieve the error code.",
        "example": "FUNCTION\nGetNameFromTag(STRING sTag)\n\tINT record;\n\tSTRING sName\n\trecord = AlarmFirstTagRec(sTag, \"\", \"\");\n\tIF record <> -1 THEN\n\t\tsName = AlarmGetFieldRec(record,\"NAME\");\n\tELSE\n\t\tsName = \"\";\n\tEND\n\tRETURN sName;\nEND",
        "name": "AlarmGetFieldRec",
        "params": [
            {
                "paramdescription": "The alarm record number, returned from any of the following alarm functions:\nTo store this value, use data type Int in Cicode or Long for variable tags (Long needs 4 bytes).",
                "paramname": "Record"
            },
            {
                "paramdescription": "The name of the field from which the data is retrieved. \nSee Browse Function Field Reference for more information about these fields.",
                "paramname": "Field"
            },
            {
                "paramdescription": "The version of an alarm.\nIf an alarm has been triggered more than once in a given period, the version lets you distinguish between different instances of the alarm's activity.\nThe version is used in filtering alarms for display. A query function passes a value to this parameter in order to get field information for a particular alarm.\nThis parameter is not needed when you use AlarmGetFieldRec() for purposes other than filtering. It will default to 0 if omitted.",
                "paramname": "nVer"
            },
            {
                "paramdescription": "Specifies the name of the cluster in which the Alarm Serverresides. This is optional if you have one cluster or areresolving the alarm server via the current cluster context. Theargument is enclosed in quotation marks \"\".",
                "paramname": "ClusterName"
            }
        ],
        "returnType": "The alarm field data (as a string) or empty string \"\".",
        "syntax": "STRING AlarmGetFieldRec(LONG Record, STRING Field [, INT Ver [, STRING  ClusterName]])"
    },
    "alarmgetfiltername": {
        "doc": "Retrieves the name of the  linked named filter for the supplied An. If empty text, there is currently no linked named filter.",
        "example": "// This example shows how to link, unlink and check the linking of a\n// named filter to an alarm list (by its animation number)\n// This example requires that the named filter \"Myfilter\" exists.\nSTRING sName;\nINT nError;\nINT nAnimationNumber=21;\nINT nSetInfoFilterName=12;\nnError = AlarmSetInfo(nAnimationNumber, nSetInfoFilterName, \"MyFilter\");\nIF nError = 0 THEN\n   sName = AlarmGetFilterName(nAnimationNumber); //\"MyFilter\"\nEND\nnError = AlarmSetInfo(nAnimationNumber, nSetInfoFilterName, \"\");\nIF nError = 0 THEN\n   sName = AlarmGetFilterName(nAnimationNumber); //\"\"\nEND\n\n        ",
        "name": "AlarmGetFilterName",
        "params": [
            {
                "paramdescription": "Animation number",
                "paramname": "An"
            }
        ],
        "returnType": "Name of linked filter or \"\".",
        "syntax": "STRING AlarmGetFilterName(INT An)"
    },
    "alarmgetinfo": {
        "doc": "Gets data on the alarm list displayed at a specified AN. Use this function to display the current alarm list information on an alarm page. If only one alarm list has been configured on an alarm page, modes 2 and 3 of this function return the current alarm page information.\nIf this function is not called from a foreground task, it becomes a blocking function. ",
        "example": "/* In the following examples, data is returned on the alarm\nlist where the cursor is positioned. */\npage = AlarmGetInfo(0,0);\n! returns the alarm page number.\noffset = AlarmGetInfo(0,1);\n! returns the alarm list offset.\ncat = AlarmGetInfo(0,2);\n! returns the alarm category displayed.\ntype = AlarmGetInfo(0,3);\n! returns the type of alarms displayed.",
        "name": "AlarmGetInfo",
        "params": [
            {
                "paramdescription": "The AN where the alarm list (with the required information)is displayed. Set the AN to 0 (zero) to get information on thealarm list where the cursor is positioned.",
                "paramname": "AN"
            },
            {
                "paramdescription": "The type of data:\n0 - Alarm page number. The vertical offset (in pages) from the AN where the alarm list commenced. The alarm list need to have scrolled off the first page for this type to return a non-zero value.\n1 - Alarm list offset. The vertical offset (in lines) from the AN where the alarm list commenced. You need to have scrolled off the first page of alarms for this type to return a non zero value.\n2 - Category of alarms displayed on the alarm list. You can use a group number to display a group of categories. \n3 - Type of alarms displayed on the alarm list. See AlarmDsp() for a list of these types.\n7 - Priority of alarms displayed on the alarm list. The return value may be a group number if the alarm list contains alarms of more than one priority.\n8 - Display mode of the alarm list.\n9 - Sorting mode of the alarm list.\n10 – Reading this field is invalid, use the function AlarmGetOrderbyKey.\n11 – Retrieves the error code for the last alarm summary request that was not able to be processed due to a buffer overflow. The last request error value will be reset on the next successful response from the servers.\n12 – Returns values as follows:\n0 = no named filter, and no custom filter.\n1 = named filter set, no custom filter (this means that the content of the named filter is empty).\n2 = no named filter, but there is custom filtering applied (this is possible if the filter is edited via the AN using AlarmFilterEdit functions or some other method).\n3 = named filter set, custom filtering is applied (it is possible that this is due to the named filter being edited or any other method through the AN).\n13 – Returns values as follows;\n0 = data from none of the clusters is ready\n1 = only data from some clusters is ready\n2 = data from all clusters is ready \n14 - Identifies if the data is available for a particular cluster. Returns 1 if data is ready, or 0.\n15 – Auto-refresh mode, where mode is:\n -1 = always auto refresh \n 0 = auto refresh disabled \n1 = auto refresh page 1, disable on all other pages.\n16 – Timeout occurred. This value is set to 0 when a data fetch is initiated for the supplied alarm list (indicated by AN). This value is set to 1 if a timeout occurs within the fetch. The timeout period is specified by the INI parameter [Alarm]AlarmListRequestTimeout.\n 0 = no timeout occurred\n1 = timeout occurred.\n17 – Alarm page number for specified AN is displayed. When the alarm list is scrolled by vertical offset (in lines), the list may span across two pages of alarms. Calling this function returns the page number of the alarm list that the specified AN is displaying. This differs to Type 0 which returns the page number based on the first line of the alarm display.",
                "paramname": "Type"
            },
            {
                "paramdescription": "Specifies the name of the cluster in which the Alarm Server resides. This is only required for type 14. The argument is enclosed in quotation marks \"\".",
                "paramname": "ClusterName"
            }
        ],
        "returnType": "Alarm list data as a numeric value.",
        "syntax": "LONG AlarmGetInfo(INT AN, INT Type  [, STRING  ClusterName])"
    },
    "alarmgetorderbykey": {
        "doc": "Retrieves the list of key(s) that are used to determine the order of the alarm list. These keys can be set by the AlarmSetInfo() function.",
        "example": "page = AlarmGetOrderbyKey(21);\n! returns the order-by key string of the alarm list at AN '21'.",
        "name": "AlarmGetOrderbyKey",
        "params": [
            {
                "paramdescription": "The AN where the alarm list (with the required information) is displayed.",
                "paramname": "nAN"
            }
        ],
        "returnType": "Order-by key (as a string).",
        "syntax": "AlarmGetOrderbyKey(nAN)"
    },
    "alarmgetthreshold": {
        "doc": "Gets the threshold of the analog alarm where the cursor is positioned.",
        "example": "No example found",
        "name": "AlarmGetThreshold",
        "params": [
            {
                "paramdescription": "The type of threshold:\n0 - High high\n1 - High\n2 - Low\n3 - Low low\n4 - Deadband\n5 - Deviation\n6 - Rate of change",
                "paramname": "nType"
            }
        ],
        "returnType": "The alarm threshold.",
        "syntax": "AlarmGetThreshold(Type)"
    },
    "alarmgetthresholdrec": {
        "doc": "Gets the threshold of analog alarms by the alarm record number. \n This is a blocking function. If the function is called from a foreground task that is unable to block, the return value will be -1 and a hardware alarm set. Use IsError() to retrieve the error code.",
        "example": "No example found",
        "name": "AlarmGetThresholdRec",
        "params": [
            {
                "paramdescription": "The alarm record number, returned from any of thefollowing alarm functions:\nTo store this value, use data type Int in Cicode or Long for variable tags (Long needs 4 bytes).",
                "paramname": "Record"
            },
            {
                "paramdescription": "The type of threshold:",
                "paramname": "Type"
            },
            {
                "paramdescription": "Specifies the name of the cluster in which the Alarm Serverresides. This is optional if you have one cluster or areresolving the alarm server via the current cluster context. Theargument is enclosed in quotation marks \"\".",
                "paramname": "ClusterName"
            }
        ],
        "returnType": "The alarm threshold or 0.0.",
        "syntax": "INT AlarmGetThresholdRec(LONG Record, INT Type [, STRING  ClusterName])"
    },
    "alarmhelp": {
        "doc": "Displays the alarm help page (associated with the alarm) where the cursor is positioned. You can assign a help page to each alarm when you define it (using the Digital Alarms or the Analog Alarms database, depending on the type of alarm). You need to also define the help page in the Pages database.",
        "example": "No example found",
        "name": "AlarmHelp",
        "params": [],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "AlarmHelp()"
    },
    "alarmhighestpriority": {
        "doc": "Returns the alarm priority and/or state of the current highest priority alarm for the given equipment in conjunction with the selected filter criteria. ",
        "example": "No example found",
        "name": "AlarmHighestPriority",
        "params": [
            {
                "paramdescription": "",
                "paramname": "Mode"
            },
            {
                "paramdescription": "A comma-separated list of equipment names to filter alarms prior to applying the filter specified in the FilterCriteria argument. Each equipment name may be a part of full equipment name from the root. For example, \"Region.Plant\" will count alarms with equipment names literally starting with \"Region.Plant\" that includes \"Region.PlantA\" and \"Region.Plant.AreaB\". If it is needed to count children of a particular equipment tree only, the equipment name should end with a period('.'). A comma in between equipment expressions is regarded as an OR operator. If an empty string is specified, return Highest Priority for all Alarms.",
                "paramname": "EquipmentFilter"
            },
            {
                "paramdescription": "A filter name OR filter text. See the topic Implementing Alarm Filters Using Cicode in the main Plant SCADA help for more information about filter syntax.",
                "paramname": "FilterCriteria"
            },
            {
                "paramdescription": "Optional length of time (in seconds) for which the count will remain in memory. Default is 30 seconds.\nThe CachedMode parameter affects the behavior of this parameter. Refer to the section below for more information.",
                "paramname": "KeepAliveSeconds"
            },
            {
                "paramdescription": "Optional flag that causes the current cached value to be supplied even when the value is being refreshed. This makes the function non-blocking. If the property has not yet been cached, an error is set.\nDefault value is 1 (true).\nA priority value in the cache is accessed when its filter criteria matches the filter criteria in a subsequent call, and the priority value's \"KeepAliveSeconds\" duration is extended. A priority will stay in the cache for 'at least' the duration specified by \"KeepAliveSeconds\", and may stay in the cache for an unspecified period of time before being discarded.\nThe period set for an existing priority will be overridden in the event a longer duration is set using \"KeepAliveSeconds\".\nA priority that is added to the cache is not immediately available for reading, so a foreground call to AlarmHighestPriority that causes a new count to be added will return a value of -1 and an error of 345 (Data not ready).",
                "paramname": "CachedMode"
            },
            {
                "paramdescription": "",
                "paramname": "IncludingReference"
            },
            {
                "paramdescription": "The rule used to determine the relative priority of alarms (currently fixed to 0).",
                "paramname": "Type"
            }
        ],
        "returnType": "For Mode 0, return the priority ID of the current highest priority alarm.",
        "syntax": "LONG AlarmHighestPriority(INT Mode [, STRING EquipmentFilter] [, STRING FilterCriteria] [, LONG KeepAliveSeconds] [, INT CachedMode] [, INT IncludingReference])"
    },
    "alarmlistcreate": {
        "doc": "Creates an alarms list at a specified AN. ",
        "example": "No example found",
        "name": "AlarmListCreate",
        "params": [
            {
                "paramdescription": "The AN number to associate with the alarms list.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The type of alarms to display in the alarms list:\nNon-hardware alarms\n0 - All active alarms, that is Types 1 and 2\n1 - All unacknowledged alarms, ON and OFF\n2 - All acknowledged ON alarms\n3 - All disabled alarms\n4 - All configured (non-hardware) alarms, that is Types 0 to 3, plus acknowledged OFF alarms.",
                "paramname": "alarm_type"
            },
            {
                "paramdescription": "10 - All summary alarms\n15 – Sequence of events with configuration events filtered out\n16 - Sequence of events",
                "paramname": "Alarm Summary"
            },
            {
                "paramdescription": "11 - All ON alarms\n12 - All OFF alarms\n17 - All unacknowledged ON alarms\n18 - All unacknowledged OFF alarms",
                "paramname": "Alarm General"
            },
            {
                "paramdescription": "The width of the area in which the alarms list will display (in pixels). ",
                "paramname": "width"
            },
            {
                "paramdescription": "The height of the area in which the alarms list will display (in pixels).",
                "paramname": "height"
            },
            {
                "paramdescription": "The height of each row in the alarms list (in pixels). ",
                "paramname": "rowheight"
            },
            {
                "paramdescription": "Determines if the alarms list includes a header row. You need to enter a value; there is no default.\n0 = no header row\n1 = include a header row",
                "paramname": "drawheader"
            },
            {
                "paramdescription": "Specifies the cluster context for the alarms displayed in the list. This value is optional. If not specified, it defaults to all clusters. ",
                "paramname": "sCluster"
            },
            {
                "paramdescription": "The name of the display format applied to the alarms list. This determines the arrangement of columns that are presented. A customized name can be defined for a display format using the parameter [Format]FormatName. \nThis value is optional. If not specified, the default format for the type of alarm specified in the alarm_type parameter is used. ",
                "paramname": "sFormat"
            },
            {
                "paramdescription": "The handle for the font you would like to use in the alarm list rows. This value is optional. If not specified, it defaults to –1 (the default font).\nFont handles are generated by the Cicode function DspFont.",
                "paramname": "hFontRow"
            },
            {
                "paramdescription": "The handle for the font you would like to use in the alarm list header row. This value is optional. If not specified, it defaults to –1 (the default font).\nFont handles are generated by the Cicode function DspFont.",
                "paramname": "hFontHeader"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned. The error code can be obtained by calling the IsError Cicode function.",
        "syntax": "INTAlarmListCreate(INT nAN, INT alarm_type, INT width, INT height, INT rowheight, INT drawheader [, STRING sCluster [, STRING sFormat [, INT hFontRow [, INT hFontHeader]]]])"
    },
    "alarmlistdestroy": {
        "doc": "Destroys an alarms list at a specified AN. ",
        "example": "No example found",
        "name": "AlarmListDestroy",
        "params": [
            {
                "paramdescription": "The AN number associated with the alarms list you want to destroy.",
                "paramname": "nAN"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned. The error code can be obtained by calling the IsError Cicode function.",
        "syntax": "INTAlarmListDestroy(INT nAN)"
    },
    "alarmlistdisplay": {
        "doc": "Displays an alarms list at a specified AN. ",
        "example": "No example found",
        "name": "AlarmListDisplay",
        "params": [
            {
                "paramdescription": "The AN number associated with the alarms list you want to display.",
                "paramname": "nAN"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned. The error code can be obtained by calling the IsError Cicode function.",
        "syntax": "INTAlarmListDisplay(INT nAN)"
    },
    "alarmlistfill": {
        "doc": "Fills an alarms list at a specified AN to be used by another routine (for example, the interlocks processing routine). ",
        "example": "No example found",
        "name": "AlarmListFill",
        "params": [
            {
                "paramdescription": "The AN number associated with the alarms list you want to use.",
                "paramname": "nAN"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned. The error code can be obtained by calling the IsError Cicode function.",
        "syntax": "INTAlarmListFill(INT nAN)"
    },
    "alarmnextcatrec": {
        "doc": "Searches for the next occurrence of an alarm category and type, commencing with the specified alarm record identifier (returned from the previous search through the AlarmFirstCatRec function). You can search all areas, the current area only, or specify an area to limit the search. \nThis function returns an alarm record identifier that you can use in other alarm functions, for example, to acknowledge, disable, or enable the alarm, or to get field data on that alarm. \nThis is a blocking function. If the function is called from a foreground task that is unable to block, the return value will be -1 and a hardware alarm set. Use IsError() to retrieve the error code.",
        "example": "No example found",
        "name": "AlarmNextCatRec",
        "params": [
            {
                "paramdescription": "The alarm record number, returned from any of thefollowing alarm functions:",
                "paramname": "Record"
            },
            {
                "paramdescription": "The alarm category or group number to match. Set Categoryto 0 (zero) to match all alarm categories.",
                "paramname": "Category"
            },
            {
                "paramdescription": "The type of alarms to display:\nNon-hardware alarms\nAlarm General\nIf you omit the Type, the default is 1.",
                "paramname": "nType"
            },
            {
                "paramdescription": "The area in which to search for alarms. If you choose to omit the area, or if you set Area to -1, only the current area will besearched.",
                "paramname": "Area"
            },
            {
                "paramdescription": "Specifies the name of the cluster in which the Alarm Serverresides. This is optional if you have one cluster or areresolving the alarm server via the current cluster context. Theargument is enclosed in quotation marks \"\".",
                "paramname": "ClusterName"
            }
        ],
        "returnType": "The alarm record identifier or -1 if no match is found.",
        "syntax": "LONG AlarmNextCatRec(LONG Record, INT Category, INTType [, INT Area] [, STRING ClusterName] )"
    },
    "alarmnextprirec": {
        "doc": "Searches for the next occurrence of an alarm of a specified priority and type, commencing with the specified alarm record identifier (returned from the previous search through the AlarmFirstPriRec() function). You can search all areas, the current area only, or specify an area to limit the search.\nThis function returns an alarm record identifier that you can use in other alarm functions, for example, to acknowledge, disable, or enable the alarm, or to get field data on that alarm. \nThis is a blocking function. If the function is called from a foreground task that is unable to block, the return value will be -1 and a hardware alarm set. Use IsError() to retrieve the error code.",
        "example": "No example found",
        "name": "AlarmNextPriRec",
        "params": [
            {
                "paramdescription": "The alarm record number, returned from any of the following alarm functions:\nTo store this value, use data type Int in Cicode or Long for variable tags (Long needs 4 bytes).",
                "paramname": "Record"
            },
            {
                "paramdescription": "The alarm Priority or group handle of a group of alarm priorities. Set Priority to 0 (zero) to match all alarm priorities.",
                "paramname": "Priority"
            },
            {
                "paramdescription": "The type of alarms to display:\nNon-hardware alarms\nAlarm General\nIf you omit the Type, the default is 1.",
                "paramname": "nType"
            },
            {
                "paramdescription": "The area in which to search for alarms. Set Area to -1 to search all areas. If you do not specify an area, only alarms in the current area on the Alarms Server are searched.",
                "paramname": "Area"
            },
            {
                "paramdescription": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\".",
                "paramname": "ClusterName"
            }
        ],
        "returnType": "The alarm record identifier or -1 if no match is found.",
        "syntax": "INT AlarmNextPriRec(LONG Record, INT Priority, INT Type [, INT Area] [, STRING ClusterName] )"
    },
    "alarmnexttagrec": {
        "doc": "Searches for the next occurrence of an alarm tag, name, and description, starting with the alarm record identifier (returned from the previous search through the AlarmFirstTagRec() function). \nThis function returns an alarm record identifier that you can use in other alarm functions, for example, to acknowledge, disable, or enable the alarm, or to get field data on that alarm.\nThis is a blocking function. If the function is called from a foreground task that is unable to block, the return value will be -1 and a hardware alarm set. Use IsError() to retrieve the error code.\nFor complex filtering operations it is more efficient to use the alarm tag browse functions AlmBrowseOpen and AlmBrowseNext.",
        "example": "No example found",
        "name": "AlarmNextTagRec",
        "params": [
            {
                "paramdescription": "The alarm record number, returned from any of the following alarm functions:\nTo store this value, use data type Int in Cicode or Long for variable tags (Long needs 4 bytes).",
                "paramname": "Record"
            },
            {
                "paramdescription": "A string that identifies the tag to be matched. It can be one of the following:\nSpecify an empty string (\" \") to match all alarm tags.",
                "paramname": "Tag"
            },
            {
                "paramdescription": "The alarm name to be matched. Specify an empty string (\" \") to match all alarm names.",
                "paramname": "Name"
            },
            {
                "paramdescription": "The alarm description to be matched. Specify an empty string (\" \") to match all alarm descriptions.",
                "paramname": "Description"
            },
            {
                "paramdescription": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\".",
                "paramname": "ClusterName"
            }
        ],
        "returnType": "The alarm record identifier or -1 if no match is found.",
        "syntax": "LONG AlarmNextTagRec(LONG Record, STRING Tag, STRING Name, VDescription [,STRING ClusterName] )"
    },
    "alarmnotifyvarchange": {
        "doc": "This function is used to provide time-stamped digital and time-stamped analog alarms with data. When called, it notifies the alarm server that the specified variable tag has changed.\nThe alarm server will then check all time-stamped digital and time-stamped analog alarms that use the variable tag to see if their alarm states need to be updated as a result of the change. Any alarm state changes that result from this check will be given the timestamp passed into this function as their time of occurrence.",
        "example": "AlarmNotifyVarChange(\"LOOP_1_SP\", 50.0, TimeCurrent() - 10, 550, \n\"ClusterXYZ\");\nThis will tell the alarm server in cluster XYZ that the value of \nvariable tag LOOP_1_SP changed to 50.0 at 9.450 seconds ago.",
        "name": "AlarmNotifyVarChange",
        "params": [
            {
                "paramdescription": "Name of the variable tag that has changed as a string. This name may include the name of the tag's cluster in the form cluster.tagname. This cluster name may be different from the cluster of the alarm server indicated by ClusterName below.\nThe Tag parameter is resolved on the alarm server, so the alarm server should be configured to connect to the tag's cluster.",
                "paramname": "Tag"
            },
            {
                "paramdescription": "",
                "paramname": "Value"
            },
            {
                "paramdescription": "",
                "paramname": "Value of the variable tag at the time of the change as a \nfloating-point number"
            },
            {
                "paramdescription": "",
                "paramname": "Timestamp"
            },
            {
                "paramdescription": "",
                "paramname": "Time/date at which the variable tag changed in the standard \nPlant SCADA time/date variable format (Seconds \nsince 1970)."
            },
            {
                "paramdescription": "Millisecond portion of the time at which the variable tag changed.",
                "paramname": "TimestampMS"
            },
            {
                "paramdescription": "Name of the cluster of the alarm server. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\".",
                "paramname": "sClusterName"
            },
            {
                "paramdescription": "An optional boolean argument that specifies whether the command is synchronous (blocking) or asynchronous (non-blocking). If it is specified as synchronous (true) the function will wait until the notification has been recorded into the alarm database before further code execution. If it is specified as asynchronous (false) the function will only return an error if no alarm server is currently available.",
                "paramname": "bSync"
            }
        ],
        "returnType": "For synchronous mode, the return value will be the error that was detected when the function was called. For asynchronous mode, the return value will be 0, unless there was no server available.",
        "syntax": "AlarmNotifyVarChange(Tag, Value, Timestamp [, TimestampMS] [, sClusterName] [, bSync] )"
    },
    "alarmqueryfirstrec": {
        "doc": "Searches for the first occurrence of an alarm category (or priority) and type. This is a wrapper function of AlarmFirstCatRec and AlarmFirstPriRec.\nThis is a blocking function. If the function is called from a foreground task that is unable to block, the return value will be -1 and a hardware alarm set. Use IsError() to retrieve the error code.",
        "example": "No example found",
        "name": "AlarmQueryFirstRec",
        "params": [
            {
                "paramdescription": "Alarm category if QueryType is 0 or alarm priority if QueryType is 1.",
                "paramname": "Group"
            },
            {
                "paramdescription": "The type of alarms to display:\nNon-hardware alarms\n0 - All active alarms, that is Types 1 and 2\n1 - All unacknowledged alarms, ON and OFF\n2 - All acknowledged ON alarms\n3 - All disabled alarms\n4 - All configured (non-hardware) alarms, that is Types 0 to 3, plus acknowledged OFF alarms.\nHardware alarms\n5 - All active alarms, that is Types 6 and 7\n6 - All unacknowledged alarms, ON and OFF\n7 - All acknowledged ON alarms\n8 - All disabled alarms\n9 - All configured alarms, that is Types 5 to 8\nAlarm Summary\n10 - All summary alarms\n15 – Sequence of events with configuration events filtered out\n16 - Sequence of events\nAlarm General\n11 - All ON alarms\n12 - All OFF alarms\n13 - All ON hardware alarms\n14 - All OFF hardware alarms\n17 - All unacknowledged ON alarms\n18 - All unacknowledged OFF alarms\nIf you omit the Type, the default is 1.",
                "paramname": "nType"
            },
            {
                "paramdescription": "",
                "paramname": "Area"
            },
            {
                "paramdescription": "",
                "paramname": "Area in which to search for alarms. Set Area to -1 to search all \nareas."
            },
            {
                "paramdescription": "",
                "paramname": "QuerynType"
            },
            {
                "paramdescription": "0 - Search by category.\n1 - Search by priority.",
                "paramname": "Query type."
            },
            {
                "paramdescription": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\".",
                "paramname": "sClusterName"
            }
        ],
        "returnType": "The alarm record identifier or -1 if no match is found.",
        "syntax": "AlarmQueryFirstRec(Group, nType, Area, QueryType [, sClusterName] )"
    },
    "alarmquerynextrec": {
        "doc": "Searches for the next occurrence of an alarm category (or priority) and type, commencing with the specified alarm record identifier (returned from the previous search through the alarm query functions).\nThis is a blocking function. If the function is called from a foreground task that is unable to block, the return value will be -1 and a hardware alarm set. Use IsError() to retrieve the error code.\nThis is wrapper function of AlarmNextCatRec and AlarmNextPriRec.",
        "example": "No example found",
        "name": "AlarmQueryNextRec",
        "params": [
            {
                "paramdescription": "Alarm record number.",
                "paramname": "Record"
            },
            {
                "paramdescription": "Alarm Category if QueryType is 0 or alarm priority if QueryType is 1.",
                "paramname": "Group"
            },
            {
                "paramdescription": "The type of alarms to display:\nNon-hardware alarms\n0 - All active alarms, that is Types 1 and 2\n1 - All unacknowledged alarms, ON and OFF\n2 - All acknowledged ON alarms\n3 - All disabled alarms\n4 - All configured (non-hardware) alarms, that is Types 0 to 3, plus acknowledged OFF alarms.\nHardware alarms\n5 - All active alarms, that is Types 6 and 7\n6 - All unacknowledged alarms, ON and OFF\n7 - All acknowledged ON alarms\n8 - All disabled alarms\n9 - All configured alarms, that is Types 5 to 8\nAlarm Summary\n10 - All summary alarms\n15 – Sequence of events with configuration events filtered out\n16 - Sequence of events\nAlarm General\n11 - All ON alarms\n12 - All OFF alarms\n13 - All ON hardware alarms\n14 - All OFF hardware alarms\n17 - All unacknowledged ON alarms\n18 - All unacknowledged OFF alarms\nIf you omit the Type, the default is 1.",
                "paramname": "nType"
            },
            {
                "paramdescription": "",
                "paramname": "Area"
            },
            {
                "paramdescription": "",
                "paramname": "Area in which to search for alarms. Set Area to -1 to search all \nareas."
            },
            {
                "paramdescription": "",
                "paramname": "QuerynType"
            },
            {
                "paramdescription": "0 - Search by category.\n1 - Search by priority.",
                "paramname": "Query type."
            },
            {
                "paramdescription": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\".",
                "paramname": "sClusterName"
            }
        ],
        "returnType": "The alarm record identifier or -1 if no match is found.",
        "syntax": "AlarmQueryNextRec(Record, Group, nType, Area, QueryType [, sClusterName] )"
    },
    "alarmresetquery": {
        "doc": "Clears the filter of the specified filter source. Used to reset the filter set up by the Cicode function AlarmFilterForm(). This function uses the AlarmFilterEdit family of Cicode functions, to reset the filter.\nAlarmResetQuery(STRING FilterSrc)\nNone",
        "example": "No example found",
        "name": "AlarmResetQuery",
        "params": [
            {
                "paramdescription": "The source where the filter will be applied to. It can either be the Animation Number (AN) of an alarm list or the name of a filter created via the AlarmFilterOpen() Cicode function. If it is not specified, it is defaulted to -1 which refers to all alarm lists on the current page.",
                "paramname": "FilterSrc"
            }
        ],
        "returnType": "None",
        "syntax": "AlarmResetQuery(STRING FilterSrc)"
    },
    "alarmsetdelay": {
        "doc": "Changes the delay setting for an alarm (that is Delay, High High Delay, Deviation Delay, etc.). This function acts on the alarm that the cursor is positioned over. Use this function during runtime to change the delay values that were specified in the alarms database. Delay changes made using this process are persistent (that is they are saved to the project).",
        "example": "No example found",
        "name": "AlarmSetDelay",
        "params": [
            {
                "paramdescription": "The type of delay:\n0 - Delay (digital alarm/advanced alarm)\n1 - High high delay (analog alarm)\n2 - High delay (analog alarm)\n3 - Low delay (analog alarm)\n4 - Low low delay (analog alarm)\n5 - Deviation delay (analog alarm)",
                "paramname": "nType"
            },
            {
                "paramdescription": "The new value for the delay. Enter a blank value \" \" to remove the delay setting.",
                "paramname": "Value"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "AlarmSetDelay(Type, Value)"
    },
    "alarmsetdelayrec": {
        "doc": "Changes the delay setting for an alarm (that is Delay, High High Delay, Deviation Delay, etc.) by the alarm record number. You can only call this function on an alarms server for local alarms, or on a redundant server if one has been configured. \nThis is a blocking function. If the function is called from a foreground task that is unable to block, an error will be returned.",
        "example": "No example found",
        "name": "AlarmSetDelayRec",
        "params": [
            {
                "paramdescription": "The alarm record number, returned from any of the following alarm functions:",
                "paramname": "Record"
            },
            {
                "paramdescription": "The type of delay:",
                "paramname": "nType"
            },
            {
                "paramdescription": "The new value for the delay. Enter a blank value \" \" to remove the delay setting.",
                "paramname": "Value"
            },
            {
                "paramdescription": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\".",
                "paramname": "sClusterName"
            }
        ],
        "returnType": "",
        "syntax": "INT AlarmSetDelayRec(LONG Record, INT Type, INT Value, STRING ClusterName)"
    },
    "alarmsetinfo": {
        "doc": "Controls different aspects of the alarm list displayed at a specified AN. Currently applies only to non-hardware alarm lists.",
        "example": "! Set the order-by key.\nAlarmSetInfo(21,10,\"{Time}\");\n! Set the sorting mode.\nAlarmSetInfo(21,9,1);\nAlarmSetInfo(21, 8, 0);\nAlarmSetInfo(21, 2, 2);\nAlarmSetInfo(21, 8, 1); ! priority mode\nAlarmSetInfo(21, 7, 4); ! apply filter\n! Change the vertical offset (pages) to 2.\nAlarmSetInfo(0,0,2);\n! Change the vertical offset (lines) to 15.\nAlarmSetInfo(0,1,15);\nAlarmSetInfo(0,2,10);\nAlarmSetInfo(0,3,5);\n! Display alarms with category 120 format and fonts\nAlarmSetInfo(20, 4, 120);\n! Display alarms with a new format\nhFmt=FmtOpen(\"MyFormat\",\"{Name}{Desc,20}\",0);\nAlarmSetInfo(20, 5, hFmt);\n! Display alarms with a new font\nhFont = DspFont(\"Times\",-60,black,gray);\nAlarmSetInfo(20, 6, hFont);",
        "name": "AlarmSetInfo",
        "params": [
            {
                "paramdescription": "The AN where the alarm list originally commenced. (ANalarm page can contain more than one alarm list). You canalso specify:\n-1 - Change the display parameters of all alarm lists displayed on the page.\n0 - Change the display parameters of the alarm list where the cursor is positioned.",
                "paramname": "AN"
            },
            {
                "paramdescription": "The type of data.The aspects and related types are listed below:\n0 - Alarm page number. The vertical offset (in pages) from the AN where the alarm list commenced.\n1 - Alarm list offset. The vertical offset (in lines) from the AN where the alarm list commenced.\n2 - Category of alarms displayed on the alarm list. To specify all categories use a value of 0.\nYou can use a group handle to display a group of categories. (A group can be defined via the Security activity, or by using the GrpOpen() function.) Before you can display a group of categories, you need to first open the group using the GrpOpen() function. You would usually do this by entering the GrpOpen() function as the Page entry command for your alarm page (set using Page Properties). Be aware, however, that you should not close the group until you close the display page. If you do, the group will be lost and the group handle will become invalid. The page would then be unable to continue displaying the desired group. The handle may be reused for another group, which means the page may display a different category, or display all alarms.\nYou would normally close the group by entering theGrpClose() function as the Page exit command.\n3 - Type of alarms displayed on the alarm list. See AlarmDsp() for a list of these types.\n4 - Display all alarms according to the format and fonts specified for one category (specified in Value).\n5 - The display format for all alarms specified by a format handle. All of the alarm categories will display in the same format.\n6 - The display font for all user alarms specified by a font handle. All of the user alarms will appear in the same font and color.\n7 - The priority of the alarms to be displayed in the alarm list. You can use a group number to display a group of priorities.\nYou can use a group handle to display a group ofpriorities. (A group can be defined using Groups -from the Project Editor System menu - or by using theGrpOpen() function.) Before you can display a groupof priorities, you need to first open the group using theGrpOpen() function. You would usually do this byentering the GrpOpen() function as the Page entrycommand for your alarm page (set using PageProperties). Be aware, however, that you should not closethe group until you close the display page. If you do,the group will be lost and the group handle willbecome invalid. The page would then be unable tocontinue displaying the desired group. You wouldnormally close the group by entering the GrpClose()function as the Page exit command.\n8 - Use the Value argument of the AlarmSetInfo() function to specify whether the display mode of the alarm list is based on Alarm Category or Priority:\nSet the Value argument to 0 (zero) to display by Category.\nSet the Value argument to 1 to display by Priority.\n9 - Use the Value argument of the AlarmSetInfo() function to specify the sorting mode of the alarm list:\nSet the Value argument to 0 (zero) to display alarms sorted by ON time within their groups.\nSet the Value argument to 1 to display alarms sorted by the order-by keys. Please be aware that this option will only be meaningful if you have already called the AlarmSetInfo() function with a Type of 10 to set the order-by keys.\n10 - Use the Alarm Order-by key specified in the Value argument of the AlarmSetInfo() function to determine the order in which the alarm list will be displayed.\nThe AlarmSetInfo() function should then be called again using a Type of 9 and a Value of 1 for Plant SCADA to sort the alarms in the order specified. \n11 – Invalid to set this field.\n12 – Associate or disassociate a named filter. By setting this field to text, you associate the specified AN to a named filter which is then applied to an alarm display list. Setting this type to empty text, will unlink from any named filter, but the disassociated alarm list will retain its value, hence the filter will still be in place until a new filter is applied. If setting the Value to text that does not correspond to a named filter, the value read back (using AlarmGetFilterName()) will be empty. \n15 – Auto-refresh mode, where mode is:\n -1 : always auto refresh \n 0 : auto refresh disabled \n1 : auto refresh page 1, disable on all other pages. \n16 – Invalid to set this field.",
                "paramname": "Type"
            },
            {
                "paramdescription": "The meaning of the Value argument depends on the data typespecified in the Type argument.\nIf you set Type = 0 (offset in pages) or Type = 1 (offset is lines), the Value argument must be within the range of alarm entries currently stored in the client cache, otherwise error code 569 will be returned. \nIf you set Type = 8, the Value argument determines whether alarms are displayed by category or priority:\n0 - Alarm list displayed by Category.\n1 - Alarm list displayed by Priority.\nIf you set Type = 10, the Value argument specifies the order-by keys to be used in sorting. Up to sixteen keys may be specified:{KeyName [,SortDirection]}[ {KeyName [,SortDirection]}]\nThe Keyname argument specifies the name of the pre-defined order-by key to be used. The valid options are a subset of the alarm display fields: Tag, Name, Category, Priority, Area, Priv, Time, State, and Type.\nThe SortDirection argument is optional, and indicates whether the sort will be ascending or descending. Valid options are: 0 Descending (default), 1 Ascending.\nFor example:\n0 (zero) if successful, otherwise an error code is returned.",
                "paramname": "Value"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "INT AlarmSetInfo(INT AN, INT Type, STRING Value)"
    },
    "alarmsetthreshold": {
        "doc": "Changes the thresholds (that is High High, Low etc.) of analog alarms. This function acts on the analog alarm where the cursor is positioned. Use this function to change (at run time) the threshold values that were specified in the Analog Alarms database. Threshold changes made using this function are permanent (that is they are saved to the project). The display format currently specified for the record (in the Analog Alarms form) will be applied to these values.",
        "example": "No example found",
        "name": "AlarmSetThreshold",
        "params": [
            {
                "paramdescription": "The type of threshold:\n0 - High high\n1 - High\n2 - Low\n3 - Low low\n4 - Deadband\n5 - Deviation\n6 - Rate of change",
                "paramname": "nType"
            },
            {
                "paramdescription": "The new value of the threshold. Enter a blank value \"\" to remove the threshold.",
                "paramname": "Value"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "AlarmSetThreshold(Type, Value)"
    },
    "alarmsetthresholdrec": {
        "doc": "Changes the threshold (that is High High, Low etc.) of analog alarms by the alarm record number. You can call this function only on an Alarms Server for alarms on that server, or on the redundant server (if a redundant server is configured). \nThreshold changes made using this function are permanent (that is they are saved to the project). The display format currently specified for the record (in the Analog Alarms form) will be applied to these values.\nThis is a blocking function. If the function is called from a foreground task that is unable to block, an error will be returned.\nTo permanently update alarmthreshold limits using AlarmSetThresholdRec(), set the parameter [Alarm]UseConfigLimits to 1.",
        "example": "No example found",
        "name": "AlarmSetThresholdRec",
        "params": [
            {
                "paramdescription": "The alarm record number, returned from any of the following alarm functions:\nTo store this value, use data type Int in Cicode or Long for variable tags (Long needs 4 bytes).",
                "paramname": "Record"
            },
            {
                "paramdescription": "The type of threshold:",
                "paramname": "Type"
            },
            {
                "paramdescription": "The new value of the threshold. Enter a blank value \"\" to remove the threshold.",
                "paramname": "Value"
            },
            {
                "paramdescription": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\".",
                "paramname": "ClusterName"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "INT AlarmSetThresholdRec (LONG Record, INT Type, STRING Value [, STRING  ClusterName])"
    },
    "alarmsplit": {
        "doc": "Splits an alarm summary entry which has no Off time. The current entry will be given an off time equal to the time when AlarmSplit() is called, and the new entry will have the same On time, with empty Off time.\nIf the alarm summary record has a valid Off time, the function does nothing.\nYou would normally call this function from a keyboard or mouse command.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "AlarmSplit",
        "params": [
            {
                "paramdescription": "Animation Number where alarm is displayed. You can:\nSet AN to where alarm is displayed which equals to AN of alarm list + Offset into the list",
                "paramname": "AN"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "AlarmSplit([INT AN])"
    },
    "alarmsumappend": {
        "doc": "Appends a new blank record to the alarm summary. Use this function to add new alarm summary entries, either for actual alarms or as special user summary entries.\nIf you specify a valid alarm tag in the sTag field, the summary entry is linked to the actual alarm. If you specify an asterisk '*' as the first letter of the tag, the summary entry becomes a user event.\nUser events are not attached to alarm records, so their status will not change. Manually change the status of the user event, by calling the AlarmSumSet() function with the index returned by AlarmSumAppend(). As user events are not attached to alarms, they don't have the alarm fields - so the AlarmSumGet() function will not return any field data.\nThe latest entry in the Alarm summary will reflect the events of the alarm\t\twhether the alarm summary entry was appended created by an actual alarm event.\nYou can use user events to keep a record of logins, or control operations that you need to display in the alarm summary etc. The fields of UserEvents needs to be set immediately after creation using the AlarmSumSet() function.\nTo give an appended alarm summary entry the appearance of having been\t\t\tAcknowledged set the Acknowledge time of the summary entry.  When the summary\t\t\tentry is linked to an actual alarm the function AlmSummaryAck() can be used to\t\t\tacknowledge the actual alarm linked to the summary entry.  However the\t\tAlmSummaryAck function will not directly affect the alarm summary entry.\nAlarmSumAppend() can only be used if the Alarm Server is on the current machine. When the Alarm Server is not in the calling process, this function will become blocking and cannot be called from a foreground task. In this case, the return value will be undefined and a Cicode hardware alarm will be raised.\nThis function can only be used if the Alarm Server is on the current machine. \nThe AlarmSumNext and AlarmSumPrev Cicode functions are unable to use the index returned by AlarmSumAppend.\nAlarmSumAppend(sTag [, ClusterName, OnTime, OnMilli, bRedundant=true] )\nsTag: \nClusterName:\nOnTime:\nOnMilli:\nbRedundant:(optional)\nThe index of the alarm summary entry, or -1 if the record could not be appended.\nAlarmSumCommit, AlamSumDelete, AlarmSumSet, AlarmSumType, AlarmDelete, MsgRPC, AlarmSumGet, AlarmSumFirst, AlarmSumNext, AlarmSumLast, AlarmSumPrev, AlarmSumFind, AlarmSplit, AlarmSumSplit",
        "example": "! Append alarm to summary display\nAlarmSumAppend(\"CV101\");\n! Append user event\niIndex = AlarmSumAppend(\"*MyEvent\");\nAlarmSumSet(iIndex, \"Comment\", \"My event comment\");\n\t\t\t",
        "name": "AlarmSumAppend",
        "params": [
            {
                "paramdescription": "The alarm tag to append. Use an asterisk '*' as the first letter to append a user event to the alarm summary. Please be aware that the AlarmSumAppend function returns the alarm summary index - not the error code.",
                "paramname": "sTag"
            },
            {
                "paramdescription": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\".",
                "paramname": "ClusterName"
            },
            {
                "paramdescription": "The alarm OnTime (if omitted or is equal to 0, will default to current time, i.e. the time the function was invoked).",
                "paramname": "OnTime"
            },
            {
                "paramdescription": "Milliseconds part of the alarm's ON time",
                "paramname": "OnMilli"
            },
            {
                "paramdescription": "New alarm record is created on both redundant server instances. This parameter has been deprecated and is always set to true.",
                "paramname": "bRedundant:(optional)"
            }
        ],
        "returnType": "The index of the alarm summary entry, or -1 if the record could not be appended.",
        "syntax": "AlarmSumAppend(sTag [, ClusterName, OnTime, OnMilli, bRedundant=true] )"
    },
    "alarmsumcommit": {
        "doc": "Commits the alarm summary entry to the Summary Device specified in the alarm category of the entry. The same alarm summary entry is unable to be committed twice. The Cicode function returns an error code if the entry has been commited by timeout (referring to [Alarm]SummaryTimeout parameter), or if AlarmSumCommit() is called twice. An entry is not commited by timeout if AlarmSumCommit() is called on this entry.\nIf the Alarm Server is not in the calling process, the calling process needs to run from the same machine as the alarm server.\t\nThis function can only be used if the Alarm Server is on the current machine. When the Alarm Server is not in the calling process, this function will become blocking and cannot be called from a foreground task. In this case, the return value will be undefined and a Cicode hardware alarm will be raised.\nIn a redundant pair scenario, this function will return an error condition and not do anything if the current server is not main. You can call this function on the primary server and the standby server so that function can succeed on one of the two servers in the specified cluster. The change will be synchronized to the other server after a short period of time (typically in 5 seconds).\nAlarmSumCommit(Index [, ClusterName] )\nIndex: \nClusterName:\n0 (zero) if successful, otherwise an error is returned.",
        "example": "/* This function commits alarm summary entries that match the\n\t\t\t\tspecified tag. */\nFUNCTION\nSumCommitTag(STRING sTag)\n    INT Next;\n    INT Index;\n    STRING Name;\n    Index=AlarmSumFirst();\n    WHILE Index<>-1 DO\n        Name=AlarmSumGet(Index,\"Tag\");\n        Next=AlarmSumNext(Index);\n        IF Name=sTag THEN\n            AlarmSumCommit(Index);\n        END\n        Index=Next;\n    END\nEND\n\t\t\t",
        "name": "AlarmSumCommit",
        "params": [
            {
                "paramdescription": "The alarm summary index (returned from the AlarmSumFirst(), AlarmSumNext(), AlarmSumLast(), AlarmSumPrev(), AlarmSumAppend(), or AlarmSumFind() function).",
                "paramname": "Index"
            },
            {
                "paramdescription": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\".",
                "paramname": "ClusterName"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "AlarmSumCommit(Index [, ClusterName] )"
    },
    "alarmsumdelete": {
        "doc": "Deletes an alarm summary entry. You identify the alarm summary entry by the Index, returned by one of the alarm summary search functions.\nBy embedding this function in a loop, you can delete a series of alarm summary entries. To start deleting from the oldest entry, call the AlarmSumFirst() function to get the index, and then call AlarmSumNext() in a loop. To delete back from the most recent entry, call AlarmSumLast() and then AlarmSumPrev() in a loop.\nYou can also get the Index from the AlarmSumFind() function, which finds an alarm summary entry by its alarm record identifier and time of activation.\nThis function can only be used if the Alarm Server is on the current machine. When the Alarm Server is not in the calling process, this function will become blocking and cannot be called from a foreground task. In this case, the return value will be undefined and a Cicode hardware alarm will be raised.\nAlarmSumDelete(Index [, ClusterName] )\nIndex: \nClusterName:\n0 (zero) if the specified alarm entry exists, otherwise an error is returned.",
        "example": "/* This function deletes all alarm summary entries that match the \n\t\t\tspecified tag. */\nFUNCTION\nSumDelTag(STRING sTag)\n    INT Next;\n    INT Index;\n    STRING Name;\n    Index=AlarmSumFirst();\n    WHILE Index<>-1 DO\n        Name=AlarmSumGet(Index,\"Tag\");\n        Next=AlarmSumNext(Index);\n        IF Name=sTag THEN\n            AlarmSumDelete(Index);\n        END\n        Index=Next;\n    END\nEND",
        "name": "AlarmSumDelete",
        "params": [
            {
                "paramdescription": "The alarm summary index (returned from the AlarmSumFirst(), AlarmSumNext(), AlarmSumLast(), AlarmSumPrev(), AlarmSumAppend(), or AlarmSumFind() function).",
                "paramname": "Index"
            },
            {
                "paramdescription": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\".",
                "paramname": "ClusterName"
            }
        ],
        "returnType": "0 (zero) if the specified alarm entry exists, otherwise an error is returned.",
        "syntax": "AlarmSumDelete(Index [, ClusterName] )"
    },
    "alarmsumfind": {
        "doc": "Finds the alarm summary index for an alarm that you specify by the alarm record identifier and alarm activation time (OnTime). You can use this index in the AlarmSumGet() function to get field data from an alarm record, in the AlarmSumSet() function to change the existing data in that record, or in the AlarmSumDelete() function to delete the record. If calling this function from a remote client, use the MsgRPC() function.\nTo work with a series of alarm summary records, call this function to get the index, and then call either AlarmSumNext() to move forwards in the summary, or AlarmSumPrev() to move backwards in the summary.\nThis function can only be used if the Alarm Server is on the current machine. When the Alarm Server is not in the calling process, this function will become blocking and cannot be called from a foreground task. In this case, the return value will be undefined and a Cicode hardware alarm will be raised.\nAlarmSumFind(Record, OnTime [, ClusterName] )\nRecord: \nOnTime: \nClusterName:\nThe index of the alarm summary entry, or -1 if no alarm summary entry is found.\nAlarmSumCommit, AlamSumDelete, AlarmSumSet, AlarmSumType, AlarmSumAppend, AlarmDelete, MsgRPC, AlarmSumGet, AlarmSumFirst, AlarmSumNext, AlarmSumLast, AlarmSumPrev, AlarmSplit, AlarmSumSplit",
        "example": "/* This function sets the summary comment from the alarm record\n\t\t\tnumber and the ontime of the summary event. */\nFUNCTION\nSumSetComment(INT AN, STRING sComment)\n    INT nRecord;\n    INT iOnTime;\n    INT hAlarm1;\n    STRING AlmTag;\n    AlmTag = AlarmGetDsp(AN, \"Tag\");\n    iOnTime = StrToDate(AlarmGetDsp(AN,\"OnDate\"))+StrToTime(AlarmGetDsp(AN,\"OnTime\"));\n    hAlarm1 = MsgOpen(\"Alarm\", 0, 0);\n    MsgRPC(hAlarm1, \"AlmSvrSumSetComment\", \"^\"\" + AlmTag + \"^\",\" + IntTostr(iOnTime) + \",^\"\" + sComment + \"^\"\", 1);\n    MsgClose(\"Alarm\", hAlarm1);\nEND\nFUNCTION \nAlmSvrSumSetComment(STRING AlmTag, INT iOnTime, STRING sComment)\n    INT nRecord = AlarmFirstTagRec(AlmTag, \"\", \"\");\n    INT Index = AlarmSumFind(nRecord, iOnTime);\n    IF Index <> -1 THEN\n        AlarmSumSet(Index, \"Comment\", sComment);\n    END\nEND",
        "name": "AlarmSumFind",
        "params": [
            {
                "paramdescription": "The alarm record number, returned from any of the following alarm functions:\nAlarmFirstCatRec() or AlarmNextCatRec() - used to search for a record by alarm category, area, and type (acknowledged, disabled, etc.). \nAlarmFirstPriRec() or AlarmNextPriRec() - used to search for a record by alarm priority, area, and type (acknowledged, disabled, etc.). \nAlarmFirstTagRec() or AlarmNextTagRec() - used to search for a record by alarm tag, name, and description. \nTo store this value, use data type Int in Cicode or Long for variable tags (Long needs 4 bytes).",
                "paramname": "Record"
            },
            {
                "paramdescription": "The ON time of the alarm associated with the Record, that is, the time that the alarm was activated.\nAlarmSumFind() requires that the OnTime argument contains the number of seconds from Midnight, so the formulation:\niOnTime = StrToTime(AlarmSumGet(iIndex, \"OnTime\"));\nwill NOT yield the correct result. The correct formulation for this calculation is:",
                "paramname": "OnTime"
            },
            {
                "paramdescription": "",
                "paramname": "OnTime = StrToTime(AlarmSumGet(iIndex, \"OnTime\")) + TimeMidnight(TimeCurrent());"
            },
            {
                "paramdescription": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\".",
                "paramname": "ClusterName"
            }
        ],
        "returnType": "The index of the alarm summary entry, or -1 if no alarm summary entry is found.",
        "syntax": "AlarmSumFind(Record, OnTime [, ClusterName] )"
    },
    "alarmsumfirst": {
        "doc": "Gets the index of the oldest alarm summary entry. You can use this index in the AlarmSumGet() function to get field data from an alarm record, in the AlarmSumSet() function to change the existing data in that record, or in the AlarmSumDelete() function to delete the record.\nTo work with a series of alarm summary records, call this function to get the index, and then call AlarmSumNext() within a loop, to move forwards in the alarm summary.\nThis function can only be used if the Alarm Server is on the current machine. When the Alarm Server is not in the calling process, this function will become blocking and cannot be called from a foreground task. In this case, the return value will be undefined and a Cicode hardware alarm will be raised.\nAlarmSumFirst( [ClusterName] )\nClusterName:\nThe index of the oldest alarm summary entry, or -1 if no alarm summary entry is found.\nAlarmSumCommit, AlamSumDelete, AlarmSumSet, AlarmSumType, AlarmSumAppend, AlarmDelete, MsgRPC, AlarmSumGet, AlarmSumNext, AlarmSumLast, AlarmSumPrev, AlarmSumFind, AlarmSplit,AlarmSumSplit",
        "example": "/* This function finds all alarm summary entries that match the \nspecified tag and sets the \"OffTime\" to the time specified. The \nalarm entry is not acknowledged or set to the off state, the alarm \nsummary \"OffTime\" field is all that is affected. */",
        "name": "AlarmSumFirst",
        "params": [
            {
                "paramdescription": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\".",
                "paramname": "ClusterName"
            }
        ],
        "returnType": "The index of the oldest alarm summary entry, or -1 if no alarm summary entry is found.",
        "syntax": "AlarmSumFirst( [ClusterName] )"
    },
    "alarmsumget": {
        "doc": "Gets field data from an alarm summary entry. The data is returned as a string. You identify the alarm summary entry by the Index, returned by one of the alarm summary search functions. If calling this function from a remote client, use the MsgRPC() function.\nBy embedding this function in a loop, you can get data from a series of alarm summary entries. To start from the oldest entry, call the AlarmSumFirst() function to get the index, and then call AlarmSumNext() in a loop. To work back from the most recent entry, call AlarmSumLast() and then AlarmSumPrev() in a loop.\nYou can also get the Index from the AlarmSumFind() function, which finds an alarm summary entry by its alarm record identifier and time of activation.\nThis function can only be used if the Alarm Server is on the current machine. When the Alarm Server is not in the calling process, this function will become blocking and cannot be called from a foreground task. In this case, the return value will be undefined and a Cicode hardware alarm will be raised.",
        "example": "No example found",
        "name": "AlarmSumGet",
        "params": [
            {
                "paramdescription": "The alarm summary index (returned from the AlarmSumFirst(), AlarmSumNext(), AlarmSumLast(), AlarmSumPrev(), AlarmSumAppend(), or AlarmSumFind() function).",
                "paramname": "Index"
            },
            {
                "paramdescription": "The name of the field from which to extract the data:",
                "paramname": "sField"
            },
            {
                "paramdescription": "",
                "paramname": ""
            },
            {
                "paramdescription": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\".",
                "paramname": "ClusterName"
            }
        ],
        "returnType": "Field data from the alarm summary entry (as a string).",
        "syntax": "AlarmSumGet(Index, sField [, ClusterName] )"
    },
    "alarmsumlast": {
        "doc": "Gets the index of the most recent alarm summary entry. You can use this index in the AlarmSumGet() function to get field data from an alarm record, in the AlarmSumSet() function to change the existing data in that record, or in the AlarmSumDelete() function to delete the record.\nTo work with a series of alarm summary records, call this function to get the index, and then call AlarmSumPrev() within a loop, to move backwards in the alarm summary.\nThis function can only be used if the Alarm Server is on the current machine.\nThis function can only be used if the Alarm Server is on the current machine. When the Alarm Server is not in the calling process, this function will become blocking and cannot be called from a foreground task. In this case, the return value will be undefined and a Cicode hardware alarm will be raised.\nAlarmSumLast( [ClusterName] )\nClusterName:\nThe index of the most recent alarm summary entry, or -1 if no alarm summary entry is found.\nAlarmSumCommit, AlamSumDelete, AlarmSumSet, AlarmSumType, AlarmSumAppend, AlarmDelete, MsgRPC, AlarmSumGet, AlarmSumFirst, AlarmSumNext, AlarmSumPrev, AlarmSumFind, AlarmSplit, AlarmSumSplit",
        "example": "/* This function finds all alarm summary entries that match the \nspecified tag and sets the \"OffTime\" to the time specified. The \nalarm entry is not acknowledged or set to the off state, the alarm \nsummary \"OffTime\" field is all that is affected. */\n\nFUNCTION\nSumSetTime(STRING sTag, INT Time)\n    INT Index;\n    STRING Name;\n    Index=AlarmSumLast();\n    WHILE Index<>-1 DO\n        Name=AlarmSumGet(Index,\"Tag\");\n        IF Name=sTag THEN\n            AlarmSumSet(Index,\"OffTime\",Time);\n        END\n        Index=AlarmSumPrev(Index);\n    END\nEND\n\t\t\t",
        "name": "AlarmSumLast",
        "params": [
            {
                "paramdescription": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\".",
                "paramname": "ClusterName"
            }
        ],
        "returnType": "The index of the most recent alarm summary entry, or -1 if no alarm summary entry is found.",
        "syntax": "AlarmSumLast( [ClusterName] )"
    },
    "alarmsumnext": {
        "doc": "Gets the index of the next alarm summary entry, that is, the entry that occurred later than the entry specified by Index. You can use this index in the AlarmSumGet() function to get field data from an alarm record, in the AlarmSumSet() function to change the existing data in that record, or in the AlarmSumDelete() function to delete the record.\nYou can use this function to work with a series of alarm summary records. Call the AlarmSumFirst() or AlarmSumFind() function to get the index, and then call AlarmSumNext() within a loop, to move forwards in the alarm summary.\nYou can also get the index of an entry as soon as it displays on the alarm summary. Alarm summary entries are recorded with the most recent entry at the end of the list. Call AlarmSumLast() to get the index for the most recent entry, and then call AlarmSumNext() to get the index for the next entry that occurs.\nThis function can only be used if the Alarm Server is on the current machine. When the Alarm Server is not in the calling process, this function will become blocking and cannot be called from a foreground task. In this case, the return value will be undefined and a Cicode hardware alarm will be raised.\nAlarmSumNext(Index [, ClusterName] )\nIndex: \nClusterName:\nThe index of the next alarm summary entry or -1 if no more alarm summary entries are found.\nAlarmSumCommit, AlamSumDelete, AlarmSumSet, AlarmSumType, AlarmSumAppend, AlarmDelete, MsgRPC, AlarmSumGet, AlarmSumFirst, AlarmSumLast, AlarmSumPrev, AlarmSumFind, AlarmSplit, AlarmSumSplit",
        "example": "No example found",
        "name": "AlarmSumNext",
        "params": [
            {
                "paramdescription": "The alarm summary index (returned from the AlarmSumFirst(), AlarmSumNext(), AlarmSumLast(), AlarmSumPrev(), or AlarmSumFind() function).",
                "paramname": "Index"
            },
            {
                "paramdescription": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\".",
                "paramname": "ClusterName"
            }
        ],
        "returnType": "The index of the next alarm summary entry or -1 if no more alarm summary entries are found.",
        "syntax": "AlarmSumNext(Index [, ClusterName] )"
    },
    "alarmsumprev": {
        "doc": "Gets the index of the previous alarm summary entry, that is, the entry that occurred before the entry specified by Index. You can use this index in the AlarmSumGet() function to get field data from an alarm record, in the AlarmSumSet() function to change the existing data in that record, or in the AlarmSumDelete() function to delete the record.\nYou can use this function to work with a series of alarm summary records. Call the AlarmSumLast() or AlarmSumFind() function to get the index, and then call AlarmSumPrev() within a loop, to move backwards in the alarm summary.\nThis function can only be used if the Alarm Server is on the current machine. When the Alarm Server is not in the calling process, this function will become blocking and cannot be called from a foreground task. In this case, the return value will be undefined and a Cicode hardware alarm will be raised.\nAlarmSumPrev(Index [, ClusterName] )\nIndex: \nClusterName:\nThe index of the previous alarm summary entry or -1 if no more alarm summary entries are found.\nAlarmSumCommit, AlamSumDelete, AlarmSumSet, AlarmSumType, AlarmSumAppend, AlarmDelete, MsgRPC, AlarmSumGet, AlarmSumFirst, AlarmSumNext, AlarmSumLast, AlarmSumFind, AlarmSplit, AlarmSumSplit",
        "example": "No example found",
        "name": "AlarmSumPrev",
        "params": [
            {
                "paramdescription": "The alarm summary index (returned from the AlarmSumFirst(), AlarmSumNext(), AlarmSumLast(), AlarmSumPrev(), or AlarmSumFind() function).",
                "paramname": "Index"
            },
            {
                "paramdescription": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\".",
                "paramname": "ClusterName"
            }
        ],
        "returnType": "The index of the previous alarm summary entry or -1 if no more alarm summary entries are found.",
        "syntax": "AlarmSumPrev(Index [, ClusterName] )"
    },
    "alarmsumset": {
        "doc": "Sets field information in an alarm summary entry. You identify the alarm summary entry by the Index, returned by one of the alarm summary search functions.\nBy embedding this function in a loop, you can change field data in a series of alarm summary entries. To start from the oldest entry, call the AlarmSumFirst() function to get the index, and then call AlarmSumNext() in a loop. To work back from the latest entry, call AlarmSumLast() and then AlarmSumPrev() in a loop.\nYou can also get the Index from the AlarmSumFind() function, which finds an alarm summary entry by its alarm record identifier and time of activation.\nThis function can only be used if the Alarm Server is on the current machine. When the Alarm Server is not in the calling process, this function will become blocking and cannot be called from a foreground task. In this case, the return value will be undefined and a Cicode hardware alarm will be raised.\nFields of an appended alarm can only be set using this function or the replacement function AlmSummarySetField().  \nYou can use user events to keep a record of logins, or control operations that\t\t\tyou need to display in the alarm summary etc. The fields of UserEvents need to be\t\t\tset immediately after creation using this function. These entries\t\t\tin the Alarm Summary cannot be filtered from the summary in an AlmSummaryOpen()\t\tbrowse session.\nAlarmSumSet(Index, sField, sData [, ClusterName] )\nIndex: \nsField: \nsData: \nClusterName:\n0 (zero) if the alarm summary entry exists, otherwise an error is returned.",
        "example": "No example found",
        "name": "AlarmSumSet",
        "params": [
            {
                "paramdescription": "The alarm summary index (returned from the AlarmSumFirst(), AlarmSumNext(), AlarmSumLast(), AlarmSumPrev(), AlarmSumAppend(), or AlarmSumFind() function).",
                "paramname": "Index"
            },
            {
                "paramdescription": "The name of the field in which data is to be set:",
                "paramname": "sField"
            },
            {
                "paramdescription": "The new value of the field.",
                "paramname": "sData"
            },
            {
                "paramdescription": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\".",
                "paramname": "ClusterName"
            }
        ],
        "returnType": "0 (zero) if the alarm summary entry exists, otherwise an error is returned.",
        "syntax": "AlarmSumSet(Index, sField, sData [, ClusterName] )"
    },
    "alarmsumsplit": {
        "doc": "Splits the alarm summary entry identified by index.\nOn operation success, the OffTime of the current alarm summary entry is filled with specified OnTime. Meanwhile, a new alarm summary entry is raised with the specified OnTime and no OffTime.\nThe operation represents a logical split at the specified OnTime to an active alarm instance. You can use this function to add a comment related to the specified OnTime.\nThe alarm summary entry must not have OffTime, or the function would return -1 and do nothing.\nThe function is blocking and cannot be called from a foreground task. In this case, the return value will be undefined and a Cicode hardware alarm will be raised.\nThis function can only be used if the alarm server is on the current machine. If the Alarm Server is not in the calling process, the calling process needs to run from the same machine as the alarm server.\nIn a redundant pair scenario, the function would return error condition and do nothing if the current server is not main. You can call this function on both the primary server and the standby server so that function can succeed on one of the two servers in the specified cluster. The change will be synchronized to the other server after a short period of time (typically in 5 seconds).\nAlarmSumSplit(Index  [, ClusterName, OnTime, OnMilli, bRedundant=true]  )\nIndex:\nClusterName:\nOnTime:\nOnMilli:\nbRedundant:(optional)\nThe Index of the new entry, or -1 on     error.\nAlarmSumCommit, AlamSumDelete, AlarmSumSet, AlarmSumType, AlarmSumAppend, AlarmDelete, MsgRPC, AlarmSumGet, AlarmSumFirst, AlarmSumNext, AlarmSumLast, AlarmSumPrev, AlarmSumFind, AlarmSplit",
        "example": "/* This function finds the first alarm summary entry that matches \nthe specified tag, splits that entry and then adds the specified \ncomment to the new entry. */\n\nFUNCTION\nAlarmSplitAdd(STRING Tag, STRING Comment)\n    INT Index;\n    STRING Name;\n    Index=AlarmSumFirst();\n    WHILE Index<>-1 DO\n        Name=AlarmSumGet(Index,\"Tag\");\n        IF Name=sTag THEN\n            AlarmSumSplit(Index);\n            Index=AlarmSumFirst();\n            AlarmSumSet(Index,\"Comment\",Comment);\n            Index=-1;\n        ELSE\n            Index=AlarmSumNext(Index);\n        END\n    END\nEND\n\t\t\t",
        "name": "AlarmSumSplit",
        "params": [
            {
                "paramdescription": "The alarm summary index (returned from the AlarmSumFirst(), AlarmSumNext(), AlarmSumLast(), AlarmSumPrev(), AlarmSumAppend(), or AlarmSumFind() function).",
                "paramname": "Index"
            },
            {
                "paramdescription": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\".",
                "paramname": "ClusterName"
            },
            {
                "paramdescription": "The alarm OnTime (if omitted or is equal to 0, will default to current time, i.e. the time the function was invoked).",
                "paramname": "OnTime"
            },
            {
                "paramdescription": "Milliseconds part of the alarm's ON time",
                "paramname": "OnMilli"
            },
            {
                "paramdescription": "New alarm record is created on both redundant server instances.This parameter has been deprecated and is always set to true.",
                "paramname": "bRedundant:(optional)"
            }
        ],
        "returnType": "The Index of the new entry, or -1 on     error.",
        "syntax": "AlarmSumSplit(Index  [, ClusterName, OnTime, OnMilli, bRedundant=true]  )"
    },
    "alarmsumtype": {
        "doc": "Retrieves a value that indicates a specified alarm's type, that is whether it's a digital alarm, an analog alarm, hardware alarm, etc.\nThis function can only be used if the Alarm Server is on the current machine. When the Alarm Server is not in the calling process, this function will become blocking and cannot be called from a foreground task. In this case, the return value will be undefined and a Cicode hardware alarm will be raised.",
        "example": "No example found",
        "name": "AlarmSumType",
        "params": [
            {
                "paramdescription": "The alarm summary index (returned from the AlarmSumFirst(), AlarmSumNext(), AlarmSumLast(), AlarmSumPrev(), AlarmSumAppend(), or AlarmSumFind() function).",
                "paramname": "Index"
            },
            {
                "paramdescription": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\".",
                "paramname": "ClusterName"
            }
        ],
        "returnType": "A number that represents one of the following alarm types:",
        "syntax": "AlarmSumType(Index [, ClusterName] )"
    },
    "alarmtagfromequipment": {
        "doc": "Returns the first tag associated with a piece of equipment.",
        "example": "No example found",
        "name": "AlarmTagFromEquipment",
        "params": [
            {
                "paramdescription": "A string that identifies the alarm to acknowledge. It can be one of the following:\nAn alarm tag — for example, \"Fire1\"\nAn alarm equipment item — for example, \"Motor1.AlarmFire\"\nSpecify an empty string (\" \") to match all alarm tags.",
                "paramname": "Tag"
            },
            {
                "paramdescription": "The cluster in which the tag resides",
                "paramname": "ClusterName"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code will be returned",
        "syntax": "INT AlarmTagFromEquipment(STRING Tag,  [, STRING ClusterName])"
    },
    "almbrowseack": {
        "doc": "The AlmBrowseAck function acknowledges the alarm tag at the current cursor position in an active data browse session.\nThis function is a non-blocking function. It does not block the calling Cicode task.",
        "example": "No example found",
        "name": "AlmBrowseAck",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by a AlmBrowseOpen call.",
                "paramname": "iSession"
            }
        ],
        "returnType": "0 (zero) if the alarm browse session exists, otherwise an error code is returned.",
        "syntax": "INT AlmBrowseAck(LONG iSession)"
    },
    "almbrowseclose": {
        "doc": "The AlmBrowseClose function terminates an active data browse session and cleans up resources associated with the session.\nThis function is a non-blocking function. It does not block the calling Cicode task.",
        "example": "No example found",
        "name": "AlmBrowseClose",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by a AlmBrowseOpen call.",
                "paramname": "iSession"
            }
        ],
        "returnType": "0 (zero) if the alarm browse session exists, otherwise an error code is returned.",
        "syntax": "INT AlmBrowseClose(LONG iSession)"
    },
    "almbrowsedisable": {
        "doc": "The AlmBrowseDisable function disables the alarm tag at the current cursor position in an active data browse session.\nThis function is a non-blocking function. It does not block the calling Cicode task.",
        "example": "No example found",
        "name": "AlmBrowseDisable",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by an AlmBrowseOpen call.",
                "paramname": "iSession"
            },
            {
                "paramdescription": "An optional comment limited to 200 characters explaining why the alarm is disabled. If the comment exceeds 200 characters, hardware error 274 (\"Invalid argument passed\") will be displayed.",
                "paramname": "Comment"
            }
        ],
        "returnType": "0 (zero) if the alarm browse session exists, otherwise an error code is returned.",
        "syntax": "INT AlmBrowseDisable(INT iSession [, INT EndTime [, STRING Comment]] )"
    },
    "almbrowseenable": {
        "doc": "The AlmBrowseEnable function enables the alarm tag at the current cursor position in an active data browse session.\nThis function is a non-blocking function. It does not block the calling Cicode task.",
        "example": "No example found",
        "name": "AlmBrowseEnable",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by an AlmBrowseOpen call.",
                "paramname": "iSession"
            },
            {
                "paramdescription": "Forces acknowledgment of an alarm after it is enabled. The accepted values are:\n0 — (default) enforced acknowledgment will not be applied.\n1 — alarm will be acknowledged when enabled.",
                "paramname": "bAcknowledge"
            }
        ],
        "returnType": "0 (zero) if the alarm browse session exists, otherwise an error code is returned.",
        "syntax": "INT AlmBrowseEnable(INT iSession [, INT bAcknowledge])"
    },
    "almbrowsefirst": {
        "doc": "The AlmBrowseFirst function places the data browse cursor at the first record.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "AlmBrowseFirst",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by a AlmBrowseOpen call.",
                "paramname": "iSession"
            }
        ],
        "returnType": "0 (zero) if the alarm browse session exists, otherwise an error code is returned.",
        "syntax": "INT AlmBrowseFirst(LONG iSession)"
    },
    "almbrowsegetfield": {
        "doc": "The AlmBrowseGetField function retrieves the value of the specified field from the record the data browse cursor is currently referencing.\nThis function is a non-blocking function. It does not block the calling Cicode task.",
        "example": "STRING fieldValue = \"\";\nSTRING fieldName = \"TYPE\";\nINT errorCode = 0;\n...\nfieldValue = AlmBrowseGetField(iSession, sFieldName);\nIF fieldValue <> \"\" THEN\n\t// Successful case\nELSE\n\t// Function returned an error\nEND\n...",
        "name": "AlmBrowseGetField",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by aAlmBrowseOpen call.",
                "paramname": "iSession"
            },
            {
                "paramdescription": "The name of the field that references the value to be returned.Supported fields are:\nSee Browse Function Field Reference for information about fields.",
                "paramname": "sFieldName"
            }
        ],
        "returnType": "The value of the specified field as a string. An empty string may or may not be an indication that an error has been detected. The last error should be checked in this instance to determine if an error has actually occurred.",
        "syntax": "STRING AlmBrowseGetField(LONG iSession, STRING FieldName)"
    },
    "almbrowsenext": {
        "doc": "The AlmBrowseNext function moves the data browse cursor forward one record. If you call this function after you have reached the end of the records, error412 is returned (Databrowse session EOF).\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "AlmBrowseNext",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by a AlmBrowseOpen call.",
                "paramname": "iSession"
            }
        ],
        "returnType": "0 (zero) if the browse has successfully been moved to the next record, otherwise an error code is returned.",
        "syntax": "INT AlmBrowseNext(LONG iSession)"
    },
    "almbrowsenumrecords": {
        "doc": "The AlmBrowseNumRecords function returns the number of records that match the filter criteria.\nThis function is a non-blocking function. It does not block the calling Cicode task.",
        "example": "INT numRecords = 0;\n...\nnumRecords = AlmBrowseNumRecords(iSession);\nIF numRecords <> 0 THEN\n    // Have records\nELSE\n    // No records\nEND\n...",
        "name": "AlmBrowseNumRecords",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by a AlmBrowseOpen call.",
                "paramname": "iSession"
            }
        ],
        "returnType": "The number of records that have matched the filter criteria. A value of 0 denotes that no records have matched. A value of -1 denotes that the browse session is unable to provide a fixed number. This may be the case if the data being browsed changed during the browse session.",
        "syntax": "LONG AlmBrowseNumRecords(LONG iSession)"
    },
    "almbrowseopen": {
        "doc": "The AlmBrowseOpen function initiates a new browse session and returns a handle to the new session that can be used in subsequent data browse function calls. Use this function to browse all configured alarms.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete. \nLONG AlmBrowseOpen( Filter, STRING Fields [, STRING Clusters [,INT AutoCloseMode]] )\nFilter: \nFields:\nClusters:\nAutoCloseMode\nReturns an integer handle to the browse session. Returns -1 when an error is detected.\nThe returned entries will be ordered alphabetically by name.",
        "example": "INT iSession;\n...\niSession = AlmBrowseOpen(\"NAME=ABC*\", \"NAME,TYPE\",\n\"ClusterA,ClusterB\");\nIF iSession <> -1 THEN\n\t// Successful case\nELSE\n\t// Function returned an error\nEND\n...",
        "name": "AlmBrowseOpen",
        "params": [
            {
                "paramdescription": "A filter expression specifying the records to return duringthe browse. An empty string indicates that all records will bereturned. Where a fieldname is not specified in the filter, it isassumed to be tagname. For example, the filter \"AAA\" isequivalent to \"Tag=AAA\". Multiple filters separated by semicolons are supported.\nSee the topic Implementing Alarm Filters Using Cicode in the main Plant SCADA help for more information about filter syntax.",
                "paramname": "Filter"
            },
            {
                "paramdescription": "Specifies via a comma delimited string the columns to bereturned during the browse. An empty string indicates thatthe server will return all available columns. Supported fieldsare:\nACKDATE, ACKDATEEXT, ACKTIME, ACQERROR, ALARMTYPE, ALMCOMMENT, AREA, CATEGORY, CLUSTER, COMMENT, CUSTOM1, CUSTOM2, CUSTOM3, CUSTOM4, CUSTOM5, CUSTOM6, CUSTOM7, CUSTOM8, DATE, DATEEXT, DEADBAND, DELTATIME, DESC, DEVDELAY, DEVIATION, DISABLEENDTIME, ERRDESC, ERRPAGE, EQUIPMENT, FORMAT, GROUP, HDELAY, HELP, HHDELAY, HIGH, HIGHHIGH, ITEM, LDELAY, LEVEL, LLDELAY, LOCALTIMEDATE, LOGSTATE, LOW, LOWLOW, MILLISEC, NAME, NATIVE_COMMENT, NATIVE_DESC, NATIVE_NAME, NATIVE_SUMDESC, OFFDATE, OFFDATEEXT, OFFMILLI, OFFTIME, OFFTIMEDATE, OLD_DESC, ONDATE, ONDATEEXT, ONMILLI, ONTIME, ONTIMEDATE, PAGING, PAGINGGROUP, PRIORITY, PRIV, QUALITY, RATE, RECEIPTLOCALTIMEDATE, RECEIPTDATE, STATE, STATE_DESC, STATE_DESC0, STATE_DESC1, STATE_DESC2, STATE_DESC3, STATE_DESC4, STATE_DESC5, STATE_DESC6, STATE_DESC7, SUMDESC, SUMSTATE, SUMTYPE, TAG, TAGEX, TIME, TIMEDATE, TYPE, TYPENUM, USERNAME, VALUE.\nSee Browse Function Field Reference for information about fields.",
                "paramname": "Fields"
            },
            {
                "paramdescription": "An optional parameter that specifies via a comma delimitedstring the subset of the clusters to browse. An empty stringindicates that the connected clusters will be browsed.",
                "paramname": "Clusters"
            },
            {
                "paramdescription": " An optional parameter to automatically close the browsing session at page navigation. \n0 - (Default) Will not automatically close the browsing session. Use AlmBrowseClose to close the session manually.\n1 - The browsing session will be closed when the page is changed or otherwise closed.\nNote: All other modes are reserved.",
                "paramname": "AutoCloseMode"
            }
        ],
        "returnType": "Returns an integer handle to the browse session. Returns -1 when an error is detected.",
        "syntax": "LONG AlmBrowseOpen( Filter, STRING Fields [, STRING Clusters [,INT AutoCloseMode]] )"
    },
    "almbrowseprev": {
        "doc": "The AlmBrowsePrev function moves the data browse cursor back one record.  If you call this function after you have reached the beginning of the records, error 412 is returned (Databrowse session EOF).\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "AlmBrowsePrev",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by a AlmBrowseOpen call.",
                "paramname": "iSession"
            }
        ],
        "returnType": "0 (zero) if the alarm browse session exists, otherwise an error code is returned.",
        "syntax": "INT AlmBrowsePrev(LONG iSession)"
    },
    "almsummaryack": {
        "doc": "The AlmSummaryAck function acknowledges the alarm in the active alarm listwhich is linked to the current entry of the alarm summary browse session.\nIf the current alarm summary browse session entry is a user event the functionwill have no effect.     \nThis function is a non-blocking function. It does not block the calling Cicode task.",
        "example": "No example found",
        "name": "AlmSummaryAck",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by a AlmSummaryOpen call.",
                "paramname": "Session"
            }
        ],
        "returnType": "0 (zero) if the alarm browse session exists, otherwise an error code is returned.",
        "syntax": "INT AlmSummaryAck(LONG Session)"
    },
    "almsummaryclear": {
        "doc": "The AlmSummaryClear function clears the latched alarm at the current cursor position in an active data browse session. A latched alarm is an alarm which is OFF and acknowledged when [Alarm]AckHold is set to 1. The function does nothing if the alarm summary entry at the cursor is not linked to a latched alarm.\nThis function is a non-blocking function. It does not block the calling Cicode task.",
        "example": "No example found",
        "name": "AlmSummaryClear",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by a AlmSummaryOpen call.",
                "paramname": "Session"
            }
        ],
        "returnType": "0 (zero) if the alarm browse session exists, otherwise an error code is returned.",
        "syntax": "INT AlmSummaryClear(LONG Session)"
    },
    "almsummaryclose": {
        "doc": "The AlmSummaryClose function terminates an active data browse session and cleans up all resources associated with the session.\nThis function is a non-blocking function. It does not block the calling Cicode task.",
        "example": "No example found",
        "name": "AlmSummaryClose",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by a AlmSummaryOpen call.",
                "paramname": "iSession"
            }
        ],
        "returnType": "0 (zero) if the alarm browse session exists, otherwise an error code is returned.",
        "syntax": "INT AlmSummaryClose(LONG iSession)"
    },
    "almsummarycommit": {
        "doc": "The AlmSummaryCommit function triggers the actual write of the value for the field previously specified by AlmSummarySetFieldValue.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.\nAlmSummaryCommit(iSession)\niSession: \n0 (zero) if the alarm browse session exists, otherwise an error is returned.",
        "example": "INT errorCode = 0;\n...\nerrorCode = AlmSummaryCommit(iSession);\nIF errorCode = 0 THEN\n    // Successful case\nELSE\n    // Function returned an error\nEND\n...\n\t\t\t",
        "name": "AlmSummaryCommit",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by a AlmSummaryOpen call.",
                "paramname": "iSession"
            }
        ],
        "returnType": "0 (zero) if the alarm browse session exists, otherwise an error is returned.",
        "syntax": "AlmSummaryCommit(iSession)"
    },
    "almsummarydelete": {
        "doc": "The AlmSummaryDelete function deletes the record in the filtered list that the cursor is currently referencing. The cursor moves to the next available entry in the data browse session after the current alarm summary is deleted.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.\nINT AlmSummaryDelete(LONG iSession) \niSession: \n0 (zero) if the alarm browse session exists, otherwise an error code is returned.",
        "example": "INT errorCode = 0;\n...\nerrorCode = AlmSummaryDelete(iSession);\nIF errorCode = 0 THEN\n    // Successful case\nELSE\n    // Function returned an error\nEND\n...",
        "name": "AlmSummaryDelete",
        "params": [
            {
                "paramdescription": "The handle to a filtered list previously returned by a AlmSummaryOpen call.",
                "paramname": "iSession"
            }
        ],
        "returnType": "0 (zero) if the alarm browse session exists, otherwise an error code is returned.",
        "syntax": "INT AlmSummaryDelete(LONG iSession) "
    },
    "almsummarydeleteall": {
        "doc": "The AlmSummaryDeleteAll function deletes every record from the filtered list source.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.\nINT AlmSummaryDeleteAll(LONG iSession)\niSession: \n0 (zero) if the alarm filtered list session exists, otherwise an error code is returned.",
        "example": "INT errorCode = 0;\n...\nerrorCode = AlmSummaryDeleteAll(iSession);\nIF errorCode = 0 THEN\n    // Successful case\nELSE\n    // Function returned an error\nEND\n...",
        "name": "AlmSummaryDeleteAll",
        "params": [
            {
                "paramdescription": "The handle to a filtered list previously returned by aAlmSummaryOpen call.",
                "paramname": "iSession"
            }
        ],
        "returnType": "0 (zero) if the alarm filtered list session exists, otherwise an error code is returned.",
        "syntax": "INT AlmSummaryDeleteAll(LONG iSession)"
    },
    "almsummarydisable": {
        "doc": "The AlmSummaryDisable function disables the alarm at the current cursor position in an active data browse session.\nThis function is a non-blocking function. It does not block the calling Cicode task.",
        "example": "No example found",
        "name": "AlmSummaryDisable",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by an AlmSummaryOpen call.",
                "paramname": "iSession"
            },
            {
                "paramdescription": "A date/time variable that indicates when the alarm will no longer be disabled. If this parameter is omitted or set to 0, the alarm will be disabled indefinitely.",
                "paramname": "EndTime"
            },
            {
                "paramdescription": "An optional comment limited to 200 characters explaining why the alarm is disabled. If the comment exceeds 200 characters, hardware error 274 (\"Invalid argument passed\") will be displayed.",
                "paramname": "Comment"
            }
        ],
        "returnType": "0 (zero) if the alarm browse session exists, otherwise an error code is returned.",
        "syntax": "INT AlmSummaryDisable(INT iSession [, INT EndTime [, STRING Comment]] )"
    },
    "almsummaryenable": {
        "doc": "The AlmSummaryEnable function enables the alarm at the current cursor position in an active data browse session.\nThis function is a non-blocking function. It does not block the calling Cicode task.",
        "example": "No example found",
        "name": "AlmSummaryEnable",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by an AlmSummaryOpen call.",
                "paramname": "iSession"
            },
            {
                "paramdescription": "Forces acknowledgment of an alarm after it is enabled. The accepted values are:\n0 — (default) enforced acknowledgment will not be applied.\n1 — alarm will be acknowledged when enabled.",
                "paramname": "bAcknowledge"
            }
        ],
        "returnType": "0 (zero) if the alarm browse session exists, otherwise an error code is returned.",
        "syntax": "INT AlmSummaryEnable(INT iSession [, INT bAcknowledge])"
    },
    "almsummaryfirst": {
        "doc": "The AlmSummaryFirst function places the data browse cursor at the first record.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "AlmSummaryFirst",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by a AlmSummaryOpen call.",
                "paramname": "iSession"
            }
        ],
        "returnType": "0 (zero) if the alarm browse session exists, otherwise an error code is returned.",
        "syntax": "INT AlmSummaryFirst(LONG iSession)"
    },
    "almsummarygetfield": {
        "doc": "The AlmSummaryGetField function retrieves the value of the specified field from the record the data browse cursor is currently referencing.\nThis function is a non-blocking function. It does not block the calling Cicode task.",
        "example": "STRING fieldValue = \"\";\nSTRING fieldName = \"TYPE\";\nINT errorCode = 0;\n...\nfieldValue = AlmSummaryGetField(iSession, sFieldName);\nIF fieldValue <> \"\" THEN\n    // Successful case\nELSE\n    // Function returned an error\nEND\n...",
        "name": "AlmSummaryGetField",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by aAlmSummaryOpen call.",
                "paramname": "iSession"
            },
            {
                "paramdescription": "The name of the field that references the value to be returned.Supported fields are:",
                "paramname": "sFieldName"
            },
            {
                "paramdescription": "",
                "paramname": "The value of the specified field as a string. An empty string may or may not be an indication that an error has been detected. The last error should be checked in this instance to determine if an error has actually occurred."
            }
        ],
        "returnType": "The value of the specified field as a string. An empty string may or may not be an indication that an error has been detected. The last error should be checked in this instance to determine if an error has actually occurred.",
        "syntax": "STRING AlmSummaryGetField(LONG iSession, STRING sFieldName)"
    },
    "almsummarylast": {
        "doc": "The AlmSummaryLast function places the data browse cursor at the most recent summary record from the last cluster of the available browsing cluster list.\nThis function is a blocking function. It blocks the calling Cicode task untilthe operation is complete.",
        "example": "No example found",
        "name": "AlmSummaryLast",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by a AlmSummaryOpen call.",
                "paramname": "iSession"
            }
        ],
        "returnType": "0 (zero) if the alarm browse session exists, otherwise an error code is returned.",
        "syntax": "INT AlmSummaryLast(LONG iSession)"
    },
    "almsummarynext": {
        "doc": "The AlmSummaryNext function moves the data browse cursor forward one record. If you call this function after you have reached the end of a summary, error 412 is returned (Databrowse session EOF).\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "AlmSummaryNext",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by a AlmSummaryOpen call.",
                "paramname": "iSession"
            }
        ],
        "returnType": "0 (zero) if the alarm browse session exists, otherwise an error code is returned.",
        "syntax": "INT AlmSummaryNext(LONG iSession)"
    },
    "almsummarynumrecords": {
        "doc": "The AlmSummaryNumRecords function retrieves the number of records in an alarm summary browse session.\nThis function is a non-blocking function. It does not block the calling Cicode task.",
        "example": "INT numRecords = 0;\n...\nnumRecords = AlmSummaryNumRecords(iSession);\nIF numRecords <> 0 THEN\n    // Have records\nELSE\n    // No records\nEND\n...",
        "name": "AlmSummaryNumRecords",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by a AlmSummaryOpen call.",
                "paramname": "iSession"
            }
        ],
        "returnType": "The number of records that have matched the filter criteria. A value of 0 denotes that no records have matched. A value of -1 denotes that the browse session is unable to provide a fixed number. This may be the case if the data being browsed changed during the browse session.",
        "syntax": "LONG AlmSummaryNumRecords(LONG iSession)"
    },
    "almsummaryopen": {
        "doc": "The AlmSummaryOpen function initiates a new browse session and returns a handle to the new session that can be used in subsequent data browse function calls. \nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.\nThe AlarmSummaryOpen function allows direct, successful subsequent execution of AlmSummaryNext and AlmSummaryPrev functions.\nThe AlmSummaryNext function executed directly after AlmSummaryOpen will place the data browse cursor at the earliest summary record.\nThe AlmSummaryPrev function executed directly after AlmSummaryOpen will place the cursor at the most recent summary record. \nNote: Performance may be affected when using the AlmSummaryOpen browse functions in a system which has accumulated large volumes of alarm summary entries.\nTo improve performance:",
        "example": "Example 1 - Specifying the fields\n\n\nINT iSession;\n...\niSession = AlmSummaryOpen(\"NAME=ABC*\", \"NAME,TYPE\",\n\"ClusterA,ClusterB\");\nIF iSession <> -1 THEN\n// Successful case\nELSE\n// Function returned an error\nEND\n...\n\t\t\t\t\n\nExample 2 - Specifying the time range for multiple incremental browse sessions\n\n\t\t\t\t\nINT session;\nSTRING t0 ;\nSTRING t1;\n           \n // Below is an example of browsing alarm summary records incrementally in small time ranges\n // of 20 minutes interval over an hour from 10:00am TO 11:00am on 9th March 2015 local time.\n            \n // 10:00 ~ 10:20\n t0 = IntToStr(TimestampToTimeInt(TimestampCreate(2015,03,09,10,00,00,000)));\n t1 = IntToStr(TimestampToTimeInt(TimestampCreate(2015,03,09,10,20,00,000)));\n session = AlmSummaryOpen(\"OnTime >= \" + t0 + \" AND OnTime < \" + t1, \"\");\n IF (session >= 0) THEN\n     AlmSummaryFirst(session);\n     // Do something with the browse session\n     // ...\n     AlmSummaryClose(session);\n END\n           \n // 10:20 ~ 10:40\n t0 = IntToStr(TimestampToTimeInt(TimestampCreate(2015,03,09,10,20,00,000)));\n t1 = IntToStr(TimestampToTimeInt(TimestampCreate(2015,03,09,10,40,00,000)));\n session = AlmSummaryOpen(\"OnTime >= \" + t0 + \" AND OnTime < \" + t1, \"\");\n IF (session >= 0) THEN\n     AlmSummaryFirst(session);\n     // Do something with the browse session\n     // ...\n     AlmSummaryClose(session);\n END\n           \n // 10:40 ~ 11:00\n t0 = IntToStr(TimestampToTimeInt(TimestampCreate(2015,03,09,10,40,00,000)));\n t1 = IntToStr(TimestampToTimeInt(TimestampCreate(2015,03,09,11,00,00,000)));\n session = AlmSummaryOpen(\"OnTime >= \" + t0 + \" AND OnTime < \" + t1, \"\");\n IF (session >= 0) THEN\n     AlmSummaryFirst(session);\n     // Do something with the browse session\n     // ...\n     AlmSummaryClose(session);\n END\n ...\n\n\nExample 3 - Specify RowLimit for multiple incremental browse sessions\n\n\t\t\t\t\nINT session;\nINT rowLimit = 500;\nSTRING continuationFilter;\nREAL ts;\nSTRING lastOnTime;\n           \n// Below is an example of browsing alarm summary records incrementally in small row limit of 50\n// The OnTime and Tag of the last record is used as the continuation for the next incremental session.\n            \n// First session\nsession = AlmSummaryOpen(\"\", \"\", \"Cluster1\", rowLimit);\nIF (session < 0) THEN\n    RETURN;\nEND\n            \nAlmSummaryFirst(session);\n// Do something with the browse session, and call AlmSummaryNext(session) to iterate\n// ...\n          \n// Capture the timestamp of the last record for browse continuation with a next session.\nAlmSummaryLast(session);\nts = (StrToReal(AlmSummaryGetField(session, \"OnMilli\")) / 1000) +\n      StrToDate(AlmSummaryGetField(session, \"OnDate\")) +\n      StrToTime(AlmSummaryGetField(session, \"OnTime\"));\n           \nlastOnTime = RealToStr(ts, 0, 3);\n\t\t\t\t\nAlmSummaryClose(session);\n            \n// Continue browsing using small row limit.\ncontinuationFilter = \"OnTime > \" + lastOnTime;\nsession = AlmSummaryOpen(continuationFilter, \"\", \"Cluster1\", rowLimit);\nIF (session < 0) THEN\n     RETURN;\nEND\n  \nIF AlmSummaryFirst(session) <> 0 THEN\n     AlmSummaryClose(session);\n      RETURN;\nEND\n            \n// Do something with the browse session, and call AlmSummaryNext(session) to iterate\n// ...\n            \n// Capture the timestamp of the last record for browse continuation with a next session.\nAlmSummaryLast(session);\nts = (StrToReal(AlmSummaryGetField(session, \"OnMilli\")) / 1000) +\n           StrToDate(AlmSummaryGetField(session, \"OnDate\")) +\n           StrToTime(AlmSummaryGetField(session, \"OnTime\"));\n           \nlastOnTime = RealToStr(ts, 0, 3);\nAlmSummaryClose(session);\n…",
        "name": "AlmSummaryOpen",
        "params": [
            {
                "paramdescription": "A filter expression specifying the records to return duringthe browse. An empty string indicates that all records will bereturned. Where a fieldname is not specified in the filter, it isassumed to be tagname. For example, the filter \"AAA\" isequivalent to \"TAG=AAA\".",
                "paramname": "Filter"
            },
            {
                "paramdescription": "Specifies via a comma delimited string the columns to bereturned during the browse. An empty string indicates thatthe server will return all available columns. Supported fieldsare:\nACKDATE, ACKDATEEXT, ACKTIME, ACQERROR, ALARMTYPE, ALMCOMMENT, AREA, CATEGORY, CLUSTER, COMMENT, CUSTOM1, CUSTOM2, CUSTOM3, CUSTOM4, CUSTOM5, CUSTOM6, CUSTOM7, CUSTOM8, DATE, DATEEXT, DEADBAND, DELTATIME, DESC, DEVIATION, ERRDESC, ERRPAGE, EQUIPMENT, FORMAT, GROUP, HELP, HIGH, HIGHHIGH, ITEM, LEVEL, LOCALTIMEDATE, LOGSTATE, LOW, LOWLOW, MILLISEC, NAME, NATIVE_COMMENT, NATIVE_DESC, NATIVE_NAME, NATIVE_SUMDESC, OFFDATE, OFFDATEEXT, OFFMILLI, OFFTIME, OFFTIMEDATE, OLD_DESC, ONDATE, ONDATEEXT, ONMILLI, ONTIME, ONTIMEDATE, PAGING, PAGINGGROUP, PRIORITY, PRIV, QUALITY, RATE, RECEIPTLOCALTIMEDATE, RECEIPTDATE, STATE, STATE_DESC, STATE_DESC0, STATE_DESC1, STATE_DESC2, STATE_DESC3, STATE_DESC4, STATE_DESC5, STATE_DESC6, STATE_DESC7, SUMDESC, SUMSTATE, SUMTYPE, TAG, TAGEX, TIME, TIMEDATE, TYPE, TYPENUM, USERNAME, VALUE.\nSee Browse Function Field Reference for information about fields.",
                "paramname": "Fields"
            },
            {
                "paramdescription": "An optional parameter that specifies via a comma delimitedstring the subset of the clusters to browse. An empty stringindicates that the connected clusters will be browsed.",
                "paramname": "Clusters"
            },
            {
                "paramdescription": "The default value of iRowLimit is -1. This will cause the browse session to use the default global maximum row limit (configured by the INI parameter [Alarm]BrowseRowLimit), or the default value of the INI parameter if not specified. \nSpecifying a small iRowLimit can reduce the round-trip time and the memory usage of AlmSummaryOpen Cicode function in a system with large alarm summary history.",
                "paramname": "RowLimit"
            },
            {
                "paramdescription": "Optional parameter to close session at page navigation.\n0 - Will not automatically close the browsing session. Use AlmSummaryClose to close the session manually.\n1 - The browsing session will be closed when the page is changed or otherwise closed.\nReturns an integer handle to the browse session. Returns -1 on error.",
                "paramname": "AutoCloseMode"
            }
        ],
        "returnType": "Returns an integer handle to the browse session. Returns -1 on error.",
        "syntax": "LONG  AlmSummaryOpen(STRING Filter, STRING Fields [, STRING Clusters [, INT RowLimit, [,INT AutoCloseMode]]])"
    },
    "almsummaryprev": {
        "doc": "The AlmSummaryPrev function moves the data browse cursor back one record.  If you call this function after you have reached the beginning of a summary, error 412 is returned (Databrowse session EOF).\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "AlmSummaryPrev",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by a AlmSummaryOpen call.",
                "paramname": "iSession"
            }
        ],
        "returnType": "0 (zero) if the alarm browse session exists, otherwise an error code is returned.",
        "syntax": "INT AlmSummaryPrev(LONG Session)"
    },
    "almsummarysetfieldvalue": {
        "doc": "The AlmSummarySetFieldValue function sets a new value for the specified field for the record the data browse cursor is currently referencing. The value is not committed until a call to AlmSummaryCommit is made.\nThe new values are discarded if the cursor is moved away from the current alarm summary entry before AlmSummaryCommit is made in the data browse session\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.\nAlmSummarySetFieldValue(iSession, sFieldname, sFieldValue)\niSession: \nsFieldName:\nsFieldValue:\n0 (zero) if the alarm browse session exists, otherwise an error is returned.",
        "example": "STRING sFieldValue = \"NEW_COMMENT\";\nSTRING sFieldName = \"COMMENT\";\nINT errorCode = 0;\n...\nerrorCode = AlmSummarySetFieldValue(iSession, sFieldname, \n\t\t\t\tsFieldValue);\nIF errorCode = 0 THEN\n\t// Successful case\nELSE\n\t// Function returned an error\nEND\n...\n\t\t\t",
        "name": "AlmSummarySetFieldValue",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by a AlmSummaryOpen call.",
                "paramname": "iSession"
            },
            {
                "paramdescription": "The name of the field whose value is to be updated. Supported fields are:\nSee Browse Function Field Reference for additional information about fields.",
                "paramname": "sFieldName"
            },
            {
                "paramdescription": "The field value to update.",
                "paramname": "sFieldValue"
            }
        ],
        "returnType": "0 (zero) if the alarm browse session exists, otherwise an error is returned.",
        "syntax": "AlmSummarySetFieldValue(iSession, sFieldname, sFieldValue)"
    },
    "almtagsack": {
        "doc": "This command is now deprecated. Use     AlmBrowseAck function instead.\nThe AlmTagsAck function acknowledges the alarm tag at the current cursor position in an active data browse session.\nThis function is a non-blocking function. It does not block the calling Cicode task.",
        "example": "No example found",
        "name": "AlmTagsAck",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by a AlmTagsOpen call.",
                "paramname": "iSession"
            }
        ],
        "returnType": "0 (zero) if the alarm browse session exists, otherwise an error code is returned.",
        "syntax": "AlmTagsAck(iSession)"
    },
    "almtagsclear": {
        "doc": "This command is now deprecated.\nThe AlmTagsClear function clears the alarm tag at the current cursor position in an active data browse session.\nThis function is a non-blocking function. It does not block the calling Cicode task.",
        "example": "No example found",
        "name": "AlmTagsClear",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by a AlmTagsOpen call.",
                "paramname": "iSession"
            }
        ],
        "returnType": "0 (zero) if the alarm browse session exists, otherwise an error code is returned.",
        "syntax": "AlmTagsClear(iSession)"
    },
    "almtagsclose": {
        "doc": "This command is now deprecated. Use AlmBrowseClose function instead.\nThe AlmTagsClose function terminates an active data browse session and cleans up all resources associated with the session.\nThis function is a non-blocking function. It does not block the calling Cicode task.",
        "example": "No example found",
        "name": "AlmTagsClose",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by a AlmTagsOpen call.",
                "paramname": "iSession"
            }
        ],
        "returnType": "0 (zero) if the alarm browse session exists, otherwise an error code is returned.",
        "syntax": "AlmTagsClose(iSession)"
    },
    "almtagsdisable": {
        "doc": "This command is now deprecated. Use AlmBrowseDisable function instead.\nThe AlmTagsDisable function disables the alarm tag at the current cursor position in an active data browse session.\nThis function is a non-blocking function. It does not block the calling Cicode task.",
        "example": "No example found",
        "name": "AlmTagsDisable",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by a AlmTagsOpen call.",
                "paramname": "iSession"
            },
            {
                "paramdescription": "A date/time variable that indicates when the alarm will no longer be disabled. If this parameter is omitted or set to 0, the alarm will be disabled indefinitely.",
                "paramname": "EndTime"
            },
            {
                "paramdescription": "An optional comment limited to 200 characters explaining why the alarm is disabled. If the comment exceeds 200 characters, hardware error 274 (\"Invalid argument passed\") will be displayed.",
                "paramname": "Comment"
            }
        ],
        "returnType": "0 (zero) if the alarm browse session exists, otherwise an error code is returned.",
        "syntax": "AlmTagsDisable(INT iSession [, INT EndTime [, STRING Comment]] )"
    },
    "almtagsenable": {
        "doc": "This command is now deprecated. Use AlmBrowseEnable function instead.\nThe AlmTagsEnable function enables the alarm tag at the current cursor position in an active data browse session. \nThis function is a non-blocking function. It does not block the calling Cicode task.",
        "example": "No example found",
        "name": "AlmTagsEnable",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by a AlmTagsOpen call.",
                "paramname": "iSession"
            },
            {
                "paramdescription": "Forces acknowledgment of an alarm after it is enabled. The accepted values are:\n0 — (default) enforced acknowledgment will not be applied.\n1 — alarm will be acknowledged when enabled.",
                "paramname": "bAcknowledge"
            }
        ],
        "returnType": "0 (zero) if the alarm browse session exists, otherwise an error code is returned.",
        "syntax": "AlmTagsEnable(INT iSession [, INT bAcknowledge])"
    },
    "almtagsfirst": {
        "doc": "This command is now deprecated. Use AlmBrowseFirst function instead.\nThe AlmTagsFirst function places the data browse cursor at the first record.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "AlmTagsFirst",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by a AlmTagsOpen call.",
                "paramname": "iSession"
            }
        ],
        "returnType": "0 (zero) if the alarm browse session exists, otherwise an error code is returned.",
        "syntax": "AlmTagsFirst(iSession)"
    },
    "almtagsgetfield": {
        "doc": "This command is now deprecated. Use AlmBrowseGetField function instead.\nThe AlmTagsGetField function retrieves the value of the specified field from the record the data browse cursor is currently referencing.\nThis function is a non-blocking function. It does not block the calling Cicode task.",
        "example": "STRING fieldValue = \"\";\nSTRING fieldName = \"TYPE\";\nINT errorCode = 0;\n...\nfieldValue = AlmTagsGetField(iSession, sFieldName);\nIF fieldValue <> \"\" THEN\n\t// Successful case\nELSE\n\t// Function returned an error\nEND\n...",
        "name": "AlmTagsGetField",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by aAlmTagsOpen call.",
                "paramname": "iSession"
            },
            {
                "paramdescription": "The name of the field that references the value to be returned.Supported fields are:\nACKDATE, ACKDATEEXT, ACKTIME, ACQERROR, ALARMTYPE, ALMCOMMENT, AREA, CATEGORY, CAUSE1, CAUSE2, CAUSE3, CAUSE4, CAUSE5, CAUSE6, CAUSE7, CAUSE8, CLUSTER, COMMENT, CONSEQUENCE1, CONSEQUENCE2, CONSEQUENCE3, CONSEQUENCE4, CONSEQUENCE5, CONSEQUENCE6, CONSEQUENCE7, CONSEQUENCE8, CUSTOM1, CUSTOM2, CUSTOM3, CUSTOM4, CUSTOM5, CUSTOM6, CUSTOM7, CUSTOM8, DATE, DATEEXT, DEADBAND, DELTATIME, DESC, DEVIATION, DISABLEENDDATE, DISABLEENDDATEEXT, DISABLEENDTIME, DISABLECOMMENT, ERRDESC, ERRPAGE, EQUIPMENT, FORMAT, GROUP, HELP, HIGH, HIGHHIGH, LEVEL, LOCALTIMEDATE, LOGSTATE, LOW, LOWLOW, MILLISEC, NAME, NATIVE_COMMENT, NATIVE_DESC, NATIVE_NAME, NATIVE_SUMDESC, OFFDATE, OFFDATEEXT, OFFMILLI, OFFTIME, OFFTIMEDATE, OLD_DESC, ONDATE, ONDATEEXT, ONMILLI, ONTIME, ONTIMEDATE, PAGING, PAGINGGROUP, PRIORITY, PRIV, QUALITY, RATE, RECEIPTLOCALTIMEDATE, RECEIPTDATE, RESPONSE1, RESPONSE2, RESPONSE3, RESPONSE4, RESPONSE5, RESPONSE6, RESPONSE7, RESPONSE8, RESPONSENUM, RESPTIME1, RESPTIME2, RESPTIME3, RESPTIME4, RESPTIME5, RESPTIME6, RESPTIME7, RESPTIME8, STATE, STATE_DESC, STATE_DESC0, STATE_DESC1, STATE_DESC2, STATE_DESC3, STATE_DESC4, STATE_DESC5, STATE_DESC6, STATE_DESC7, SUMDESC, SUMSTATE, SUMTYPE, TAG, TAGEX, TIME, TIMEDATE, TYPE, TYPENUM, USERNAME, VALUE.\nSee Browse Function Field Reference for information about fields.",
                "paramname": "sFieldName"
            }
        ],
        "returnType": "The value of the specified field as a string. An empty string may or may not be an indication that an error has been detected. The last error should be checked in this instance to determine if an error has actually occurred.",
        "syntax": "AlmTagsGetField(iSession, sFieldName)"
    },
    "almtagsnext": {
        "doc": "This command is now deprecated. Use AlmBrowseNext function instead.\nThe AlmTagsNext function moves the data browse cursor forward one record. If you call this function after you have reached the end of the records, error412 is returned (Databrowse session EOF).\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "AlmTagsNext",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by a AlmTagsOpen call.",
                "paramname": "iSession"
            }
        ],
        "returnType": "0 (zero) if the browse has successfully been moved to the next record, otherwise an error code is returned.",
        "syntax": "AlmTagsNext(iSession)"
    },
    "almtagsnumrecords": {
        "doc": "This command is now deprecated. Use AlmBrowseNumRecords function instead.\nThe AlmTagsNumRecords function returns the number of records that match the filter criteria.\nThis function is a non-blocking function. It does not block the calling Cicode task.",
        "example": "INT numRecords = 0;\n...\nnumRecords = AlmTagsNumRecords(iSession);\nIF numRecords <> 0 THEN\n    // Have records\nELSE\n    // No records\nEND\n...",
        "name": "AlmTagsNumRecords",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by a AlmTagsOpen call.",
                "paramname": "iSession"
            }
        ],
        "returnType": "The number of records that have matched the filter criteria. A value of 0 denotes that no records have matched. A value of -1 denotes that the browse session is unable to provide a fixed number. This may be the case if the data being browsed changed during the browse session.",
        "syntax": "AlmTagsNumRecords(iSession)"
    },
    "almtagsopen": {
        "doc": "This command is now deprecated. Use AlmBrowseOpen function instead.\nThe AlmTagsOpen function initiates a new browse session and returns a handle to the new session that can be used in subsequent data browse function calls.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete. \nAlmTagsOpen( sFilter, sFields [, sClusters] )\nsFilter: \nsFields:\nsClusters:\nReturns an integer handle to the browse session. Returns -1 when an error is detected.\nThe returned entries will be ordered alphabetically by name.",
        "example": "INT iSession;\n...\niSession = AlmTagsOpen(\"NAME=ABC*\", \"NAME,TYPE\",\n\"ClusterA,ClusterB\");\nIF iSession <> -1 THEN\n\t// Successful case\nELSE\n\t// Function returned an error\nEND\n...",
        "name": "AlmTagsOpen",
        "params": [
            {
                "paramdescription": "A filter expression specifying the records to return duringthe browse. An empty string indicates that all records will bereturned. Where a fieldname is not specified in the filter, it isassumed to be tagname. For example, the filter \"AAA\" isequivalent to \"Tag=AAA\".",
                "paramname": "sFilter"
            },
            {
                "paramdescription": "Specifies via a comma delimited string the columns to bereturned during the browse. An empty string indicates thatthe server will return all available columns. Supported fieldsare:\nACKDATE, ACKDATEEXT, ACKTIME, ACQERROR, ALARMTYPE, ALMCOMMENT, AREA, CATEGORY, CLUSTER, COMMENT, CUSTOM1, CUSTOM2, CUSTOM3, CUSTOM4, CUSTOM5, CUSTOM6, CUSTOM7, CUSTOM8, DATE, DATEEXT, DEADBAND, DELTATIME, DESC, DEVIATION, DISABLEENDTIME, ERRDESC, ERRPAGE, EQUIPMENT, FORMAT, GROUP, HELP, HIGH, HIGHHIGH, ITEM, LEVEL, LOCALTIMEDATE, LOGSTATE, LOW, LOWLOW, MILLISEC, NAME, NATIVE_COMMENT, NATIVE_DESC, NATIVE_NAME, NATIVE_SUMDESC, OFFDATE, OFFDATEEXT, OFFMILLI, OFFTIME, OFFTIMEDATE, OLD_DESC, ONDATE, ONDATEEXT, ONMILLI, ONTIME, ONTIMEDATE, PAGING, PAGINGGROUP, PRIORITY, PRIV, QUALITY, RATE, RECEIPTLOCALTIMEDATE, RECEIPTDATE, STATE, STATE_DESC, STATE_DESC0, STATE_DESC1, STATE_DESC2, STATE_DESC3, STATE_DESC4, STATE_DESC5, STATE_DESC6, STATE_DESC7, SUMDESC, SUMSTATE, SUMTYPE, TAG, TAGEX, TIME, TIMEDATE, TYPE, TYPENUM, USERNAME, VALUE.\nSee Browse Function Field Reference for information about fields.",
                "paramname": "sFields"
            },
            {
                "paramdescription": "An optional parameter that specifies via a comma delimitedstring the subset of the clusters to browse. An empty stringindicates that the connected clusters will be browsed.",
                "paramname": "sClusters"
            }
        ],
        "returnType": "Returns an integer handle to the browse session. Returns -1 when an error is detected.",
        "syntax": "AlmTagsOpen( sFilter, sFields [, sClusters] )"
    },
    "almtagsprev": {
        "doc": "This command is now deprecated. Use AlmBrowsePrev function instead.\nThe AlmTagsPrev function moves the data browse cursor back one record.  If you call this function after you have reached the beginning of the records, error 412 is returned (Databrowse session EOF).\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "AlmTagsPrev",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by a AlmTagsOpen call.",
                "paramname": "iSession"
            }
        ],
        "returnType": "0 (zero) if the alarm browse session exists, otherwise an error code is returned.",
        "syntax": "AlmTagsPrev(iSession)"
    },
    "anbyname": {
        "doc": "Retrieves the animation point number of an ActiveX object.   ",
        "example": "No example found",
        "name": "AnByName",
        "params": [
            {
                "paramdescription": "The name given to the ActiveX object. This name is visible in the \"Identification\" tab of the ActiveX control in the Graphics Builder and is used to access the object.\nIf the Animation number for an object is 35 and you renamed the object to fred use AnByName(\"Fred\"); which will return 35.\n If you left the name of the object as the default use AnByName(\"AN35\"); which will return 35. ",
                "paramname": "sName"
            }
        ],
        "returnType": "The animation point number of the object - if successful, otherwise an error code is returned.",
        "syntax": "AnByName(sName)"
    },
    "arccos": {
        "doc": "Calculates the arccosine of an angle.",
        "example": "Variable=ArcCos(0.4);\n! Sets Variable to 1.1592...",
        "name": "ArcCos",
        "params": [
            {
                "paramdescription": "The cosine of the angle.",
                "paramname": "Number"
            }
        ],
        "returnType": "The arccosine (the angle, in radians) of Number.",
        "syntax": "ArcCos(Number)"
    },
    "arcsin": {
        "doc": "Calculates the arcsine of an angle.",
        "example": "Variable=ArcSin(1);\n! Sets Variable to 1.5707...",
        "name": "ArcSin",
        "params": [
            {
                "paramdescription": "The sine of the angle.",
                "paramname": "Number"
            }
        ],
        "returnType": "The arcsine (the angle, in radians) of Number.",
        "syntax": "ArcSin(Number)"
    },
    "arctan": {
        "doc": "Calculates the arctangent of an angle.",
        "example": "Variable=ArcTan(0.4);\n! Sets Variable to 0.3805...",
        "name": "ArcTan",
        "params": [
            {
                "paramdescription": "The tangent of the angle.",
                "paramname": "Number"
            }
        ],
        "returnType": "The arctangent (the angle, in radians) of Number.",
        "syntax": "ArcTan(Number)"
    },
    "areacheck": {
        "doc": "Determines whether the current user has access to a specified area.",
        "example": "IsArea = AreaCheck(5);",
        "name": "AreaCheck",
        "params": [
            {
                "paramdescription": "The area number (0 - 255)",
                "paramname": "Area"
            }
        ],
        "returnType": "TRUE (1) if the user has access to the Area or FALSE (0) if not.",
        "syntax": "AreaCheck(Area)"
    },
    "arraycopy": {
        "doc": "Makes a copy of an array. ",
        "example": "...\nhArray2 = ArrayCopy(hArray1);\n...",
        "name": "ArrayCopy",
        "params": [
            {
                "paramdescription": "The handle of the array you want to copy.",
                "paramname": "hArray"
            }
        ],
        "returnType": "The handle of the created copy. If unsuccessful, -1 is returned. The error code can be obtained by calling the IsError Cicode function.",
        "syntax": "INT ArrayCopy(INT hArray)"
    },
    "arraycreate": {
        "doc": "Creates an array. An array can include up to 2,097,153 elements, but each dimension needs to have less than 32765. \nA Plant SCADA project will only support up to 32765 arrays. \nINT ArrayCreate(STRING sArrayName, INT x [, INT y [, INT z]])\nsArrayName: \nx: \ny: \nz: \nThe handle of the array. If unsuccessful, –1 is returned. The error code can be obtained by calling the IsError Cicode function.\nArrayCopy, ArrayCreateByAn, ArrayDestroy, ArrayDestroyByAn, ArrayExists, ArrayExistsByAn, ArrayFillFromAlarmDataByAn, ArrayGetInfo, ArrayGetInt, ArrayGetIntByAn, ArrayGetMapName, ArrayGetMapNameByAn, ArrayGetString, ArrayGetStringByAn, ArrayIsDirty, ArraySetInt, ArraySetIntByAn, ArraySetIsDirty, ArraySetString, ArraySetStringByAn, ArraySwap, DspArrayByAn",
        "example": "...\n\nhArray = ArrayCreate(\"TestArray\", 128, 128, 128);\nerr0 = IsError();   // error = 0 - number of elements 2,097,152\n\nhArray = ArrayCreate(\"TestArray\", \n129\n, 128, 128);\nerr1 = IsError();   // error = 272 out of memory\n\nhArray = ArrayCreate(\"TestArray\", 128, 128, \n129\n);\nerr2 = IsError();   // error = 272 out of memory\n\nhArray = ArrayCreate(\"TestArray\", 32765, 1, 1);\nerr3 = IsError();   // error = 0\n\nhArray = ArrayCreate(\"TestArray\", 32765, 10, 5);\nerr4 = IsError();   // error = 0 - number of elements 1,638,250\n\nhArray = ArrayCreate(\"TestArray\", \n32766\n, 1, 1);\nerr5 = IsError();   // error = 257 - value is out of range\n\nhArray = ArrayCreate(\"TestArray\", 1, \n32766\n, 1);\nerr6 = IsError();   // error = 257 - value is out of range\n\nhArray = ArrayCreate(\"TestArray\", 1, 1, \n32766\n);\nerr7 = IsError();   // error = 257 - value is out of range\n\nhArray = ArrayCreate(\"TestArray\", 32765);\nerr8 = IsError();   // error = 0\n\n...",
        "name": "ArrayCreate",
        "params": [
            {
                "paramdescription": "The name of the array. ",
                "paramname": "sArrayName"
            },
            {
                "paramdescription": "The size of the array's x–dimension (from 1 to 32765).",
                "paramname": "x"
            },
            {
                "paramdescription": "The size of the array's y–dimension (from 1 to 32765). This value is optional. If not specified, it defaults to 1. ",
                "paramname": "y"
            },
            {
                "paramdescription": "The size of the array's z–dimension (from 1 to 32765). This value is optional. If not specified, it defaults to 1. ",
                "paramname": "z"
            }
        ],
        "returnType": "The handle of the array. If unsuccessful, -1 is returned. The error code can be obtained by calling the IsError Cicode function.",
        "syntax": "INT ArrayCreate(STRING sArrayName, INT x [, INT y [, INT z]])"
    },
    "arraycreatebyan": {
        "doc": "Creates an array at a specified AN. An array can include up to 2,097,153 elements, but each dimension needs to have less than 32765. \nA Plant SCADA project will only support up to 32765 arrays. \nINTArrayCreateByAn(INT nAN, INT x [, INT y [, INT z]])\nhAN: \nx: \ny: \nz: \nThe handle of the array. If unsuccessful, –1 is returned. The error code can be obtained by calling the IsError Cicode function.\nArrayCreate, ArrayCopy, ArrayDestroy, ArrayDestroyByAn, ArrayExists, ArrayExistsByAn, ArrayFillFromAlarmDataByAn, ArrayGetArrayByAn, ArrayGetInfo, ArrayGetInt, ArrayGetIntByAn, ArrayGetMapName, ArrayGetMapNameByAn, ArrayGetString, ArrayGetStringByAn, ArrayIsDirty, ArraySetInt, ArraySetIntByAn, ArraySetIsDirty, ArraySetString, ArraySetStringByAn, ArraySwap, DspArrayByAn",
        "example": "...\n\nhArray = ArrayCreateByAn(hAn, 128, 128, 128);\nerr0 = IsError();   // error = 0 - number of elements 2,097,152\n\nhArray = ArrayCreateByAn(hAn, \n129\n, 128, 128);\nerr1 = IsError();   // error = 272 out of memory\n\nhArray = ArrayCreateByAn(hAn, 128, 128, \n129\n);\nerr2 = IsError();   // error = 272 out of memory\n\nhArray = ArrayCreateByAn(hAn, 32765, 1, 1);\nerr3 = IsError();   // error = 0\n\nhArray = ArrayCreateByAn(hAn, 32765, 10, 5);\nerr4 = IsError();   // error = 0 - number of elements 1,638,250\n\nhArray = ArrayCreateByAn(hAn, \n32766\n, 1, 1);\nerr5 = IsError();   // error = 257 - value is out of range\n\nhArray = ArrayCreateByAn(hAn, 1, \n32766\n, 1);\nerr6 = IsError();   // error = 257 - value is out of range\n\nhArray = ArrayCreateByAn(hAn, 1, 1, \n32766\n);\nerr7 = IsError();   // error = 257 - value is out of range\n\nhArray = ArrayCreateByAn(hAn, 3, 3, 3);\nerr8 = IsError();   // error = 0\n\n...",
        "name": "ArrayCreateByAn",
        "params": [
            {
                "paramdescription": "The AN number to associate with the array.\n Elements in a Genie can access array cell values associated with a particular AN number without having the array handle. The Genie creates the array and associates it with the AN of one of the items in the Genie when it is initialized or the page is created. Other items in the Genie can then get or set values in that array. The List View Genie uses this ‘ByAn’ array feature.",
                "paramname": "hAN"
            },
            {
                "paramdescription": "The size of the array's x–dimension (from 1 to 32765).",
                "paramname": "x"
            },
            {
                "paramdescription": "The size of the array's y–dimension (from 1 to 32765). This value is optional. If not specified, it defaults to 1. ",
                "paramname": "y"
            },
            {
                "paramdescription": "The size of the array's z–dimension (from 1 to 32765). This value is optional. If not specified, it defaults to 1.",
                "paramname": "z"
            }
        ],
        "returnType": "The handle of the array. If unsuccessful, -1 is returned. The error code can be obtained by calling the IsError Cicode function.",
        "syntax": "INTArrayCreateByAn(INT nAN, INT x [, INT y [, INT z]])"
    },
    "arraydestroy": {
        "doc": "Destroys an array.",
        "example": "Error1 = ArrayDestroy(hArray);",
        "name": "ArrayDestroy",
        "params": [
            {
                "paramdescription": "The handle of the array that will be destroyed. ",
                "paramname": "hArray"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "INTArrayDestroy(INT hArray)"
    },
    "arraydestroybyan": {
        "doc": "Destroys an array associated with the specified AN.",
        "example": "error1 = ArrayDestroyByAn(nAn);",
        "name": "ArrayDestroyByAn",
        "params": [
            {
                "paramdescription": "The AN number associated with the array that will be destroyed.",
                "paramname": "nAN"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "INTArrayDestroyByAn(INT nAN)"
    },
    "arrayexists": {
        "doc": "Determines if an array with a specified handle exists. ",
        "example": "...\nIF (ArrayExists(hArray1)) THEN\nMapName = ArrayGetMapName(hArray1);\nEND\n...",
        "name": "ArrayExists",
        "params": [
            {
                "paramdescription": "The handle of the array. ",
                "paramname": "hArray"
            }
        ],
        "returnType": "TRUE if the array exists. FALSE if the array does not exist.",
        "syntax": "INT ArrayExists(INT hArray)"
    },
    "arrayexistsbyan": {
        "doc": "Determines if an array associated with a specified AN exists. ",
        "example": "...\nIF (ArrayExistsByAn(hAN)) THEN\n    MapName = ArrayGetMapNameByAn(hAn);\nEND\n...",
        "name": "ArrayExistsByAn",
        "params": [
            {
                "paramdescription": "The AN associated with an array.",
                "paramname": "nAN"
            }
        ],
        "returnType": "TRUE if the array exists. FALSE if the array does not exist.",
        "syntax": "INT ArrayExistsByAn(INT nAN)"
    },
    "arrayfillfromalarmdatabyan": {
        "doc": "This function is used to fill an array with information from internal alarm record caches.  It is used by alarm page Genies to obtain the alarm record information to be displayed on the page.",
        "example": "error1 = ArrayFillFromAlarmDataByAn(600);",
        "name": "ArrayFillFromAlarmDataByAn",
        "params": [
            {
                "paramdescription": "The AN number for the alarm list you want to use to fill the array.",
                "paramname": "hAN"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "INT ArrayFillFromAlarmDataByAn(INT hAN)"
    },
    "arraygetarraybyan": {
        "doc": "Retrieves an array associated with a specified AN.",
        "example": "hArray = ArrayGetArrayByAn(hAn);",
        "name": "ArrayGetArrayByAn",
        "params": [
            {
                "paramdescription": "The AN number associated with the array that will be retrieved.",
                "paramname": "nAN"
            }
        ],
        "returnType": "The handle of the array. If unsuccessful, -1 is returned. The error code can be obtained by calling the IsError Cicode function.",
        "syntax": "INT ArrayGetArrayByAn(INT nAN)"
    },
    "arraygetinfo": {
        "doc": "Retrieves the size of the x–, y–, or z–dimension for an array. ",
        "example": "...\nhArray = ArrayCreate(\"TestArray\", 3, 4, 5);\nx=ArrayGetInfo(hArray,0);  //x-dimension expected = 3\ny=ArrayGetInfo(hArray,1);  //y-dimension expected = 4\nz=ArrayGetInfo(hArray,2);  //z-dimension expected = 5",
        "name": "ArrayGetInfo",
        "params": [
            {
                "paramdescription": "The handle of the array. ",
                "paramname": "hArray"
            },
            {
                "paramdescription": "0 = the array's x–dimension\n1 = the array's y–dimension\n2 = the array's z–dimension",
                "paramname": "nType"
            }
        ],
        "returnType": "The size of the x-, y-, or z-dimension, if successful. If unsuccessful, -1 is returned. The error code can be obtained by calling the IsError Cicode function.",
        "syntax": "INT ArrayGetInfo(INT hArray, INT nType)"
    },
    "arraygetint": {
        "doc": "Retrieves an integer value from an array. ",
        "example": "...\n// Set the integer value at Array(1,2,3) to be 444\nArraySetInt(hArray, 444, 1, 2, 3);\n// Get the integer value at Array(1,2,3)\nvalue = ArrayGetInt(hArray, 1, 2, 3);\n// value = 444\n...",
        "name": "ArrayGetInt",
        "params": [
            {
                "paramdescription": "The handle of the array. ",
                "paramname": "hArray"
            },
            {
                "paramdescription": "The index for the x–dimension.",
                "paramname": "x"
            },
            {
                "paramdescription": "The index for the y–dimension.",
                "paramname": "y"
            },
            {
                "paramdescription": "The index for the z–dimension.",
                "paramname": "z"
            }
        ],
        "returnType": "The requested integer, if successful. If unsuccessful, the error code can be obtained by calling the IsError Cicode function.",
        "syntax": "INT ArrayGetInt(INT hArray, INT x [, INT y [, INT z]])"
    },
    "arraygetintbyan": {
        "doc": "Retrieves an integer value from an array associated with a specified AN.",
        "example": "...\n// Set the integer value at (1,2,3) of the array associated with hAn to be 444\nArraySetIntByAn(hAn, 444, 1, 2, 3);\n// Get the integer value at (1,2,3) of the array associated with hAn\nvalue = ArrayGetIntByAn(hAn, 1, 2, 3);\n// value = 444\n...",
        "name": "ArrayGetIntByAn",
        "params": [
            {
                "paramdescription": "The AN number.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The index for the x–dimension.",
                "paramname": "x"
            },
            {
                "paramdescription": "The index for the y–dimension.",
                "paramname": "y"
            },
            {
                "paramdescription": "The index for the z–dimension.",
                "paramname": "z"
            }
        ],
        "returnType": "The requested integer, if successful. If unsuccessful, -1 is returned. The error code can be obtained by calling the IsError Cicode function.",
        "syntax": "INT ArrayGetIntByAn(INT nAN, INT x [, INT y [, INT z]])"
    },
    "arraygetmapname": {
        "doc": "Retrieves the name of the map associated with an array. ",
        "example": "MapName = ArrayGetMapName(hArray1);",
        "name": "ArrayGetMapName",
        "params": [
            {
                "paramdescription": "The handle of the array. ",
                "paramname": "hArray"
            }
        ],
        "returnType": "If successful, the requested map name as a string. If unsuccessful, \" \" is returned. The error code can be obtained by calling the IsError Cicode function.",
        "syntax": "STRING ArrayGetMapName(INT hArray)"
    },
    "arraygetmapnamebyan": {
        "doc": "Retrieves the name of the map for an array associated with a specified AN. ",
        "example": "MapName = ArrayGetMapNameByAn(hAn);",
        "name": "ArrayGetMapNameByAn",
        "params": [
            {
                "paramdescription": "The AN associated with the array.",
                "paramname": "nAN"
            }
        ],
        "returnType": "If successful, the requested map name as a string. If unsuccessful, \" \" is returned. The error code can be obtained by calling the IsError Cicode function.",
        "syntax": "STRING ArrayGetMapNameByAn(INT nAN)"
    },
    "arraygetstring": {
        "doc": "Retrieves a string from an array. ",
        "example": "// Set the string value at Array(1,2,3) to be “abc”\nArraySetString(hArray, “abc”, 1, 2, 3);\n// Get the integer value at Array(1,2,3)\nvalue = ArrayGetString(hArray, 1, 2, 3);\n// value = “abc”\n...",
        "name": "ArrayGetString",
        "params": [
            {
                "paramdescription": "The handle of the array. ",
                "paramname": "hArray"
            },
            {
                "paramdescription": "The index for the x–dimension.",
                "paramname": "x"
            },
            {
                "paramdescription": "The index for the y–dimension.",
                "paramname": "y"
            },
            {
                "paramdescription": "The index for the z–dimension.",
                "paramname": "z"
            }
        ],
        "returnType": "The requested string, if successful. If unsuccessful, \" \" is returned. The error code can be obtained by calling the IsError Cicode function.",
        "syntax": "STRING ArrayGetString(INT hArray, INT x [, INT y [, INT z]])"
    },
    "arraygetstringbyan": {
        "doc": "Retrieves a string value from an array associated with a specified AN. ",
        "example": "// Set the integer value at (1,2,3) of the array associated with hAn to be “abc”\nArraySetStringByAn(hAn, “abc”, 1, 2, 3);\n// Get the integer value at (1,2,3) of the array associated with hAn\nvalue = ArrayGetStringByAn(hAn, 1, 2, 3);\n// value = “abc”\n...",
        "name": "ArrayGetStringByAn",
        "params": [
            {
                "paramdescription": "The AN associated with array.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The index for the x–dimension.",
                "paramname": "x"
            },
            {
                "paramdescription": "The index for the y–dimension.",
                "paramname": "y"
            },
            {
                "paramdescription": "The index for the z–dimension.",
                "paramname": "z"
            }
        ],
        "returnType": "The requested string, otherwise an error is returned.",
        "syntax": "STRING ArrayGetStringByAn(INT nAN, INT x [, INT y [, INT z]])"
    },
    "arrayisdirty": {
        "doc": "Determines if an array is ‘dirty’ (information in the array has changed). When any array element is changed, the ‘Dirty’ flag of the array is set to be TRUE.",
        "example": "hArray = ArrayCreate(\"TestArray\", 3, 3, 3);\nerror1 = ArraySetIsDirty(hArray, 0);         // reset is dirty\nintig1 = ArrayIsDirty(hArray);               // intig1 = 0 -> reset\nArraySetInt(hArray, 444, 1, 2, 3);           // Change a value\nintig1 = ArrayIsDirty(hArray) ;              // intig1 = 1 -> set",
        "name": "ArrayIsDirty",
        "params": [
            {
                "paramdescription": "The handle of the array. ",
                "paramname": "hArray"
            }
        ],
        "returnType": "1 if true (is dirty), or 0 if false (is not dirty). An error is not returned by this function.",
        "syntax": "INT ArrayIsDirty(INT hArray)"
    },
    "arraysetint": {
        "doc": "Sets an integer value within an array. ",
        "example": "...\nerror1= ArraySetInt(hArray, IntToStr(i), 0, 0, 0);\nvalue1= ArrayGetInt(hArray, 0, 0, 0);\n...",
        "name": "ArraySetInt",
        "params": [
            {
                "paramdescription": "The handle of the array. ",
                "paramname": "hArray"
            },
            {
                "paramdescription": "The value you would like to set. ",
                "paramname": "nValue"
            },
            {
                "paramdescription": "The index for the x–dimension.",
                "paramname": "x"
            },
            {
                "paramdescription": "The index for the y–dimension.",
                "paramname": "y"
            },
            {
                "paramdescription": "The index for the z–dimension.",
                "paramname": "z"
            }
        ],
        "returnType": "If unsuccessful, an error code will be returned by the IsError Cicode function.",
        "syntax": "INTArraySetInt(INT hArray, INT nValue, INT x [, INT y [, INT z]])"
    },
    "arraysetintbyan": {
        "doc": "Sets an integer value in an array associated with a specified AN. ",
        "example": "...\n// Set the integer value at (1,2,3) of the array associated with hAn to be 444\nArraySetIntByAn(hAn, 444, 1, 2, 3);\n// Get the integer value at (1,2,3) of the array associated with hAn\nvalue = ArrayGetIntByAn(hAn, 1, 2, 3);\n// value = 444\n...",
        "name": "ArraySetIntByAn",
        "params": [
            {
                "paramdescription": "The AN associated with the array.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The value you would like to set. ",
                "paramname": "nValue"
            },
            {
                "paramdescription": "The index for the x–dimension.",
                "paramname": "x"
            },
            {
                "paramdescription": "The index for the y–dimension.",
                "paramname": "y"
            },
            {
                "paramdescription": "The index for the z–dimension.",
                "paramname": "z"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "INTArraySetIntByAn(INT nAN, INT nValue, INT x [, INT y [, INT z]])"
    },
    "arraysetisdirty": {
        "doc": "Allows you to indicate that an array is dirty (meaning the information in the array has changed), or not dirty (the information in the array has not been changed). ",
        "example": "hArray = ArrayCreate(\"TestArray\", 3, 3, 3);\nerror1 = ArraySetIsDirty(hArray, 0);         // reset is dirty\nintig1 = ArrayIsDirty(hArray);               // intig1 = 0 -> reset\nArraySetInt(hArray, 444, 1, 2, 3);           // Change a value\nintig1 = ArrayIsDirty(hArray) ;              // intig1 = 1 -> set",
        "name": "ArraySetIsDirty",
        "params": [
            {
                "paramdescription": "The handle of the array. ",
                "paramname": "hArray"
            },
            {
                "paramdescription": "0= False\n1 = True",
                "paramname": "IsDirty"
            }
        ],
        "returnType": "If unsuccessful, an error code will be returned by the IsError Cicode function.",
        "syntax": "ArraySetIsDirty(INT hArray, INT IsDirty)"
    },
    "arraysetstring": {
        "doc": "Sets a string value in an array. ",
        "example": "// Set the string value at Array(1,2,3) to be “abc”\nArraySetString(hArray, “abc”, 1, 2, 3);\n// Get the integer value at Array(1,2,3)\nvalue = ArrayGetString(hArray, 1, 2, 3);\n// value = “abc”\n...",
        "name": "ArraySetString",
        "params": [
            {
                "paramdescription": "The handle of the array. ",
                "paramname": "hArray"
            },
            {
                "paramdescription": "The string value you would like to set. ",
                "paramname": "sValue"
            },
            {
                "paramdescription": "The index for the x–dimension.",
                "paramname": "x"
            },
            {
                "paramdescription": "The index for the y–dimension.",
                "paramname": "y"
            },
            {
                "paramdescription": "The index for the z–dimension.",
                "paramname": "z"
            }
        ],
        "returnType": "If unsuccessful, an error code will be returned by the IsError Cicode function.",
        "syntax": "INTArraySetString(INT hArray, STRING sValue, INT x [, INT y [, INT z]])"
    },
    "arraysetstringbyan": {
        "doc": "Sets a string value in an array associated with a specified AN. ",
        "example": "// Set the integer value at (1,2,3) of the array associated with hAn to be “abc”\nArraySetStringByAn(hAn, “abc”, 1, 2, 3);\n// Get the integer value at (1,2,3) of the array associated with hAn\nvalue = ArrayGetStringByAn(hAn, 1, 2, 3);\n// value = “abc”\n...",
        "name": "ArraySetStringByAn",
        "params": [
            {
                "paramdescription": "The AN associated with the array.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The string value you would like to set. ",
                "paramname": "sValue"
            },
            {
                "paramdescription": "The index for the x–dimension.",
                "paramname": "x"
            },
            {
                "paramdescription": "The index for the y–dimension.",
                "paramname": "y"
            },
            {
                "paramdescription": "The index for the z–dimension.",
                "paramname": "z"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "INTArraySetStringByAn(INT nAN, STRING sValue, INT x [, INT y [, INT z]])"
    },
    "arrayswap": {
        "doc": "Swaps the contents of two arrays.",
        "example": "error1 = ArraySwap(hArray1, hArray2);",
        "name": "ArraySwap",
        "params": [
            {
                "paramdescription": "The handle of the array that you would like to swap with hArray2. ",
                "paramname": "hArray1"
            },
            {
                "paramdescription": "The handle of the array that you would like to swap with hArray1. ",
                "paramname": "hArray2"
            }
        ],
        "returnType": "If unsuccessful, an error code will be returned by the IsError Cicode function.",
        "syntax": "INT ArraySwap(INT hArray1, INT hArray2)"
    },
    "ass": {
        "doc": "Associates a variable tag or equipment with a Super Genie. This association is only made for the next Super Genie you display (either in the current window or in a new window). You cannot create an association for a Super Genie that is already displayed. You need to call this function once for every Super Genie substitutionstring in the Super Genie, otherwise the variable (substitution string) will remainuninitialized and it will be displayed as #ASC.\nThis function provides the lowest level of support for associating Super Genie variables with physical tags. The higher level functions (listed below) are simpler to use.",
        "example": "//Using a string identifier for the substitution parameter\n        Ass(-2,\"Level\", \"MIlK_LEVEL\",0);             \n         \n// Associate variable tag PV123 with the next Genie to display in the current window\nAss(-3, 5, \"PV123\", 0);",
        "name": "Ass",
        "params": [
            {
                "paramdescription": "The association will be created for the next Super Genie todisplay in the window specified here; enter the windownumber or:\n-3 - for the current window when the page is changed. The page can be changed by using the Page Cicode functions like PageDisplay, PageGoto, etc.\n-2 - for the next new window or page displayed.",
                "paramname": "hWin"
            },
            {
                "paramdescription": "The argument number or name (substitution string number or name) of theSuper Genie string to be replaced by sTag. For example, toreplace ?INT 3? with sTag, set nArg to 3 ,or ?Level? set nArg to Level.",
                "paramname": "nArg"
            },
            {
                "paramdescription": "Variable tag, or equipment and item name reference of a variable tag (using equipment.item notation) that will replace the Super Genieassociation. Partial tag names or equipment.item tag references can also be used. \nThe name of the tag can be prefixed by the name of the cluster for example, \"ClusterName.Tag\" or \"ClusterName.Equipment.Item\".",
                "paramname": "sTag"
            },
            {
                "paramdescription": "The mode of the association. Set to 0.",
                "paramname": "nMode"
            },
            {
                "paramdescription": "Specifies the name of the cluster in which the Variable Tagresides. This is optional if you have one cluster or areresolving the tag via the page's current cluster context. Theargument is enclosed in quotation marks \"\".\nResolution of the tag's cluster context occurs when the page is displayed. It is resolved to the page's cluster context, not the context in force when this function is called.",
                "paramname": "sClusterName"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.When using partial associations, an error 274 or 289 may be returned even though the association is successful, and can be ignored.",
        "syntax": "Ass(hWin, nArg, sTag, nMode [, sClusterName] )"
    },
    "asschain": {
        "doc": "Chains the associations from the current Super Genie to a new Super Genie. Use this function to display a new Super Genie when you already have one displayed. The new Super Genie will inherit the associations of the first Super Genie.\nThis function provides the lowest level of support for chaining associations from one Super Genie to another. You should call the higher level functions AssChainPage(), AssChainWin(), and AssChainPopUp() - these functions are simpler to use.",
        "example": "// Copy associations from the current Super Genie to !NewGenie\nAssChain(WinNumber(), WinNumber(), 0);\nPageDisplay(\"!NewGenie\");",
        "name": "AssChain",
        "params": [
            {
                "paramdescription": "The next Super Genie to display in the window specifiedhere will inherit the associations of the current SuperGenie - enter the window number, or:\n-3: for the current window when the page is changed. The page can be changed by using the Page Cicode functions like PageDisplay, PageGoto, etc.\n-2: for the next new window or page displayed.",
                "paramname": "hDest"
            },
            {
                "paramdescription": "The number of the window containing the source SuperGenie (that is the Super Genie from which the associations willbe inherited).",
                "paramname": "hSource"
            },
            {
                "paramdescription": "The mode of the association. Set to 0.",
                "paramname": "nMode"
            }
        ],
        "returnType": "Returns the number of associations copied.",
        "syntax": "AssChain(hDest, hSource, nMode)"
    },
    "asschainpage": {
        "doc": "Chains the associations from the current Super Genie to a new Super Genie, and displays the new Super Genie (in the current window). Use this function to display a new Super Genie when you already have one displayed. The new Super Genie will inherit the associations of the first Super Genie.",
        "example": "// Display new Super Genie in current window, using current associations\nAssChainPage(\"!NewGenie\");",
        "name": "AssChainPage",
        "params": [
            {
                "paramdescription": "The page name of the Super Genie. If you prefixed yourSuper Genie page name with an exclamation mark (!),remember to include it here.",
                "paramname": "sPage"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "AssChainPage(sPage)"
    },
    "asschainpopup": {
        "doc": "Chains the associations from the current Super Genie to a new Super Genie, and displays the new Super Genie in a new popup window. Use this function to display a new Super Genie in a new popup window when a Super Genie is already displayed. The new Super Genie will inherit the associations of the first.",
        "example": "// Display new Super Genie in new popup using current associations\nAssChainPopUp(\"!NewGenie\");",
        "name": "AssChainPopUp",
        "params": [
            {
                "paramdescription": "The page name of the Super Genie. If you prefixed yourSuper Genie page name with an exclamation mark (!),remember to include it here.",
                "paramname": "sPage"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "AssChainPopUp(sPage)"
    },
    "asschainwin": {
        "doc": "Chains the associations from the current Super Genie to a new Super Genie, and displays the new Super Genie in a new window. The new window will be of the same type as the current window. Use this function to display a new Super Genie in a new window when a Super Genie is already displayed. The new Super Genie will inherit the associations of the first.",
        "example": "// Displays a new super genie in a new window using the current associations\nAssChainWin(\"!NewGenie\", 100, 200, 1 + 8);",
        "name": "AssChainWin",
        "params": [
            {
                "paramdescription": "The page name of the Super Genie. If you prefixed yourSuper Genie page name with an exclamation mark (!),remember to include it here.",
                "paramname": "sPage"
            },
            {
                "paramdescription": "The mode of the window:\nYou can select multiple modes by adding modes together (for example, set Mode to 9 to open a page child window without maximize, minimize, or system menu icons).",
                "paramname": "Mode"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "AssChainWin(sPage, X, Y, Mode)"
    },
    "asschainwinfree": {
        "doc": "Stores the  associations on an existing Super Genie, closes it, then assigns the tags to a new window. This allows a Super Genie popup window to call another popup window, and close the parent popup.\nThis function is effectively the same as the AssChainWin() function, but frees the current Super Genie.",
        "example": "// Close the current genie window and display a new genie using the current associations\nAssChainWinFree(\"!GeniePopup\", 200, 300, 1 + 8);",
        "name": "AssChainWinFree",
        "params": [
            {
                "paramdescription": "The page name of the Super Genie. If you prefixed yourSuper Genie page name with an exclamation mark (!),remember to include it here.",
                "paramname": "sPage"
            },
            {
                "paramdescription": "The mode of the window:\nYou can select multiple modes by adding modes together (for example, set Mode to 9 to open a page child window without maximize, minimize, or system menu icons).",
                "paramname": "Mode"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "AssChainWinFree(sPage, X, Y, Mode)"
    },
    "assequipparameters": {
        "doc": "Associates a set of equipment parameters defined in Plant SCADA Studio System Model | Equipment | Runtime Parameters with a page. This association is only made for the next page you display (either in the current window or in a new window). You cannot create an association for a page that is already displayed.",
        "example": "No example found",
        "name": "AssEquipParameters",
        "params": [
            {
                "paramdescription": "The association will be created for the next page to display in the window specified here; enter the window number or:",
                "paramname": "hWin"
            },
            {
                "paramdescription": "Specifies the name of the cluster in which the equipment resides. The cluster name is optional if you have one cluster or are resolving the tag via the page's current cluster context. The argument is enclosed in quotation marks \"\".\nResolution of the tag's cluster context occurs when the page is displayed. It is resolved to the page's cluster context, not the context in force when this function is called.\nIt can contain Variable tag, or equipment and item name reference of a variable tag (using equipment.item notation) that will replace the Super Genie association. Partial tag names or equipment.item tag references can also be used.\nThe name of the tag can be prefixed by the name of the cluster for example, \"ClusterName.Tag\" or \"ClusterName.Equipment.Item\".",
                "paramname": "sClusterName"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.When using partial associations, an error 274 or 289 may be returned even though the association is successful, and can be ignored.",
        "syntax": "AssEquipParameters(hWin, sClusterName, sEquipmentName )"
    },
    "assequipreferences": {
        "doc": "Creates Super Genie associations for each piece of equipment referenced by the specified equipment.",
        "example": "No example found",
        "name": "AssEquipReferences",
        "params": [
            {
                "paramdescription": "The association will be created for the next Super Genie todisplay in the window specified here; enter the windownumber or:\n-3 - for the current window when the page is changed. The page can be changed by using Page Cicode functions like PageDisplay and PageGoto.\n-2 - for the next new window or page displayed.",
                "paramname": "hWin"
            },
            {
                "paramdescription": "The cluster and prefixed equipment name",
                "paramname": "sClusterAndEquipment"
            },
            {
                "paramdescription": "The category of reference to create associations for.\n If no association name exists then the equipment reference will be skipped.\nExample\nThis example creates associations on the next page displayed in current window (-3 = same as other Ass Cicode functions) for references from “Pump1” on “Cluster1” with the category “MyCategory.\nAss, AssChain, AssMetadata, AssMetadataPage, AssMetadataPopup, AssMetadataWin, AssChainPage, AssChainPopUp, AssChainWin, AssChainWinFree, AssGetProperty, AssGetScale, AssInfo, AssInfoEx, AssPage, AssPopUp, AssScaleStr, AssTag, AssTitle, AssVarTags, AssWin\nPublished August 2022",
                "paramname": "sCategory"
            }
        ],
        "returnType": "",
        "syntax": "AssEquipReferences (INT hwin, STRING sClusterAndEquipment, STRING sCategory)"
    },
    "assert": {
        "doc": "Verifies that the specified expression is TRUE. If then expression is FALSE, the current task will be halted. This is useful to help prevent the execution of code you do not want to run in the event an error has been detected.\nThis function can be used in a debug mode, where the FALSE assertion will be logged to the Kernel and SysLog.DAT, with the time, date, Cicode file name, and line number. Additionally the operator will be prompted with a dialog. The debug mode can be set by using the [Code]DebugMessage parameter or DebugMsgSet() function.",
        "example": "INT\nFUNCTION FileDisplayEx(STRING sFileName);\n\tINT hFile;\n\thFile = FileOpen(sFileName, \"r\");\n\tAssert(hFile <> -1);\n\t...\n\tFileClose(hFile);\n\tRETURN 0;\nEND",
        "name": "Assert",
        "params": [
            {
                "paramdescription": "The boolean expression. This expression needs to evaluate to TRUE (1) or FALSE (0).",
                "paramname": "bCondition"
            }
        ],
        "returnType": "None. However, if the assertion tests as FALSE, error 347 is generated.",
        "syntax": "Assert(bCondition)"
    },
    "assgetproperty": {
        "doc": "This function gets association information about the current Super Genie from the data source (that is, information about a variable tag that has been substituted into the Super Genie). You can only call this function on a Super Genie after the associations are completed.\nUse this function to display association information as part of the Super Genie. For example, if you have a Super Genie that is a loop controller, you could display the name of the loop at the top of the loop controller box. Each time the Super Genie is used with different associations (specifically a different tag name association) the correct loop name will be displayed.\nIf a constant value is associated, then only the constant value can be retrieved through the TagName property. The remaining properties are not valid.\nThis function replaces AssInfo.",
        "example": "//Using a string identifier for the substitution parameter\nAssGetProperty(\"MILK_LEVEL\", \"TagName\", 0);",
        "name": "AssGetProperty",
        "params": [
            {
                "paramdescription": "The argument number or name (integer or string) of the association from which to getinformation.\nWhen you associate a partial variable tag name (or partial equipment.item to reference variable tag) a prefix or suffix needs be added to the association to form a valid tag reference. The Argument sArg needs to be parsed as a string when partial tag names are used for the association, such as \"[a]?1?[b]\".\nFor example, where the substitution is a valid equipment reference and ?INT 1?.HourRun is a valid 'equipment.item' reference to a tag, set sArg to:\n \"?INT 1?.HourRun\"",
                "paramname": "sArg"
            },
            {
                "paramdescription": "The property to read. Property names are case sensitive.Supported properties are:\nAddress - The configured address of the referenced tag (as specified in the Variable Tags properties).\nArraySize - Array size of the referenced tag. Returns 1 for non-array types.\nAssFullName - Full name of the referenced tag in the form cluster.tagname even if the tag is not resolved.\nClusterName - Name of the cluster the referenced tag resides on.\nDataBitWidth - Number of bits used to store the value.\nDescription - Description of the referenced tag.\nEngUnitsHigh - Maximum scaled value.\nEngUnitsLow - Minimum scaled value.\nEquipment - Name of the equipment.\nFormat - Format bit string. The format information is stored in the integer as follows:\nBits 0-7 - format width\nBits 8-15 - number of decimal places\nBits 16 - zero-padded\nBit 17 - left-justified \nBit 18 - display engineering units\nBit 20 - exponential (scientific) notation.\nErrorValUsed - Returns 1 if the defined error value was used for the SuperGenie association. This means that tag name is invalid/unresolved or the substitutions are not complete. This is only relevant for named Super Genies. Returns zero (0) if the association string provided a value, or a default value was not defined.\nFormatDecPlaces - Number of decimal places for default format.\nFormatWidth - Number of characters used in default format.\nFullName - Full name of the referenced tag in the form cluster.tagname If the referenced tag is not resolved, returns an empty string.\nItem - Name of the equipment item associated with the Tag. If the tag is not resolved, returns an empty string.\nLiteral - Returns 1 if the substitution is a literal value, returns 0 if the substitution is a tag name.\nRangeHigh - Maximum unscaled value.\nRangeLow - Minimum unscaled value.\nTagName - Name of the tag for the specified association. Will retrieve the tag name regardless if you used equipment.item to reference the tag.\nType - General type of associated tag. Allowed values are:\nUnits - Engineering Units for example, %, mm, Volts.\nCustom1 ... Custom8 - User-defined strings.",
                "paramname": "sProperty"
            },
            {
                "paramdescription": "Optional parameter that specifies from where to retrieve the value for the property.\n-1 - The mode is determined by the INI parameter [Client]TagReadCachedMode.\n0 - The property value is retrieved direct from the server in blocking mode and an error code is returned if it is not on the server (or the server is unavailable).\n1 - The property value is retrieved from the cache and an error code is returned if the cache is not loaded yet.\n2 - The property value is retrieved from the local configuration and an error code is returned if it is not available (this is the traditional behavior).\n3 - The property value is retrieved from the cache, if the cache is loaded, and from the local configuration, if the cache is not loaded yet.\nDefault value is -1.",
                "paramname": "iCachedMode"
            }
        ],
        "returnType": "String representation of the property of the referenced tag. On detection of an error, an empty string and an error  are set.",
        "syntax": "AssGetProperty(sArg, sProperty [, iCachedMode] )"
    },
    "assgetscale": {
        "doc": "Gets scale information about the tag references for the current Super Genie from the datasource (that is scale information about a variable tag that has been substituted into the Super Genie). You can only call this function on a Super Genie after the associations are completed.\nUse this function to display association scale information as part of the Super Genie. For example, if you have a bar graph illustrating output, you could indicate zero, 50%, and full scale output on the vertical axis of the graph. Each time the Super Genie is used with different associations the correct scale values will be displayed.\nThe value is returned as a formatted string using the association format specification and (optionally) the engineering units.\nThis function replaces AssScaleStr.",
        "example": "// Display the zero, 50% and full scale of the 2nd argument \n// of the association of the current Super Genie\nDspText(31,0,AssGetScale(2, 0, 1));\nDspText(32,0,AssGetScale(2, 50, 1));\nDspText(33,0,AssGetScale(2, 100, 1));",
        "name": "AssGetScale",
        "params": [
            {
                "paramdescription": "The argument number or name of the association from which to getinformation.\nWhen you associate a partial variable tag name (or partial equipment.item to reference variable tag) a prefix or suffix needs be added to the association to form a valid tag reference. The Argument sArg needs to be parsed as a string when partial tag names are used for the association ie \"[a]?1?[b]\".\neg where the substitution is a valid equipment reference and ?INT 1?.HourRun is a valid equipment.item reference to a tag.\nset sArg to \"?INT 1?.HourRun\"",
                "paramname": "sArg"
            },
            {
                "paramdescription": "The percentage of full scale of the returned value.",
                "paramname": "iPercent"
            },
            {
                "paramdescription": "Flag to determine if the value is returned with engineeringunits:\n0 - Return the value without engineering units\n1 - Return the value with engineering units",
                "paramname": "iEngUnits"
            },
            {
                "paramdescription": "Optional flag to attempt to retrieve the cached value for theproperty rather than the current value. This makes thefunction non-blocking. If the property has not yet beencached, an error is set.\n0 - Do not force cached read. Cicode is blocking\n1 - Force cached read. Cicode is non-blocking\nDefault value is 1 (true).",
                "paramname": "iCached"
            }
        ],
        "returnType": "The scale of the referenced tag (as a string).",
        "syntax": "AssGetScale(sArg, iPercent, iEngUnits [, iCached] )"
    },
    "assinfo": {
        "doc": "Gets association information about the current Super Genie (that is information about a variable tag that has been substituted into the Super Genie). You can only call this function on a Super Genie after the associations are completed.\nUse this function to display association information as part of the Super Genie. For example, if you have a Super Genie that is a loop controller, you could display the name of the loop at the top of the loop controller box. Each time the Super Genie is used with different associations (specifically a different tag name or equipment.item association) the correct loop name will be displayed.",
        "example": "",
        "name": "AssInfo",
        "params": [
            {
                "paramdescription": "When you associate variable tags (can use equipment.item to reference the variable tag) with Super Genies, theSuper Genie substitution strings are replaced by variabletags. The sArg argument allows you to get informationabout one of those variable tags. What you need to know iswhich substitution string it replaced when the associationwas performed.\nEnter the argument number or name (substitution string number or name) of the relevant substitution string. For example, if you want information about the variable that replaced substitution string\n?INT 3?\nset sArg to 3.\nOr \n?Level?\nset sArg to Level\nWhen you associate a partial variable tag name (or partial equipment.item to reference variable tag) a prefix or suffix needs be added to the association to form a valid tag reference. The Argument sArg needs to be parsed as a string when partial tag names are used for the association ie \"[a]?1?[b]\".\neg where the substitution is a valid equipment reference and ?INT 1?.HourRun is a valid equipment.item reference to a tag.\nset sArg to \"?INT 1?.HourRun\"",
                "paramname": "sArg"
            },
            {
                "paramdescription": "The type of information to get:\n0 - Tag reference as defined in sArg. If the referenced tag is not resolved, returns an empty string.\n1 - Engineering units\n2 - Raw zero scale\n3 - Raw full scale\n4 - Engineering zero scale\n5 - Engineering full scale\n6 - Width of the format\n7 - Number of decimal places of format\n8 - The Tag format as a long integer. The format information is stored in the integer as follows:\nBits 0-7 - format width\nBits 8-15 - number of decimal places\nBits 16 - zero-padded\nBit 17- left-justified \nBit 18 - display engineering units\nBit 20 - exponential (scientific) notation \n9 - Logical Unit Number - I/O device number (for internal use)\n10 - Raw Type - Protocol's raw data type number for this tag. Type numbers are:\n0 - Digital\n1 - Integer\n2 - Real\n3 - BCD\n4 - Long\n 5 - Long BCD\n6 - Long Real\n7 - String\n 8 - Byte\n 9 - Void\n 10 - Unsigned integer\n11 - Bit Width - Tag's size in bits. For example, an INT is 16 bits\n12 - Unit Type - Protocol's unit type number for this tag\n13 - Unit Address - Tag's address after the protocol DBF's template is applied.\n14 - Unit Count - Array size. For example, if the tag's address is I1[50], the unit count is 50.\n15 - Record Number - Tag's record number in variable.DBF - 1. That is, the first tag has a record number of 0.\n16 - Comment - As defined in the variable tags list.\n17 - ClusterName of the tag. If the referenced tag is not resolved, returns an empty string.\n18 - Full name (cluster.tagname) of the referenced tag. If the tag is not resolved, returns an empty string.\n19 - Full name (cluster.tagname) of the referenced tag even if the tag is not resolved.\n20 - Configured Address of the tag. If the tag is not resolved, returns an empty string.\n21 - Network Number - I/O device number (as defined by the Number field of the I/O Devices dialog).\n22 - Name of the equipment associated with the Tag. If the referenced tag is not resolved, returns an empty string.\n23 - General Type.",
                "paramname": "nType"
            },
            {
                "paramdescription": "0 - Digital\n1 - Byte\n2 - Integer16\n3 - UInteger 16\n4 - Long\n5 - Real\n6 - String\n7 - ULong\n8 - Undefined\n24 - Reserved for internal use.\n25 - Name of the equipment item associated with the Tag. If the tag is not resolved, returns an empty string.\nIf the tag is a local variable, mode 9 error code 348 is retrieved when cache mode is 0,1,2,3. Modes 12, 13, 14 and 15 will return an empty string (error 274 is trapped).\nType 8 - 16 are only supported when iCachedMode equals to 2 or 3.\n26 - Custom 1 - a user-defined string.\n27 - Custom 2 - a user-defined string.\n28 - Custom 3 - a user-defined string.\n29 - Custom 4 - a user-defined string.\n30 - Custom 5 - a user-defined string.\n31 - Custom 6 - a user-defined string.\n32 - Custom 7 - a user-defined string.\n33 - Custom 8 - a user-defined string.",
                "paramname": ""
            },
            {
                "paramdescription": "Optional parameter that specifies from where to retrieve the value for the property. \n-1 - The mode is determined by the INI parameter [Client]TagReadCachedMode.\n0 - The property value is retrieved direct from the server in blocking mode and an error code is returned if it is not on the server (or the server is unavailable).\n1 - The property value is retrieved from the cache and an error code is returned if the cache is not loaded yet.\n2 - The property value is retrieved from the local configuration and an error code is returned if it is not available (this is the traditional behavior).\n3 - The property value is retrieved from the cache, if the cache is loaded, and from the local configuration, if the cache is not loaded yet.\nDefault value is -1.\nThe value of the information as a string.",
                "paramname": "iCachedMode"
            }
        ],
        "returnType": "The value of the information as a string.",
        "syntax": "AssInfo(sArg, nType [, iCachedMode])"
    },
    "assinfoex": {
        "doc": "Gets association information about the current Super Genie (that is information about a variable tag that has been substituted into the Super Genie). You can only call this function on a Super Genie after the associations are completed.\nUse this function to display association information as part of the Super Genie. For example, if you have a Super Genie that is a loop controller, you could display the name of the loop at the top of the loop controller box. Each time the Super Genie is used with different associations (specifically a different tag name association) the correct loop name will be displayed.",
        "example": "//Using a string identifier for the substitution parameter",
        "name": "AssInfoEx",
        "params": [
            {
                "paramdescription": "When you associate variable tags with super Genies, theSuper Genie substitution strings are replaced by variabletags. The sArg argument allows you to get informationabout one of those variable tags. What you need to know iswhich substitution string it replaced when the associationwas performed.\nEnter the argument number (substitution string number) of the relevant substitution string. For example, if you want information about the variable that replaced substitution string\n?INT 3?\nset sArg to 3.\nWhen you associate a partial variable tag name (or partial equipment.item to reference variable tag) a prefix or suffix needs be added to the association to form a valid tag reference. The Argument sArg needs to be parsed as a string when partial tag names are used for the association ie \"[a]?1?[b]\".\neg where the substitution is a valid equipment reference and ?INT 1?.HourRun is a valid equipment.item reference to a tag.\nset sArg to \"?INT 1?.HourRun\"",
                "paramname": "sArg"
            },
            {
                "paramdescription": "The type of information to get:\n0 - The referenced tag from the variables table. This is the same as sName argument. (Returned to be compatible with the AssInfo() function).\n1 - Engineering units\n2 - Raw zero scale\n3 - Raw full scale\n4 - Engineering zero scale\n5 - Engineering full scale\n6 - Width of the format\n7 - Number of decimal places of format\n8 - The Tag format as a long integer. The format information is stored in the integer as follows:\n9 - Logical Unit Number - I/O device number (for internal use)\n10 - Raw Type - Protocol's raw data type number for this tag. Type numbers are:\n0 - Digital\n1 - Integer\n2 - Real\n3 - BCD\n4 - Long\n 5 - Long BCD\n6 - Long Real\n7 - String\n 8 - Byte\n 9 - Void\n 10 - Unsigned integer\n11 - Bit Width - Tag's size in bits. For example, an INT is 16 bits\n12 - Unit Type - Protocol's unit type number for this tag\n13 - Unit Address - Tag's address after the protocol DBF's template is applied.\n14 - Unit Count - Array size. For example, if the tag's address is I1[50], the unit count is 50.\n15 - Record Number - Tag's record number in variable.DBF - 1. That is, the first tag has a record number of 0.\n16 - Comment - As defined in the variable tags list.\n17 - ClusterName of the tag.\n18 - Full name (cluster.tagname) of the tag.\n19 - Full name (cluster.tagname) of the referenced tag even if the tag is not resolved.\n20 - Configured Address of the tag. If the tag is not resolved, returns an empty string.\n21 - Network Number - I/O device number (as defined by the Number field of the I/O Devices dialog).\n22 - Name of the equipment associated with the Tag. If the association tag is not resolved, returns an empty string.\nIf the tag is a local variable, mode 9 error code 348 is retrieved when cache mode is 0,1,2,3. Modes 12, 13, 14 and 15 will return an empty string (error 274 is trapped).\n23 - General Type.",
                "paramname": "nType"
            },
            {
                "paramdescription": "0 - Digital\n1 - Byte\n2 - Integer16\n3 - UInteger 16\n4 - Long\n5 - Real\n6 - String\n7 - ULong\n8 - Undefined\n24 - Reserved for internal use.\n25 - Name of the equipment item associated with the Tag. If the tag is not resolved, returns an empty string.\n26 - Custom 1 - a user-defined string.\n27 - Custom 2 - a user-defined string.\n28 - Custom 3 - a user-defined string.\n29 - Custom 4 - a user-defined string.\n30 - Custom 5 - a user-defined string.\n31 - Custom 6 - a user-defined string.\n32 - Custom 7 - a user-defined string.\n33 - Custom 8 - a user-defined string.",
                "paramname": ""
            },
            {
                "paramdescription": "Optional parameter that specifies from where to retrieve the value for the property. \n-1 - The mode is determined by the INI parameter [Client]TagReadCachedMode.\n0 - The property value is retrieved direct from the server in blocking mode and an error code is returned if it is not on the server (or the server is unavailable).\n1 - The property value is retrieved from the cache and an error code is returned if the cache is not loaded yet.\n2 - The property value is retrieved from the local configuration and an error code is returned if it is not available (this is the traditional behaviour).\n3 - The property value is retrieved from the cache, if the cache is loaded, and from the local configuration, if the cache is not loaded yet.\nDefault value is -1.\nThe value of the information as a string. If an error is detected an empty string is returned. The error code can be obtained by calling the IsError Cicode function.",
                "paramname": "iCachedMode"
            }
        ],
        "returnType": "The value of the information as a string. If an error is detected an empty string is returned. The error code can be obtained by calling the IsError Cicode function.",
        "syntax": "AssInfoEx(sArg, nType [, iCachedMode] )"
    },
    "assmetadata": {
        "doc": "This non-blocking function performs Super Genie associations using the \"Name\" and \"Value\" fields defined on the Object Properties - Metadata tab, and matches it to the 'Name' field in the page associations table. While performing associations any additional metadata entries are ignored.",
        "example": "\t\t/* Example of calling AssMetadata after other cicode functions */\n        An = DspGetAnCur();\n        SomeVal = TagRead(\"SomeTag\");\t// do additional work\n        AssMetadata(-2, An);\n        PageOpen(\"!TestSG\");",
        "name": "AssMetadata",
        "params": [
            {
                "paramdescription": "The associations will be created for the next Super Genie to display in the window specified. Enter the window number or\n-3: for the current window when the page is changed. The page can be changed by using the Page Cicode functions like PageDisplay, PageGoto, etc.\n-2: for the next new window or page displayed.",
                "paramname": "hWin"
            },
            {
                "paramdescription": " An animation number that uniquely identifies an object. This object contains the list of metadata definitions that will be used to perform the association operations.This parameter is optional with -2 being the default value.When -2 is specified, it is equivalent to DspGetAnCur() which returns the animation number of the current active command cursor, please refer DspGetAnCur() for usage and limitations. \n0 (zero) if successful, otherwise an error code is returned.When using partial associations, an error 274 may be returned even though the association is successful, and can be ignored.",
                "paramname": "nAN"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.When using partial associations, an error 274 may be returned even though the association is successful, and can be ignored.",
        "syntax": "AssMetadata(hWin [, nAn])"
    },
    "assmetadatapage": {
        "doc": "Uses the metadata information from the current object for the page associations for a new Super Genie page, and displays the new Super Genie (in the current page).",
        "example": "No example found",
        "name": "AssMetadataPage",
        "params": [
            {
                "paramdescription": "The name of the Super Genie page to open.",
                "paramname": "sPage"
            },
            {
                "paramdescription": " An animation number that uniquely identifies an object. This object contains the list of metadata definitions that will be used to perform the association operations.This parameter is optional with -2 being the default value. When -2 is specified, it is equivalent to DspGetAnCur() which returns the animation number of the current active command cursor, please refer DspGetAnCur() for usage and limitations. \n0 (zero) if successful, otherwise an error code is returned.",
                "paramname": "nAN"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "AssMetadataPage(sPage [,nAN])"
    },
    "assmetadatapopup": {
        "doc": "Uses the metadata information from the current animation point for the associations for a new Super Genie page, and displays the new Super Genie in a pop up window.",
        "example": "No example found",
        "name": "AssMetadataPopUp",
        "params": [
            {
                "paramdescription": "The name of the Super Genie page to open.",
                "paramname": "sPage"
            },
            {
                "paramdescription": " An animation number that uniquely identifies an object. This object contains the list of metadata definitions that will be used to perform the association operations.This parameter is optional with -2 being the default value. When -2 is specified, it is equivalent to DspGetAnCur() which returns the animation number of the current active command cursor, please refer DspGetAnCur() for usage and limitations. \n0 (zero) if successful, otherwise an error code is returned.",
                "paramname": "nAN"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "AssMetadataPopUp(sPage [,nAN])"
    },
    "assmetadatawin": {
        "doc": "Uses the metadata information from the current animation-point for the associations for a new Super Genie page, and displays the new Super Genie in a new window.",
        "example": "No example found",
        "name": "AssMetadataWin",
        "params": [
            {
                "paramdescription": "The name of the Super Genie page to open.",
                "paramname": "sPage"
            },
            {
                "paramdescription": "The x pixel coordinate of the top left corner of the window. Default value is 0.",
                "paramname": "X"
            },
            {
                "paramdescription": "The y pixel coordinate of the top left corner of the window. Default value is 0.",
                "paramname": "Y"
            },
            {
                "paramdescription": "The mode of the window:\n0 - Normal page (default value).\n1 - Page child window. The window is closed when a new page is displayed, for example, when the PageDisplay() or PageGoto() function is called. The parent is the current active window.\n2 - Window child window. The window is closed automatically when the parent window is freed with the WinFree() function. The parent is the current active window.\n4 - No re-size. The window is displayed with thin borders and no maximize/minimize icons. The window cannot be re-sized.\n8 - No icons. The window is displayed with thin borders and no maximize/minimize or system menu icons. The window cannot be re-sized.\n16 - No caption. The window is displayed with thin borders, no caption, and no maximize/minimize or system menu icons. The window cannot be re-sized.\n32 - Echo enabled. When enabled, keyboard echo, prompts, and error messages are displayed on the parent window. This mode should only be used with child windows (for example, Mode 1 and 2).\n64 - Always on top.\n128 - Open a unique window. This mode stops this window from being opened more then once.\n256 - Display the entire window. This mode commands that no parts of the window will appear off the screen\n512 - Open a unique Super Genie. This mode stops a Super Genie from being opened more than once (at the same time). However, the same Super Genie with different associations can be opened.\n1024 - Disables dynamic resizing of the new window, overriding the setting of the [Page]DynamicSizing parameter.\n4096 - Allows the window to be resized without maintaining the current aspect ratio. The aspect ratio defines the relationship between the width and the height of the window, which means this setting allows you to stretch or compress the window to any proportions. This option overrides the setting of the [Page]MaintainAspectRatio parameter.\n8192 - Text on a page will be resized in proportion with the maximum scale change for a resized window. For example, consider a page that is resized to three times the original width, and half the original height. If this mode is set, the font size of the text on the page will be tripled (in proportion with the maximum scale). This option overrides the setting of the [Page] ScaleTextToMax parameter.\n16384 - Hide the horizontal scroll bar.\n32768 - Hide the vertical scroll bar.\n65536 - Disable horizontal scrolling.\n131072 - Disable vertical scrolling.\nYou can select multiple modes by adding modes together (for example, set Mode to 9 to open a page child window without maximize, minimize, or system menu icons).",
                "paramname": "Mode"
            },
            {
                "paramdescription": " An animation number that uniquely identifies an object. This object contains the list of metadata definitions that will be used to perform the association operations.This parameter is optional with -2 being the default value.When -2 is specified, it is equivalent to DspGetAnCur() which returns the animation number of the current active command cursor, please refer DspGetAnCur() for usage and limitations. \n0 (zero) if successful, otherwise an error code is returned.",
                "paramname": "nAN"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "AssMetadataWin(sPage, INT x, INT y, INT mode [,nAN])"
    },
    "asspage": {
        "doc": "Associates up to eight variable tags or equipment.item tag references with a Super Genie and displays the Super Genie in the current window. Partial tag names and equipment.item tag references can also be used. The first variable tag (sTag1) replaces Super Genie substitution string 1. The second variable tag (sTag2) replaces substitution string 2, and so on.\nThis function has the same effect as calling Ass() or AssTag() eight times, and then calling the PageDisplay() function. The AssPage() function provides a quick way of associating eight Super Genie variables and displaying the Super Genie - at the same time.\nIf you want to associate more than eight tags with the Super Genie, it is strongly recommended you call the AssVarTags(), AssTag(), or Ass() function to create the associations before you call this function.",
        "example": "// Associate 3 tags with the Super Genie then display the Super Genie\nAssPage(\"!MyGenie\", \"PV123\", \"OP123\", \"SP123\");",
        "name": "AssPage",
        "params": [
            {
                "paramdescription": "The page name of the Super Genie. If you prefixed yourSuper Genie page name with an exclamation mark (!),remember to include it here.",
                "paramname": "sPage"
            },
            {
                "paramdescription": "The first eight physical tags to be associated with the SuperGenie. For any given Super Genie, the variable tags willreplace the Super Genie substitution strings as follows:\nBecause there is a strict correlation between the variable tag numbers and the substitution string numbers, you need to know how your Super Genie substitutions are numbered. For example, if your Super Genie has three unique substitution strings, numbered 1, 3, & 4, you need to enter a blank (\"\") for sTag2.\nThe name of the tag can be prefixed by the name of the cluster for example, \"ClusterName.Tag\".",
                "paramname": "sTag1..sTag8"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "AssPage(sPage, sTag1, [sTag2..8] )"
    },
    "asspopup": {
        "doc": "Associates up to eight variable tags or equipment.item tag references with a Super Genie and displays the Super Genie in a popup window. Partial tag names or equipment.item tag references can also be used. The first variable tag (sTag1) replaces Super Genie substitution string 1. The second variable tag (sTag2) replaces substitution string 2, and so on.\nThis function has the same effect as calling the Ass() function or the AssTag() function eight times, and then calling the WinNewAt() function to create a window at the position of the mouse. The AssPopUp() function is a quick way of associating eight Super Genie variables and displaying the Super Genie in a new window at the same time.\nIf you want to associate more than eight tags with the Super Genie, you need to call the AssVarTags(), AssTag(), or Ass() function to create the associations before you call this function.",
        "example": "// Associate 3 tags with the Super Genie then display it\nAssPopUp(\"!MyGenie\", \"PV123\", \"OP123\", \"SP123\");",
        "name": "AssPopUp",
        "params": [
            {
                "paramdescription": "The page name of the Super Genie. If you prefixed yourSuper Genie page name with an exclamation mark (!),remember to include it here.",
                "paramname": "sPage"
            },
            {
                "paramdescription": "The first 8 physical tags to be associated with the SuperGenie. For any given Super Genie, the variable tags willreplace the Super Genie substitution strings as follows:\nBecause there is a strict correlation between the variable tag numbers and the substitution string numbers, you need to know how your Super Genie substitutions are numbered. For example, if your Super Genie has three unique substitution strings, numbered 1, 3, & 4, you have to enter a blank (\"\") for sTag2.\nThe name of the tag can be prefixed by the name of the cluster for example, \"ClusterName.Tag\".",
                "paramname": "sTag1..sTag8"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "AssPopUp(sPage, sTag1, [sTag2..8] )"
    },
    "assscalestr": {
        "doc": "Gets scale information about the associations of the current Super Genie (that is scale information about a variable tag that has been substituted into the Super Genie). You can only call this function on a Super Genie after the associations are completed.\nUse this function to display association scale information as part of the Super Genie. For example, if you have a bar graph illustrating output, you could indicate zero, 50%, and full scale output on the vertical axis of the graph. Each time the Super Genie is used with different associations the correct scale values will be displayed.\nThe value is returned as a formatted string using the association format specification and (optionally) the engineering units.",
        "example": "//Using a string identifier for the substitution parameter\nAssScaleStr(\"MILK_LEVEL\", 50, 1);\n \n// Display the zero, 50% and full scale of the variable that was substituted for\nSuper Genie arg no. 3DspText(31,0,AssScaleStr(3, 0, 1));DspText(32,0,AssScaleStr(3, 50, 1));DspText(33,0,AssScaleStr(3, 100, 1));\t\t\t",
        "name": "AssScaleStr",
        "params": [
            {
                "paramdescription": "When you associate variable tags with Super Genies, theSuper Genie substitution strings are replaced by variabletags. The nArg argument allows you to get scale informationabout a particular variable tag. You need to knowwhich substitution string the tag replaced when theassociation was performed.\nEnter the argument number or name (substitution string number or name) of the relevant substitution string. For example, if you want scale information about the variable that replaced substitution string:\n?INT 3?\nset nArg to 3.\nor \n?Level?\nset nArg to Level\nWhen you associate a partial variable tag name (or partial equipment.item to reference variable tag) a prefix or suffix needs be added to the association to form a valid tag reference. The Argument sArg needs to be parsed as a string when partial tag names are used for the association ie \"[a]?1?[b]\".\neg where the substitution is a valid equipment reference and ?INT 1?.HourRun is a valid equipment.item reference to a tag.\nset sArg to \"?INT 1?.HourRun\"",
                "paramname": "sArg"
            },
            {
                "paramdescription": "The percentage of full scale of the returned value.",
                "paramname": "Percent"
            },
            {
                "paramdescription": "Determines if the value is returned with engineering units:\n0 - Do not return the value with engineering units\n1 - Return the value with engineering units",
                "paramname": "EngUnits"
            },
            {
                "paramdescription": "Optional parameter that specifies from where to retrieve the value for the property. \n-1 - The mode is determined by the INI parameter [Client]TagReadCachedMode.\n0 - The property value is retrieved direct from the server in blocking mode and an error code is returned if it is not on the server (or the server is unavailable).\n1 - The property value is retrieved from the cache and an error code is returned if the cache is not loaded yet.\n2 - The property value is retrieved from the local configuration and an error code is returned if it is not available (this is the traditional behaviour).\n3 - The property value is retrieved from the cache, if the cache is loaded, and from the local configuration, if the cache is not loaded yet.\nDefault value is -1.",
                "paramname": "CachedMode"
            }
        ],
        "returnType": "The scale of the referenced tag(as a string).",
        "syntax": "STRING AssScaleStr(STRING Arg, INT Percent,  INT EngUnits[,INT CachedMode])"
    },
    "asstag": {
        "doc": "Associates a variable tag or equipment.item tag reference with  a Super Genie. The association will only be created for the next Super Genie you display in the current window, and will only come into effect after you re-display the Super Genie. You need to call thisfunction once for every substitution string in the current Super Genie, or thesuper-genie variable (substitution string) will remain uninitialized and it willdisplay as #ASC. You cannot use this function to create associations for variablesthat will display in new windows.",
        "example": "// Associate variable tag PV123 and PV124 with !MyGenie\nAssTag(1, \"PV123\");\nAssTag(2, \"PV124\");\n// Re-display the current Super Genie\nPageDisplay(\"!MyGenie\");",
        "name": "AssTag",
        "params": [
            {
                "paramdescription": "The argument name (substitution string name) of theSuper Genie string to be replaced by sTag. For example, toreplace ?INT equip? with sTag, set nArg to equip.",
                "paramname": "nArg"
            },
            {
                "paramdescription": "The variable tag or equipment.item tag reference that will replace the Super Geniesubstitution string.Partial tag names or equipment.item tag references can also be used. \nThe name of the tag can be prefixed by the name of the cluster for example, \"ClusterName.Tag\" or \"ClusterName.equipment.item\".",
                "paramname": "sTag"
            },
            {
                "paramdescription": "Specifies the name of the cluster in which the Variable Tagresides. This is optional if you have one cluster or areresolving the tag via the current cluster context. Theargument is enclosed in quotation marks \"\".\nResolution of the tag's cluster context occurs when the page is displayed. It is resolved to the page's cluster context, not the context in force when this function is called.",
                "paramname": "sClusterName"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.When using partial associations, an error 274, or 289 may be returned even though the association is successful, and can be ignored.",
        "syntax": "AssTag(nArg, sTag [, sClusterName] )"
    },
    "asstitle": {
        "doc": "Sets the runtime window title to the tag name of the first variable substituted into the Super Genie.\nSee Page Properties - General for information regarding using named associations in the Window Title field.",
        "example": "No example found",
        "name": "AssTitle",
        "params": [
            {
                "paramdescription": "The number of characters to mask (hide) from the right of thetitle string (optional).",
                "paramname": "Mask"
            },
            {
                "paramdescription": "A string to add to the beginning of the title string (optional).",
                "paramname": "Prefix"
            },
            {
                "paramdescription": "A string to add to the end of the title string (optional).",
                "paramname": "Suffix"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "AssTitle( [Mask] [, Prefix] [, Suffix])"
    },
    "assvartags": {
        "doc": "Associates up to eight variable tags or equipment.item tag references with a Super Genie. Partial tag names or equipment.item tag references can also be used. This association is only made for the next Super Genie you display (either in the current window or in a new window). This function has an offset that allows you to specify which substitution string the first variable tag will replace. This means that if you have a Super Genie with more than 8 substitution strings, you can use this function repeatedly (while increasing the offset), until you have associated the necessary variable tags.\nThis function has the same effect as calling the Ass() function or the AssTag() function eight times. The AssVarTags() function is a quick way of associating up to eight Super Genie variables at the same time.\nAssVarTags(hWin, nOffset, sTag1, [sTag2..8] )\nhWin: \nnOffset: \nsTag1..8: \nNo value is returned.",
        "example": "// Associate 12 variables to the Super Genie\nAssVarTags(WinNumber(), 0, \"PV123\", \"SP123\", \"OP123\", \"PV124\", \"SP124\", \"OP124\",\n           \"PV125\", \"SP125\");\nAssVarTags(WinNumber(), 8, \"OP125\", \"PV126\", \"SP126\", \"OP126\");\nPageDisplay(\"!MyGenie\");    // Display the Super Genie",
        "name": "AssVarTags",
        "params": [
            {
                "paramdescription": "The association will be created for the next Super Genie todisplay in the window specified here - enter the windownumber or:",
                "paramname": "hWin"
            },
            {
                "paramdescription": "By default, the first variable tag (sTag1) will replacesubstitution string 1, and sTag2 will replace substitutionstring 2, and so on. Enter an offset to change this so thatsTag1 replaces a substitution string other than the first. Forexample, an offset of 8 means that sTag1 replaces string 9instead of the default string 1 (8+1=9), and sTag2 replacesstring 10 instead of string 2 (8+2=10) etc. This means that youcan use this function repeatedly to associate more than eightvariables.",
                "paramname": "nOffset"
            },
            {
                "paramdescription": "The physical variable tags (up to eight) to be associated withthe Super Genie. For any given Super Genie, the variable tagswill replace the Super Genie substitution strings as follows:\nBecause there is a strict correlation between the variable tag numbers and the substitution string numbers, you need to know how your Super Genie substitutions are numbered. For example, if your Super Genie has three unique substitution strings, numbered 1, 3, & 4, you need to enter a blank (\"\") for sTag2.\nThe name of the tag can be prefixed by the name of the cluster for example, \"ClusterName.Tag\".",
                "paramname": "sTag1..8"
            }
        ],
        "returnType": "No value is returned.",
        "syntax": "AssVarTags(hWin, nOffset, sTag1, [sTag2..8] )"
    },
    "asswin": {
        "doc": "Associates up to eight variable tags or equipment.item tag references with a Super Genie, and displays the Super Genie in a new window. This function has the same effect as calling the Ass() or AssTag() function eight times, and then calling the WinNewAt() function. The AssWin() function is a quick way of associating eight Super Genie variables and creating a new window - at the same time.\nIf you want to associate more than eight tags with the Super Genie you need to call the AssVarTags(), AssTag(), or Ass() function to create the associations before you call this function.",
        "example": "// Associate 3 tags with the Super Genie\n// then display the new window at (100,200) in mode 9\nAssWin(\"!MyGenie\", 100, 200, 1 + 8, \"PV123\", \"OP123\", \"SP123\");",
        "name": "AssWin",
        "params": [
            {
                "paramdescription": "The page name of the Super Genie. If you prefixed yourSuper Genie page name with an exclamation mark (!),remember to include it here.",
                "paramname": "sPage"
            },
            {
                "paramdescription": "The mode of the window:\nYou can select multiple modes by adding modes together (for example, set Mode to 9 to open a page child window without maximize, minimize, or system menu icons).",
                "paramname": "Mode"
            },
            {
                "paramdescription": "The first eight physical tags to be associated with the SuperGenie. For any given Super Genie, the variable tags willreplace the Super Genie substitution strings as follows:\nBecause there is a strict correlation between the variable tag numbers and the substitution string numbers, you need to know how your Super Genie substitutions are numbered. For example, if your Super Genie has three unique substitution strings, numbered 1, 3, & 4, you need to enter a blank (\"\") for sTag2.\nThe variable tags that you specify here need to be the same data type as that specified by the relevant Super Genie substitution strings. For example, only a digital tag could replace the substitution string ?DIGITAL 4?. If the substitution string does not specify a type (for example, ?5?), you can use any type except STRING.\nThe name of the tag can be prefixed by the name of the cluster for example, \"ClusterName.Tag\".",
                "paramname": "sTag1..8"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "AssWin(sPage, X, Y, Mode, sTag1, [sTag2..8] )"
    },
    "asswinreplace": {
        "doc": "This function removes the associations on a specified Super Genie window and applies any pending associations. This may be a useful alternative to calling PageDisplay or WinNewAt to update associations, as a full page reload is not required. \nYou need to call this function once for every Super Genie substitution string in the specified window, otherwise the variable (substitution string) will remain uninitialized and will be displayed as #ASC.",
        "example": "No example found",
        "name": "AssWinReplace",
        "params": [
            {
                "paramdescription": "The number of the window where associations will be replaced.",
                "paramname": "nTargetWindow"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "AssWinReplace(nTargetWindow)"
    },
    "beep": {
        "doc": "Beeps the internal speaker or sound card (installed in the computer). If you use the internal speaker on your computer, the function does not return until the sound has completed. If you use a sound card, the function returns immediately and the sound plays in the background.\nUse the Windows Control Panel to set up waveforms.",
        "example": "/* Beeps the speaker with the default waveform. */\nBeep(0);",
        "name": "Beep",
        "params": [
            {
                "paramdescription": "The type of sound:\n-1 - Standard beep\n0 - Default beep waveform\n1 - Critical stop waveform\n2 - Question waveform\n3 - Exclamation waveform\n4 - Asterisk waveform",
                "paramname": "nSound"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "Beep(nSound)"
    },
    "callevent": {
        "doc": "Simulates an event, triggering any OnEvent() function that has the same Type argument specified.\nPlant SCADA starts running the function immediately, without reading any data from the I/O devices. Any I/O device variable that you use will contain either 0 (zero) or the last value read.",
        "example": "! Call Event Type 1 - key has been pressed in the current window.\nNumber=WinNumber();\nCallEvent(Number,1);",
        "name": "CallEvent",
        "params": [
            {
                "paramdescription": "The number of the window, returned from the WinNew(),WinNewAt(), or WinNumber() function.",
                "paramname": "Window"
            },
            {
                "paramdescription": "The type of event:\n0 - The mouse has moved. When the mouse moves the callback function is called. The return value must be 0.\n1 - A key has been pressed. When the user presses a key, the callback function is called after Plant SCADA checks for hot keys. If the return value is 0, Plant SCADA checks for key sequences. If the return value is not 0, Plant SCADA assumes that you will process the key and does not check the key sequence. It is up to you to remove the key from the key command line.\nIf you are using a right mouse button click as an event, you should read about the ButtonOnlyLeftClick parameter.\n2 - Error event. This event is called if an error is detected in Cicode, so you can write a single error function to check for your errors. If the return value is 0, Plant SCADA continues to process the error and generates a hardware error - it may then halt the Cicode task. If the return value is not 0, Plant SCADA assumes that you will process the error, and continues the Cicode without generating a hardware error.\n3 - Page user communication error. A communication error has been detected in the data required for this page. If the return value is 0 (zero), Plant SCADA still animates the page. If the return value is not zero, it does not update the page.\n4 - Page user open. A new page is being opened. This event allows you to define a single function that is called when all pages are opened. The return value must be 0.\n5 - Page user close. The current page is being closed. This event allows you to define a single function that is called when all pages are closed. The return value must be 0.\n6 - Page user always. The page is active. This event allows you to define a single function that is called when all pages are active. The return value must be 0.\n7 - Page communication error. A communication error has been detected in the data required for this page. Reserved for use by Plant SCADA.\n8 - Page open. This event is called each time a page is opened. Reserved for use by Plant SCADA.\n9 - Page close. This event is called each time a page is closed. Reserved for use by Plant SCADA.\n10 - Page always. This event is called while a page is active. Reserved for use by Plant SCADA.\n11..17 - Undefined.\n18 - Report start. The report server is about to start a new report. This event is called on the report server. The return value must be 0.\n19 - Device history. A device history has just completed. The return value must be 0.\n20 - Login. A user has just logged in.\n21 - Logout. A user has just logged out.\n22 - Trend needs repainting. This event is called each time Plant SCADA re-animates a real-time trend or scrolls an historical trend. You should use this event to add additional animation to a trend, because Plant SCADA deletes all existing animation when a trend is re-drawn. (For example, if you want to display extra markers, you must use this event.)\n23 - Hardware error has been detected.\n24 - Keyboard cursor moved. This event is called each time the keyboard command cursor moves. The cursor can be moved by the cursor keys, the mouse, or the Cicode function KeySetCursor(). Note that you can find where the keyboard command cursor is located by calling the function KeyGetCursor().\n25 - Network shutdown. A Shutdown network command has been issued.\n26 - Runtime system shutdown and restart. (Required because of configuration changes.)\n27 - Event. An event has occurred.\n28 - Accumulator. An accumulator has logged a value.\n29 - Slider. A slider has been selected.\n30 - Slider. A slider has moved.\n31 - Slider. A slider has been released (that is stopped moving).\nWhile responding to slider events 29, 30, and 31, you can set any variables but you cannot call functions that cause immediate changes to animations on the page (for example, DspText() and DspSym()). Types 29, 30, & 31 relate only to V3.xx and V4.xx animations, and will be superseded in future releases.\n32 - Shutdown. Plant SCADA is being shutdown.\n33 - Reserved for Plant SCADA internal use.\n34 - 41 - Plant SCADA Confirmation Events. Reserved for Plant SCADA internal use. For the confirmation events, two sets of event type code are defined. The runtime calls the Plant SCADA event handler first, and conditionally proceed to the user's event handler depending on the return value of the Plant SCADA event handler. \n34 -Plant SCADA Event: Child Window Close Confirmation.\n35 - Plant SCADA Event: Main Window Close Confirmation.\n36 - Plant SCADA Event: Maximize Window Confirmation.\n37 - Plant SCADA Event: Minimize Window Confirmation.\n38 - Plant SCADA Event: Restore Window Confirmation.\n39 - Plant SCADA Event: Move Window Confirmation.\n40 - Plant SCADA Event: Size Window Confirmation.\n41 - Plant SCADA Event: Shutdown Confirmation Confirmation.\n42 to 49 - User Confirmation Events. These functions are called when a specific event (mainly from Window title bar) occur and before the runtime performs the intended action. This gives a chance for the user to decide what to do with the event. If the return value is 0, the event will be passed on to the default handler so the intended action will be performed. If the return value is not 0, the event will be ignored and no further action will be taken.\n42 - Child Window Close Confirmation, when the close button of the windows' title bar is clicked or an equivalent Windows' message is received.\n43 - Main Window Close Confirmation, when close button of the windows' title bar is clicked which will cause the process to shutdown.\n44 - Maximize Window Confirmation, when the maximize button of the windows' title bar is clicked or an equivalent Windows' message is received.\n45- Minimize Window Confirmation, when the minimize button of the windows' title bar is licked or an equivalent Windows' message is received.\n46 - Restore Window Confirmation, when the restore button of the windows' title bar is clicked or an equivalent Windows' message is received.\n47 - Move Window Confirmation, when the window is being dragged or an equivalent Windows' message is received.\n48 - Size Window Confirmation, when the windows is being resized or an equivalent Windows' message is received.\n49 - Shutdown Confirmation, when shutdown() function is called.\n50 - 127 - Reserved for future Plant SCADA use.\n128 - 256 - User-defined events. These events are for your own use.",
                "paramname": "Type"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is set. To view the error, use the IsError() function.",
        "syntax": "CallEvent(Window, nType)"
    },
    "chainevent": {
        "doc": "Calls an event function using the function handle. This creates a chain of event handlers from a single event. Use the GetEvent() function to get the function number of the current event handler.",
        "example": "No example found",
        "name": "ChainEvent",
        "params": [
            {
                "paramdescription": "The function handle, as returned from the GetEvent() function.",
                "paramname": "hFn"
            }
        ],
        "returnType": "The return value of the called event function.",
        "syntax": "ChainEvent(hFn)"
    },
    "chartostr": {
        "doc": "Converts an ASCII code into a string.",
        "example": "str = CharToStr(65);\n! Sets str to \"A\".",
        "name": "CharToStr",
        "params": [
            {
                "paramdescription": "The ASCII code to convert.",
                "paramname": "ASCIICode"
            }
        ],
        "returnType": "A string containing the converted ASCII code.",
        "syntax": "CharToStr(ASCIICode)"
    },
    "citectinfo": {
        "doc": "Gets information about a Plant SCADA variable. This function returns internal statistics and other information about the Plant SCADAruntime system.",
        "example": "! Get free memory\nFreeMemory = CitectInfo(\"Memory\", \"\", 0); \n! Get free disk space on C:\nFreeDisk = CitectInfo(\"Disk\", 3, 0);\n! Get max cycle time for digital alarms\nMaxCycleTime = CitectInfo(\"Stats\",\"Digital Alm\",\"1\");",
        "name": "CitectInfo",
        "params": [
            {
                "paramdescription": "The name of the group to which the variable belongs. Validgroup names are: \"General\", \"Port\", \"IODevice\", \"Network\",\"Stats\", \"Memory\", \"Disk\" or \"Queue\".",
                "paramname": "sGroup"
            },
            {
                "paramdescription": "The name of the variable. This name depends on sGroup:\n\"General\" - the name is ignored.\n\"Port\" - the name of the I/O port configured in the database (with the Ports database). The port information is only valid for an I/O server. If the port name is \"total\", the total statistics for the I/O server are returned.\n\"IODevice\" - the name of the I/O device configured in the I/O devices database.\n\"Network\" - the name is ignored.\n\"Stats\" - The name of the statistics buffer or Statistical Information Record (SIR):\n\"Alarm Proc\" - Alarm Processing (includes Digital, Analog, Advanced and High Resolution alarms).\n\"Citect n\" - The Plant SCADA window where n is the window number (returned from the WinNumber() function)\n\"Code n\" - The user Cicode task (thread) where n is the task handle (returned from the TaskHnd() function)\n\"Reset\" - Reset the Plant SCADA statistics.\n\"ElapsedTimeMS\" - The elapsed time since statistics have been reset. Returns -1 if more than 20 days has elapsed.\n\"Memory\" - the measurement used\n0 = bytes\nKB = kilobytes\nMB = megabytes\nGB = gigabytes\n\"Disk\" - The disk drive to access: \n0 = The current drive\n3 = C:\n4 = D: and so on.\n\"Queue\" - The name of the queue. ",
                "paramname": "sName"
            },
            {
                "paramdescription": "The type of information to get, depending on sGroup:\n\"General\" - General statistics:\n0 - CPU usage\n1 - Plant SCADA Kernel cycles per second\n2 - Plant SCADA Kernel tasks per second\n3 - Plant SCADA Kernel boot time\n4 - Plant SCADA Kernel running time (in seconds)\n5 - Plant SCADA startup time\n6 - Plant SCADA running time in seconds\n7 - Not supported in v7.10 or later\n8 - Total read requests\n9 - Total read requests per second\n10 - Total write requests\n11 - Total write requests per second\n12 - Total Physical read requests\n13 - Total Physical read requests per second\n14 - Total Physical write requests\n15 - Total Physical write requests per second\n16 - Total Blocked read requests\n17 - Total Blocked write requests\n18 - Total Digital read requests\n19 - Total Register read requests\n20 - Total Digital read requests per second\n21 - Total Register read requests per second\n22 - Total Cache reads count\n23 - Total Cache reads %\n24 - Overall Average response time (ms)\n25 - Overall Minimum response time (ms)\n26 - Overall Maximum response time (ms)\n27 - Request sample for response times\n28 - Static point count is no longer supported. Calling the function with parameter 28 returns a value of 0 and a hardware alarm is raised.\n29 - Dynamic point count currently in use\n30 - Number of pending read requests from the device\n31 - Number of pending write requests to the device\n32 - Determines if Plant SCADA Kernel window is open\n33 - Percentage of the CPU used by the current Plant SCADA process\n34 - Total CPU time spent by the current Plant SCADA process in milliseconds\n35 - Total number of handles opened by the current Plant SCADA process\n36 - Total number of threads owned by the current Plant SCADA process\n\"Port\" - Port information for the I/O Server:\n0 - Read requests\n1 - Write requests\n2 - Physical read requests\n3 - Physical write requests\n4 - Cached read requests\n5 - Cached write requests\n6 - Blocked read requests\n7 - Blocked write requests\n8 - Read requests per second\n9 - Write requests per second\n10 - Error count\n11 - Read bytes counter\n12 - Channel usage %\n13 - Read bytes per second\n14 - Statistics, minimum read time\n15 - Statistics, maximum read time\n16 - Statistics, average read time\n17 - Statistics, time of samples\n18 - Statistics, number of sample\n100 - 119 - Driver specific counter values.Plant SCADA drivers can maintain up to 20 unique counters that can be accessed via this function. They are zero based, indexed from 100 to 119. If a value is not defined or maintained by the driver, 0 is returned for the value of the counter.\n\"IODevice\" - I/O device information for the I/O device:\n0 - Client side status:\n1 = Running - Client is either talking to an online IO device or talking to a scheduled device that is not currently connected but has a valid cache\n2 = Standby - Client is talking to an online standby IO device\n4 = Starting - Client is talking to an IO device that is attempting to come online\n8 = Stopping - Client is talking to an IO device that is in the process of stopping\n16 = Offline - Client is pointing to an IO device that is currently offline\n32 = Disabled - Client is pointing to a device that is disabled\n66 = Standby write - Client is talking to an I/O device configured as a standby write device\n1 - I/O Server status:\n1 = Running - I/O Server is either talking to an online IO device or talking to a scheduled device that is not currently connected but has a valid cache\n2 = Standby - I/O Server is talking to an online standby IO device\n4 = Starting - I/O Server is talking to an IO device that is attempting to come online\n8 = Stopping - I/O Server is talking to an IO device that is in the process of stopping\n16 = Offline - I/O Server is pointing to an IO device that is currently offline\n32 = Disabled - I/O Server is pointing to a device that is disabled\n66 = Standby write - I/O Server is talking to an I/O device configured as a standby write device\n2 - If this I/O device is a standby device\n3 - Last generic error\n4 - Last driver error\n5 - Error count\n6 - Initialization count\n7 - Statistics, minimum read time\n8 - Statistics, maximum read time\n9 - Statistics, average read time\n10 - Statistics, number of samples\n\"Network\" - Network statistical information:\n0 - Read Network Control Blocks (NCBs)\n1 - Maximum pending read NCBs\n2 - Minimum pending read NCBs\n3 - Current pending read NCBs\n4 - Number of short read NCBs\n5 - Write NCBs\n6 - Maximum pending write NCBs\n7 - Minimum pending write NCBs\n8 - Current pending write NCBs\n9 - Number of short write NCBs\n10 - Total NCBs\n11 - Maximum pending total NCBs\n12 - Minimum pending total NCBs\n13 - Current pending total NCBs\n14 - Number of short total NCBs\n15 - Minimum send response time in milliseconds\n16 - Maximum send response time in milliseconds\n17 - Average send response time in milliseconds\n18 - Send packet count\n\"Stats\" - Statistical information:\n0 - Minimum time between code executions (cycles)\n1 - Maximum time between code executions (cycles)\n2 - Average time between code executions (cycles)\n3 - Total cycle time in milliseconds\n4 - Minimum time to execute the code in milliseconds\n5 - Maximum time to execute the code in milliseconds\n6 - Average time to execute the code in milliseconds\n7 - Total execute time in milliseconds\n\"Memory\" - Memory information:\n0 - Free virtual memory\n1 - Free windows system resources as %\n2 - Free Physical Memory\n3 - Memory Paging File Size\n4 - Total Physical Memory\n5 - Total % of Physical Memory Used\n6 - Total working set size counter for current Plant SCADA process\n7 - Private bytes counter of current Plant SCADA process\n\"Disk\" - Disk information:\n0 - Free disk space in bytes\n1 - Total disk space in bytes\n2 - Free disk space in kilobytes\n3 - Total disk space in kilobytes\n4 - Free disk space in megabytes\n5 - Total disk space in megabytes\n\"Queue\" - Disk information:\n0 - Returns the length of the queue from the process that this is being called on.",
                "paramname": "sType"
            }
        ],
        "returnType": "The type of information (as an integer).",
        "syntax": "CitectInfo(sGroup, sName, sType)"
    },
    "clipcopy": {
        "doc": "Copies a string to the Windows clipboard. When the string is in the clipboard, you can paste it to any Windows program.",
        "example": "ClipCopy(\"put this in clipboard\");",
        "name": "ClipCopy",
        "params": [
            {
                "paramdescription": "The string to copy to the clipboard.",
                "paramname": "sText"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "ClipCopy(sText)"
    },
    "clippaste": {
        "doc": "Pastes a string from the Windows clipboard.",
        "example": "/* Get string from clipboard into sText. */\nsText = ClipPaste();",
        "name": "ClipPaste",
        "params": [],
        "returnType": "The contents of the clipboard (as a string). If the clipboard is empty, an empty string is returned.",
        "syntax": "ClipPaste()"
    },
    "clipreadln": {
        "doc": "Reads a single line of text from the Windows clipboard. With this function, you can read a block of text from the clipboard - line by line. Call the function once to read each line of text from the clipboard. When the end of the clipboard is reached, an empty string is returned.",
        "example": "/* Get first line of text from clipboard. */\nsText = ClipReadLn();\nWHILE StrLength(sText) > 0 DO\n    ! Do something with text\n    ...\n    ! Read next line of clipboard\n    sText = ClipReadLn();\nEND",
        "name": "ClipReadLn",
        "params": [],
        "returnType": "One line of text from the clipboard (as a string). If the clipboard is empty, an empty string is returned.",
        "syntax": "ClipReadLn()"
    },
    "clipsetmode": {
        "doc": "Sets the format of data sent to the Windows clipboard.",
        "example": "/* Set the clipboard to CSV mode, write two values, and reset the \nclipboard to the original mode. */\nnOldMode = ClipSetMode(2);\nClipCopy(\"100,200\");\nClipSetMode(nOldMode);",
        "name": "ClipSetMode",
        "params": [
            {
                "paramdescription": "The mode of the data:\n1 - ASCII Text\n2 - CSV (Comma separated values) format\nYou can select multiple modes by adding modes together.",
                "paramname": "nMode"
            }
        ],
        "returnType": "The value of the previous mode.",
        "syntax": "ClipSetMode(nMode)"
    },
    "clipwriteln": {
        "doc": "Writes a line of text to the Windows clipboard. With this function, you can write any amount of text to the clipboard. Call this function once for each line of text. To terminate the block of text, call this function and pass an empty string.",
        "example": "ClipWriteLn(\"first line of text\");\nClipWriteLn(\"second line of text\");\nClipWriteLn(\"\"); ! End of write operation",
        "name": "ClipWriteLn",
        "params": [
            {
                "paramdescription": "The line of text to write to the clipboard, or an empty string (\"\") to end the write operation.",
                "paramname": "sText"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "ClipWriteLn(sText)"
    },
    "clusteractivate": {
        "doc": "This function allows the user to activate an inactive cluster. When a cluster is made active, all data associated with that cluster is available to the client, and hardware alarms will occur if no connections can be made to the servers in the cluster.",
        "example": "No example found",
        "name": "ClusterActivate",
        "params": [
            {
                "paramdescription": "The name of the cluster to activate enclosed in quotation marks \"\".",
                "paramname": "sClusterName"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "ClusterActivate(ClusterName)"
    },
    "clusterdeactivate": {
        "doc": "This function allows the user to deactivate an active cluster. When a cluster is made inactive, no data associated with that cluster is available to the client, and hardware alarms will not occur if no connections can be made to the servers in the cluster.",
        "example": "No example found",
        "name": "ClusterDeactivate",
        "params": [
            {
                "paramdescription": "The name of the cluster to deactivate enclosed in quotation marks \"\".",
                "paramname": "sClusterName"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "ClusterDeactivate(ClusterName)"
    },
    "clusterfirst": {
        "doc": "This function allows the user to retrieve the first configured cluster in the project.",
        "example": "No example found",
        "name": "ClusterFirst",
        "params": [],
        "returnType": "The name of the first configured cluster.",
        "syntax": "ClusterFirst()"
    },
    "clustergetname": {
        "doc": "ClusterGetName is deprecated in this version of Plant SCADA.",
        "example": "// Return and display the server names.//\nClusterGetName(sPrimary, sStandby, 0);\nPrompt(\"Name of Cluster\" + sPrimary);",
        "name": "ClusterGetName",
        "params": [
            {
                "paramdescription": "The name of the cluster's primary server (that is that which was set as sPrimary using the ClusterSetName() function). Must be a String type variable.",
                "paramname": "sPrimary"
            },
            {
                "paramdescription": "The name of the cluster's standby server (that is that which was set as sStandby using the ClusterSetName() function). Must be a String type variable.",
                "paramname": "sStandby"
            },
            {
                "paramdescription": "The mode is for future expansion of the function - set to 0 (zero).",
                "paramname": "nMode"
            }
        ],
        "returnType": "The status of the get name.",
        "syntax": "ClusterGetName(sPrimary, sStandby, nMode)"
    },
    "clusterisactive": {
        "doc": "This function allows the user to determine if a cluster is active.",
        "example": "No example found",
        "name": "ClusterIsActive",
        "params": [
            {
                "paramdescription": "The name of the cluster to query enclosed in quotation marks \"\".",
                "paramname": "sClusterName"
            }
        ],
        "returnType": "TRUE if active, FALSE otherwise. If the cluster name was invalid, this function will return FALSE and a hardware alarm will be generated.",
        "syntax": "ClusterIsActive(ClusterName)"
    },
    "clusternext": {
        "doc": "This function allows the user to retrieve the next configured cluster in the project.",
        "example": "No example found",
        "name": "ClusterNext",
        "params": [
            {
                "paramdescription": "Any configured cluster name enclosed in quotation marks \"\", this will usually be the name of the previous cluster as returned from ClusterFirst, or a previous call to ClusterNext.",
                "paramname": "sClusterName"
            }
        ],
        "returnType": "The name of the next configured cluster or an empty string if there is no more clusters.",
        "syntax": "ClusterNext(ClusterName)"
    },
    "clusterservertypes": {
        "doc": "This function allows the user to determine which servers are defined for a given cluster.",
        "example": "No example found",
        "name": "ClusterServerTypes",
        "params": [
            {
                "paramdescription": "The name of the cluster to query enclosed in quotation marks \"\".",
                "paramname": "sClusterName"
            }
        ],
        "returnType": "Logical OR of the following server flags:",
        "syntax": "ClusterServerTypes(ClusterName)"
    },
    "clustersetname": {
        "doc": "ClusterSetName is deprecated in this version of Plant SCADA.",
        "example": "// Connect to Cluster A, with server CITECTA1 as primary server, \nand CITECTA2 as standby.//\nClusterSetName(\"CITECTA1\", \"CITECTA2\", 0);\n// Display the menu page for Cluster A Project.//\nPageDisplay(\"MenuA\");",
        "name": "ClusterSetName",
        "params": [
            {
                "paramdescription": "The name of the cluster's primary server (Reports Server, Alarms Server etc.), as defined using the Computer Setup Wizard. When the ClusterSetName() function is used, Plant SCADA will attempt to connect to this server.",
                "paramname": "sPrimary"
            },
            {
                "paramdescription": "The name of the cluster's standby server (Reports Server, Alarms Server etc.), as defined using the Computer Setup Wizard. If the sPrimary server is unavailable when the ClusterSetName() function is used, Plant SCADA will attempt to connect to this server.\nIf there is no standby server, enter an empty string for sStandby.",
                "paramname": "sStandby"
            },
            {
                "paramdescription": "The mode of the connection:\n0 - If you select this mode, Plant SCADA will renew the last connection. If it was connected to the sPrimary server, when this function was last used, it will attempt to connect to it again. If it was last connected to the sStandby server, it will attempt to connect to it again.\nThis mode is useful when a server is known to be unavailable, as it facilitates faster cluster switching.\n1 - Plant SCADA will attempt to connect to the sPrimary server first, each time this function is used. If the sPrimary server is unavailable, Plant SCADA will try the sStandby server.",
                "paramname": "nMode"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "ClusterSetName(sPrimary, sStandby, nMode)"
    },
    "clusterstatus": {
        "doc": "This function allows the user to determine the connection status from the client to a server on a cluster.",
        "example": "No example found",
        "name": "ClusterStatus",
        "params": [
            {
                "paramdescription": "The name of the cluster to query enclosed in quotation marks \"\".",
                "paramname": "clusterName"
            },
            {
                "paramdescription": "The type of server (not a bit mask):\n1 - Alarm Server\n2 - Trend Server\n4 - Report Server\n8 - IO Server\nOne of the following values:\n-1 - if the cluster does not contain a server of the given type.",
                "paramname": "servernType"
            }
        ],
        "returnType": "One of the following values:",
        "syntax": "ClusterStatus(clusterName, serverType)"
    },
    "clusterswapactive": {
        "doc": "This function allows the user to deactivate an active cluster at the same time as activating an inactive cluster. The arguments may be passed in any order, but one cluster needs to be active and the other needs to be inactive.",
        "example": "No example found",
        "name": "ClusterSwapActive",
        "params": [
            {
                "paramdescription": "The name of the cluster to activate or deactivate enclosed in quotation marks \"\".",
                "paramname": "clusterNameA"
            },
            {
                "paramdescription": "The name of the cluster to activate or deactivate enclosed in quotation marks \"\".",
                "paramname": "clusterNameB"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "ClusterSwapActive(clusterNameA, clusterNameB)"
    },
    "codesetmode": {
        "doc": "Sets various execution modes for Cicode tasks in the current thread. Using this function, you can specify whether to:",
        "example": "! disable local image write\nCodeSetMode(0, 0);",
        "name": "CodeSetMode",
        "params": [
            {
                "paramdescription": "Type of mode:\n0 - Write to a local image of an I/O device. If you set Value to 1, this mode is enabled, and Cicode writes its local memory image of the I/O device whenever you write to the I/O device. (Cicode assumes that most writes to the I/O device will be done immediately).\nThis local image might produce problems, or you might want to verify that the data was actually written to the I/O device. If you set Value to 0 (zero), this check is disabled, and Cicode does not write to the local memory image.\n1 - Check if a variable is within range before writing it to the I/O device. If you set Value to 1, this mode is enabled. When a variable tag is modified, Cicode checks the new value of the variable against the Scales specified in the Variable Tags database. If the value of the variable is out of scale, Cicode generates a hardware error, and does not write to the I/O device.\nIf you set Value to 0 (zero), this check is disabled. Cicode writes the variable to the I/O device without checking if its value is within range.\n2 - Echo error messages to the operator. If you set Value to 1, this mode is enabled. When a simple user error occurs (for example, if the PageDisplay() function is passed a bad page name), Cicode displays an error message at the Error AN, and returns an error code from the function.\nIf you set Value to 0 (zero), the echo is disabled. Cicode does not display the error message, and the output of the DspError() function is stopped.\n3 - Ignore the case of string data in the current thread of Cicode. If you set Value to 1, this mode is enabled, and Plant SCADA will ignore case in string data. For example, Plant SCADA will equate \"Hello\" to \"HELLO\".\nIf you set Value to 0 (zero), Plant SCADA will be case sensitive to string data. Case sensitivity is used when a string comparison operation is performed. For example:\nIF sStr1 = sStr2 THEN\n(You can also make Plant SCADA case sensitive to strings in all of your Cicode, using the [Code]IgnoreCase parameter.)\n4 - Calls the Cicode Profiler. If you set Value to 1, the Profiler is enabled. This will only enable\\disable the Profiler for the current Cicode task.",
                "paramname": "nType"
            },
            {
                "paramdescription": "The value of the mode:\n0 - Disable\n1 - Enable",
                "paramname": "Value"
            }
        ],
        "returnType": "-1 if there is an error, otherwise the last value of the mode.",
        "syntax": "CodeSetMode(nType, Value)"
    },
    "codetrace": {
        "doc": "Traces Cicode into the Kernel and the SYSLOG.DAT file. Use this function for finding bugs in your Cicode. It will trace the functions called, the arguments to those functions, and their return values. It will also trace any errors, writes to the I/O devices, and task state changes.\nCodeTrace(hTask, nMode)\nhTask: \nnMode: \n0 (zero) if successful, otherwise an error code is returned.",
        "example": "// Start tracing errors\nCodeTrace(TaskHnd(), 4);\n....\n// Stop tracing\nCodeTrace(TaskHnd(), 0);\n// trace functions in new task\nCodeTrace(-2, 1 + 2);\nTaskNew(\"MyFunc\", \"data\", 0);",
        "name": "CodeTrace",
        "params": [
            {
                "paramdescription": "The Cicode task handle as returned from TaskHnd() functionor any of the following special values:\n0 - Foreground Cicode.\n-2 - The next created task.\n-3 - New created tasks.\n-4 - All tasks.",
                "paramname": "hTask"
            },
            {
                "paramdescription": "The mode of the trace:\n0 - Tracing off\n1 - Trace user Cicode functions calls\n2 - Trace built-in function calls\n4 - Trace errors\n8 - Trace writes to the I/O devices\n16 - Trace task state changes\n-1 - All modes (except 0)",
                "paramname": "nMode"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "CodeTrace(hTask, nMode)"
    },
    "comclose": {
        "doc": "Closes a communication port. Any Cicode tasks that are waiting for a read or write operation to complete (or that are retrying to read or write) return with a range error. Plant SCADA automatically closes all communication ports at shutdown.\nThis function can only be called from an I/O Server.",
        "example": "No example found",
        "name": "ComClose",
        "params": [
            {
                "paramdescription": "The communication port handle, returned from the ComOpen() function. This handle identifies the table where all data on the associated communication port is stored.",
                "paramname": "hPort"
            }
        ],
        "returnType": "0 if the port is successfully closed, or an error if the port is already closed or if the port number is invalid.",
        "syntax": "ComClose(hPort)"
    },
    "comopen": {
        "doc": "Opens a communication port for access. The board and port need to both be defined in the database (using the Boards and Ports forms from the Communication menu).\nIf you try to open the same COM port twice with ComOpen(), the second openwill not succeed and return -1. If this is passed without checking other Comfunctions, the COM port may not do anything. For this reason, do not openCOM ports twice, and always check the return value from ComOpen().\nThe communication system should be used for low speed communications only.You should not use the communication functions to communicate with highspeed PLCs - the performance may not be adequate. If you need high speedcommunication (for communicating with PLCs, etc.), you should write aprotocol driver. Refer to the Plant SCADA \"Driver Development Kit\".\nThis function can only be called from an I/O Server.",
        "example": "INT\nFUNCTION\nStartSerial(STRING sPort)\n    INT    hPort;\n    hPort = ComOpen(sPort, 0);\n    IF hPort < 0 THEN\n        Prompt(\"Cannot open port \" + sPort);\n        RETURN -1;\n    END\n    TaskNew(\"SerialRead\", hPort, 0);\n    TaskNew(\"SerialWrite\", hPort, 0);\n    ComClose(hPort);\n    RETURN 0;\nEND\nINT\nFUNCTION\nSerialWrite(INT hPort)\n    STRING buffer;\n    INT SerialWriteError;\n    INT length;\n    WHILE 1 DO\n        ! put data into buffer and set length\n        .\n        .\n        SerialWriteError = ComWrite(hPort, buffer, length, 2);\n        IF SerialWriteError THEN\n            Prompt(\"Error Writing port\");\n            ComReset(hPort);\n        END\n    END\n    RETURN 0;\nEND        \nINT\nFUNCTION\nSerialRead(INT hPort)\n    STRING    buffer;\n    INT    length;\n    INT    total;\n    INT    SerialReadError;\n    total = 0;\n    WHILE 1 DO\n        length = 128; ! need to set length as read modifies\n        SerialReadError = ComRead(hPort, buffer, length, 2);    \n        IF SerialReadError THEN\n            Prompt(\"Error from port \" + SerialReadError : ####);\n            ComReset(hPort);\n        ELSE\n            ! get data from buffer, length is set to number read\n            .\n            .\n        END\n    END\n    RETURN 0;\nEND",
        "name": "ComOpen",
        "params": [
            {
                "paramdescription": "The port name as specified in the Ports database.",
                "paramname": "sPort"
            },
            {
                "paramdescription": "The mode of the open:\n0 - Take control of the port from Plant SCADA. In this non-shared mode, you have complete access to the port - Plant SCADA cannot use the port. Communication will be restored when the port is closed.\n1 - Share the port with Plant SCADA. In this mode, you can write to the port, and Plant SCADA can also use it. Please be aware that ComRead will be unreliable if the communication port is opened as shared.",
                "paramname": "nMode"
            }
        ],
        "returnType": "A communication port handle if the communication system is opened successfully, otherwise -1 is returned. The handle identifies the table where all data on the associated port is stored. You can use the handle in the other communication functions, to send and receive characters from the port.",
        "syntax": "ComOpen(sPort, nMode)"
    },
    "comread": {
        "doc": "Reads characters from a communication port. The characters are read from the communication port into a string buffer. If no characters have arrived after the specified timeout, the function returns with a timeout error. If the timeout is 0, the function gets any characters that have arrived from the last call, and returns immediately.\nYou use the iLength variable to specify the length of the buffer, or the maximum number of characters to read when ComRead() is called. When ComRead() returns, iLength is set to the actual number of characters read. Because iLength is modified by this function, you need to reset it before each call.\nYou should not treat the string buffer as a normal string - it has no string terminator. Use the StrGetChar() function to extract characters from the buffer.\nIt is strongly recommended not to call ComRead() while another ComRead() is still pending on the same port, because it can produce unexpected results.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete. This function can only be called from an I/O Server.",
        "example": "No example found",
        "name": "ComRead",
        "params": [
            {
                "paramdescription": "The communication port handle, returned from theComOpen() function. This handle identifies the table wherethe data on the associated communication port is stored.",
                "paramname": "hPort"
            },
            {
                "paramdescription": "The buffer into which to put the characters. The actualnumber of characters read is returned in iLength. Must be a String type variable. ",
                "paramname": "sBuffer"
            },
            {
                "paramdescription": "The number of characters to read into the buffer. Themaximum length you may read in one call is 128 characters.When the function returns, this variable is set to the actualnumber of characters read. Must be a Long type variable.",
                "paramname": "iLength"
            },
            {
                "paramdescription": "The timeout for the read to complete:\nIf iTimeOut = 0 (zero), the function checks for characters in the buffer and returns.\nIf iTimeOut > 0, the function returns after this number of seconds - if no characters have been received.\nIf iTimeOut < 0, the function waits forever for characters.\n0 (zero) if the read is successful, otherwise an error code is returned.",
                "paramname": "iTimeOut"
            }
        ],
        "returnType": "0 (zero) if the read is successful, otherwise an error code is returned.",
        "syntax": "ComRead(hPort, sBuffer, iLength, iTimeOut)"
    },
    "comreset": {
        "doc": "Resets the communication port. This function can only be called from an I/O Server.",
        "example": "No example found",
        "name": "ComReset",
        "params": [
            {
                "paramdescription": "The communication port handle, returned from the ComOpen() function. This handle identifies the table where all data on the associated communication port is stored.",
                "paramname": "hPort"
            }
        ],
        "returnType": "0 (zero) if the write is successful, otherwise an error code is returned.",
        "syntax": "ComReset(hPort)"
    },
    "comwrite": {
        "doc": "Writes characters to a communication port. The characters are written from the string buffer to the port. If the characters have not been transmitted after the specified timeout, the function returns with a timeout error. If the timeout is 0, the function returns immediately and the characters are transmitted in the background.\nComWrite() does not treat the buffer as a true string, but rather as an array of characters of the length specified - you can send any character to the communication port. Use the StrSetChar() function to build the buffer. Do not call ComWrite() while another ComWrite() is still pending on the same port, because it can produce unexpected results.\nYou use the iLength variable to specify the length of the buffer, or the maximum number of characters to write when ComWrite() is called. When ComWrite() returns, iLength is reset to zero.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.\nThis function can only be called from an I/O Server.",
        "example": "No example found",
        "name": "ComWrite",
        "params": [
            {
                "paramdescription": "The communication port handle, returned from the ComOpen() function. This handle identifies the table where all data on the associated communication port is stored.",
                "paramname": "hPort"
            },
            {
                "paramdescription": "The buffer from which to write the characters. Must be a String type variable.",
                "paramname": "sBuffer"
            },
            {
                "paramdescription": "The number of characters to write from the buffer. The maximum number of characters you can write is 128. Must be a Long type variable.",
                "paramname": "iLength"
            },
            {
                "paramdescription": "The timeout for the write to complete.\nIf iTimeOut = 0 (zero), the characters are copied to the communication buffer and the function returns immediately - the characters are transmitted in the background.\nIf iTimeOut > 0, the function returns after this number of seconds - if the characters cannot be transmitted.\nIf iTimeOut < 0, the function waits forever to transmit the characters.\n0 (zero) if the write is successful, otherwise an error code is returned.",
                "paramname": "iTimeOut"
            }
        ],
        "returnType": "0 (zero) if the write is successful, otherwise an error code is returned.",
        "syntax": "ComWrite(hPort, sBuffer, iLength, iTimeOut)"
    },
    "cos": {
        "doc": "Calculates the trigonometric cosine of an angle.",
        "example": "Variable=Cos(0.7854);\n! Sets Variable to 0.7071...",
        "name": "Cos",
        "params": [
            {
                "paramdescription": "Any angle (in radians).",
                "paramname": "Angle"
            }
        ],
        "returnType": "The cosine of Angle.",
        "syntax": "Cos(Angle)"
    },
    "createcontrolobject": {
        "doc": "Creates a new instance of an ActiveX object.\nAn object created using this function remains in existence until the page is closed or the associated Cicode Object is deleted. This function does not require an existing animation point. When the object is created, an animation point is created internally. This animation point is freed when the object is destroyed.\nCreateControlObject(sClass, sName, x1, y1, x2, y2, sEventClass)\nsClass:\nsName: \nx1:\ny1:\nx2:\ny2:\nsEventClass: \nThe newly created object, if successful, otherwise an error is generated.",
        "example": "// This function creates a single instance of the calendar control \nat the designated location with an object name of \"CalendarEvent\" \nand an event class of \"CalendarEvent\"//\nFUNCTION\nCreateCalendar()\n\tOBJECT Calendar;\n\tSTRING sCalendarClass;\n\tSTRING sEventClass;\n\tSTRING sObjectName;\n\tsCalendarClass = \"MSCal.Calendar.7\";\n\tsEventClass = \"CalendarEvent\";\n\tsObjectName = \"MyCalendar\";\n\tCalendar = CreateControlObject(sCalendarClass, sObjectName, 16, \n\t100, 300, 340, sEventClass);\nEND\n// This function shows how to change the title font of the \ncalendar//\nFUNCTION\nCalendarSetFont(STRING sFont)\n\tOBJECT Font;\n\tOBJECT Calendar;\n\tCalendar = ObjectByName(\"MyCalendar\");\n\tFont = _ObjectGetProperty(Calendar, \"TitleFont\");\n\t_ObjectSetProperty(Font, \"Name\", sFont);\nEND\n// This function shows how to change the background color of the \ncalendar//\nFUNCTION\nCalendarSetColor(INT nRed, INT nGreen, INT nBlue)\n\tOBJECT Calendar;\n\tCalendar = ObjectByName(\"MyCalendar\");\n\t_ObjectSetProperty(Calendar, \"BackColor\", \n\tPackedRGB(nRed,nGreen,nBlue));\nEND\n// This function shows how to call the NextDay method of the \ncalendar//\nFUNCTION\nCalendarNextDay()\n\tOBJECT\tCalendar;\n\tCalendar = ObjectByName(\"MyCalendar\");\n\t_ObjectCallMethod(Calendar, \"NextDay\");\nEND\n// This function shows you how to write a mouse click event \nhandler for the calendar//\nFUNCTION\nCalendarEvent_Click(OBJECT This)\n\tINT nDay;\n\tINT nMonth;\n\tINT nYear;\n\tnDay = _ObjectGetProperty(This, \"Day\");\n\tnMonth = _ObjectGetProperty(This, \"Month\");\n\tnYear = _ObjectGetProperty(This, \"Year\");\n\t...\n\tYour code goes here...\n\t...\nEND",
        "name": "CreateControlObject",
        "params": [
            {
                "paramdescription": "The class of the object. You can use the object's human readable name, its program ID, or its GUID. If the class does not exist, the function will return an error message.\nFor example:\n\"Calendar Control 8.0\" - human readable name\n\"MSCAL.Calendar.7\" - Program ID\n\"{8E27C92B-1264-101C-8A2F-040224009C02}\" - GUID",
                "paramname": "sClass"
            },
            {
                "paramdescription": "The name for the object in the form of \"AN\" followed by its AN number, for example, \"AN35\". This name is used to access the object.",
                "paramname": "sName"
            },
            {
                "paramdescription": "The x coordinate of the object's top left hand corner as it will appear in your Plant SCADA window.",
                "paramname": "x1"
            },
            {
                "paramdescription": "The y coordinate of the object's top left hand corner as it will appear in your Plant SCADA window.",
                "paramname": "y1"
            },
            {
                "paramdescription": "The x coordinate of the object's bottom right hand corner as it will appear in your Plant SCADA window.",
                "paramname": "x2"
            },
            {
                "paramdescription": "The y coordinate of the object's bottom right hand corner as it will appear in your Plant SCADA window.",
                "paramname": "y2"
            },
            {
                "paramdescription": "The string you would like to use as the event class for the object.",
                "paramname": "sEventClass"
            }
        ],
        "returnType": "The newly created object, if successful, otherwise an error is generated.",
        "syntax": "CreateControlObject(sClass, sName, x1, y1, x2, y2, sEventClass)"
    },
    "createobject": {
        "doc": "Creates a new instance of an ActiveX object. If you use this function to create an ActiveX object, it will have no visual component (only the automation component will be created).\nIf you assign an object created with the CreateObject() function to a local variable, that object will remain in existence until the variable it is assigned to goes out of scope. This means that such an object will only be released when the Cicode function that created it ends.\nIf you assign an object created with the CreateObject() function to a module or global scope variable, then that object will remain in existence until the variable either has another object assigned or is set to NullObject, provided the CreateObject() call is not made within a loop.\nObjects created by calls to CreateObject() within WHILE or FOR loops are only released on termination of the Cicode function in which they are created, regardless of the scope of the variable to which the object is assigned. The use of CreateObject() within a loop may therefore result in the exhaustion of system resources, and is not generally recommended unless performed as shown in the examples below.\nCreateObject(sClass)\nsClass: \nThe newly created object, if successful, otherwise an error is generated.",
        "example": "/* In the example below, the variable objTest is local. Resources \nassociated with calls to ProcessObject() will be released each \ntime that function ends. */\nFUNCTION Forever()\n    WHILE 1 DO\n        ProcessObject();\n        Sleep(1);\n    END\nEND\nFUNCTION ProcessObject()\n    .OBJECT objTest;\n    objTest=CreateObject(\"MyObject\");\n    - do something\nEND\n/* In the example below, the variable objTest is global. Resources \nassociated with calls to ProcessObject() will be released when \nobjTest is set to NullObject. */\nFUNCTION Forever()\n    WHILE 1 DO\n        ProcessObject();\n        Sleep(1);\n    END\nEND\nFUNCTION ProcessObject()\n    objTest=CreateObject(\"MyObject\");\n    - do something\n    objTest=NullObject;\nEND",
        "name": "CreateObject",
        "params": [
            {
                "paramdescription": "The class of the object. You can use the object's human readable name, its program ID, or its GUID. If the class does not exist, the function will return an error.\nFor example:\n\"Calendar Control 8.0\" - human readable name\n\"MSCAL.Calendar.7\" - Program ID\n\"{8E27C92B-1264-101C-8A2F-040224009C02}\" - GUID\nThe newly created object, if successful, otherwise an error is generated.",
                "paramname": "sClass"
            }
        ],
        "returnType": "The newly created object, if successful, otherwise an error is generated.",
        "syntax": "CreateObject(sClass)"
    },
    "date_ciref": {
        "doc": "Gets the current date in string format.",
        "example": "No example found",
        "name": "Date_CIREF",
        "params": [
            {
                "paramdescription": "The format required:",
                "paramname": "Format"
            },
            {
                "paramdescription": "0 - Short time format, hh:mm AM/PM.\n1 - Long time format, hh:mm:ss AM/PM.\n2 - Short date format, dd/mm/yy.\n3 - Long date format, day month year.\n4 - Time and date, weekday month day year hh:mm:ss AM/PM.\n5 - Long time period, hh:mm:ss. Time needs to be in seconds.\n6 - Millisecond time period, hh:mm:ss.xxx (\"xxx\" represents milliseconds). Time needs to be in milliseconds.\n7 - Short time period, hh:mm. Time needs to be in seconds.\n8 - Long time period, \"xxxxx Days hh Hours mm min ss sec where xxxxx = number of days since 1/1/1970\". Time needs to be in seconds.\n9 - Extended date format, dd/mm/yyyy.\n10 - Local TimeDate format, yyyy-mm-dd hh:mm:ss\n11 - Time of Day, hh:mm:ss tt format with no date\nUTC: \nCoordinated Universal Time (optional)\n0 - Display the string as a local date/time (default).\n1 - Display the string as a UTC date/time (valid for formats 0-4 and 9).\nIf omitted, the default Format is 2. These formats follow the Regional Settings found in the Windows Control Panel.",
                "paramname": "Format of the string"
            }
        ],
        "returnType": "The current date (in string format).",
        "syntax": "Date( [Format] )"
    },
    "dateadd": {
        "doc": "Adds time (in seconds) to a time/date value. The return value is in time/date variable format. Use this function for time and date calculations.",
        "example": "DateVariable=DateAdd(StrToDate(\"3/11/91\"),86400);\n! Adds 24 hours to 3/11/91.\nNewDate=TimeToStr(DateVariable);\n! Sets NewDate to 4/11/91.",
        "name": "DateAdd",
        "params": [
            {
                "paramdescription": "The time/date to which the AddTime will be added.",
                "paramname": "Time"
            },
            {
                "paramdescription": "The time to add, in seconds.",
                "paramname": "AddTime"
            }
        ],
        "returnType": "The date as a time/date variable.",
        "syntax": "DateAdd(Time, AddTime)"
    },
    "dateday": {
        "doc": "Gets the day of the month from a time/date variable.\nTime/date functions can only be used with dates between 1980 and 2035. You should check that the date you are using is valid with Cicode similar to the following:",
        "example": "! If the current system date is 3rd November 1991;\nVariable=DateDay(TimeCurrent());\n! Sets Variable to 3.",
        "name": "DateDay",
        "params": [
            {
                "paramdescription": "The time/date variable.",
                "paramname": "Time"
            }
        ],
        "returnType": "The day of the month as an integer.",
        "syntax": "DateDay(Time)"
    },
    "dateinfo": {
        "doc": "Returns the date format currently used on the Plant SCADA Server.",
        "example": "! If the current system date is the fourth of December 2002;\nTwelfthMonth=DateInfo(9,12);\n! Sets TwelfthMonth to \"December\".",
        "name": "DateInfo",
        "params": [
            {
                "paramdescription": "Determines the contents of the string returned by the DateInfo() function. Valid values and resulting strings are:\n1 - The current date order:\n\"0\" - MMDDYY\n\"1\" - DDMMYY\n\"2\" - YYMMDD.\n2 - The current date delimiter.\n3 - The current short date format.\n4 - The current long date format.\n5 - The current extended date format.\n6 - The short weekday string. The particular weekday returned is determined by the nExtra argument.\n7 - The long weekday string. The particular weekday returned is determined by the nExtra argument.\n8 - The short month string. The particular month returned is determined by the nExtra argument.\n9 - The long month string. The particular month returned is determined by the nExtra argument.",
                "paramname": "nInfo"
            },
            {
                "paramdescription": "When an nInfo argument of 6 or 7 is specified, the nExtra argument determines which weekday (1-7) is returned by the DateInfo() function.\nWhen an nInfo argument of 8 or 9 is specified, the nExtra argument determines which month (1-12) is returned by the DateInfo() function.\nThe nExtra argument is ignored if any other nInfo value is passed to the function.",
                "paramname": "nExtra"
            }
        ],
        "returnType": "A string containing one of the following:",
        "syntax": "DateInfo(nInfo, nExtra)"
    },
    "datemonth": {
        "doc": "Gets the month from a time/date variable.",
        "example": "! If the current system date is 3rd November 1991;\nVariable=DateMonth(TimeCurrent());\n! Sets Variable to 11.",
        "name": "DateMonth",
        "params": [
            {
                "paramdescription": "The time/date variable.",
                "paramname": "Time"
            }
        ],
        "returnType": "The month of the year as an integer.",
        "syntax": "DateMonth(Time)"
    },
    "datesub": {
        "doc": "Subtracts time (in seconds) from a time/date value. The return value is in time/date variable format. Use this function for time and date calculations.",
        "example": "Variable=DateSub(StrToDate(\"05/11/91\"),StrToDate(\"03/11/91\"));\n! Sets Variable to number of seconds between 2 date/times.\nStr=TimeToStr(Variable,5);\n! Sets Str to \"48:00:00\".",
        "name": "DateSub",
        "params": [
            {
                "paramdescription": "The time/date from which the SubTime will be subtracted.",
                "paramname": "Time"
            },
            {
                "paramdescription": "The time to subtract, in seconds.",
                "paramname": "SubTime"
            }
        ],
        "returnType": "The time difference (in seconds) as an integer.",
        "syntax": "DateSub(Time, SubTime)"
    },
    "dateweekday": {
        "doc": "Gets the day of the week from a time/date variable.\nTime/date functions can only be used with dates from 1980 to 2035. You should check that the date you are using is valid with Cicode similar to the following:",
        "example": "! If the current system date is Sunday, 3rd November 1991;\nVariable=DateWeekDay(TimeCurrent());\n! Sets Variable to 1.",
        "name": "DateWeekDay",
        "params": [
            {
                "paramdescription": "The time/date variable.",
                "paramname": "Time"
            }
        ],
        "returnType": "An integer representing the day of the week as follows:",
        "syntax": "DateWeekDay(Time)"
    },
    "dateyear": {
        "doc": "Gets the year from a time/date variable.\nTime/date functions can only be used with dates between 1980 and 2035. You should check that the date you are using is valid with Cicode similar to the following:",
        "example": "! If the current system date is 3rd November 1991;\nVariable=DateYear(TimeCurrent(),0);\n! Sets Variable to 91.\n! If the current system date is 18th October 2000;\nVariable=DateYear(TimeCurrent(),0);\n! Sets Variable to 0.\nVariable=DateYear(TimeCurrent(),1);\n! Sets Variable to 1991.",
        "name": "DateYear",
        "params": [
            {
                "paramdescription": "The time/date variable.",
                "paramname": "Time"
            },
            {
                "paramdescription": "The format required:\n0 - Short year, yy. If you use this mode during the year 2000, 0 (zero) will be returned.\n1 - Long year, yyyy\nIf omitted, the default Mode is 0.",
                "paramname": "Mode"
            }
        ],
        "returnType": "The year as an integer.",
        "syntax": "DateYear(Time [, Mode] )"
    },
    "ddeexec": {
        "doc": "Executes a command in an external Windows application running on the same computer. With this function, you can control other applications that support DDE. Refer to the documentation provided with the external Windows application to determine if DDE is supported and what functions can be called.\nYou cannot use DDEExec() to call macros on a remote computer or to call Access SQLs. For these calls, Network DDE needs to pass the sDocument argument, so you need to use the DDEh... functions, passing sDocument in the DDEhInitiate() function.",
        "example": "/* Instruct the Excel application to recalculate its spreadsheet \nimmediately. */\nDDEExec(\"Excel\",\"[Calculate.Now()]\");",
        "name": "DDEExec",
        "params": [
            {
                "paramdescription": "Application name (.EXE filename), for example, \"WinWord\".",
                "paramname": "sApplication"
            },
            {
                "paramdescription": "The command that the application will execute.",
                "paramname": "sCommand"
            }
        ],
        "returnType": "1 (one) if successful, otherwise an error code is returned.",
        "syntax": "DDEExec(sApplication, sCommand)"
    },
    "ddehexecute": {
        "doc": "Executes a command in an external Windows application. You need to first start a conversation with the DDEhInitiate function, and use the handle returned by that function to identify the conversation.\nWith this function, you can control other applications that support DDE. Refer to the documentation provided with your other Windows application to determine if DDE is supported and what functions can be called.\nThis function is a blocking function. It will block the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "DDEhExecute",
        "params": [
            {
                "paramdescription": "The integer handle that identifies the DDE conversation, returned from the DDEhInitiate function.",
                "paramname": "Handle"
            },
            {
                "paramdescription": "The command that the application will execute.",
                "paramname": "sCommand"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "DDEhExecute(Handle, sCommand)"
    },
    "ddehgetlasterror": {
        "doc": "Gets the latest error code issued from Windows for the conversation identified by the handle.",
        "example": "No example found",
        "name": "DDEhGetLastError",
        "params": [
            {
                "paramdescription": "The integer handle that identifies the DDE conversation, returned from the DDEhInitiate function.",
                "paramname": "Handle"
            }
        ],
        "returnType": "The error code last issued from Windows DDEML (for that conversation):",
        "syntax": "DDEhGetLastError(Handle)"
    },
    "ddehinitiate": {
        "doc": "Starts a conversation with an external Windows application. When the data exchange is complete, you should terminate the conversation to free system resources.",
        "example": "! Read from Excel spreadsheet\nSTRING FUNCTION GetExcelData();\n    INT hChannel;\n    STRING sData;\n    hChannel = DDEhInitiate(\"EXCEL\", \"DATA.XLS\");\n    IF hChannel > -1 THEN\n        sData = DDEhRequest(hChannel, \"R1C1\");\n        DDEhTerminate(hChannel);\n        hChannel = -1;\n    END;\n    RETURN sData;\nEND\n! Write to Excel spreadsheet\nFUNCTION SetExcelData(STRING sData);\n    INT hChannel;\n    hChannel = DDEhInitiate(\"EXCEL\", \"DATA.XLS\");\n    IF hChannel > -1 THEN\n        DDEhPoke(hChannel, \"R1C1\", sData);\n        DDEhTerminate(hChannel);\n        hChannel = -1;\n    END;\nEND\n! Execute Excel Macro\nFUNCTION DoExcelMacro();\n    INT        hChannel;\n    hChannel = DDEhInitiate(\"EXCEL\", \"DATA.XLS\");\n    IF hChannel > -1 THEN\n        DDEhExecute(hChannel, \"[RUN(^\"TestMacro^\")]\");\n        DDEhTerminate(hChannel);\n        hChannel = -1;\n    END;\nEND",
        "name": "DDEhInitiate",
        "params": [
            {
                "paramdescription": "The application name (.EXE filename), for example, \"WinWord\".",
                "paramname": "sApplication"
            },
            {
                "paramdescription": "The document, topic, or file name.",
                "paramname": "sDocument"
            }
        ],
        "returnType": "An integer handle for the conversation between Plant SCADA and the other application, or -1 if the conversation is not started successfully. The handle is used by the other DDEh... functions, to identify the conversation.",
        "syntax": "DDEhInitiate(sApplication, sDocument)"
    },
    "ddehpoke": {
        "doc": "Writes a value to an external Windows application, for example, an Excel spreadsheet. The value is written once to the application. (To write the value dynamically, you need to call this function at the rate at which the data needs to be updated.)\nYou need to first start a conversation with the DDEhInitiate function, and use the handle returned by that function to identify the conversation.\nThis function is a blocking function. It will block the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "DDEhPoke",
        "params": [
            {
                "paramdescription": "The integer handle that identifies the DDE conversation, returned from the DDEhInitiate function.",
                "paramname": "Handle"
            },
            {
                "paramdescription": "A unique name for the item; for example, the variable name, field name, or spreadsheet cell position.",
                "paramname": "sItem"
            },
            {
                "paramdescription": "The value of the item.",
                "paramname": "sValue"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "DDEhPoke(Handle, sItem, sValue)"
    },
    "ddehreadln": {
        "doc": "Reads a line of text from a DDE Conversion, for example, from an Excel spreadsheet. You need to first start a conversation with the DDEhInitiate function, and use the handle returned by that function to identify the conversation. This function allows you to read a large amount of data via DDE. Keep calling the function until an empty string is returned to verify that all the data has been read.\nThis function is a blocking function. It will block the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "DDEhReadLn",
        "params": [
            {
                "paramdescription": "The integer handle that identifies the DDE conversation, returned from the DDEhInitiate function.",
                "paramname": "Handle"
            },
            {
                "paramdescription": "A unique topic name for the item; for example, the variable name, field name, or spreadsheet cell position.",
                "paramname": "sTopic"
            }
        ],
        "returnType": "A line of data, or an empty string when all data has been read.",
        "syntax": "DDEhReadLn(Handle, sTopic)"
    },
    "ddehrequest": {
        "doc": "Reads a value from an external Windows application, for example, from an Excel spreadsheet. You need to first start a conversation with the DDEhInitiate function, and use the handle returned by that function to identify the conversation.\nThis function is a blocking function. It will block the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "DDEhRequest",
        "params": [
            {
                "paramdescription": "The integer handle that identifies the DDE conversation, returned from the DDEhInitiate function.",
                "paramname": "Handle"
            },
            {
                "paramdescription": "A unique name for the item; for example, the variable name, field name, or spreadsheet cell position.",
                "paramname": "sItem"
            }
        ],
        "returnType": "A string of data, or an empty string if the function cannot read the value.",
        "syntax": "DDEhRequest(Handle, sItem)"
    },
    "ddehsetmode": {
        "doc": "Set the mode of the DDE conversation. The default mode of a DDE conversation is to use TEXT data format - a simple string of data. This function allows you to set the mode to CSV (Comma Separated Values). Some Windows applications support this mode of data as it helps them to separate the data. For example, when you send CSV format to Excel, each value will be placed into a unique cell. If you use TEXT mode all the data will be placed into the same cell.",
        "example": "No example found",
        "name": "DDEhSetMode",
        "params": [
            {
                "paramdescription": "The integer handle that identifies the DDE conversation, returned from the DDEhInitiate function.",
                "paramname": "Handle"
            },
            {
                "paramdescription": "The mode of the DDE conversation:\n1 - Text (default)\n2 - CSV",
                "paramname": "sMode"
            }
        ],
        "returnType": "The error code.",
        "syntax": "DDEhSetMode(Handle, sMode)"
    },
    "ddehterminate": {
        "doc": "Closes the conversation identified by the handle, and frees the resources associated with that conversation. After you call this function, the handle is no longer valid.\nWith Network DDE, you might need to terminate and re-initiate a conversation. For example, if you delete rows on an MS Access sheet, the deleted rows display as #DELETED until you terminate and re-initiate the conversation.",
        "example": "No example found",
        "name": "DDEhTerminate",
        "params": [
            {
                "paramdescription": "The integer handle that identifies the DDE conversation, returned from the DDEhInitiate function.",
                "paramname": "Handle"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "DDEhTerminate(Handle)"
    },
    "ddehwriteln": {
        "doc": "Writes a line of text to the DDE conversation. With this function, you can write any amount of text to the DDE conversation. Call this function once for each line of text. To terminate the block of text, call this function and pass an empty string.",
        "example": "!    Write to Excel spreadsheet\n!    write the numbers 1..8 into 8 unique cells in Excel.\nFUNCTION WriteExcelData(STRING sData);\n    INT hChannel;\n    hChannel = DDEhInitiate(\"EXCEL\", \"DATA.XLS\");\n    IF hChannel > -1 THEN\n        // set to CSV mode so EXCEL will put each value in a cell\n        DDEhSetMode(hChannel, 2);\n        DDEhWriteLn(hChannel, \"\", \"1,2,3,4\");\n        DDEhWriteLn(hChannel, \"R1C1:R2C4\", \"5,6,7,8\");\n        DDEhWriteLn(hChannel,\"R1C1:R2C4\",\"\"); \n        DDEhTerminate(hChannel);\n        hChannel = -1;\n    END;\nEND",
        "name": "DDEhWriteLn",
        "params": [
            {
                "paramdescription": "The integer handle that identifies the DDE conversation, returned from the DDEhInitiate function.",
                "paramname": "Handle"
            },
            {
                "paramdescription": "A unique name for the topic the data will be written to; for example, the spreadsheet cell position. The topic is only used when you complete the write by passing an empty string for data.",
                "paramname": "sTopic"
            },
            {
                "paramdescription": "The line of data to write. To terminate the data and make Plant SCADA send the data, set the data to an empty string.",
                "paramname": "sData"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "DDEhWriteLn(Handle, sTopic, sData)"
    },
    "ddepost": {
        "doc": "Makes a Plant SCADA variable value available for DDE linking (which means it posts a DDE link so that it can be read by other DDE compliant applications running on the same computer). This sets up Plant SCADA to behave as a DDE Server for this DDE channel.\nAfter a value is posted, other Windows applications running on the same computer can read the value by using their own DDE Client functions. If the value of the posted variable changes, any linked applications are informed of the new value.\nTo link to this value from any DDE Client applications running on the same computer, they need to appropriately use the DDE Client syntax with:\nUnlike the DDERead() and DDEWrite() Cicode functions which are static, the DDEPost() function can be used to create a dynamic DDE link, providing the DDE Client applications appropriately set their side of the DDE channel to be automatically updated.",
        "example": "! In Cicode, post a string \"PV1\" for external DDE \napplications to connect with DDEPost(\"TAGONE\",PV1);\n/* To link to this posted tag from a cell in Excel, set the cell to\n=Citect|Data!TAGONE\n. This will set the value of the Excel cell to the string \"PV1\". */\n/* To link to this posted tag from a field in Word, set the field \nto{DDEAuto Citect Data TAGONE}. This will set the value of the \nfield link to the string \"PV1\". */",
        "name": "DDEPost",
        "params": [
            {
                "paramdescription": "A unique name for the item; for example, the variable name, field name, or spreadsheet cell position.",
                "paramname": "sItem"
            },
            {
                "paramdescription": "The value of the item.",
                "paramname": "sValue"
            }
        ],
        "returnType": "The value that is posted, or empty string if the function does not succeed in posting the link.",
        "syntax": "DDEPost(sItem, sValue)"
    },
    "dderead": {
        "doc": "Reads values from an external DDE compliant Windows application running on the same computer, (for example, from an Excel spreadsheet cell or a Word document).\nThis is a one-way static communication which is read once from the application per call. To read the value dynamically, call this function at the rate at which the data is required to be updated.\nUse this function when you want precise control over exactly what you want from the DDE exchange.",
        "example": "/* Read the value from R1C1 (Row1,Column1) of an Excel spreadsheet \nnamed \"Sheet1\". */\nDDERead(\"Excel\",\"Sheet1\",\"R1C1\");\n/* Read the value from the Item1 bookmark of the Word document \nnamed \"Recipes.doc\". */\nDDERead(\"Winword\",\"Recipes\",\"Item1\");",
        "name": "DDERead",
        "params": [
            {
                "paramdescription": "The application name (.EXE filename), for example, \"WinWord\".",
                "paramname": "sApplication"
            },
            {
                "paramdescription": "The document, topic, or file name.",
                "paramname": "sDocument"
            },
            {
                "paramdescription": "A unique name for the item; for example, the variable name, field name, or spreadsheet cell position.",
                "paramname": "sItem"
            },
            {
                "paramdescription": "A flag that tells the application whether or not to set up an advise loop:\n0 - Do not set up advise loop.\n1 - Set up advise loop (default).",
                "paramname": "Mode"
            }
        ],
        "returnType": "The value (from the external application) as a string, or an empty string if the function cannot read the desired values.",
        "syntax": "DDERead(sApplication, sDocument, sItem [, Mode] )"
    },
    "ddewrite": {
        "doc": "Writes a value to an external Windows application, for example, to an Excel spreadsheet. The value is written once to the application. To write the value dynamically, you need to call this function at the rate at which the data needs to be updated.\nUse DDEWrite() to cause Plant SCADA runtime to initiate the DDE conversation with a DDE compliant application running on the same computer.",
        "example": "/* Write the value of a \nPlant SCADA\n variable named \nTAGONE to R1C1 (Row1,Column1) of an Excel spreadsheet named \n\"Sheet1\". The value is in string format. */\nDDEWrite(\"Excel\",\"Sheet1\",\"R1C1\",TAGONE);",
        "name": "DDEWrite",
        "params": [
            {
                "paramdescription": "The application name (.EXE filename), for example, \"WinWord\".",
                "paramname": "sApplication"
            },
            {
                "paramdescription": "The document, topic, or file name.",
                "paramname": "sDocument"
            },
            {
                "paramdescription": "A unique name for the item; for example, the variable name, field name, or spreadsheet cell position.",
                "paramname": "sItem"
            },
            {
                "paramdescription": "The value of the item.",
                "paramname": "sValue"
            }
        ],
        "returnType": "The value that is sent to the other application, or an empty string if the function does not successfully write the value.",
        "syntax": "DDEWrite(sApplication, sDocument, sItem, sValue)"
    },
    "debugbreak": {
        "doc": "Causes a breakpoint exception error to occur (error number 342). This allows programmers to trap invalid states in their Cicode. If the Cicode Editor is not running, and the Plant SCADA Runtime will start debugger on hardware errors option is set (Debug menu - Options), the Debugger will be started. When the debugger starts, the correct Cicode file, function, and line will be displayed.",
        "example": "!Check to see that rSpan is greater than zero else cause a break. \nIf rSpan equals 0 it would cause a Divide by Zero hardware error \nanyway.\nIF rSpan > 0 THEN\n    rCalcRate = iAmount/rSpan;\nELSE\n    DebugBreak();\nEND",
        "name": "DebugBreak",
        "params": [],
        "returnType": "None.",
        "syntax": "DebugBreak()"
    },
    "debugmsg": {
        "doc": "Provides in-line debug messages of user Cicode, to the Kernel, Debugger Debug window, and the SysLog.DAT file. This function can be enabled or disabled with the [Code]DebugMessage parameter or DebugMsgSet() function at runtime.",
        "example": "INT\nFUNCTION\nFileDisplayEx(STRING sFileName);\n\tINT hFile;\n\thFile = FileOpen(sFileName, \"r\");\n\tDebugMsg(\"When opening file \" + sFileName + \", the handle was:\n\t \" + IntToStr(hFile));\n\t...\n\tFileClose(hFile);\n\tRETURN 0;\nEND",
        "name": "DebugMsg",
        "params": [
            {
                "paramdescription": "The debugging message to log. Be sure to enclose this message in double quotes (\" \").",
                "paramname": "sMessage"
            }
        ],
        "returnType": "None.",
        "syntax": "DebugMsg(sMessage)"
    },
    "debugmsgset": {
        "doc": "Enables/disables the DebugMsg() logging functionality. It also controls whether logging is enabled for the Assert() function. This function also sets the [Code]DebugMessage parameter appropriately.",
        "example": "No example found",
        "name": "DebugMsgSet",
        "params": [
            {
                "paramdescription": "The logging mode:\n0 - Disable logging.\n1 - Enable logging.",
                "paramname": "nMode"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "DebugMsgSet(nMode)"
    },
    "degtorad": {
        "doc": "Converts an angle from degrees to radians.",
        "example": "Variable=DegToRad(180);\n! Sets Variable to 3.1415... (pi).",
        "name": "DegToRad",
        "params": [
            {
                "paramdescription": "Any angle (in degrees).",
                "paramname": "Angle"
            }
        ],
        "returnType": "The angle in radians.",
        "syntax": "DegToRad(Angle)"
    },
    "delayshutdown": {
        "doc": "Terminates Plant SCADA's operation after the specified delay period (in milliseconds). This function is suitable to be called by the CTAPI. The delay period enables the user to close the connection between the CTAPI and third-party applications before Plant SCADA shuts down.",
        "example": "DelayShutdown(10 000) \n!Terminates \nPlant SCADA\n's operation after 10 seconds",
        "name": "DelayShutdown",
        "params": [
            {
                "paramdescription": "The period (in milliseconds) after whichPlant SCADA will shut down.",
                "paramname": "Delay"
            }
        ],
        "returnType": "No return value.",
        "syntax": "DelayShutdown(Delay)"
    },
    "devappend": {
        "doc": "Appends a blank record to the end of a device. After the record is appended, you can use the DevSetField() function to add data to fields in the record.\nYou need to first call the DevOpen() function to get the device handle (hDev).",
        "example": "INT FUNCTION WriteAlarmCount( INT hDevice, STRING sAlarm, INT iCount, INT iTime )\n    DevAppend(hDevice);\n    DevSetField(hDevice, \"ALARM\", sAlarm);\n    DevSetField(hDevice, \"TIME\", IntToStr(iTime));\n    DevSetField(hDevice, \"COUNT\", IntToStr(iCount));\nEND\n\nINT FUNCTION WriteAlarmCount( INT hSqlDevice, STRING sAlarm, INT iCount, INT iTime )\n    DevSetField(hSqlDevice, \"ALARM\", sAlarm);\n    DevSetField(hSqlDevice, \"TIME\", IntToStr(iTime));\n    DevSetField(hSqlDevice, \"COUNT\", IntToStr(iCount));\n    DevAppend(hSglDevice);\nEND",
        "name": "DevAppend",
        "params": [
            {
                "paramdescription": "The device handle, returned from the DevOpen() function. The device handle identifies the table where all data on the associated device is stored.",
                "paramname": "hDev"
            }
        ],
        "returnType": "0 (zero) if the record is successfully appended, otherwise an error code is returned.",
        "syntax": "DevAppend(hDev)"
    },
    "devclose": {
        "doc": "Closes a device. Any data in the buffer is flushed to the device before it is closed. After a device is closed, its device handle becomes invalid and cannot be used.\n For SQL devices, this function is a blocking Cicode function.",
        "example": "DevClose(hDev);",
        "name": "DevClose",
        "params": [
            {
                "paramdescription": "The device handle, returned from the DevOpen() function.The device handle identifies the table where data on theassociated device is stored.",
                "paramname": "hDev"
            },
            {
                "paramdescription": "The mode of the close:\n0 - Close the device in user mode - the default mode if none is specified. A device opened by Cicode function DevOpen() need to be closed in this mode.\n1 - Close the device in remove logging mode - under this mode, the current device will be rolled over to history files immediately. You should only use this mode in a report.\n2 - Close the device in keep logging mode - under this mode, the current device will not be rolled over to history files. This allows subsequent messages to be written to the same file. This mode is used internally in a report written in rich text format (rtf).\n0 (zero) if successful, otherwise an error code is returned.",
                "paramname": "Mode"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "DevClose(hDev, Mode)"
    },
    "devcontrol": {
        "doc": "Controls a dBASE or SQL device. You can pack a dBASE device to physically remove deleted records, or re-index a dBASE device to regenerate the keys. You can issue queries to an SQL device, or get the error status of the last SQL query.\n For SQL devices, this function is a blocking Cicode function.",
        "example": "! pack a dBASE file device\nDevControl(hDev, 1, \"\");",
        "name": "DevControl",
        "params": [
            {
                "paramdescription": "The device handle, returned from the DevOpen() function. The device handle identifies the table where all data on the associated device is stored.",
                "paramname": "hDev"
            },
            {
                "paramdescription": "The type of command:\n0 - Re-index the device based on the key defined in the device record (dBASE devices only).\n1 - Pack the database file - all deleted records are removed (dBASE devices only).\n2 - Issue a direct SQL query to the device (SQL devices only).\n3 - Get error status of the last SQL query (SQL devices only).",
                "paramname": "nType"
            },
            {
                "paramdescription": "The command data, that is the SQL query to be issued. Used only for Type 2 commands.",
                "paramname": "sData"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "DevControl(hDev, Type [, sData])"
    },
    "devcurr": {
        "doc": "Gets the current device handle. You can only call this function in a report, to get the handle of the device where the report is logging. You can then use the other device functions (for example, DevPrint()) to access that logging device. (To get the handle of a device other than a logging device, you need to use the DevOpen() function.)\nIf the report is logging to a group of devices, this function will return the group handle. However, not all device functions support group handles, for example, you cannot read from a group of devices.",
        "example": "! Get the report device number.\nhDev=DevCurr();",
        "name": "DevCurr",
        "params": [],
        "returnType": "The current device handle or group handle. If no device is configured, -1 is returned.",
        "syntax": "DevCurr()"
    },
    "devdelete": {
        "doc": "Deletes the current record in a dBASE database device. The record is not physically deleted, but is marked for deletion. You can physically delete the record by packing the database with the DevControl() function.\n For SQL devices, this function is a blocking Cicode function.",
        "example": "! Delete the current record.\nDevDelete(hDev);",
        "name": "DevDelete",
        "params": [
            {
                "paramdescription": "The device handle, returned from the DevOpen() function. The device handle identifies the table where all data on the associated device is stored.",
                "paramname": "hDev"
            }
        ],
        "returnType": "0 (zero) if the record is successfully deleted, otherwise an error code is returned.",
        "syntax": "DevDelete(hDev)"
    },
    "devdisable": {
        "doc": "Disables (and re-enables) a device from all access, and discards any data written to the device. When a device is disabled, it cannot be opened, and data cannot be read from the device. Use this function to disable logging to a database or printer.\nThe State argument is a toggle. A State of 1 disables the device(s), but you can then re-enable the device(s) by repeating the function with State = 0.",
        "example": "! Disable the AlarmLog device.\nDevDisable(\"AlarmLog\",1);\n:\nDevDisable(\"AlarmLog\",0);        ! Re-enable the device.",
        "name": "DevDisable",
        "params": [
            {
                "paramdescription": "The device name, or * (asterisk) for all devices.",
                "paramname": "sName"
            },
            {
                "paramdescription": " The disable state:\n0 - Enable the device.\n1 - Disable the device.",
                "paramname": "State"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "DevDisable(sName, State)"
    },
    "deveof": {
        "doc": "Gets the status of the end of file (EOF) flag for a device. When you use the DevPrev(), DevNext(), or DevSeek() function, the start or end of the device will eventually be reached, and the EOF flag will be set. Use this function to test the EOF flag.",
        "example": "hDev = DevOpen(\"Log\", 0);\nWHILE NOT DevEOF(hDev) DO\n    Prompt(DevGetField(hDev,\"Tag\"));\n    DevNext(hDev);\nEND\nDevClose(hDev);",
        "name": "DevEOF",
        "params": [
            {
                "paramdescription": "The device handle, returned from the DevOpen() function. The device handle identifies the table where all data on the associated device is stored.",
                "paramname": "hDev"
            }
        ],
        "returnType": "1 if the EOF flag has been set, otherwise 0 (zero).",
        "syntax": "DevEOF(hDev)"
    },
    "devfind": {
        "doc": "Searches a device for a record that contains specified data in a specified field. The search starts at the current record and continues forward until the matched data is found or the end of the database is reached. If the file has a keyed index, an indexed search is used.\n For SQL devices, this function is a blocking Cicode function.",
        "example": "! Find the Ice cream recipe.\nDevNotFound=DevFind(hDev,\"Ice cream\",\"Recipe\");\nIF DevNotFound=0 THEN\n\t! Get the recipe values.\n\t..\nELSE\n\tPrompt(\"Ice cream not found\");\nEND",
        "name": "DevFind",
        "params": [
            {
                "paramdescription": "The device handle, returned from the DevOpen() function. The device handle identifies the table where all data on the associated device is stored.",
                "paramname": "hDev"
            },
            {
                "paramdescription": "The data to find in sField, as a string.\nFor SQL devices: The DevFind() function can distinguish between numbers, strings, and dates, so you do not need to enclose the data in quote marks. Dates and times need to be in the correct format:\nDate: YYYY-MM-DD\nTime: HH:MM:SS\nDateTime: YYYY-MM-DD HH:MM:SS[.F...] (The fraction .F... is optional.)",
                "paramname": "sFind"
            },
            {
                "paramdescription": "The field name to match.",
                "paramname": "sField"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "DevFind(hDev, sFind, sField)"
    },
    "devfirst": {
        "doc": "Finds the first record in a device.\n For SQL devices, this function is a blocking Cicode function.",
        "example": "! Find the first record.\nFirstRec = DevFirst(hDev);",
        "name": "DevFirst",
        "params": [
            {
                "paramdescription": "The device handle, returned from the DevOpen() function. The device handle identifies the table where all data on the associated device is stored.",
                "paramname": "hDev"
            }
        ],
        "returnType": "The first indexed record (if the device is an indexed database), otherwise the first record in the device.",
        "syntax": "DevFirst(hDev)"
    },
    "devflush": {
        "doc": "Flushes buffered data to the physical device. Plant SCADA normally optimizes the writing of data for maximum performance, so use this function only if it is really necessary.",
        "example": "! Flush device to disk.\nDevFlush(hDev);",
        "name": "DevFlush",
        "params": [
            {
                "paramdescription": "The device handle, returned from the DevOpen() function.The device handle identifies the table where data on theassociated device is stored.",
                "paramname": "hDev"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "DevFlush(hDev)"
    },
    "devgetfield": {
        "doc": "Gets field data from the current record in a device.",
        "example": "INT\nFUNCTION\nGetRecipe(STRING sName)\n    INT hDev;\n    hDev = DevOpen(\"Recipe\", 0);\n    IF hDev >= 0 THEN\n        DevSeek(hDev, 1);\n        IF DevFind(hDev, sName, \"NAME\") = 0 THEN\n            PLC_FLOUR = DevGetField(hDev, \"FLOUR\");\n            PLC_WATER = DevGetField(hDev, \"WATER\");\n            PLC_SALT = DevGetField(hDev, \"SALT\");\n            PLC_MILK = DevGetField(hDev, \"MILK\");\n        ELSE\n            DspError(\"Cannot Find Recipe \" + sName);\n        END\n        DevClose(hDev);\n    ELSE\n        DspError(\"Cannot open recipe database\");\n    END\nEND",
        "name": "DevGetField",
        "params": [
            {
                "paramdescription": "The device handle, returned from the DevOpen() function. The device handle identifies the table where all data on the associated device is stored.",
                "paramname": "hDev"
            },
            {
                "paramdescription": "The field name, as a string of up to 10 characters. (The dBASE file format limits all field names to a maximum of 10 characters.)",
                "paramname": "sField"
            }
        ],
        "returnType": "The field data (as a string). If the field is not found an empty string is returned.",
        "syntax": "DevGetField(hDev, sField )"
    },
    "devhistory": {
        "doc": "Renames a device file and any subsequent history files. The current device is closed and renamed as the first history file. For example, the device file 'Templog.txt' is renamed as 'Templog.001'. If a history file 'Templog.001' already exists, it is renamed as 'Templog.002', and so on. The next time data is written to the device, a new device file is created.\nThe DevHistory function does not support SQL devices.",
        "example": "! Create history file\nDevHistory(hDev);",
        "name": "DevHistory",
        "params": [
            {
                "paramdescription": "The device handle, returned from the DevOpen() function. The device handle identifies the table where all data on the associated device is stored.",
                "paramname": "hDev"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "DevHistory(hDev)"
    },
    "devinfo": {
        "doc": "Gets information on a device.",
        "example": "! Get the number of fields in a device.\nNoFields=DevInfo(hDev,6);\nFOR I=1 TO NoFields DO\n    ! Get and display the name of each field.\n    sField=DevInfo(hDev,-I);\n    nLength=DevInfo(hDev,-I - NoFields);\n    Prompt(\"Field Name \"+sField + \"Length \" + nLength:##);\nEND",
        "name": "DevInfo",
        "params": [
            {
                "paramdescription": "The device handle, returned from the DevOpen() function. The device handle identifies the table where all data on the associated device is stored.",
                "paramname": "hDev"
            },
            {
                "paramdescription": "Type of information:\n-n: Name of field n (where n is any number up to the total number of fields). For example, if there are 10 fields, -7 will return the name of field 7.\n- (Total no. of fields + n): Length of field n (where n is any number up to the total number of fields). For example, if there are 10 fields, -15 will return the length of field 5.\n0: Device Name\n1: Format\n2: Header\n3: File Name\n4: Number of history files\n5: Form length\n6: Number of fields\n7: Disable flag\n8: Device type\n9: Record size\n10: Format number\n11: Type of history schedule:\n0: Event triggered\n1: Daily\n2: Weekly\n3: Monthly\n4: Yearly\n12: The history period, in seconds, or week day, month or year, for example, if history is weekly then this is the day of the week, that is 1 to 7\n13: Synchronisation time of day of the history in seconds, for example, 36000 (that is, 10:00:00)\n14: The time the next history file will be created in seconds",
                "paramname": "nType"
            }
        ],
        "returnType": "The device information as a string if successful, otherwise an empty string is returned.",
        "syntax": "DevInfo(hDev, nType)"
    },
    "devmodify": {
        "doc": "Modifies the attributes of a device. The device needs to be closed before you can modify a device.\nThis function allows you to dynamically change the file name or other attributes of a device at run time. You can use a single device to access many files. For example, you can create a device called Temp with a file name of TEMP.DBF. Using this function you could dynamically change the file name to access any dBASE file.\nThis function is useful in conjunction with the FormOpenFile() or FormSaveAsFile() functions. (These functions allow the operator to select file names easily.)\nWhen using this function, you should be careful that no other Cicode function is already using the same device. Check the return value of this function before opening the device or you will destroy the data in the device to which it is already attached. If the device is already open, calling DevModify will return an error (and raise a hardware alarm to notify user).\nIf DevModify returns error, it means it has not modified the device and thedevice parameters will remain as they were before the call to DevModify.\nUse a semaphore to help protect your Cicode.\n For SQL devices, this function is a blocking Cicode function.",
        "example": "! change the file name of MyDev\nDevModify(\"MyDev\", \"*\", \"*\", \"c:\\data\\newfile.dbf\", -1);\n! change the fields and file name of MyDev\nDevModify(\"MyDev\", \"{time}{date}{tags}\", \"*\",\n\"C:\\DATA\\OLDFILE.DBF\", -1);\n! change the device to TXT file\nDevModify(\"MyDev\", \"*\", \"*\", \"C:\\DATA\\OLDFILE.TXT\", ASCII_DEV);",
        "name": "DevModify",
        "params": [
            {
                "paramdescription": "The name of the device.",
                "paramname": "Name"
            },
            {
                "paramdescription": "A new format for the device or \"*\" to use the existing format.See Format Templates for more information. ",
                "paramname": "Format"
            },
            {
                "paramdescription": "A new header for the device or \"*\" to use the existing header.",
                "paramname": "Header"
            },
            {
                "paramdescription": "A new file name for the device or \"*\" (asterisk) to use theexisting filename.",
                "paramname": "FileName"
            },
            {
                "paramdescription": "A new device type.\nor -1 to use the existing device type.",
                "paramname": "nType"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "DevModify(sName, Format, Header, FileName, nType)"
    },
    "devnext": {
        "doc": "Gets the next record in a device. If the end of the database is reached, the EOF flag is set and an error code is returned.\n For SQL devices, this function is a blocking Cicode function.",
        "example": "Status=0;\nI = 0;\nhDev = DevOpen(\"Log\", 0);\nWHILE Status = 0 DO\n    DspText(20 + I, 0, DevGetField(hDev,\"Tag\"));\n    I = I + 1;\n    Status = DevNext(hDev);\nEND\nDevClose(hDev);",
        "name": "DevNext",
        "params": [
            {
                "paramdescription": "The device handle, returned from the DevOpen() function. The device handle identifies the table where all data on the associated device is stored.",
                "paramname": "hDev"
            }
        ],
        "returnType": "0 if the next record is read, or an error if the end of the database is reached.",
        "syntax": "DevNext(hDev)"
    },
    "devopen": {
        "doc": "Opens a device and returns the device handle. The device needs to be defined in the Plant SCADA database. If the device cannot be opened, and user error checking is not enabled, the current Cicode task is halted.\nYou can use this function to return the handle of a device that is already open. The DevOpen() function does not physically open another device - it returns the same device handle as when the device was opened. The mode of the second open call is ignored. To re-open an open device in a different mode, you need to first close the device and then re-open it in the new mode.\n For SQL devices, this function is a blocking Cicode function. When using an ODBC driver to connect to an SQL server or database, experience has shown that connecting only once on startup and not closing the device yields the best performance. ODBC connection is slow and if used on demand may affect your system's performance. Also, some ODBC drivers may leakmemory on each connection and may cause errors after a number of re-connects.",
        "example": "INT\nFUNCTION\nPrintRecipe(STRING sCategory)\n    STRING sRecipe;\n    INT hRecipe, hPrinter;\n    ErrSet(1); ! enable user error checking\n    hRecipe = DevOpen(\"Recipe\", 0);\n    IF hRecipe = -1 THEN\n        DspError(\"Cannot open recipe\");\n        RETURN FALSE;\n    END\n    hPrinter = DevOpen(\"Printer1\", 0);\n    IF hPrinter = -1 THEN\n        DspError(\"Cannot open printer\");\n        RETURN FALSE;\n    END\n    ErrSet(0); ! disable user error checking\n    WHILE NOT DevEof(hRecipe) DO\n        sRecipe = DevReadLn(hRecipe);\n        DevWriteLn(hPrinter, sRecipe);\n    END\n    DevClose(hRecipe);\n    DevClose(hPrinter);\n    RETURN TRUE;\nEND",
        "name": "DevOpen",
        "params": [
            {
                "paramdescription": "The name of the device.",
                "paramname": "Name"
            },
            {
                "paramdescription": "The mode of the open:\n0 - Open the device in shared mode - the default mode when opening a device if none is specified.\n1 - Open the device in exclusive mode. In this mode only one user can have the device open. The open will return an error if another user has the device open in shared or exclusive mode.\n2 - Open the device in indexed mode. In this mode the device will be accessed in index order. This mode is only valid if the device is a database device and has an index configured in the Header field at the Devices form. Please be aware that specifying mode 2 when opening an ASCII device is ignored internally.\n4 - Open the device in 'SQL not select' mode. If opened in this mode, you need to not attempt to read from an SQL device.\n8 - Open the device in logging mode. In this mode the history files will be created automatically.\n16 - Open the device in read only mode. In this mode data can be viewed, but not written. This mode is supported only by DBF and ASCII files - it is ignored by printers and SQL/ODBC databases.",
                "paramname": "nMode"
            }
        ],
        "returnType": "The device handle. If the device cannot be opened, -1 is returned. The device handle identifies the table where all data on the associated device is stored.",
        "syntax": "DevOpen(sName [, nMode] )"
    },
    "devprev": {
        "doc": "Gets the previous record in a device. If the start of the database is reached, the EOF flag is set and an error code is returned.",
        "example": "Status=0;\nI = 0;\nhDev = DevOpen(\"Log\", 0);\niError = DevSeek(hDev, DevSize(hDev)); ! seek to end \nWHILE iError = 0 DO\n    DspText(20 + I, 0, DevGetField(hDev,\"Tag\"));\n    I = I + 1;\n    iError = DevPrev(hDev);\nEND\nDevClose(hDev);",
        "name": "DevPrev",
        "params": [
            {
                "paramdescription": "The device handle, returned from the DevOpen() function. The device handle identifies the table where all data on the associated device is stored.",
                "paramname": "hDev"
            }
        ],
        "returnType": "0 if the record is read successfully, or an error code if the start of the database is reached.",
        "syntax": "DevPrev(hDev)"
    },
    "devprint": {
        "doc": "Prints free-format data to groups of devices. Using this function, you can write data to many devices at the same time. You would normally use this function in a report.",
        "example": "! Get the report device number or group number (for a group of \ndevices).\nhGrp=DevCurr();\n! Print PV123 to a group of devices.\nDevPrint(hGrp,\"PV123=\"+PV123:###,1);",
        "name": "DevPrint",
        "params": [
            {
                "paramdescription": "The device handle, or the group handle for a group of devices.",
                "paramname": "hGrp"
            },
            {
                "paramdescription": "The data to print to the group of devices.",
                "paramname": "sData"
            },
            {
                "paramdescription": "The newline flag:\n0 - Do not insert a newline character.\n1 - Insert a newline character.",
                "paramname": "NewLine"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "DevPrint(hGrp, sData, NewLine)"
    },
    "devread": {
        "doc": "Reads characters from a device. If the device is record-based, the current field is read. If the device is free-format, the specified number of characters is read. If the number of characters specified is greater than the number of characters remaining in the device, only the remaining characters are read.\nThe DevRead function does not support SQL devices. Use the DevGetField function for these devices.",
        "example": "! Read 20 characters from a device.\nStr=DevRead(hDev,20);",
        "name": "DevRead",
        "params": [
            {
                "paramdescription": "The device handle, returned from the DevOpen() function. The device handle identifies the table where all data on the associated device is stored.",
                "paramname": "hDev"
            },
            {
                "paramdescription": "The number of characters to read.",
                "paramname": "Length"
            }
        ],
        "returnType": "The data (in string format). If the end of the device is found, an empty string is returned.",
        "syntax": "DevRead(hDev, Length)"
    },
    "devreadln": {
        "doc": "Reads data from the current record of a device until the end of the line, or end of the record. If the device is record-based, the record number is incremented. The carriage return and newline characters are not returned.\nThe DevReadLn function does not support SQL devices. Use the DevGetField function for these devices.",
        "example": "Str=DevReadLn(hDev);",
        "name": "DevReadLn",
        "params": [
            {
                "paramdescription": "The device handle, returned from the DevOpen() function. The device handle identifies the table where all data on the associated device is stored.",
                "paramname": "hDev"
            }
        ],
        "returnType": "The data (in string format). If the end of the device is found, an empty string is returned and the EOF flag is set.",
        "syntax": "DevReadLn(hDev)"
    },
    "devrecno": {
        "doc": "Gets the current record number of a device. If the device is record-based, the record number ranges from 1 to the maximum size of the file. If the device is free-format, the record number ranges from 0 to the maximum byte size -1.\nThe DevRcNo function does not support SQL devices. For these devices -1 is returned.",
        "example": "! Get the current record number.\nRec=DevRecNo(hDev);",
        "name": "DevRecNo",
        "params": [
            {
                "paramdescription": "The device handle, returned from the DevOpen() function. The device handle identifies the table where all data on the associated device is stored.",
                "paramname": "hDev"
            }
        ],
        "returnType": "The record number. If an error is detected while getting the record number, -1 is returned.",
        "syntax": "DevRecNo(hDev)"
    },
    "devseek": {
        "doc": "Moves the device pointer to a specified position in the device. If the device is a database, and it is opened in indexed mode, DevSeek will seek to the record number - not through the index. To locate the first record in an indexed device, call the DevFirst() function.",
        "example": "hDev=DevOpen(\"Log\", 0);\nDevSeek(hDev,100);\nDevGetField(hDev,\"Tag\");\n! Gets the value of the \"Tag\" field at record 100.",
        "name": "DevSeek",
        "params": [
            {
                "paramdescription": "The device handle, returned from the DevOpen() function.The device handle identifies the table where all data on theassociated device is stored.",
                "paramname": "hDev"
            },
            {
                "paramdescription": "The offset in the device. If the device is a database device, theoffset is the record number. If the device is a binary device,the offset is in bytes (from 0 to the maximum file size -1).\n0 (zero) if the seek was successful, otherwise an error code is returned.",
                "paramname": "Offset"
            }
        ],
        "returnType": "0 (zero) if the seek was successful, otherwise an error code is returned.",
        "syntax": "DevSeek(hDev, Offset)"
    },
    "devsetfield": {
        "doc": "Sets new field data in the current record in a device.",
        "example": "! Set the fields in the \"Recipe\" device.\nhDev=DevOpen(\"Recipe\", 0);\nDevSeek(hDev, 1);\nDevSetField(hDev,\"Name\", \"WhiteBread\");\nDevSetField(hDev,\"Flour\", IntToStr(iFlour));\nDevSetField(hDev,\"Water\", iWater:####);\nDevSetField(hDev,\"Salt\", iSalt);\nDevClose(hDev);",
        "name": "DevSetField",
        "params": [
            {
                "paramdescription": "The device handle, returned from the DevOpen() function. The device handle identifies the table where all data on the associated device is stored.",
                "paramname": "hDev"
            },
            {
                "paramdescription": "The field name, as a string of up to 10 characters. (The dBASE file format limits all field names to a maximum of 10 characters.)",
                "paramname": "sField"
            },
            {
                "paramdescription": " New field data, in string format. Plant SCADA converts any other data type into a string before setting the data.",
                "paramname": "sData"
            }
        ],
        "returnType": "0 (zero) if the data is successfully set, otherwise an error code is returned.",
        "syntax": "DevSetField(hDev, sField , sData)"
    },
    "devsize": {
        "doc": "Gets the size of a physical device.\nThe DevSize function does not support SQL devices. For these devices -1 will be returned.",
        "example": "INT NoRec;\nNoRec=DevSize(hDev);\n! Seek to the last record.\nDevSeek(hDev,NoRec);",
        "name": "DevSize",
        "params": [
            {
                "paramdescription": "The device handle, returned from the DevOpen() function. The device handle identifies the table where all data on the associated device is stored.",
                "paramname": "hDev"
            }
        ],
        "returnType": "If the device is a database device, the number of records is returned. If the device is a binary device, the number of bytes in the file is returned. If an error is detected, -1 is returned.",
        "syntax": "DevSize(hDev)"
    },
    "devwrite": {
        "doc": "Writes a string to a device. If the device is free-format, the data is written to the device as specified. If the device is record-based, the data is written to the current field, and the field pointer is moved to the next field.\nWriting to a DBF device appends the data to the device.\nWriting to a SQL device appends the data to the device only when all fields of the row have been written.",
        "example": "! Write PV123 to the device.\nDevWrite(hDev,\"PV123=\"+PV123:###.#);",
        "name": "DevWrite",
        "params": [
            {
                "paramdescription": "The device handle, returned from the DevOpen() function. The device handle identifies the table where all data on the associated device is stored.",
                "paramname": "hDev"
            },
            {
                "paramdescription": "The data to write, as a string.",
                "paramname": "sData"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "DevWrite(hDev, sData)"
    },
    "devwriteln": {
        "doc": "Writes a string to a device. If the device is free-format, the data is written to the device, followed by a newline character. If the device is record-based, a new record is appended to the device and the data is written to this record. The record pointer is then moved to the next record.",
        "example": "/* Write PV123 to the device followed by a newline character */\nDevWriteLn(hDev,\"PV123=\"+PV123:###.#);",
        "name": "DevWriteLn",
        "params": [
            {
                "paramdescription": "The device handle, returned from the DevOpen() function. The device handle identifies the table where all data on the associated device is stored.",
                "paramname": "hDev"
            },
            {
                "paramdescription": "The data to write, as a string.",
                "paramname": "sData"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "DevWriteLn(hDev, sData)"
    },
    "devzap": {
        "doc": "Zaps a device. If a database device is zapped, all records are deleted. If an ASCII file is zapped, the file is truncated to 0 (zero) length. Use this function when you want to delete all records in a database or file without deleting the actual file.\n For SQL devices, this function is a blocking Cicode function.",
        "example": "! Delete all records in the alarm log database.\nhDev = DevOpen(\"AlarmLog\", 0);\nDevZap(hDev);",
        "name": "DevZap",
        "params": [
            {
                "paramdescription": "The device handle, returned from the DevOpen() function. The device handle identifies the table where all data on the associated device is stored.",
                "paramname": "hDev"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "DevZap(hDev)"
    },
    "displayruntimemanager": {
        "doc": "This function will start the Plant SCADA Runtime Manager if it is not already running, otherwise it will just bring the Plant SCADA Runtime Manager to the foreground.",
        "example": "No example found",
        "name": "DisplayRuntimeManager",
        "params": [],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "DisplayRuntimeManager()"
    },
    "dllcall": {
        "doc": "Calls a DLL function, and passes a string of arguments to that function. Plant SCADA converts these arguments (where required) into the type specified in the DLLOpen() call. If an argument cannot be converted, it is set to zero (0) or an empty string \"\".\nYou need to first open the DLL with the DLLOpen() function.\nOnly one call to the DLLCall() function can be made at a time, which meansruntime will wait for the called function to return before doing anything else. Ifthe called function takes too long to return, it won't let other tasks execute.Therefore, care needs to be taken so that one call returns before the next is made.\nGood programming practice requires that functions which are not expected tocomplete in a short time are run as separate Windows threads and return a valueimmediately to Plant SCADA.",
        "example": "No example found",
        "name": "DLLCall",
        "params": [
            {
                "paramdescription": "The DLL function handle, returned from DLLOpen().",
                "paramname": "hFunction"
            },
            {
                "paramdescription": "The string of arguments to pass to the DLL function. The argument string contains all the arguments for the function, separated by commas (,). Enclose string arguments in quote marks \"\", and use the string escape character (^) to put a string delimiter within a string. This syntax is the same as the syntax for the TaskNew() function",
                "paramname": "sArgs"
            }
        ],
        "returnType": "The result of the function, as a string.",
        "syntax": "DLLCall(hFunction, sArgs)"
    },
    "dllcallex": {
        "doc": "Calls a DLL function, and passes the specified arguments to that function.\nYou need to first open the DLL with the DLLOpen function.\nOnly one call to the DLLCallEx() function can be made at a time, which meansruntime will wait for the called function to return before doing anything else. Ifthe called function takes too long to return, it won't let other tasks execute.Therefore, care needs to be taken so that one call returns before the next is made.\n Good programming practice requires that functions which are not expected to complete in a short time are run as separate Windows threads and return a value immediately to Plant SCADA.",
        "example": "/* This function is called when \nPlant SCADA\n starts up, \nto initialize all the DLLs that are called */\nINT hAnsiUpper;\nINT hGlobalAlloc;\nFUNCTION InitMyDLLs()\n\t! Open DLL to AnsiUpper\n\thAnsiUpper = DLLOpen(\"USER.DLL\", \"AnsiUpper\", \"CC\");\n\thGlobalAlloc = DLLOpen(\"Kernel\", \"GlobalAlloc\", \"IIJ\");\nEND\n/* This is the Cicode entry point into the DLL function call. This \nfunction hides the DLL interface from the rest of \nPlant SCADA\n. *\nSTRING\nFUNCTION AnsiUpper(STRING sString)\n\tSTRING sResult;\n\tsResult = DLLCallEx(hAnsiUpper, sString);\n\tRETURN sResult;\nEND\n/* Allocate memory and return memory handle */\nINT\nFUNCTION GlobalAlloc(INT Mode, INT Length)\n\tINT hMem;\n\thMem = DLLCallEx(hGlobalAlloc, Mode, Length);\n\tRETURN hMem;\nEND ",
        "name": "DLLCallEx",
        "params": [
            {
                "paramdescription": "The DLL function handle, returned from DLLOpen().",
                "paramname": "hFunction"
            },
            {
                "paramdescription": "A variable length parameter list of method arguments. The parameters will be passed to the function in the order that you enter them. Specifying too few or too many parameters will generate an Invalid Argument hardware error. An Invalid Argument hardware error will also be generated if you specify a parameter to the DLL function with the wrong type.",
                "paramname": "vParameters"
            }
        ],
        "returnType": "The result of the function. If the DLL function returns a string then your Cicode return variable should be of type STRING. All other types will be INT.",
        "syntax": "DLLCallEx(hFunction,vParameters)"
    },
    "dllclasscallmethod": {
        "doc": "Use this function to call a method of a .Net object, passing in the method name and any arguments required for the matching prototype of the method.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.\nVAR DllClassCallMethod(OBJECT object, STRING sMethod, VARARGS args)\nobject: \nsMethod:\nargs\nVar if successful, otherwise an error code is returned.",
        "example": "No example found",
        "name": "DllClassCallMethod",
        "params": [
            {
                "paramdescription": ".Net object.",
                "paramname": "object"
            },
            {
                "paramdescription": "The name of the method",
                "paramname": "sMethod"
            },
            {
                "paramdescription": "Args for functions.",
                "paramname": "args"
            }
        ],
        "returnType": "Var if successful, otherwise an error code is returned.",
        "syntax": "VAR DllClassCallMethod(OBJECT object, STRING sMethod, VARARGS args)"
    },
    "dllclasscreate": {
        "doc": "Use this function to instantiate a new .Net object by specifying the path, class and arguments required for the matching constructor of the class.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "DllClassCreate",
        "params": [
            {
                "paramdescription": "The full path string.",
                "paramname": "sPath"
            },
            {
                "paramdescription": "The class of the object.",
                "paramname": "sClass"
            },
            {
                "paramdescription": "",
                "paramname": "Args"
            },
            {
                "paramdescription": "",
                "paramname": "Args for the constructor."
            }
        ],
        "returnType": ".Net object if successful, otherwise an error code is returned.",
        "syntax": "OBJECT DllClassCreate(STRING sPath, STRING sClass [, vParameters Args])"
    },
    "dllclassdispose": {
        "doc": "Use this function to clean up resources used by the .Net object and any other objects created via the use of the object.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "DllClassDispose",
        "params": [
            {
                "paramdescription": " .Net object.",
                "paramname": "object"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "INT DllClassDispose(OBJECT object)"
    },
    "dllclassgetproperty": {
        "doc": "Use this function to get a property of the .Net object.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "DllClassGetProperty",
        "params": [
            {
                "paramdescription": ".Net object.",
                "paramname": "object"
            },
            {
                "paramdescription": "The property to read. ",
                "paramname": "sProperty"
            }
        ],
        "returnType": "Var if successful, otherwise an error code is returned.",
        "syntax": "VAR DllClassGetProperty(OBJECT object, STRING sProperty)"
    },
    "dllclassisvalid": {
        "doc": "Use this function to validate the handle for the class returned from DllClassCreate.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "DllClassIsValid",
        "params": [
            {
                "paramdescription": "",
                "paramname": "1 if handle is valid or 0"
            }
        ],
        "returnType": "1 if handle is valid or 0",
        "syntax": "INT DllClassIsValid(OBJECT)"
    },
    "dllclasssetproperty": {
        "doc": "Use this function to set a property of the .Net object. The property may be of any type or an object itself.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "DllClassSetProperty",
        "params": [
            {
                "paramdescription": ".Net object.",
                "paramname": "object"
            },
            {
                "paramdescription": "The name of the property of the .Net object.",
                "paramname": "sProperty"
            },
            {
                "paramdescription": "The value to which the property of the .Net object will be set to.",
                "paramname": "Value"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "INT DllClassSetProperty(OBJECT object, STRING sProperty, VARIANT Value)"
    },
    "dllclose": {
        "doc": "Closes the link to a DLL function, and frees the memory allocated for that function link. When the link is closed, you cannot call the function. Plant SCADA automatically closes all function links at shutdown.",
        "example": "No example found",
        "name": "DLLClose",
        "params": [
            {
                "paramdescription": "The DLL function handle, returned from DLLOpen().",
                "paramname": "hFunction"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "DLLClose(hFunction)"
    },
    "dllopen": {
        "doc": "Opens a link to a DLL function, by loading the specified DLL library into memory and attaching it to the named function. After you open the function link, you can call the function with the DLLCall() function. You pass the function number returned from the DLLOpen() function as an argument in the DLLCall() function.\nPlant SCADA only supports DLL functions that accept arguments via stack-based calling conventions. For example, in Win32 only cdecl and stdcall are supported.\nOne accepted method for interfacing with a DLL function is to write a Cicode function file. This file contains the DLLOpen() function to initialize the functions, and one Cicode function for each DLL function, as an interface. In this way, you can hide the DLL interface in this file. Any other Cicode function will call the Cicode interface, and the call to the DLL remains transparent.\nPlease be aware that DLLs need to be on the path. The file extension is not required.",
        "example": "/* This function is called when \nPlant SCADA\n starts up,\nto initialize the DLLs that are called */\nINT hAnsiUpper;\nINT hGlobalAlloc;\nFUNCTION InitMyDLLs()\n\t! Open DLL to AnsiUpper\n\thAnsiUpper = DLLOpen(\"USER.DLL\", \"AnsiUpper\", \"CC\");\n\thGlobalAlloc = DLLOpen(\"Kernel\", \"GlobalAlloc\", \"IIJ\");\nEND\n/* This is the Cicode entry point into the DLL function call. This\nfunction hides the DLL interface from the rest of \nPlant SCADA\n. */\nSTRING\nFUNCTION AnsiUpper(STRING sString)\n\tSTRING sResult;\n\tsResult = DLLCall(hAnsiUpper, \"^\"\" + sString + \"^\"\");\n\tRETURN sResult;\nEND\n/* Allocate memory and return memory handle */\nINT\nFUNCTION GlobalAlloc(INT Mode, INT Length)\n\tSTRING sResult;\n\tINT hMem;\n\tsResult = DLLCall(hGlobalAlloc, Mode : #### + \",\" + Length : ####);\n\thMem = StrToInt(sResult);\n\tRETURN hMem;\nEND",
        "name": "DLLOpen",
        "params": [
            {
                "paramdescription": "The DLL library name.",
                "paramname": "sLib"
            },
            {
                "paramdescription": "The function name. An underscore (_) is required in thefunction name for a 'C' function, but not for a Pascal function.When you call a DLL from a Cicode function, sName needs to bethe same as the name defined in the .DEF file used to link theDLL. The file extension is not required.",
                "paramname": "sName"
            },
            {
                "paramdescription": "The string specifying the function arguments. The firstcharacter in the string is the return value of the function.\nA - Logical.\nB - IEEE 8 byte floating point number.\nC - Null terminated string. Maximum string length 255 characters.\nD - Byte counted string. First byte contains the length of the string, maximum string length 255 characters.\nH - Unsigned 2 byte integer.\nI - Signed 2 byte integer.\nJ - Signed 4 byte integer.",
                "paramname": "sArgs"
            }
        ],
        "returnType": "The DLL function handle, or -1 if the library or function could not be found or loaded.",
        "syntax": "DLLOpen(sLib, sName, sArgs)"
    },
    "driverinfo": {
        "doc": "Provides information about the driver for a specified I/O device. Select the device using the IODevice argument, and the information to be returned using the Type argument.\nThis function can only be used if the I/O Server is on the current machine. When the I/O Server is not in the calling process, this function will become blocking and cannot be called from a foreground task. In this case, the return value will be undefined and a Cicode hardware alarm will be raised.",
        "example": "// Using the IODevice Number\nsName = DriverInfo(20, 0); ! Get the name of the driver used with I/O device 20\nsName = DriverInfo(2, 1); ! Get the title of the driver used with I/O device 2\n// Using the IODevice Name\nsName = DriverInfo(\"IODev\",3);\n! Get the Max Retrys value of the driver used with IODev\nsName = DriverInfo(\"IODev1\",5);\n! Get the Receive Timeout value of the driver used with IODev1",
        "name": "DriverInfo",
        "params": [
            {
                "paramdescription": "The name of the I/O device.",
                "paramname": "IODevice"
            },
            {
                "paramdescription": "The type of information returned about the driver. Specifyone of the following:\n0 - Driver Name\n1 - Driver Title\n2 - Block constant\n3 - Max Retrys\n4 - Transmit Delay\n5 - Receive Timeout\n6 - Polltime\n7 - Watchtime (milliseconds",
                "paramname": "nType"
            },
            {
                "paramdescription": "Specifies the name of the cluster in which the I/O Serverresides. This is optional if you have one cluster or areresolving the I/O server via the current cluster context. Theargument is enclosed in quotation marks \"\".",
                "paramname": "sClusterName"
            },
            {
                "paramdescription": "Specifies the name of the the I/O Server. This parameter is only required if you are running more than one I/O server process from the same cluster on the same computer and need to instruct the system which process to redirect to. The argument is enclosed in quotation marks \"\".",
                "paramname": "ServerName"
            }
        ],
        "returnType": "The driver information as a string. In the case of an       error the return value is an empty string.",
        "syntax": "DriverInfo(IODevice, nType [, sClusterName] [, ServerName]  )"
    },
    "dspancreatecontrolobject": {
        "doc": "Creates a new instance of an ActiveX object. If the object already exists for the given Animation Point Number, then that object will be used, that is a new object will not be created, the existing object will merely be refreshed.\nAN object created using this function remains in existence until the page is closed or the associated Cicode Object is deleted.",
        "example": "No example found",
        "name": "DspAnCreateControlObject",
        "params": [
            {
                "paramdescription": "The animation-point number.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The class of the object. You can use the object's human readable name, its program ID, or its GUID. If the class does not exist, the function will return an error.\nFor example:\n\"Calendar Control 8.0\" - human readable name \n\"MSCAL.Calendar.7\" - Program ID\n\"{8E27C92B-1264-101C-8A2F-040224009C02}\" - GUID",
                "paramname": "sClass"
            },
            {
                "paramdescription": "The width of the ActiveX object.",
                "paramname": "Width"
            },
            {
                "paramdescription": "The height of the ActiveX object.",
                "paramname": "Height"
            },
            {
                "paramdescription": "The string you would like to use as the event class for the object.",
                "paramname": "sEventClass"
            }
        ],
        "returnType": "The newly created object, if successful, otherwise an error is generated.",
        "syntax": "DspAnCreateControlObject(nAN, sClass, Width, Height [, sEventClass] )"
    },
    "dspanfree": {
        "doc": "Frees (removes) an AN from the current page. If an animation exists at the animation number, it is deleted before the AN is freed. Use this function to free existing ANs or ANs created with the DspAnNew() function. Please be aware that the ANs are only freed in memory - the change is not persistent. The next time the pageis opened it will display the AN.\nDspAnFree(nAN)\nnAN:  \n0 (zero) if successful, otherwise an error is returned.",
        "example": "/* Remove AN20 from the current page. */\nDspAnFree(20);",
        "name": "DspAnFree",
        "params": [
            {
                "paramdescription": "The animation-point number.",
                "paramname": "nAN"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "DspAnFree(nAN)"
    },
    "dspangetarea": {
        "doc": "Gets the area configured for an object at a specific AN (animation-point number). The area is returned as an integer.",
        "example": "/* Get the area configured for the object at AN60. /\nDspAnGetArea(60);",
        "name": "DspAnGetArea",
        "params": [
            {
                "paramdescription": "The animation-point number.",
                "paramname": "nAN"
            }
        ],
        "returnType": "The area if successful, otherwise an error is returned. If the object is configured with 'Same area as page' checked, the area of the page will be returned. AN area of 0 (zero) means no areas are configured for the object.",
        "syntax": "DspAnGetArea(nAN)"
    },
    "dspangetmetadata": {
        "doc": "Retrieves the field value of the specified metadata entry.",
        "example": "No example found",
        "name": "DspAnGetMetadata",
        "params": [
            {
                "paramdescription": "An animation number that uniquely identifies an object. This object contains the list of metadata definitions that will be used to perform the association operations. When -2 is specified, it is equivalent to using DspGetAnCur(). (See DspGetAnCur for usage and limitations.) ",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The name of the metadata entry for which to search.\nValue for the specified metadata. Returns empty string if amatching metadata entry is not defined and error code if unsuccessful.",
                "paramname": "sMetaName"
            }
        ],
        "returnType": "Value for the specified metadata. Returns empty string if a\nmatching metadata entry is not defined and error code if unsuccessful.",
        "syntax": "DspAnGetMetadata(nAN, sMetaName)"
    },
    "dspangetmetadataat": {
        "doc": "Retrieves metadata information at the specified index.",
        "example": "No example found",
        "name": "DspAnGetMetadataAt",
        "params": [
            {
                "paramdescription": "An animation number that uniquely identifies an object. This object contains the list of metadata definitions that will be used to perform the association operations. When -2 is specified, it is equivalent to using DspGetAnCur(). (See DspGetAnCur for usage and limitations.) ",
                "paramname": "nAn"
            },
            {
                "paramdescription": "The index of the metadata in the animation point. The index is 0-based; i.e. the first metadata entry has an index of 0, the next 1, and so on.",
                "paramname": "nIndex"
            },
            {
                "paramdescription": "The name of the field from which to retrieve the information for the metadata. Supported fields are:\nName\nValue\nThe field value string. If there is an error, an empty string is returned. The error code can be obtained by calling the IsError Cicode function.",
                "paramname": "sField"
            }
        ],
        "returnType": "The field value string. If there is an error, an empty string is returned. The error code can be obtained by calling the IsError Cicode function.",
        "syntax": "DspAnGetMetadataAt(nAN,nIndex,sField)"
    },
    "dspangetpos": {
        "doc": "Gets the x and y coordinates of an AN, in pixels, relative to the top-left corner of the window.",
        "example": "/* Get the position of AN20 into X and Y. /\nDspAnGetPos(20,X,Y);",
        "name": "DspAnGetPos",
        "params": [
            {
                "paramdescription": "The animation-point number.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "Variables used to store the x and y pixel coordinates ofthe AN, returned from this function.",
                "paramname": "X, Y"
            },
            {
                "paramdescription": "0 – (Default mode) Gets coordinates of an AN on the page. If the AN has not been displayed yet, e.g. default visibility state is hidden, (0, 0) is returned from calling the function.",
                "paramname": "nMode"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned. The X and Y variables are set to the AN's position if successful, or to -1 if an error has been detected.",
        "syntax": "DspAnGetPos(nAN, X, Y [, nMode])"
    },
    "dspangetprivilege": {
        "doc": "Gets the privileges configured for an object at a specific AN (animation-point number). The privilege is returned as an integer.",
        "example": "/* Get the privileges of the object at AN45. /\nDspAnGetPrivilege(45);",
        "name": "DspAnGetPrivilege",
        "params": [
            {
                "paramdescription": "The animation-point number.",
                "paramname": "nAN"
            }
        ],
        "returnType": "The privilege if successful, otherwise an error is returned. A privilege of 0 (zero) means no privileges are configured for the object.",
        "syntax": "DspAnGetPrivilege(nAN)"
    },
    "dspaninfo": {
        "doc": "Gets information on an AN - the type or state of the animation that is currently displayed.",
        "example": "IF DspAnInfo(25,0) = \"1\" THEN\n    /* If color on AN 25, then get the color */\n    col = DspAnInfo(25,1);\nEND",
        "name": "DspAnInfo",
        "params": [
            {
                "paramdescription": "The animation-point number.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The type of information:\n0 - The type of animation currently displayed at the AN. The following is returned:\n0 - No animation is displayed.\n1 - Color is displayed.\n2 - A bar graph is displayed.\n3 - Text is displayed.\n4 - A symbol is displayed.\n5 - AN animation symbol is displayed.\n6 - A trend is displayed.\n7 - A button is displayed.\n8 - A slider is displayed.\n9 - A plot is displayed.\n1 - The state of the animation currently displayed. If color is displayed, thecolor is returned. If a bar graph, trend, or symbol is displayed, the bar,trend, or symbol name is returned. If text is displayed, the font handle isreturned.\n2 - The value of the text or the name of a button at the given AN point isreturned.\n3 - The type of animation currently displayed at the AN for Mode 0 plus the following:\n10 - Rich Edit\n11 - Bitmap\n12 - Straight Line\n13 - Free hand Line\n14 - Rectangle\n15 - Ellipse\n16 - Spark\n17 - Group\n18 - Windows Meta File\n19 - Poly Line\n20 - Dynamic object\n21 - Pipe\n22 - Symbol Set\n23 - OCX\n24 - Basic AN\n25 - Number\n26 - Advanced AN\n27 - Keyboard AN\n28 - Sizemove AN\n29 - Touch AN",
                "paramname": "nType"
            }
        ],
        "returnType": "The animation information, which depends on the type passed argument, as described above, as a string.",
        "syntax": "DspAnInfo(nAN, nType)"
    },
    "dspaninrgn": {
        "doc": "Checks if an AN is within a region bounded by two ANs.\nWill return False if any of the specified ANs are completely clipped. A partially clipped AN is treated as being fully visible.",
        "example": "DspGetMouse(X,Y);\nDspAnMove(250,X,Y);\nIF DspAnInRgn(250,20,30) THEN\n    Prompt(\"Mouse in region bounded by AN20 and AN30\");\nELSE\n    Prompt(\"Mouse not in region\");\nEND",
        "name": "DspAnInRgn",
        "params": [
            {
                "paramdescription": "The animation-point number.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "One - the AN at a corner of the region; two - the AN at the opposite corner of the region.",
                "paramname": "One, Two"
            }
        ],
        "returnType": "1 if the AN is within the region, or 0 (zero) if it is not.",
        "syntax": "pAnInRgn(nAN, One, Two)"
    },
    "dspanmove": {
        "doc": "Moves an AN to a new position. Any animation at this AN is also moved.",
        "example": "DspAnMove(25,100,200);\n! Moves AN25 to pixel location 100,200.",
        "name": "DspAnMove",
        "params": [
            {
                "paramdescription": "The animation-point number.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The x pixel coordinates of the new position.",
                "paramname": "X"
            },
            {
                "paramdescription": "The y pixel coordinates of the new position.",
                "paramname": "Y"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "DspAnMove(nAN, X, Y)"
    },
    "dspanmoverel": {
        "doc": "Moves an AN relative to its current position. Any animation at this AN is also moved.",
        "example": "DspAnMoveRel(25,10,20);\n/* Moves AN25 by 10 pixels to the right and 20 pixels downward, \nrelative to its current position. */",
        "name": "DspAnMoveRel",
        "params": [
            {
                "paramdescription": "The animation-point number.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The number of pixels to move the AN in the x plane.",
                "paramname": "X"
            },
            {
                "paramdescription": "The number of pixels to move the AN in the y plane.",
                "paramname": "Y"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "DspAnMoveRel(nAN, X, Y)"
    },
    "dspannew": {
        "doc": "Creates an AN at the specified x and y coordinates.",
        "example": "AN=DspAnNew(100,200);\nDspSym(AN,20);\n/* Displays symbol 20 at pixel location 100,200 */",
        "name": "DspAnNew",
        "params": [
            {
                "paramdescription": "The x pixel coordinate where the new AN is created.",
                "paramname": "X"
            },
            {
                "paramdescription": "The y pixel coordinate where the new AN is created.",
                "paramname": "Y"
            }
        ],
        "returnType": "If successful, the new AN is returned. If the AN cannot be created, -1 is returned. If an AN already exists at this location, that AN is returned.",
        "syntax": "DspAnNew(X, Y)"
    },
    "dspannewrel": {
        "doc": "Creates an AN at a distance of x,y pixels from a specified AN.",
        "example": "AN=DspAnNewRel(20,100,200);\n/* Creates an AN at 100x and 200y pixels from AN20 */",
        "name": "DspAnNewRel",
        "params": [
            {
                "paramdescription": "The AN used as a reference for the new AN.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The distance in the x plane (in pixels) from the reference AN to the new AN.",
                "paramname": "X"
            },
            {
                "paramdescription": "The distance in the y plane (in pixels) from the reference AN to the new AN.",
                "paramname": "Y"
            }
        ],
        "returnType": "If successful, the new AN is returned. If the AN cannot be created, -1 is returned. If an AN already exists at this location, that AN is returned.",
        "syntax": "DspAnNewRel(nAN, X, Y)"
    },
    "dspansetmetadata": {
        "doc": "Non-blocking function, that sets the value of the specified metadata entry.\nDspAnSetMetadata(nAn, sMetaName, sValue)\nnAn: \nsMetaName: \nsValue: \n0 if successful, error code if unsuccessful",
        "example": "No example found",
        "name": "DspAnSetMetadata",
        "params": [
            {
                "paramdescription": "An animation number that uniquely identifies an object. This object contains the list of metadata definitions that will be used to perform the association operations. When -2 is specified, it is equivalent to using DspGetAnCur(). (See DspGetAnCur for usage and limitations.) ",
                "paramname": "nAn"
            },
            {
                "paramdescription": "The name of metadata entry for which to search.",
                "paramname": "sMetaName"
            },
            {
                "paramdescription": "The value for the metadata to be set.",
                "paramname": "sValue"
            }
        ],
        "returnType": "0 if successful, error code if unsuccessful",
        "syntax": "DspAnSetMetadata(nAn, sMetaName, sValue)"
    },
    "dspansetmetadataat": {
        "doc": "Non-blocking function, that sets the value of a metadata entry.\nDspAnSetMetadataAt(nAN, nIndex, sField, sFieldValue)\nnAn: \nnIndex: \nsField: \nsFieldValue: \n0 if successful, error code if unsuccessful",
        "example": "No example found",
        "name": "DspAnSetMetadataAt",
        "params": [
            {
                "paramdescription": "An animation number that uniquely identifies an object. This object contains the list of metadata definitions that will be used to perform the association operations. When -2 is specified, it is equivalent to using DspGetAnCur(). (See DspGetAnCur for usage and limitations.) ",
                "paramname": "nAn"
            },
            {
                "paramdescription": "The index of the metadata in the animation point.",
                "paramname": "nIndex"
            },
            {
                "paramdescription": "The name of the field in which to set the information for the metadata. Supported fields are:\nName\nValue",
                "paramname": "sField"
            },
            {
                "paramdescription": "The value to set in the specified field of the metadata entry.\n0 if successful, error code if unsuccessful",
                "paramname": "sFieldValue"
            }
        ],
        "returnType": "0 if successful, error code if unsuccessful",
        "syntax": "DspAnSetMetadataAt(nAN, nIndex, sField, sFieldValue)"
    },
    "dspansetname": {
        "doc": "Using a valid AN set the name of an animation object.",
        "example": "No example found",
        "name": "DspAnSetName",
        "params": [
            {
                "paramdescription": "The AN used as a reference for the new Animation Name.",
                "paramname": "hAN"
            },
            {
                "paramdescription": "Animation Name to be set",
                "paramname": "sName"
            }
        ],
        "returnType": "Returns an error if given name is already in use.",
        "syntax": "DspAnSetName(hAN, sName)"
    },
    "dsparraybyan": {
        "doc": "Displays an alarm list associated with a specified AN at the location of that AN. The array associated with the AN contains the alarm data. It is typically used as part of an alarm list or generic list Genie.",
        "example": "DspArrayByAn(hAn);",
        "name": "DspArrayByAn",
        "params": [
            {
                "paramdescription": "The AN associated the array that contains alarm data.",
                "paramname": "nAN"
            }
        ],
        "returnType": "0 (zero). If there is an error, the error code can be obtained by calling the IsError Cicode function.",
        "syntax": "INTDspArrayByAn(INT nAN)"
    },
    "dspbar": {
        "doc": "Displays a bar graph (on a graphics page) at a specified AN. To scale a tag into the correct range, use the EngToGeneric() function.",
        "example": "DspBar(25,\"Bars.Loops\",320);\n/* Displays a value of 320 (that is 10%) on the loops bar (from the \nbars library) at AN25. */\nDspBar(25,3,320);\n/* Displays a value of 320 (that is 10%) on bar definition 3 \n(\nPlant SCADA\n Version 1.xx) at AN25. */\nDspBar(26,\"Loops_Bar\",EngToGeneric(Tag1,0,100));\n/* Displays Tag1 on the loops_bar (from the global library) at \nAN26. Tag1 has an engineering scale of 0 to 100. */",
        "name": "DspBar",
        "params": [
            {
                "paramdescription": "The AN where the bar graph will be displayed.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The name of the bar graph to display in the format <[LibName.]BarName>. If you do not specify the library name, a bar graph from the Global library displays (if it exists). To display a Version 1.xx bar graph, specify the bar definition (1 to 255). For example, if you specify bar 1, Plant SCADA displays the bar graph Global.Bar001.",
                "paramname": "Bar"
            },
            {
                "paramdescription": "The value to display on the bar graph. The value needs to be from 0 to 32000 to give 0 to full-scale range on the bar.",
                "paramname": "Value"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "DspBar(nAN, Bar, Value)"
    },
    "dspbmp": {
        "doc": "Displays a bitmap at a specified AN. This function allows you to display any bitmap file at run time. (You can get a new bitmap file from operator input or from the plant, and display it dynamically.)",
        "example": "No example found",
        "name": "DspBmp",
        "params": [
            {
                "paramdescription": "The animation-point number.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The name of the bitmap (.BMP) file. The file needs to be in the user project path. (Only .bmp files are supported. Other image formats like .png or .jpg are not supported.)",
                "paramname": "sFile"
            },
            {
                "paramdescription": "The mode of bitmap display:\n0 - Erase the existing bitmap and display this bitmap.\n1 - Do not erase the existing bitmap, just draw the new bitmap. (This mode provides smoother animation than Mode 0, but the bitmaps needs to be the same size).\n2 - Do not erase the existing bitmap, just draw the new bitmap. This mode is similar to mode 1, but it displays the bitmap about 3 times faster. However, the bitmap should not contain any transparent color, or it will display as a random color. Use this mode for fast, smooth animation.",
                "paramname": "Mode"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "DspBmp(nAN, sFile, Mode)"
    },
    "dspbutton": {
        "doc": "Displays a button at a specified AN. When the button is selected, the key definition is put into the key command line. The font, width, height, and down and repeat keys of the button are optional. If you do not specify a width and height, the button adjusts to the size of the button sName.",
        "example": "/* Display a self-sizing button at AN20 using the default font. \nThe button is named \"Help\". When selected, the Key Code \"KEY_F1\" \nis put into the key command line. */\nDspButton(20,KEY_F1,\"Help\");\n/* Display the same button at AN20, but in an existing font called \n\"BigFont\". */\nDspButton(20,KEY_F1,\"Help\",DspFontHnd(\"BigFont\");",
        "name": "DspButton",
        "params": [
            {
                "paramdescription": "The animation-point number.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The key generated when the command button is selected (when the mouse button is released after being clicked down). This is the default operation for commands activated by a button.",
                "paramname": "UpKey"
            },
            {
                "paramdescription": "The name to display on the button.",
                "paramname": "Name"
            },
            {
                "paramdescription": "The handle of the font used to display the button name. Use the DspFont() function to create a new font and return the font handle. Use the DspFontHnd() function to return the font handle of an existing font. The Windows button font is used if the font is omitted or is not defined in the database.",
                "paramname": "hFont"
            },
            {
                "paramdescription": "The width of the button in pixels.",
                "paramname": "Width"
            },
            {
                "paramdescription": "The height of the button in pixels.",
                "paramname": "Height"
            },
            {
                "paramdescription": "The key generated when the mouse button is clicked down (over the command button). Normally this parameter is not used, because most buttons are configured to activate a command when the mouse button is released (returning to the `up' position).",
                "paramname": "DownKey"
            },
            {
                "paramdescription": "The key generated repetitively, while the mouse button is being held down (over the command button).",
                "paramname": "RepeatKey"
            },
            {
                "paramdescription": "A number indicating the visibility style of the button:\n0 - NORMAL: The button appears as a standard button.\n1 - BORDER_3D: The button is drawn with only the 3-D border (transparent face).\n2 - BORDER: The button is drawn with only a thin line border.\n3 - TARGET: The button is totally transparent - this constitutes a screen target.\n0 (zero) if successful, otherwise an error is returned.",
                "paramname": "Style"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "DspButton(nAN, UpKey, Name [, hFont] [, Width] [, Height] [, DownKey] [, RepeatKey] [, Style])"
    },
    "dspbuttonfn": {
        "doc": "Displays a button at a specified AN. When the button is selected, a user function is called. If the width and height are 0 (zero), then the button adjusts to the size of the button sName.",
        "example": "DspButtonFn(20,MyFunc,\"Help\",0,50,10);\n! Call this function when the button is selected.\nINT\nFUNCTION\nMyFunc()\n    PageDisplay(\"Help\");\n    RETURN 0;\nEND",
        "name": "DspButtonFn",
        "params": [
            {
                "paramdescription": "The animation-point number.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The user function called when the command button is selected (when the mouse button is released after being clicked down). This is the default operation for commands activated by a button. This callback function can have no arguments, so specify the function with no parentheses (). The callback function needs to return INT as its return data type. You cannot specify a Plant SCADA built-in function for this argument.",
                "paramname": "UpFunction"
            },
            {
                "paramdescription": "The name to display on the button.",
                "paramname": "Name"
            },
            {
                "paramdescription": "The handle of the font used to display the button name. Use the DspFont() function to create a new font and return the font handle. Use the DspFontHnd() function to return the font handle of an existing font. The Windows button font is used if the font is omitted or is not defined in the database.",
                "paramname": "hFont"
            },
            {
                "paramdescription": "The width of the button in pixels.",
                "paramname": "Width"
            },
            {
                "paramdescription": "The height of the buton in pixels.",
                "paramname": "Height"
            },
            {
                "paramdescription": "The user function called when the mouse button is clicked down (over the command button). Normally this parameter is not used, because most buttons are configured to activate when the mouse button is released (returning to the `up' position). The callback function needs to have no arguments, so specify the function with no parentheses (). The callback function needs to return INT as its return data type. You cannot specify a Plant SCADA built-in function for this argument.",
                "paramname": "DownFunction"
            },
            {
                "paramdescription": " The user function called repetitively, while the mouse button is being held down (over the command button) The callback function needs to have no arguments, so specify the function with no parentheses (). The callback function needs to return INT as its return data type. You cannot specify a Plant SCADA built-in function for this argument.",
                "paramname": "RepeatFunction"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "DspButtonFn(nAN, UpFunction, Name [, hFont] [, Width] [, Height] [, DownFunction] [, RepeatFunction] )"
    },
    "dspchart": {
        "doc": "Displays a chart at an AN. Charts are trend lines with markers on them. Values are plotted on the chart pens. You need to specify Value1, but Value2 to Value8 are optional.\nIf more values (than the configured pens) are specified, the additional values are ignored. If fewer values (than the configured pens) are specified, the pens that have no values are not displayed.\nYou should use this function only if you want to control the display of charts directly.\nDspChart(nAN, Chart, Value1 [, Value2 ... Value8] )\nnAN: \nChart: \nValue1: \nValue2 ... 8: \n0 (zero) if successful, otherwise an error is returned.",
        "example": "/* Using chart definition 5 at AN25,     display a value of 10 on \nPen1, 20 on Pen2,     30 on Pen3 and 40 on Pen4 of the chart. */\nDspChart(25,5,10,20,30,40);\n/* Using chart definition 6 at AN26, display a value of 100 on Pen1 \nand 500 on Pen2 of the chart. */\nDspChart(26,6,100,500);",
        "name": "DspChart",
        "params": [
            {
                "paramdescription": "The AN where the chart will be displayed.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The chart to display.",
                "paramname": "Chart"
            },
            {
                "paramdescription": "The value to display on Pen 1 of the chart.",
                "paramname": "Value1"
            },
            {
                "paramdescription": " The values to display on Pen 2...Pen 8 of the chart. These values are optional.",
                "paramname": "Value2 ... 8"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "DspChart(nAN, Chart, Value1 [, Value2 ... Value8] )"
    },
    "dspclearclip": {
        "doc": "Clears the clipping rectangle surrounding the object or group of objects.",
        "example": "DspClearClip(17)\t\t\t\t",
        "name": "DspClearClip",
        "params": [
            {
                "paramdescription": "The animation-point number of the object or groups within the clipping rectangle.",
                "paramname": "nAn"
            }
        ],
        "returnType": "If ANn is invalid will return 0",
        "syntax": "DspClearClip(INT nAN)"
    },
    "dspcol": {
        "doc": "DspCol is deprecated in this version of Plant SCADA.",
        "example": "DspCol(25,RED);\n/* Displays the color red at AN25. */",
        "name": "DspCol",
        "params": [
            {
                "paramdescription": "The animation-point number.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The color to display at the AN.",
                "paramname": "Color"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "DspCol(nAN, Color)"
    },
    "dspdel": {
        "doc": "Deletes all objects from a specified AN.",
        "example": "DspDel(25);\n! Deletes all animation at AN25.",
        "name": "DspDel",
        "params": [
            {
                "paramdescription": "The animation-point number.",
                "paramname": "nAN"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "DspDel(nAN)"
    },
    "dspdelayrenderbegin": {
        "doc": "Delays screen updating until DspDelayRenderEnd is called. This function should be used with DspDelayRenderEnd() to \"sandwich\" Cicode that will modify the appearance of a page. The code should be preceded by DspDelayRenderBegin(), and followed by DspDelayRenderEnd(). This will reduce screen update times, because the modifying code is given time to execute before the page is updated with the changes, and the changes are all made in a single re-draw.\nYou can call this function as many times in a row as you like, as long as each is ended with a call to DspDelayRenderEnd.\nBecause your display will stop updating while the \"sandwiched\" code runs, you should try to make that code as efficient as possible. Do not call Sleep() or any other Cicode functions that will take a long time to run.\nDo not call WinSelect within the \"sandwiched\" code. Do not call this function directly from the Kernel.",
        "example": "/* Begin delay so the following code can be executed before the \nimages are re-drawn. */\nDspDelayRenderBegin(); \nDspBMP(50, \"Image1.bmp\", 0) ! Display the bitmap \"Image1.bmp\" \nat AN 50\nDspBMP(100, \"Image2.bmp\", 0) ! Display the bitmap \"Image2.bmp\" \nat AN 100\nDspBMP(150, \"Image3.bmp\", 0) ! Display the bitmap \"Image3.bmp\" \nat AN 150\nDspBMP(200, \"Image4.bmp\", 0) ! Display the bitmap \"Image4.bmp\" \nat AN 200\nDspBMP(250, \"Image5.bmp\", 0) ! Display the bitmap \"Image5.bmp\" \nat AN 250\n/* End delay so the images can be re-drawn. */\nDspDelayRenderEnd();",
        "name": "DspDelayRenderBegin",
        "params": [],
        "returnType": "",
        "syntax": "DspDelayRenderBegin()"
    },
    "dspdelayrenderend": {
        "doc": "Ends the screen update delay set by DspDelayRenderBegin. This function should be used with DspDelayRenderBegin() to \"sandwich\" Cicode that will modify the appearance of a page. The code should be preceded by DspDelayRenderBegin(), and followed by DspDelayRenderEnd(). This will reduce screen update times, because the modifying code is given time to execute before the page is updated with the changes, and the changes are all made in a single re-draw.\nBecause your display will stop updating while the \"sandwiched\" code runs, you should try to make that code as efficient as possible. Do not call Sleep() or any other Cicode functions that will take a long time to run.\nDo not call WinSelect within the \"sandwiched\" code. Do not call this function directly from the Kernel.",
        "example": "/* Begin delay so the following code can be executed before the \nimages are re-drawn. */\nDspDelayRenderBegin(); \nDspBMP(50, \"Image1.bmp\", 0) ! Display the bitmap \"Image1.bmp\" \nat AN 50\nDspBMP(100, \"Image2.bmp\", 0) ! Display the bitmap \"Image2.bmp\" \nat AN 100\nDspBMP(150, \"Image3.bmp\", 0) ! Display the bitmap \"Image3.bmp\" \nat AN 150\nDspBMP(200, \"Image4.bmp\", 0) ! Display the bitmap \"Image4.bmp\" \nat AN 200\nDspBMP(250, \"Image5.bmp\", 0) ! Display the bitmap \"Image5.bmp\" \nat AN 250\n/* End delay so the images can be re-drawn. */\nDspDelayRenderEnd();",
        "name": "DspDelayRenderEnd",
        "params": [],
        "returnType": "No value is returned.",
        "syntax": "DspDelayRenderEnd()"
    },
    "dspdirty": {
        "doc": "Forces Plant SCADA to update an AN. Normally, Plant SCADA updates the animation on the AN only if the data has changed. This function tells Plant SCADA to update the AN the next time it animates the AN - even if the data has not changed.\nUse this function when you have complex animations that overlap. If two or more animations overlap, you should use the DspDel() or DspDirty() function on their ANs, and then display them in the same order (when they need to be updated).",
        "example": "DspDirty(20);\n! Forces an update of AN20.",
        "name": "DspDirty",
        "params": [
            {
                "paramdescription": "The animation-point number.",
                "paramname": "nAN"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "DspDirty(nAN)"
    },
    "dsperror": {
        "doc": "Displays an error message at the prompt AN on the operator's computer. You can disable the error message display (of this function) by setting the Cicode execution mode in the CodeSetMode() function.",
        "example": "DspError(\"Error found\");\n! Displays \"Error found\" at the prompt AN.",
        "name": "DspError",
        "params": [
            {
                "paramdescription": "The message to be displayed.",
                "paramname": "String"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "DspError(String)"
    },
    "dspfile": {
        "doc": "Defines the screen attributes for displaying a text file. This function defines a \"window\" where the file will be displayed. You should call this function before any file-to-screen function.\nyou need to define sequential ANs for each line of text in the display. The file is displayed starting at the specified AN, then the next (highest) AN, and so on. You should not use proportionally-spaced fonts, because the columns of text might not be aligned.\nYou would normally call this function as the entry function for a graphics page. Use the DspFileSetName() function to specify the file to be displayed. This function is a low level animation function - it controls exactly how the file is to display. If you just want to display a file, use the PageFile() function.",
        "example": "DspFile(20,0,20,80);\n/* Defines the attributes of a screen display to start at AN20,\nusing the default font, with a window size of 20 lines x 80\ncolumns. */",
        "name": "DspFile",
        "params": [
            {
                "paramdescription": " The AN where the file display window will be positioned.When this is set to -2, the window will be created in theRuntime Kernel. However, the hFont argument is ignored.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The handle for the font that is used to display the file,returned from the DspFont() or DspFontHnd() function. Thefont handle identifies the table where data on theassociated font is stored.",
                "paramname": "hFont"
            },
            {
                "paramdescription": "The maximum number of lines to display on one page of thefile display window.",
                "paramname": "Height"
            },
            {
                "paramdescription": "The width of the file display window, in characters.",
                "paramname": "Width"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "DspFile(nAN, hFont, Height, Width)"
    },
    "dspfilegetinfo": {
        "doc": "Gets the attributes of a file-to-screen display (used for displaying text files).",
        "example": "! Display the page number of the file display.\nPageNumber=IntToStr(DspFileGetInfo(20,2)/DspFileGetInfo(20,1)+1);\nDspText(12,0,\"Page No \"+PageNumber);",
        "name": "DspFileGetInfo",
        "params": [
            {
                "paramdescription": "The AN where the file display window will be located. This AN needs to be the same as the AN specified with the DspFile() function.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The type of data required:\n0 - The width of the file display window, in characters.\n1 - The maximum number of lines that can display in one page of the file display window.\n2 - The file-to-screen row offset number.\n3 - The file-to-screen column offset number.\n4 - The number of lines in the displayed file.",
                "paramname": "nType"
            }
        ],
        "returnType": "The attributes of the \"window\" as an integer. If an incorrect AN is specified, an error is returned.",
        "syntax": "DspFileGetInfo(nAN, Type)"
    },
    "dspfilegetname": {
        "doc": "Gets the name of the file being displayed in the display \"window\". You can use this function to display the file name on the screen.",
        "example": "DspText(11,0,DspFileGetName(20));\n! Displays the name of the file displayed at AN20.",
        "name": "DspFileGetName",
        "params": [
            {
                "paramdescription": "The animation-point number.",
                "paramname": "nAN"
            }
        ],
        "returnType": "The name of the file (as a string). If an incorrect AN is specified, an error is returned.",
        "syntax": "DspFileGetName(nAN)"
    },
    "dspfilescroll": {
        "doc": "Scrolls a file (displayed in the display \"window\") by a number of characters.",
        "example": "No example found",
        "name": "DspFileScroll",
        "params": [
            {
                "paramdescription": "The animation-point number.",
                "paramname": "nAN"
            },
            {
                "paramdescription": " The direction in which to scroll:\n1 - Left\n2 - Right\n3 - Up\n4 - Down",
                "paramname": "Direction"
            },
            {
                "paramdescription": "The number of characters to scroll. To page up or page down through the file, scroll by the height of the file-to-screen window (returned by DspFileGetInfo(AN, 1)).",
                "paramname": "Characters"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "DspFileScroll(nAN, Direction, Characters)"
    },
    "dspfilesetname": {
        "doc": "Sets the name of the file to display in the display \"window\". You should call the DspFile() function first (as the entry function for a graphics page) to define the attributes of the display. You can then use the DspFileSetName() function (as a keyboard command) to display a user-specified file. When you call this function, the specified file name is read from disk and displayed on the screen.",
        "example": "DspFile(20,0,20,80);\n/* Defines the file-to-screen display to commence at AN20 using \nthe default font, with a window size of 20 lines x 80 columns. */\nDspFileSetName(20,\"C:\\AUTOEXEC.BAT\");\n! Displays file C:\\AUTOEXEC.BAT.",
        "name": "DspFileSetName",
        "params": [
            {
                "paramdescription": "The animation-point number.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The name of the file to display.",
                "paramname": "sName"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "DspFileSetName(nAN, sName)"
    },
    "dspfont": {
        "doc": "Creates a font and returns a font handle. If the requested font already exists, its font handle is returned. You can use this font handle in the functions that display text, buttons, and text files.\nIf the exact font size does not exist, the closest font size is used.",
        "example": "Font = DspFont(\"Helv\", -12, White, Red);\nDspText(20, Font, \"Text in Helv Font\");\n/* Displays \"Text in Helv Font\" in 12-point Helvetica font in\nwhite on red at AN20. */\nFont = DspFont(\"Helv\", 24, White, Red, Black);\nDspText(20, Font, \"Text in Helv Font\");\n/* Displays \"Text in Helv Font\" in 24 pixel Helvetica font in\nflashing black and white on red at AN20. */",
        "name": "DspFont",
        "params": [
            {
                "paramdescription": "The font type, for example, \"Helv\".",
                "paramname": "FontType"
            },
            {
                "paramdescription": "The font size, as a positive number for pixels, or a negativenumber for points.",
                "paramname": "PixelSize"
            },
            {
                "paramdescription": "The foreground color used for the text. If implementingflashing color, this is the initial color that will be used. Selecta color from the list of Predefined Color Names and Codes orcreate an RGB-based color using the functionMakeColour.",
                "paramname": "ForeOnColor"
            },
            {
                "paramdescription": "The color used for the background of text. If implementingflashing color, this is the initial color that will be used. Selecta color from the list of Predefined Color Names and Codes orcreate an RGB-based color using the functionMakeColour.",
                "paramname": "BackOnColor"
            },
            {
                "paramdescription": "An optional argument only required if implementingflashing color for the font foreground. It represents thesecondary color used. Select a color from the list ofPredefined Color Names and Codes or create an RGB-basedcolor using the function MakeColour.",
                "paramname": "ForeOffColor"
            },
            {
                "paramdescription": "An optional argument only required if implementingflashing color for the font background. It represents thesecondary color used. Select a color from the list ofPredefined Color Names and Codes or create an RGB-basedcolor using the function MakeColour.",
                "paramname": "BackOffColor"
            }
        ],
        "returnType": "The font handle as an integer. If the font cannot be created, -1 is returned. The font handle identifies the table where all data on the associated font is stored.",
        "syntax": "DspFont(FontType, PixelSize, ForeOnColor, BackOnColor [, ForeOffColor] [, BackOffColor] )"
    },
    "dspfonthnd": {
        "doc": "Gets the font handle of a font that is defined in the Fonts database. You can use this font handle in the functions that display text, buttons, and text files.",
        "example": "hBigFont=DspFontHnd(\"BigFont\");\nDspText(20,hBigFont,\"Text in Big Font\");\n/* Displays \"Text in Big Font\" in 24-point Helvetica font in blue\non an unchanged background at AN20. */",
        "name": "DspFontHnd",
        "params": [
            {
                "paramdescription": "The font name in the fonts database.",
                "paramname": "Name"
            }
        ],
        "returnType": "The font handle as an integer. If the font cannot be found, -1 is returned. The font handle identifies the table where the data on the associated font is stored.",
        "syntax": "DspFontHnd(sName)"
    },
    "dspfullscreen": {
        "doc": "Disables or enables the fullscreen mode of the currently active window. This function does not resize the window when it is called; it merely sets the mode flag. The next time the window is displayed, its size (on screen) changes to reflect the setting of the flag. This function overrides the [Animator]FullScreen parameter setting.\nIf [Page]DynamicSizing is turned on, a page in fullscreen state takes up the entire display area (assuming this does not affect its aspect ratio), and it cannot be resized. Also, a fullscreen page will display without a title bar unless Title Bar is checked in Page Properties (or was checked when the page was created). Resizing pages can result in lower picture quality. If this is unacceptable, you should re-design the page using the desired resolution.\nIf [Page]DynamicSizing is turned off, fullscreen will have the same limitations as it had in versions of Plant SCADA prior to V5.10. In other words, for a page to be displayed in fullscreen, the size of the page needs to be the same size as the display (or bigger). If the page is smaller than the display, the title bar will still display even if fullscreen mode is enabled. Check the size of the graphic pages in CtDraw Tools|Page Attributes Dialog to verify that it is the same as the display resolution. For example 640x480 for VGA, 800x600 for SVGA and 1024x768 for XGA.",
        "example": "/*Minimize the Window, Enable fullscreen mode and then maximize\nthe window.*/\nWinMode(6);\nDspFullScreen(1);\nWinMode(3);",
        "name": "DspFullScreen",
        "params": [
            {
                "paramdescription": "Fullscreen mode:\n0 - Disable fullscreen mode.\n1 - Enable fullscreen mode without title bar\n2 – Enable fullscreen mode with title bar.",
                "paramname": "Mode"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "DspFullScreen(Mode)"
    },
    "dspgetanbottom": {
        "doc": "Gets the bottom extent of the object at the specified AN.",
        "example": "nBottom = DspGetAnBottom(30);",
        "name": "DspGetAnBottom",
        "params": [
            {
                "paramdescription": "The animation-point number.",
                "paramname": "nAN"
            }
        ],
        "returnType": "The y coordinate of the bottom extent of the object at the AN. If no object exists at the AN, -1 is returned.",
        "syntax": "DspGetAnBottom(nAN)"
    },
    "dspgetancur": {
        "doc": "Gets the AN of the current graphics object. This function should only be used by expressions or Cicode functions called from the condition fields of a graphics object, excluding input/command fields. If you need to know the AN that triggered the input/command, the KeyGetCursor function may be used as it returns the AN where the cursor is currently positioned.\nYou cannot call this function from the Button or Keyboard forms.",
        "example": "/* Function displays a number at the current AN and returns the\nvalue supplied in the call */\nINT\nFUNCTION\nMyFunc(INT value)\n    INT AN, hNew;\n    AN = DspGetAnCur();\n    hNew = DspAnNewRel(AN, 0, 20);\n    DspStr(hNew, \"Default\", VALUE:###.#);\n    RETURN value;\nEND",
        "name": "DspGetAnCur",
        "params": [],
        "returnType": "The AN associated with the current graphics object. If this function is called outside the page animation system or from an input/command field, -1 will be returned.",
        "syntax": "DspGetAnCur()"
    },
    "dspgetanextent": {
        "doc": "Gets the extent (the page co-ordinates) of the object  at the specified AN.",
        "example": "// Get extents at AN 25.\nDspGetAnExtent(25, Top, Left, Bottom, Right);",
        "name": "DspGetAnExtent",
        "params": [
            {
                "paramdescription": "The AN at which the object is positioned.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "A buffer that contains the top-most extent of the object.",
                "paramname": "Top"
            },
            {
                "paramdescription": "A buffer that contains the left-most extent of the object.",
                "paramname": "Left"
            },
            {
                "paramdescription": "A buffer that contains the bottom-most extent of the object.",
                "paramname": "Bottom"
            },
            {
                "paramdescription": "A buffer that contains the right-most extent of the object.",
                "paramname": "Right"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned. The Top, Left, Bottom, and Right arguments contain the extents of the object, in pixels.",
        "syntax": "DspGetAnExtent(nAN, Top, Left, Bottom, Right)"
    },
    "dspgetanfirst": {
        "doc": "Gets the first AN on the current page, based on the order in which the ANs were stored by Graphics Builder.",
        "example": "No example found",
        "name": "DspGetAnFirst",
        "params": [],
        "returnType": "The value for the first AN, otherwise an error is returned.",
        "syntax": "DspGetAnFirst()"
    },
    "dspgetanfromname": {
        "doc": "Name used to retrieve the AN of an object on the page. Use the following relative path syntax:\n[RelativePath].[Group].[Group].Control\nThis will browse the group hierarchy to a specific starting point, and then drill down to other groups to find the named control or object. \nIf you do not use a relative path the system will first look for an object within the groups specified relative to the object the cicode is running on, and if the name is not found, it will then search the page for the first existence of the object name. See Referencing an object using a name at runtime  for more information.\nDspGetAnFromName(sName)\nsName\nAN of object or -1 if not found.",
        "example": "// Example of relative pathing syntax\n// Reference from a current group, symbol or genie\nDspGetAnFromName(\".\\Object1\")\n// Navigate three levels up and from the root level search for Object1.\nDspGetAnFromName(\"..\\..\\..\\Object1\")\n\t\t\t\t",
        "name": "DspGetAnFromName",
        "params": [
            {
                "paramdescription": "The Name of the object used as a reference for the AN. ",
                "paramname": "sName"
            }
        ],
        "returnType": "AN of object or -1 if not found.",
        "syntax": "DspGetAnFromName(sName)"
    },
    "dspgetanfromnamerelative": {
        "doc": "Name used to retrieve the animation number (AN) of an object on the page relative to a given Animation Number(AN). Use the following syntax:\n[RelativePath].[Group].[Group].Control\nThis will browse the group hierarchy to a specific starting point, and then drill down to other groups to find the named control or object. \n See Referencing an object using a name at runtime  more information on the relative path syntax.\nDspGetAnFromNameRelative(hAN, sName)\nhAN\nsName\nAN of object or -1 if not found.",
        "example": "// example of relative pathing syntax\nDspGetAnFromNameRelative(625, \"..\\..\\..\\Object1\")\n//Using another AN as browse starting point\nDspGetAnFromNameRelative(639, \"..\\..\\Object1\")",
        "name": "DspGetAnFromNameRelative",
        "params": [
            {
                "paramdescription": "AN used as the starting point for the search. ",
                "paramname": "hAN"
            },
            {
                "paramdescription": "The Name used as a reference for the AN. ",
                "paramname": "sName"
            }
        ],
        "returnType": "AN of object or -1 if not found.",
        "syntax": "DspGetAnFromNameRelative(hAN, sName)"
    },
    "dspgetanfrompoint": {
        "doc": "Gets the AN of the object at a specified set of screen coordinates. If the X and Y coordinates given are within the extents of an object, then the AN number of the object will be returned.\nFor example, if there is a button at coordinates (300, 140), and it is 100 wide, 50 high, this function would return the AN if it uses X between 300 & 400 and Y between 140 and 190, such as DspGetAnFromPoint(325,180).\nDspGetAnFromPoint(X, Y [, PrevAN] )\nX: \nY: \nPrevnAN: \nThe AN or 0 (zero) if no object exists at the point.\nFor clipped objects the AN will not be returned  if the mouse is over the clipped region.",
        "example": "DspGetMouse(X,Y);\n// GetMouse position\nAN = DspGetAnFromPoint(X,Y);\n// Gets AN if mouse is over the object\nPrompt(\"AN of object =\"+nAN:###);\n!Displays the object's AN at the prompt line\n\nINT nAn;\nnAn = DspGetAnFromPoint(100,100)\nWHILE nAn <> 0 DO\n    //Do Something\n    nAn = DspGetAnFromPoint(100,100,nAn);\nEND",
        "name": "DspGetAnFromPoint",
        "params": [
            {
                "paramdescription": "The x coordinate of the screen point.",
                "paramname": "X"
            },
            {
                "paramdescription": "The y coordinate of the screen point.",
                "paramname": "Y"
            },
            {
                "paramdescription": "Retrieves the previous AN (in z-order) in situations where a number of objects overlap at the specified point. The default of 0 (zero) specifies no previous AN. A non-zero value should only ever be passed if it is the result of a previous call to DspGetAnFromPoint.",
                "paramname": "PrevnAN"
            }
        ],
        "returnType": "The AN or 0 (zero) if no object exists at the point.",
        "syntax": "DspGetAnFromPoint(X, Y [, PrevAN] )"
    },
    "dspgetanheight": {
        "doc": "Gets the height of the object at a specified AN.",
        "example": "nHeight = DspGetAnHeight(30);",
        "name": "DspGetAnHeight",
        "params": [
            {
                "paramdescription": "The animation-point number.",
                "paramname": "nAN"
            }
        ],
        "returnType": "The height of the object (in pixels). If no object exists at the AN, -1 is returned.",
        "syntax": "DspGetAnHeight(nAN)"
    },
    "dspgetanleft": {
        "doc": "Gets the left extent of the object at the specified AN.",
        "example": "nLeft = DspGetAnLeft(30);",
        "name": "DspGetAnLeft",
        "params": [
            {
                "paramdescription": "The animation-point number.",
                "paramname": "nAN"
            }
        ],
        "returnType": "The x coordinate of the left extent of the object at the AN. If no object exists at the AN, -1 is returned.",
        "syntax": "DspGetAnLeft(nAN)"
    },
    "dspgetannext": {
        "doc": "Returns the AN that follows the specified AN, based on the order in which the ANs were stored on a page by Graphics Builder.",
        "example": "No example found",
        "name": "DspGetAnNext",
        "params": [
            {
                "paramdescription": "The animation-point number.",
                "paramname": "nAN"
            }
        ],
        "returnType": "The value for the next AN. If -1 is returned, it means the specified AN is invalid or it is the last AN on the page.",
        "syntax": "DspGetAnNext(nAN)"
    },
    "dspgetanrawextent": {
        "doc": "Gets the extent of the object  from the graphics page at the specified AN. The extent represents the page co-ordinates at which the object was originally inserted.\nDspGetAnRawExtent(nAN, Top, Left, Bottom, Right)\nnAN: \nTop: \nLeft: \nBottom: \nRight: \n0 (zero) if successful, otherwise an error is returned. The Top, Left, Bottom, and Right arguments contain the extents of the object, in pixels.",
        "example": "No example found",
        "name": "DspGetAnRawExtent",
        "params": [
            {
                "paramdescription": "The AN at which the object is positioned.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "A buffer that contains the top-most extent of the object.",
                "paramname": "Top"
            },
            {
                "paramdescription": "A buffer that contains the left-most extent of the object.",
                "paramname": "Left"
            },
            {
                "paramdescription": "A buffer that contains the bottom-most extent of the object.",
                "paramname": "Bottom"
            },
            {
                "paramdescription": "A buffer that contains the right-most extent of the object.",
                "paramname": "Right"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned. The Top, Left, Bottom, and Right arguments contain the extents of the object, in pixels.",
        "syntax": "DspGetAnRawExtent(nAN, Top, Left, Bottom, Right)"
    },
    "dspgetanright": {
        "doc": "Gets the right extent of the object at the specified AN.",
        "example": "nRight = DspGetAnRight(30);",
        "name": "DspGetAnRight",
        "params": [
            {
                "paramdescription": "The animation-point number.",
                "paramname": "nAN"
            }
        ],
        "returnType": "The x coordinate of the right extent of the object at the AN. If no object exists at the AN, -1 is returned.",
        "syntax": "DspGetAnRight(nAN)"
    },
    "dspgetantop": {
        "doc": "Gets the top extent of the object at the specified AN.",
        "example": "nTop = DspGetAnTop(30);",
        "name": "DspGetAnTop",
        "params": [
            {
                "paramdescription": "The animation-point number.",
                "paramname": "nAN"
            }
        ],
        "returnType": "The y coordinate of the top extent of the object at the AN. If no object exists at the AN, -1 is returned.",
        "syntax": "DspGetAnTop(nAN)"
    },
    "dspgetanwidth": {
        "doc": "Gets the width of the object at a specified AN.",
        "example": "nWidth = DspGetAnWidth(30);",
        "name": "DspGetAnWidth",
        "params": [
            {
                "paramdescription": "The animation-point number.",
                "paramname": "nAN"
            }
        ],
        "returnType": "The width of the object (in pixels). If no object exists at the AN, -1 is returned.",
        "syntax": "DspGetAnWidth(nAN)"
    },
    "dspgetenv": {
        "doc": "Gets a page environment variable.",
        "example": "FUNCTION\nPageGroup()\n    PageDisplay(DspGetEnv(\"GroupMenu\"));\nEND",
        "name": "DspGetEnv",
        "params": [
            {
                "paramdescription": "The name of the variable (set using the page environment dialog). \nThe value of the variable (as a string).",
                "paramname": "sName"
            }
        ],
        "returnType": "The value of the variable (as a string).",
        "syntax": "DspGetEnv(sName)"
    },
    "dspgetmetadatafromname": {
        "doc": "Name used to retrieve the metadata of an object on the page. Use the following relative path syntax:\n[RelativePath].[Group].[Group].Control\nThis will browse the group hierarchy to a specific starting point, and then drill down to other groups to find the named control or object and metadata.   See Referencing an object using a name at runtime  for more information.",
        "example": "// example of relative pathing syntax\n// Relative pathing varies according to the starting point of the search\nDspGetMetadataFromName(\"Object1\", \"Pump\")\nDspGetMetadataFromName(\".\\Object1\", \"Pump\")\nDspGetMetadataFromName(\"..\\..\\..\\Object1\", \"Pump\")",
        "name": "DspGetMetadataFromName",
        "params": [
            {
                "paramdescription": "The Name used as a reference for the object. ",
                "paramname": "sName"
            },
            {
                "paramdescription": "The name of the metadata to be returned.\nThe name belonging to the metadata name/value pair defined in the object's properties metadata tab. See the topic Metadata in the main help for more information.",
                "paramname": "sMetaName"
            }
        ],
        "returnType": "The value of the metadata or blank.",
        "syntax": "DspGetMetadataFromName(sName, sMetaName)"
    },
    "dspgetmetadatafromnamerelative": {
        "doc": "Name used to retrieve the metadata of an object on the page relative to a given Animation Number (AN). Use the following  syntax:\n[RelativePath].[Group].[Group].Control\nThis will browse the group hierarchy from the given AN, and then drill down to other groups to find the named control or object. See Referencing an object using a name at runtime  for more information.",
        "example": "// example of relative pathing syntax\nDspGetMetadataFromNameRelative(639, \"..\\..\\Object1\", \"Pump\")\n//Using another AN as browse starting point\nDspGetMetadataFromNameRelative(625, \"..\\..\\..\\Object1\", \"Pump\")",
        "name": "DspGetMetadataFromNameRelative",
        "params": [
            {
                "paramdescription": "AN used as the starting point for the search.",
                "paramname": "hAN"
            },
            {
                "paramdescription": "The name of the AN used as a reference for the object.",
                "paramname": "sName"
            },
            {
                "paramdescription": "The name of the metadata to be returned. \nThe name belonging to the metadata name/value pair defined in the object's properties metadata tab. See the topic Metadata in the main help for more information.",
                "paramname": "sMetaName"
            }
        ],
        "returnType": "The value of the metadata or blank.",
        "syntax": "DspGetMetadataFromNameRelative(hAN, sName, sMetaName)"
    },
    "dspgetmouse": {
        "doc": "Gets the x and y coordinates of the mouse position, relative to the top left corner of the window.",
        "example": "! If the mouse cursor is at x,y pixel coordinate 43,20;\nDspGetMouse(X,Y);\n! Sets X to 43 and Y to 20.",
        "name": "DspGetMouse",
        "params": [
            {
                "paramdescription": "A locally declared variable used to store the x pixel coordinate of themouse position, returned from this function.",
                "paramname": "X"
            },
            {
                "paramdescription": "A locally declared variable used to store the y pixel coordinate of themouse position, returned from this function.\n0 (zero) if successful, otherwise an error is returned. The X and Y variables are set to the mouse position.",
                "paramname": "Y"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned. The X and Y variables are set to the mouse position.",
        "syntax": "DspGetMouse(X, Y)"
    },
    "dspgetmouseover": {
        "doc": "Determines if the mouse is within the boundaries of a given AN.",
        "example": "No example found",
        "name": "DspGetMouseOver",
        "params": [
            {
                "paramdescription": "The AN of the animation you wish to check, or -1 for the current AN. Defaults to -1.",
                "paramname": "nAN"
            }
        ],
        "returnType": "1 if within the specified AN, 0 if not.",
        "syntax": "DspGetMouseOver(nAN)"
    },
    "dspgetnamefroman": {
        "doc": "Using a valid animation number (AN) the animation name of the object is returned.",
        "example": "No example found",
        "name": "DspGetNameFromAn",
        "params": [
            {
                "paramdescription": "The AN used as a reference for the name of the object.",
                "paramname": "hAN"
            }
        ],
        "returnType": "The animation name of the object, or blank",
        "syntax": "DspGetNameFromAn(hAN)"
    },
    "dspgetnearestan": {
        "doc": "Gets the AN nearest to a specified x,y pixel location.\nIf using groups and the nearest object to the specified coordinates is part of a group, the AN of the object is returned, not the AN of the group.\nIf using clipping objects completely clipped ANs will be ignored when determining the nearest AN to the specified x, y pixel location. Partially clipped ANs are treated as being fully visible.",
        "example": "DspGetMouse(X,Y);\n! Gets mouse position.\nAN=DspGetNearestAn(X,Y);\n! Gets AN nearest to the mouse.\nPrompt(\"Mouse At AN\"+nAN:###);\n! Displays AN nearest to the mouse.",
        "name": "DspGetNearestAn",
        "params": [
            {
                "paramdescription": "The x coordinate (in pixels).",
                "paramname": "X"
            },
            {
                "paramdescription": "The y coordinate (in pixels).",
                "paramname": "Y"
            }
        ],
        "returnType": "The animation point number (AN). A value of -1 is returned if no AN is found.",
        "syntax": "DspGetNearestAn(X, Y)"
    },
    "dspgetparentan": {
        "doc": "Gets the parent animation number (if any), for the specified animation number. AN animation point will have a parent animation point if it corresponds to an object in a group.",
        "example": "// Get the parent animation for object 89 (part of a symbol set)\nAN = DspGetParentAn(89);",
        "name": "DspGetParentAn",
        "params": [
            {
                "paramdescription": "The animation-point number.",
                "paramname": "AN"
            }
        ],
        "returnType": "The parent animation point number (AN). If no parent animation exists or an invalid animation number is passed, 0 (zero) is returned.",
        "syntax": "DspGetParentAn(nAN)"
    },
    "dspgetslider": {
        "doc": "Gets the current position (value) of a slider at an AN. You can call this function in the slider event to find the new position of the slider.",
        "example": "// Get the position of the slider at AN 30\nnPos = DspGetSlider(30);",
        "name": "DspGetSlider",
        "params": [
            {
                "paramdescription": "The animation-point number.",
                "paramname": "nAN"
            }
        ],
        "returnType": "The value of the slider from 0 to 32000. If no animation exists at the AN, -1 is returned.",
        "syntax": "DspGetSlider(nAN)"
    },
    "dspgettip": {
        "doc": "Gets the tool tip text associated with an AN.",
        "example": "!Display the tool tip text on AN19\nDspText(19, 0, DspGetTip(KeyGetCursor(), 1));",
        "name": "DspGetTip",
        "params": [
            {
                "paramdescription": "The AN from which to get the tool tip text. If no object is configured at the AN, the function will return an empty string.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "0 - Tool tips from all animation records configured at the AN. Tips are concatenated with a newline character between each string. (This mode is only used for V3.xx and V4.xx animations, and has been subsequently superseded.)\n1 - The tool tip from the object configured at the AN.",
                "paramname": "Mode"
            }
        ],
        "returnType": "The tool tip text (as a string). If no user tip is available, an empty string is returned.",
        "syntax": "DspGetTip(nAN, Mode)"
    },
    "dspgraybutton": {
        "doc": "Grays and disables a button. If the button is a symbol, the symbol is overwritten with a gray mask. (When a button is grayed, it cannot be selected.) If the Disabled field in the Buttons database is blank, the button is enabled unless you use this function. If the Disabled field in the Buttons database contains an expression, this function will not override the expression.",
        "example": "! Disable button at AN21\nDspGrayButton(21, GRAY_SUNK);",
        "name": "DspGrayButton",
        "params": [
            {
                "paramdescription": "The AN where the button is located.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The mode of the operation:\n0 - Ungray the button.\n1 - (GRAY_SUNK) Recess the text or symbol (the text or symbol on the button is recessed and shadowed).\n2 - (GRAY_PART) This mode is now obsolete - it now has the same effect as GRAY_ALL.\n3 - (GRAY_ALL) - Mask the entire button (a gray mask displays over the face of the button).",
                "paramname": "nMode"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise, -1 (if no AN is found).",
        "syntax": "DspGrayButton(nAN, nMode)"
    },
    "dspinfo": {
        "doc": "Extracts individual pieces of object information from an AN. Each AN can have multiple expressions associated with it, and each expression can have multiple variables associated with it. You use an index to refer to each individual expressions or variables. Typically, you would query the number of expressions, then the number of variables in a given expression, then the details of a given variable tag.",
        "example": "INT hInfo;\nINT iEngineeringValue;\nINT iNumberOfExpressions;\nINT iNumberOfTags;\nINT iExpressionIndex;\nINT iTagIndex;\nSTRING sObjectType;\nSTRING sExpressionText;\nSTRING sExpressionResult;\nSTRING sExpressionContext;\nSTRING sTagName;\nhInfo  = DspInfoNew(AN);\nIF (hInfo > -1) THEN\n    sObjectType = DspInfo(hInfo, 0, 0);\n    iNumberOfExpressions = StrToInt(DspInfo(hInfo, 7, 0));\n    FOR iExpressionIndex = 0 TO iExpressionIndex < iNumberOfExpressions DO\n        sExpressionText = DspInfo(hInfo, 1, iExpressionIndex);\n        sExpressionResult = DspInfo(hInfo, 2, iExpressionIndex);\n        sExpressionContext = DspInfo(hInfo, 6, iExpressionIndex);\n        iNumberOfTags = StrToInt(DspInfo(hInfo, 8, iExpressionIndex));\n        FOR iTagIndex = 0 TO iTagIndex < iNumberOfTags DO\n            sTagName = DspInfo(hInfo, 3, iTagIndex);\n            iEngineeringValue = StrToInt(DspInfo(hInfo, 5, iTagIndex));\n            ..\n        END\n        ..\n    END\nEND",
        "name": "DspInfo",
        "params": [
            {
                "paramdescription": "The object information block handle, as returned by DspInfoNew(). This handle identifies the table (or block) where all object data is stored.",
                "paramname": "hInfo"
            },
            {
                "paramdescription": "The type of data to extract:\n0 - Object title (the name of the object type)\n1 - Object expression text\n2 - Object expression result text\n3 - The variable tag name\n4 - Not supported. \nNote: Getting the raw value using DspInfo is no longer supported. To get the raw value of a tag, use the TagSubscribe function, specifying a value of \"Raw\" for the sScaleMode parameter. When using TagSubscribe, you can either call SubscriptionGetAttribute to obtain the value whenever required or register a callback cicode function to run when the value changes. See TagSubscribe for more details.\n5 - The engineering value associated with the variable\n6 - The Cicode context. Calling DspInfo with this Type will return a string describing the context in which the Cicode expression is contained. For example, if it appears on the horizontal movement tab it would return \"Move X\".\n7 - The number of Cicode expressions. Calling DspInfo with this Type will return the number of Cicode expressions associated with this animation point.\n8 - The number of tags in the expression. Calling DspInfo with this Type will return the number of tags that appear in the given Cicode expression.\n9 - Name of the cluster in which the variable tag resides.\n10 - Full name of the variable tag in the form cluster.tagname.",
                "paramname": "nType"
            },
            {
                "paramdescription": "An index to the variable within the information block. The required index changes according to the Type as follows:\nFor Types 0 to 2, 6 and 8, the index needs to be set to the index of the expression that you wish to query.\nFor Types 3 to 5, the index needs to be set to the index of the tag that you wish to query. When one of these types is used, DspInfo will query the tag in the most recently queried expression (otherwise expression 0).\nFor Type 7, the index is ignored.\nThe object information (as a string). A blank string is returned if you specify a non-existent expression or variable.",
                "paramname": "Index"
            }
        ],
        "returnType": "The object information (as a string). A blank string is returned if you specify a non-existent expression or variable.",
        "syntax": "DspInfo(hInfo, Type, Index)"
    },
    "dspinfodestroy": {
        "doc": "Destroys an object information block created by DspInfoNew(). You should destroy an object information block when you no longer need it, to free Plant SCADA resources.\nWhen the page (with which the object is associated) is closed, Plant SCADA automatically destroys the object information block.",
        "example": "hInfo=DspInfoNew(20);\n! Do animation operation\nDspInfoDestroy(hInfo);",
        "name": "DspInfoDestroy",
        "params": [
            {
                "paramdescription": "The object information block handle, as returned by DspInfoNew(). This handle identifies the table (or block) where all object data is stored.",
                "paramname": "hInfo"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "DspInfoDestroy(hInfo)"
    },
    "dspinfofield": {
        "doc": "Obtains static and real-time data from a variable tag. You get static data from the Variable Tags database. The additional field \"Eng_Value\", returns dynamic real-time data for the variable tag. To get this real-time data, you need to first call the DspInfoNew() function to get the information block handle hInfo.\nGetting the raw value of a variable tag using DspInfoField is no longer supported. To get the raw value of a tag, use the TagSubscribe function, specifying a value of \"Raw\" for the sScaleMode parameter.  When using TagSubscribe, you can either call SubscriptionGetAttribute to obtain the value whenever required or register callback cicode function to run when the value changes.  See TagSubscribe for more details.",
        "example": "! Get the  I/O device that Variable Tag \"PV123\" belongs to.\nIODev=DspInfoField(0,\"PV123\",\"Unit\");\n! Get the real-time engineering value of a tag.\nhInfo=DspInfoNew(20);\nsTag=DspInfo(hInfo,3,0);\nEngValue=DspInfoField(hInfo,sTag,\"Eng_Value\");",
        "name": "DspInfoField",
        "params": [
            {
                "paramdescription": "The object information block handle, as returned byDspInfoNew(). This handle identifies the table (or block)where data on the object is stored. Set this handle to 0(zero) if you do not require real-time data.",
                "paramname": "hInfo"
            },
            {
                "paramdescription": "The name of the variable tag. The name of the tag can beprefixed by the name of the cluster that is \"ClusterName.Tag\".This argument does not support arrays. If array syntax isused, the information will be retrieved for only the tag name.",
                "paramname": "sTag"
            },
            {
                "paramdescription": "The name of the field from which to extract the data:\nCluster - Name of the cluster in which the Tag resides\nComment - Variable tag comment\nEng_Full - Engineering Full Scale\nEng_Zero - Engineering Zero Scale\nEng_Units - Engineering Units\nEng_Value - Scaled engineering value - Dynamic\nField - Description\nFullName - Full name of the tag in the form cluster.tagname.\nName - Variable Tag Name\nType - Data Type\nUnit - I/O Device Name",
                "paramname": "sField"
            },
            {
                "paramdescription": "Specifies the name of the cluster in which the Tag resides.This is optional if you have one cluster or are resolving thetag via the current cluster context. The argument is enclosedin quotation marks \"\".",
                "paramname": "sClusterName"
            }
        ],
        "returnType": "The data (as a string).",
        "syntax": "DspInfoField(hInfo, sTag, sField [, sClusterName] )"
    },
    "dspinfonew": {
        "doc": "Creates an object information block. Use this function with the associated low-level animation information functions to get and process object information on an AN.\nIf you need simple animation help, use the InfoForm() or the InfoFormAn() functions.\nDspInfoNew(nAN)\nnAN:  \nThe object information block handle. If no object data is available, then -1 is returned.",
        "example": "/*This example creates a form, with the title \"Tag Info\" and a \nsize of 25 x 5 characters. It creates an information block for the \nAN closest to the mouse cursor and then extracts the name,  I/O \ndevice, and engineering value for the first tag in the object \nexpression.*/\nINT hInfo;\nSTRING sTag;\nhInfo=DspInfoNew(DspGetNearestAN());\nIF hInfo>-1 THEN\n    FormNew(\"Tag Info\",25,5,2);\n    sTag=DspInfo(hInfo,3,0);\n    FormPrompt(0,0,sTag);\n    FormPrompt(0,16,DspInfoField(hInfo,sTag,\"Unit\"));\n    FormPrompt(0,32,DspInfoField(hInfo,sTag,\"Eng_Value\"));\n    FormRead(0);\n    DspInfoDestroy(hInfo);\nEND",
        "name": "DspInfoNew",
        "params": [
            {
                "paramdescription": "The AN for which object information is provided.",
                "paramname": "nAN"
            }
        ],
        "returnType": "The object information block handle. If no object data is available, then -1 is returned.",
        "syntax": "DspInfoNew(nAN)"
    },
    "dspinfovalid": {
        "doc": "Checks if an object information block handle is valid. An object information block handle becomes invalid after it is destroyed, or if the user closes the page it is associated with. Use this function if background Cicode is using the object information block, and the operator closes the page.",
        "example": "IF DspInfoValid(hInfo) THEN\n    EngValue=DspInfoField(hInfo,sTag,\"Eng_Value\");\nEND",
        "name": "DspInfoValid",
        "params": [
            {
                "paramdescription": "The object information block handle, as returned by DspInfoNew(). This handle identifies the table (or block) where all object data is stored.",
                "paramname": "hInfo"
            }
        ],
        "returnType": "1 if the information block handle is valid, otherwise 0 (zero).",
        "syntax": "DspInfoValid(hInfo)"
    },
    "dspisbuttongray": {
        "doc": "Gets the current status of a button.",
        "example": "! Check the status of the button at AN21\nstatus = DspIsButtonGray(21);",
        "name": "DspIsButtonGray",
        "params": [
            {
                "paramdescription": "The AN for which object information is provided.",
                "paramname": "nAN"
            }
        ],
        "returnType": "The current mode of the button:",
        "syntax": "DspIsButtonGray(nAN)"
    },
    "dspkernel": {
        "doc": "Displays the Kernel window and prompts the user to login as the 'kernel' user. A corresponding 'kernel' user must have already been defined in the project. Kernel access should be restricted to authorised personnel only as once they are in the Kernel, they can execute any Cicode function without further privilege restrictions and therefore have total control of Plant SCADA (and subsequently the plant and equipment). Please be aware that you can also open theKernel by setting the [Debug]Menu parameter to 1 and, when yoursystem is running, selecting Kernel from the control-menu box.\nDspKernel(nMode)\nnMode: \n0 (zero) if successful, otherwise an error is returned.",
        "example": "DspKernel(1);\n!Display the Runtime Kernel window",
        "name": "DspKernel",
        "params": [
            {
                "paramdescription": "The display mode of Kernel:\n1 - Display the Kernel. If the Kernel is already displayed and nMode=1, the keyboard focus is changed to the Kernel.\n0 - Hide the Kernel",
                "paramname": "nMode"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "DspKernel(nMode)"
    },
    "dspmarkermove": {
        "doc": "Moves a trend or chart marker to a specified position.",
        "example": "No example found",
        "name": "DspMarkerMove",
        "params": [
            {
                "paramdescription": "The AN where the trend or chart is positioned.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The marker handle, as returned from the DspMarkerNew() function. The marker handle identifies the table where all data on the associated marker is stored.",
                "paramname": "hMarker"
            },
            {
                "paramdescription": "The offset by which to move the marker. Vertical markers have an offset from 0 (zero) to the maximum number of samples in the trend. Horizontal markers have a offset of 0 (zero) to 32000.",
                "paramname": "Offset"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "DspMarkerMove(nAN, hMarker, Offset)"
    },
    "dspmarkernew": {
        "doc": "Creates a new trend marker. A trend marker is used to show cursor values or limits on a trend. You can use up to 10 markers on a single trend or chart.\nIf you add markers to a trend or chart that Plant SCADA is animating, you need to repaint them using the trend paint event (OnEvent(Window,22)). (Otherwise Plant SCADA will delete any markers displayed when the trend is updated.)",
        "example": "INT offset;  ! offset of marker\nINT hMarker;     ! marker handle\nhMarker = DspMarkerNew(40, 0, WHITE);\n! create a new marker, vertical WHITE\noffset = 100;\nDspMarkerMove(40, hMarker, offset);\n! Moves marker to offset 100\nOnEvent(22, MyTrendPaint);\n! set trend paint event, needs to stop event when change pages\n! this function is called when \nPlant SCADA\n updates the trend\nINT\nFUNCTION\nMyTrendPaint()\n    DspMarkerMove(40, hMarker, offset);\n    RETURN 0;\nEND",
        "name": "DspMarkerNew",
        "params": [
            {
                "paramdescription": "The animation-point number.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The mode of the marker:\n0 - A vertical marker\n1 - A horizontal marker",
                "paramname": "Mode"
            },
            {
                "paramdescription": "The color of the marker (flashing color not supported). Selecta color from the list of Predefined Color Names and Codes orcreate an RGB color using the function MakeColour.",
                "paramname": "Color"
            }
        ],
        "returnType": "The marker handle, or -1 if the function is unsuccessful. The marker handle identifies the table where data on the associated marker is stored.",
        "syntax": "DspMarkerNew(nAN, Mode, Color)"
    },
    "dspmci": {
        "doc": "Controls a multimedia device. The Media Control Interface (MCI) is a high-level command interface to multimedia devices and resource files. MCI provides applications with device-independent capabilities for controlling audio and visual peripherals (for example, for playing multimedia devices and recording multimedia resource files).\nUsing this function, you can control multimedia devices by using simple commands like open, play, and close. MCI commands are a generic interface to multimedia devices. You can control any supported multimedia device, including audio playback and recording. For a full overview of MCI, see the Windows Multimedia Programmer's Guide.",
        "example": "DspMCI(\"open cdaudio\")\nDspMCI(\"set cdaudio time format tmsf\")\nDspMCI(\"play cdaudio from 6 to 7\")\nDspMCI(\"close cdaudio\")\n/*Plays track 6 of an audio CD*/\nDspMCI(\"open c:\\mmdata\\purplefi.wav type waveaudio alias finch\")\nDspMCI(\"set finch time format samples\")\nDspMCI(\"play finch from 1 to 10000\")\nDspMCI(\"close finch\")\n/*Plays the first 10,000 samples of a waveform audio file*/",
        "name": "DspMCI",
        "params": [
            {
                "paramdescription": "The MCI command. See the Microsoft Windows Multimedia Programmer's Guide for details.",
                "paramname": "sCommand"
            }
        ],
        "returnType": "A string message with the status of the MCI command.",
        "syntax": "DspMCI(sCommand)"
    },
    "dspplaysound": {
        "doc": "Plays a waveform (sound). Wave form sound files *.wav are provided with Windows and by third-party developers, or you can record them yourself to play long (and complex) sound sequences.\nWhen the sSoundname is a sound file path and “Mode is “0”, this function loads the .wav file from the specified path (Sound Files) and plays the associated waveform. If the specified sound file is not available in the mentioned path, an error message will be returned and a hardware alarm will be reported. Use of a system sound in this mode is not supported and will result in  an error message and a hardware alarm.\nWhen the sSoundname is a system sound name and nMode is “1”, this function searches the system for the entry withthe specified name and plays the associated waveform. If the name cannot be found, there is no error message indicated as either a return value or hardware alarm. For this reason, the use of mode 0 with waveform files is recommended over mode 1 with system sounds. Further, use of a valid wave form sound file in this mode instead of mode \"0\" will result in an error message and a hardware alarm informing the wrong mode is in use.",
        "example": "DspPlaySound(\"C:\\WINNT\\MEDIA\\Notify.wav\",0);\nDspPlaySound(\"SystemStart\",1);",
        "name": "DspPlaySound",
        "params": [
            {
                "paramdescription": "Sound File Path: Sound file to be played from the specified path.\nSystem Sound Name: The predefined system waveform to be played. Examples of predefined sounds include:\nSystemAsterisk\nSystemExclamation\nSystemQuestion\nSystemDefault\nSystemHand\nSystemExit\nSystemStart",
                "paramname": "sSoundname"
            },
            {
                "paramdescription": "Mode 0: For use when the “sSoundname” is a sound file path.\nMode 1: For use when the “sSoundname” is a system sound name.",
                "paramname": "nMode"
            }
        ],
        "returnType": "TRUE if successful, otherwise FALSE (if an error is detected).",
        "syntax": "DspPlaySound(sSoundname, nMode)"
    },
    "dsppopupconfigmenu": {
        "doc": "Displays the contents of a menu node as a pop-up (context) menu, and run thecommand associated with the selected menu item. You can specify the contents ofa menu using the menu configuration dialog at design time, or using the Menufamily of Cicode functions at runtime.",
        "example": "No example found",
        "name": "DspPopupConfigMenu",
        "params": [
            {
                "paramdescription": "The parent node of the menu tree returned from any of the followingfunctions:\nMenuGetGenericNode(), MenuGetPageNode() or MenuGetWindowNode() - used to get the parent node of menu tree for a page. \nMenuGetFirstChild(), MenuGetNextChild(), MenuGetPrevChild(), MenuGetParent() - used to traverse to other nodes in a menu tree ",
                "paramname": "hParent"
            },
            {
                "paramdescription": "Whether not to recursively transverse child tree nodes and list them as sub-menus in the pop-up menu. This parameter is optional. If it is left unspecified, its value will be defaulted to 0 (recursive). When it is set to 1, only the immediate child nodes of the specified menu handle will be listed. In this mode, tree nodes will be listed as normal menu items (instead of submenus) in the pop-up menu. ",
                "paramname": "bNonRecursive"
            },
            {
                "paramdescription": "The x-coordinate (relative to the page) at which the menu will be displayed.This parameter is optional. If it is left unspecified, the menu will display at the cursor's current position. ",
                "paramname": "XPos"
            },
            {
                "paramdescription": " The y-coordinate (relative to the page) at which the menu will be displayed.This parameter is optional. If it is left unspecified, the menu will display at the cursor's current position. ",
                "paramname": "YPos"
            }
        ],
        "returnType": "0 if the selected meun command is run or error code if menu command cannot run.",
        "syntax": "DspPopupConfigMenu(hParent, [, bNonRecursive [, XPos  [, YPos]]])"
    },
    "dsppopupmenu": {
        "doc": "Creates a popup menu consisting of a number of menu items. Multiple calls to this function enable you to add new items and create sub menus, building a system of linked, Windows-style menus.\nMenu items can be displayed as checked and/or disabled. You can also specify a bitmap to display as a menu icon.\nThis function is first called to build the menu's items and links, and then called again to display it on the screen. In this final call, you have the option to specify the coordinates at which the menu will display, or let it default to the current cursor position.",
        "example": "!Example 1 illustrates one menu with three menu items.\nFUNCTION BuildPopupMenus()\n    INT iSelection;\n    DspPopupMenu(0, \"Item 1,!Item 2,~Item 3\");\n    iSelection = DspPopupMenu(-1, \"\", 150, 300);\n    ! The above builds a menu with three items:\n    ! 'Item 1' will be shown as normal, 'Item 2' will be shown as disabled,\n    ! and 'Item 3' will be shown as checked.\n    ! The menu will be displayed at position (150, 300).\nEND\n\n!Example 2 illustrates the creation of two menus which are linked. \nFUNCTION BuildLinkedPopupMenus()\n    INT iSelection;\n    DspPopupMenu(0, \"Item A,Item B>1,Item C\");\n    DspPopupMenu(1, \"Item B1,,[Trend]Item B2,,Item B3\");\n    iSelection = DspPopupMenu();\n    ! The above will build two menus - Menu 0 and Menu 1\n    ! Item B on Menu 0 links to Menu 1.\n    ! 'Item B2' will be shown with Trend.BMP at its left.\n    ! The menu will be displayed at the cursor's position.\n    ! If 'Item A' is selected, iSelection will equal 1\n    ! If 'Item C' is selected, iSelection will equal 2\n    ! If 'Item B1' is selected, iSelection will equal 101\n    ! If 'Item B2' is selected, iSelection will equal 102\n    ! If 'Item B3' is selected, iSelection will equal 103\nEND",
        "name": "DspPopupMenu",
        "params": [
            {
                "paramdescription": "An integer representing the menu you are adding items to. The first menu created is Menu 0. If left unspecified, this parameter defaults to -1, causing the menu to be displayed on the screen.\nMultiple function calls with the same iMenuNumber allow you to build up entries in a particular menu. For example, the following four function calls with iMenuNumber = 1 build up 8 entries in Menu 1:\n DspPopupMenu(1, \"Selection A>2, Selection B>3\");\n DspPopupMenu(1, \"Selection C>2, Selection D\");\n DspPopupMenu(1, \"Selection E>2, Selection F>3\");\n DspPopupMenu(1, \"Selection G>2, Selection H\");",
                "paramname": "iMenuNumber"
            },
            {
                "paramdescription": "A comma-separated string defining the items in each menu. The default value for this parameter is an empty string, which will get passed to the function in the call to display the menu.\nThe (!), (~), and (,) symbols control display options for menu items.\nFor example, !Item1 disables Item1; ~Item2 checks Item2; and ,Item3 inserts a separator above Item3. To insert a link from a menu item to a sub menu, use the (>) symbol. For example, : Item4>1 means Item4 links to menu 1.\nTo insert a bitmap to the left of a menu item as its icon, use the following notation: [Icon]Item5 Inserts the bitmap Icon.BMP to the left of Item5. [Icon] needs to be placed before the Item name, but after any disable (!) or check (~) symbols you may wish to specify.\nBitmap files used for menu icons need to be saved in the project directory so that they can be found by Plant SCADA.",
                "paramname": "sMenuItems"
            },
            {
                "paramdescription": "The x-coordinate (relative to the page) at which the menu will be displayed. This parameter is optional. If it is left unspecified, the menu will display at the cursor's current position.",
                "paramname": "XPos"
            },
            {
                "paramdescription": "The y-coordinate (relative to the page) at which the menu will be displayed. This parameter is optional. If it is left unspecified, the menu will display at the cursor's current position.",
                "paramname": "YPos"
            }
        ],
        "returnType": "The selected menu item as an integer. This comprises the menu number (return value div 100), and the position of the item in the menu (return value mod 100). For example, a return value of 201 indicates that the first item in Menu 2 was selected, and a return value of 3 indicates that the third item in Menu 0 was selected.",
        "syntax": "DspPopupMenu(iMenuNumber, sMenuItems [, XPos] [, YPos] )"
    },
    "dsprichtext": {
        "doc": "Creates a Rich Text object of the given dimensions at the animation point nAN. This object can then be used to display an RTF file (like an RTF report) called using the DspRichTextLoad function.",
        "example": "//This will produce a rich text object at animation point 57,\nwhich is 200 pixels high, and 200 pixels wide. This object will be\nfor display purposes only (that is read only)//\nDspRichText(57,200,200,0);",
        "name": "DspRichText",
        "params": [
            {
                "paramdescription": "The AN at which the rich text object will display when the DspRichText command is run.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The height of the rich text object in pixels. The height is established by measuring down from the animation point.",
                "paramname": "iHeight"
            },
            {
                "paramdescription": "The width of the rich text object in pixels. The width is established by measuring across to the right from the animation point.",
                "paramname": "iWidth"
            },
            {
                "paramdescription": "The display mode for the rich text object. The mode can be any combination of:\n0 - Disabled - should be used if the rich text object is to be used for display purposes only.\n1 - Enabled - allows you to select and copy the contents of the RTF object (for instance an RTF report), but you will not be able to make changes.\n2 - Read/Write - allows you to edit the contents of the RTF object. Remember, however, that the object needs to be enabled before it can be edited. If it has already been enabled, you can just enter Mode 2 as your argument. If it is not already enabled, you will need to enable it. By combining Mode 1 and Mode 2 in your argument (3), you can enable the object, and make it read/write at the same time.\nBecause the content of the rich text object is just a copy of the original file, changes will not affect the actual file, until saved using the DspRichTextSave function.",
                "paramname": "nMode"
            }
        ],
        "returnType": "0 if successful, otherwise an error is returned.",
        "syntax": "DspRichText(nAN, iHeight, iWidth, nMode)"
    },
    "dsprichtextedit": {
        "doc": "Enables editing of the contents of the rich text object at nAN if nEdit = TRUE, and disables editing if nEdit = FALSE.",
        "example": "// Enables editing of the rich text object at AN 25 - if one\nexists. Otherwise an error will be returned to iResult //\niResult = DspRichTextEdit(25,TRUE);",
        "name": "DspRichTextEdit",
        "params": [
            {
                "paramdescription": "The reference AN for the rich text object.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The value of this argument determines whether you will be able to edit the contents of the rich text object at AN. Enter TRUE to enable editing, or enter FALSE to make the contents read-only.\nChanges made to the contents of the object will not be saved until the DspRichTextSave function is used.",
                "paramname": "bEdit"
            }
        ],
        "returnType": "0 if successful, otherwise an error is returned.",
        "syntax": "DspRichTextEdit(nAN, bEdit)"
    },
    "dsprichtextenable": {
        "doc": "Enables the rich text object at nAN if nEnable = TRUE, and disables the object if nEnable = FALSE. When the object is disabled, its contents cannot be selected or copied etc.",
        "example": "// This line disables the rich text object at AN 25 - if one\nexists. Otherwise an error will be returned to iResult //\niResult = DspRichTextEnable(25,FALSE);",
        "name": "DspRichTextEnable",
        "params": [
            {
                "paramdescription": "The reference AN for the rich text object.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The value of this argument determines whether the rich text object at AN will be enabled or disabled. Enter TRUE to enable the object (that is you can select and copy the contents of the RTF object, but you can't make changes). Enter FALSE to disable the object (that is make it display only).",
                "paramname": "bEnable"
            }
        ],
        "returnType": "0 if successful, otherwise an error is returned.",
        "syntax": "DspRichTextEnable(nAN, bEnable)"
    },
    "dsprichtextgetinfo": {
        "doc": "Retrieves size information about the rich text object at animation point nAN.",
        "example": "! Gets the height of the rich text object at AN 25 - if one exists.\niHeight = DspRichTextGetInfo(25,0);\n! Gets the width of the rich text object at AN 423.\niWidth = DspRichTextGetInfo(423,1);",
        "name": "DspRichTextGetInfo",
        "params": [
            {
                "paramdescription": "The reference AN for the rich text object.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The following size information (in pixels) can be returned about the specified rich text object:\n0 - Height\n1 - Width",
                "paramname": "iType"
            }
        ],
        "returnType": "The requested information as a string (units = pixels).",
        "syntax": "DspRichTextGetInfo(nAN, iType)"
    },
    "dsprichtextload": {
        "doc": "Loads a copy of the file Filename into the rich text object) at animation point nAN. (The rich text object may have been created using either the DspRichTextLoad function or the PageRichTextFile function.)",
        "example": "// This will look in the [Data] path (as specified in the\nCitect.ini file), and load a copy of the file DayRep.rtf into the\nrich text object at animation point 57. //\nDspRichTextLoad(57,\"[Data]\\DayRep.rtf\");\n// This will look in the [Data] path (as specified in the\nCitect.ini file), and load a copy of the history file DayRep.003\ninto the rich text object at animation point 908. //\nDspRichTextLoad(908, \"[Data]\\DayRep.003\");\n// This will load a copy of the history file\nf:\\MyApplication\\data\\DayRep.006, into the rich text object at animation\npoint 908. //\nDspRichTextLoad(908, \"f:\\MyApplication\\data\\DayRep.006\");",
        "name": "DspRichTextLoad",
        "params": [
            {
                "paramdescription": "The animation point at which a copy of the rich text file (for example, an RTF report) will display. This AN needs to match that of a rich text object (created using either the DspRichText function, or the PageRichTextFile function), or the copy of the file will not be loaded into anything, and will not display.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The name of the file to be copied and loaded into the rich text object at the specified animation point. The filename needs to be entered in quotation marks \"\". \nThe maximum file size that can be loaded is 512kb.\nIf you are loading a copy of an RTF report, the report needs to already have been run and saved to a file. Remember that the filename for the saved report comes from the File Name field in the Devices form. The location of the saved file needs to also be included as part of the filename. For example, if the filename in the Devices form listed [Data];RepDev.rtf, then you would need to enter \"[Data]\\repdev.rtf\" as your argument. Alternatively, you can manually enter the path, for example, \"c:\\MyApplication\\data\\repdev.rtf\".\nIf you are keeping a number of history files for the report, instead of using the extension rtf, you need to change it to reflect the number of the desired history file, for example, 001.",
                "paramname": "sFilename"
            }
        ],
        "returnType": "0 if successful, otherwise an error is returned.",
        "syntax": "DspRichTextLoad(nAN, sFilename)"
    },
    "dsprichtextpgscroll": {
        "doc": "Scrolls the contents of the rich text object displayed at nAN, by one page length in the direction given in direction.",
        "example": "// This line scrolls the contents of the rich text object at AN 25\ndown one page. Otherwise an error will be returned to iResult //\niResult = DspRichTextPgScroll(25,4);\n// This line scrolls the contents of the rich text object at AN 423\nright one page. Otherwise an error will be returned to iResult //\niResult = DspRichTextPgScroll(423,2);",
        "name": "DspRichTextPgScroll",
        "params": [
            {
                "paramdescription": "The reference AN for the rich text object.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The direction in which you want to scroll each time this function is run. You can choose from the following:\n1 - Left\n2 - Right\n3 - Up\n4 - Down\n8 - Scroll to top\n16 - Scroll to bottom",
                "paramname": "iDirection"
            }
        ],
        "returnType": "0 if successful, otherwise an error is returned.",
        "syntax": "DspRichTextPgScroll(nAN, iDirection)"
    },
    "dsprichtextprint": {
        "doc": "Prints the contents of the rich text object at animation point nAN, to the port PortName.",
        "example": "! This lines prints \nDspRichTextPrint(25,\"LPT1:\");",
        "name": "DspRichTextPrint",
        "params": [
            {
                "paramdescription": "The reference AN for the rich text object.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The name of the printer port to which the contents of the rich text object will be printed. This name needs to be enclosed within quotation marks \"\". For example \"LPT1\", to print to the local printer, or \"\\\\Pserver\\canon1\" using UNC to print to a network printer.",
                "paramname": "sPortName"
            }
        ],
        "returnType": "0 if successful, otherwise an error is returned.",
        "syntax": "DspRichTextPrint(nAN, sPortName)"
    },
    "dsprichtextsave": {
        "doc": "Saves the contents of the rich text object at animation point nAN, to the file Filename.",
        "example": "// These lines show two different ways of saving the contents of\nthe rich text object (at AN 25) to file DayRep.rtf//\nDspRichTextSave(25,\"[Data]\\DayRep.rtf\");\nDspRichTextSave(25,\"c:\\MyApplication\\data\\DayRep.rtf\");",
        "name": "DspRichTextSave",
        "params": [
            {
                "paramdescription": "The reference AN for the rich text object.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The name under which the contents of the rich text object will be saved. This name needs to be enclosed within quotation marks \"\", and needs to include the destination path. For example \"[Data]\\saved.rtf\".",
                "paramname": "sFilename"
            }
        ],
        "returnType": "0 if successful, otherwise an error is returned.",
        "syntax": "DspRichTextSave(nAN, sFilename)"
    },
    "dsprichtextscroll": {
        "doc": "Scrolls the contents of the rich text object displayed at nAN, in the direction given in direction, by the number of lines/units given in amount. Remember that the height of a line varies according to the font used, therefore if you need to scroll absolute distances, it might be advisable to use the DspRichTextPgScroll function.",
        "example": "DspRichTextScroll(25,4,8);\nDspRichTextScroll(423,2,1);",
        "name": "DspRichTextScroll",
        "params": [
            {
                "paramdescription": "The reference AN for the rich text object.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The direction in which you want to scroll each time this function is run. You can choose from the following:\n1 - Left\n2 - Right\n3 - Up\n4 - Down\n8 - Scroll to top\n16 - Scroll to bottom",
                "paramname": "iDirection"
            },
            {
                "paramdescription": "The amount by which you would like to scroll each time this function is run. Enter the number of lines (for a vertical direction) or units (for a horizontal direction) by which you would like to scroll.",
                "paramname": "iAmount"
            }
        ],
        "returnType": "0 if successful, otherwise an error is returned.",
        "syntax": "DspRichTextScroll(nAN, iDirection, iAmount)"
    },
    "dsprubend": {
        "doc": "Ends the rubber band selection, and returns the coordinates of the rubber band selection. The meaning of the cx and cy values depend on the nMode you specify in the DspRubStart() function.",
        "example": "No example found",
        "name": "DspRubEnd",
        "params": [
            {
                "paramdescription": "The x and y coordinates of the start position. Must be a Long type variable.",
                "paramname": "x,y"
            },
            {
                "paramdescription": "The x and y coordinates of the end position. Must be a Long type variable.",
                "paramname": "cx,cy"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "DspRubEnd(x, y, cx, cy)"
    },
    "dsprubmove": {
        "doc": "Moves the rubber band selection to the new position. You need to first have defined a rubber band selection using the  DspRubStart() and DspRubEnd() functions.\nThis function will erase the existing rubber band and then redraw it in the new position. You would normally move the rubber band by mouse input, but you can get input from the keyboard or any other Cicode to control the rubber band.",
        "example": "No example found",
        "name": "DspRubMove",
        "params": [
            {
                "paramdescription": "The x and y coordinates of the current position.",
                "paramname": "x,y"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "DspRubMove(x, y)"
    },
    "dsprubsetclip": {
        "doc": "Sets the clipping region for the rubber band display. If you enable the clipping region, the rubber band will not move outside of the clip region. This allows you to restrict the rubber band to within some constrained region. (For example, to prevent an operator from dragging the rubber band outside of the trend display when zooming the trend.)\nyou need to call this function (to enable the clipping region) before you can start the rubber band selection (with the DspRubStart() function).",
        "example": "// Set the clipping region to a rectangle starting at 100, 100 to \n200, 300\nDspRubSetClip(100, 100, 200, 300);\n// Start the rubber band display with clipping mode on\nDspRubStart(x, y, 4);",
        "name": "DspRubSetClip",
        "params": [
            {
                "paramdescription": "The x and y coordinates of the clipping region.",
                "paramname": "x1,y1,x2,y2"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "DspRubSetClip(x1, y1, x2, y2)"
    },
    "dsprubsetcolor": {
        "doc": "Sets the color of the rubber band tool that is used to select a section within a trend object.  ",
        "example": "DspRubSetColor(WHITE);          // The rubber band will be white (the default)\nDspRubSetColor(MakeColour(221, 221, 221));   // The rubber band will be grey\nDspRubSetColor(MakeColour(255, 0, 0));        // The rubber band will be red\nDspRubSetColor(MakeColour(0, 255, 0));        // The rubber band will be green\nDspRubSetColor(MakeColour(0, 0, 255));        // The rubber band will be blue",
        "name": "DspRubSetColor",
        "params": [
            {
                "paramdescription": "An integer representing the color to use for the rubber band. The default value is white (0x00FFFFFF). \nThere are a set of labels available in the Include project that you can use:\nBLACK — 0x00000000\nBLUE — 0x00000080\nGREEN — 0x00008000\nCYAN — 0x00008080\nRED — 0x00800000\nMAGENTA — 0x00800080\nBROWN — 0x00808000\nGREY — 0x00BFBFBF\nDARK_GREY — 0x007F7F7F\nLIGHT_BLUE — 0x000000FF\nLIGHT_GREEN — 0x0000FF00\nLIGHT_CYAN — 0x0000FFFF\nLIGHT_RED — 0x00FF0000\nLIGHT_MAGENTA — 0x00FF00FF\nYELLOW — 0x00FFFF00\nWHITE — 0x00FFFFFF\nThe previous rubber band color as an integer. ",
                "paramname": "Color"
            }
        ],
        "returnType": "The previous rubber band color as an integer. ",
        "syntax": "DspRubSetColor(INT Color)"
    },
    "dsprubstart": {
        "doc": "Starts the rubber band selection. Call this function when the left mouse button is pressed - the rubber band is displayed at the starting position. Call the DspRubEnd() function to end the selection, when the mouse button is released. The DspRubMove() function moves the selection to the new position.\nThis function is used by the trend templates for the trend zoom function. Use the rubber band functions whenever you want the operator to select a region on the screen or display a dynamic rectangle on the screen.\nYou can only display one rubber band per page. If you display a second rubber band, the first rubber band is erased. To move a rubber band with the mouse, use the OnEvent() function to get notification of the mouse movement, and then the DspRubMove() function. Because these are generic rubber-band display functions, you can get input from the keyboard, Cicode variables, the I/O device, and the mouse.",
        "example": "INT xRub,yRub,cxRub,cyRub;\n/* Call this function on left mouse button down. */\nFUNCTION\nStartSelection()\n    INT x,y;\n    DspGetMouse(x,y);      ! Get the current mouse position\n    DspRubStart(x,y,0);    ! Start the rubber banding\n    OnEvent(0,MouseEvent); ! Attach mouse move event\nEND\n/* Call this function on left mouse button up. */\nFUNCTION\nEndSelection()\n    ! Stop the rubber banding and get sizes into the ..Rub variables\n    DspRubEnd(xRub,yRub,cxRub,cyRub);\n    OnEvent(0,0);          ! Stop mouse move event\nEND\nINT\nFUNCTION\nMouseEvent()\n    INT x,y;\n    DspGetMouse(x,y);      ! Get mouse position\n    DspRubMove(x,y);       ! Move the rubber band\n    RETURN 0\nEND",
        "name": "DspRubStart",
        "params": [
            {
                "paramdescription": "The x and y coordinates of the current position.",
                "paramname": "x,y"
            },
            {
                "paramdescription": "The mode of the rubber banding operation:\n0 - cx,cy as absolute pixel positions\n1 - cx,cy in pixels relative to x,y\n2 - (x,y) the distance from top left to (cx,cy)\n4 - enable the rubber band selection using the clipping region defined by DspRubSetClip().",
                "paramname": "nMode"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "DspRubStart(x, y, nMode)"
    },
    "dspsetclip": {
        "doc": "Sets the clip rectangle for the AN of an object or group of objects, defined by the top, left, right and bottom  co- ordinates. \n\nIf an AN has a clip rectangle specified, then any part (object) of the AN that is outside of the rectangle will not be rendered. You can use a clip rectangle for \"control\" type genies like treeviews that have scrollbars, to clip the contents of the control to the control's area when the scrollbar is moved. \nA clip rectangle can be set for a group which will affect all the children of the group (and their children). \nA clip rectangle set on a child will override the clip set on the group (this also applies to nested groups).\nWhen an AN  is clipped (i.e. it is outside the clip rectangle) then it will not respond to mouse input i.e. touch commands will not be invoked, tooltips will not be displayed, and the kobject will not be given the focus rectangle for keyboard input. If it is partially clipped, then this only applies to the clipped part, the visible part still responds as normal.",
        "example": "DspSetClip(17, 200, 200, 800, 500);",
        "name": "DspSetClip",
        "params": [
            {
                "paramdescription": "The animation-point number of the object or group of objects inside the clipping region.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The x coordinate of the left side of the clipping boundary ",
                "paramname": "nLeft"
            },
            {
                "paramdescription": "The x coordinate of the top of the clipping boundary ",
                "paramname": "nTop"
            },
            {
                "paramdescription": "The y co-ordinate of the right side of the clip rectangle. ",
                "paramname": "nRight"
            },
            {
                "paramdescription": "The y co-ordinate of the bottom of the clip rectangle. . ",
                "paramname": "nBottom"
            }
        ],
        "returnType": "It returns an error if nAN is invalid, or the specified rectangle is invalid i.e. nLeft >= nRight or nTop >= nBottom.",
        "syntax": "DspSetClip(INT nAN, INT nLeft, INT nTop, INT nRight, INT nBottom)"
    },
    "dspsetcurcolor": {
        "doc": "Sets the color of the focus rectangle. The focus rectangle is used to highlight a selectable object, tab or list item as the mouse moves over it. ",
        "example": "DspSetCurColor(WHITE);          // The focus rectangle will be white (the default)\nDspSetCurColor(MakeCitectColour(221, 221, 221));   // The focus rectangle will be grey\nDspSetCurColor(MakeCitectColour(255, 0, 0);        // The focus rectangle will be red\nDspSetCurColor(MakeCitectColour(0, 255, 0);        // The focus rectangle will be green\nDspSetCurColor(MakeCitectColour(0, 0, 255);        // The focus rectangle will be blue",
        "name": "DspSetCurColor",
        "params": [
            {
                "paramdescription": "An integer representing the color to use for the focus rectangle. The default value is white (0x00FFFFFF). \nThere are a set of labels available in the Include project that you can use:\nBLACK — 0x00000000\nBLUE — 0x00000080\nGREEN — 0x00008000\nCYAN — 0x00008080\nRED — 0x00800000\nMAGENTA — 0x00800080\nBROWN — 0x00808000\nGREY — 0x00BFBFBF\nDARK_GREY — 0x007F7F7F\nLIGHT_BLUE — 0x000000FF\nLIGHT_GREEN — 0x0000FF00\nLIGHT_CYAN — 0x0000FFFF\nLIGHT_RED — 0x00FF0000\nLIGHT_MAGENTA — 0x00FF00FF\nYELLOW — 0x00FFFF00\nWHITE — 0x00FFFFFF\nTRANSPARENT - 0xFF000000\nThe previous focus rectangle color as an integer. ",
                "paramname": "Color"
            }
        ],
        "returnType": "The previous focus rectangle color as an integer. ",
        "syntax": "DspSetCurColor(INT Color)"
    },
    "dspsetmetadatafromname": {
        "doc": "Name used to set the metadata of an object on the page. Use the following syntax:\n[RelativePath].[Group].[Group].Control",
        "example": "No example found",
        "name": "DspSetMetadataFromName",
        "params": [
            {
                "paramdescription": "The Name used as a reference for the object. ",
                "paramname": "sName"
            },
            {
                "paramdescription": "The Name of the metadata to be returned.",
                "paramname": "sMetaName"
            },
            {
                "paramdescription": "The value of the metadata to be returned.",
                "paramname": "sValue"
            }
        ],
        "returnType": "The value of the metadata or error code.",
        "syntax": "DspSetMetadataFromName(sName, sMetaName, sValue)"
    },
    "dspsetmetadatafromnamerelative": {
        "doc": "Name used to set the metadata of an object on the page relative to the given AN. Use the following syntax:\n[RelativePath].[Group].[Group].Control\nThis will browse the group hierarchy to the given AN, and then drill down to other groups to find the named control or object.\nSee Referencing an object using a name at runtime  for more information.",
        "example": "No example found",
        "name": "DspSetMetadataFromNameRelative",
        "params": [
            {
                "paramdescription": "AN used as the starting point for the search of the object name.",
                "paramname": "hAN"
            },
            {
                "paramdescription": "The Name used as a reference for the object. ",
                "paramname": "sName"
            },
            {
                "paramdescription": "The Name of the metadata to be returned.",
                "paramname": "sMetaName"
            },
            {
                "paramdescription": "The Name of the metadata to be returned.",
                "paramname": "sValue"
            }
        ],
        "returnType": "The value of the metadata or error code",
        "syntax": "DspSetMetadataFromNameRelative(hAN, sName, sMetaName, sValue)"
    },
    "dspsetpopupmenufont": {
        "doc": "Allows you to set the font and font size for text that appears in popup menus at runtime. For example, you can use this function to adjust the size of the text that appears in context menus to suit a particular screen resolution. \nDspSetPopupMenuFont(hFont)\nhFont:\nThe handle of font to be used.",
        "example": "No example found",
        "name": "DspSetPopupMenuFont",
        "params": [
            {
                "paramdescription": "The handle of font to be used.",
                "paramname": "hFont"
            }
        ],
        "returnType": "No return value.",
        "syntax": "DspSetPopupMenuFont(hFont)"
    },
    "dspsetslider": {
        "doc": "Sets the current position of a slider at the specified AN. You can use this function to move a slider, and adjust the value of the variable associated with the slider.",
        "example": "// Set the position of the slider at AN 30 to 1/2 scale\nDspSetSlider(30, 16000);",
        "name": "DspSetSlider",
        "params": [
            {
                "paramdescription": "The animation-point number.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The position of the slider from 0 to 32000 where 0 is the zero position of the slider and 32000 if full position of the slider.",
                "paramname": "nPos"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "DspSetSlider(nAN, nPos)"
    },
    "dspsettip": {
        "doc": "Sets tool tip text associated with an AN. Any existing text associated with the AN will be replaced with the new text.",
        "example": "!Set a tool tip for AN19\nDspSetTip(19, \"Start Slurry Pump\");",
        "name": "DspSetTip",
        "params": [
            {
                "paramdescription": "The animation-point number.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The tool tip text to set for the AN.",
                "paramname": "sText"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "DspSetTip(nAN, sText)"
    },
    "dspsettooltipfont": {
        "doc": "Sets the font for tool tip text.\nThe parameter [Animator]TooltipFont also specifies the tool tip font. The parameter is checked at startup, and if it is set, the font is set accordingly. You can then use DspSetTooltipFont() to override the parameter until the next time you start Plant SCADA.",
        "example": "!Set the tool tip font to Bold, Italic, Times New Roman, with a \npoint size of 12\nDspSetTooltipFont(\"Times New Roman\", 12, \"BI\");",
        "name": "DspSetTooltipFont",
        "params": [
            {
                "paramdescription": "The name of the Windows font to be used, enclosed by quotation marks \" \". A value for this parameter is required, however specifying an empty string \"\" will set the tooltip font to the default of MS Sans Serif.",
                "paramname": "sName"
            },
            {
                "paramdescription": "The size of the font in points. If you do not specify a value, the point size defaults to 12.",
                "paramname": "nPointSize"
            },
            {
                "paramdescription": "A string specifying the format of the font. Use one or all of the following, enclosed by quotation marks \" \":\nB to specify Bold\nI to specify Italics\nU to specify Underline\nIf you don't specify a value for this parameter, it will default to an empty string and no formatting will be applied.",
                "paramname": "sAttribs"
            }
        ],
        "returnType": "No return value.",
        "syntax": "DspSetTooltipFont(sName [, nPointSize] [, sAttribs] )"
    },
    "dspstatus": {
        "doc": "Determines whether the object at the specified AN will be grayed (hatch pattern) in the event communication attempts are unsuccessful.",
        "example": "DspStatus(67, 1)\n// Disable the animation at AN 67",
        "name": "DspStatus",
        "params": [
            {
                "paramdescription": "The animation-point number.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "0 - Normal display when communication attempts are unsuccessful\n1 - Gray the object (with a hatch pattern) when communication attempts are unsuccessful",
                "paramname": "nMode"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "DspStatus(nAN, nMode)"
    },
    "dspstr": {
        "doc": "Displays a string at a specified AN.",
        "example": "DspStr(25,\"RedFont\",\"Display this text\");\n/* Displays \"Display this text\" using \"RedFont\" at AN25. \"RedFont\"\nneeds to be defined in the Fonts database. */",
        "name": "DspStr",
        "params": [
            {
                "paramdescription": "The AN where the text will be displayed.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The name of the font that is used to display the text. The FontName needs to be defined in the Fonts database. If the font is notfound, the default font is used.",
                "paramname": "sFont"
            },
            {
                "paramdescription": "The text to display.",
                "paramname": "sText"
            },
            {
                "paramdescription": " Length of the text to display, either in characters or pixels depending on Mode (default -1, no truncation)",
                "paramname": "iLength"
            },
            {
                "paramdescription": " The alignment of the text string:\n0 - Left Justified (default)\n1 - Right Justified.\n2 - Center Justified.",
                "paramname": "iAlignMode"
            },
            {
                "paramdescription": " The length mode of the text string:\n0 - Length as pixels truncated (default)\n1 - Length as pixels truncated with ellipsis\n2 - Length interpreted as characters.",
                "paramname": "iLengthMode"
            },
            {
                "paramdescription": "Determines if the original text is provided as tool tip when the displayed text becomes truncated. \n0 - Tool tip is not available (default).\n1 - Tool tip is available.",
                "paramname": "bTooltip"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "DspStr(nAN, sFont, sText [, iLength] [, iAlignMode] [, iLengthMode] [, bTooltip])"
    },
    "dspsym": {
        "doc": "Displays a symbol or a Genie at a specified AN. This dynamically displayed object  will disappear at page navigation.\nTo display a Genie, the Genie should be configured to be used with this function. See \"Create a New Genie\" topic for more information.",
        "example": "! Display the centrifuge symbol (from the pumps library) at AN25.\nDspSym(25,\"Pumps.Centrifuge\");",
        "name": "DspSym",
        "params": [
            {
                "paramdescription": "The AN where the symbol will be displayed.",
                "paramname": "iAN"
            },
            {
                "paramdescription": "The name of the symbol to display in the format <[LibName.]SymName>. If you do not specify the library name, a symbol from the Global library will display (if it exists).",
                "paramname": "sSymbol"
            },
            {
                "paramdescription": "Not used. The mode is always set to 1, which means do not erase the existing symbol, just draw the new symbol.",
                "paramname": "iMode"
            },
            {
                "paramdescription": "Symbol Type:\n0 - Symbol. sSymbol parameter is interpreted as a symbol. If you do not specify the library name, a symbol from the Global library will display (if it exists).\n1 - Dynamic Genie, sSymbol parameter is interpreted as a Genie.\n2 - Priority Genie. sSymbol is interpreted as a priority which is a numeric key in the alarm priority table and the function selects \"Library Name.Genie Name\" from the table.\n3 - Priority Genie Thumbnail. sSymbol is interpreted as a priority which is a numeric key in the alarm priority table and the function selects \"Library Name.Thumbnail Name\" from the table.\n4 - Mode Genie. sSymbol is interpreted as a mode which is a display name in the alarm mode table. The function selects \"Library Genie Name\" from the table.\n5 - .Mode Genie Thumbnail. sSymbol is interpreted as a mode which is a display name in the alarm mode table. The function selects \"Library Genie Name\" from the table.\n0 (zero) if successful, otherwise one of the following errors will be returned. A hardware alarm is also raised against DspSym when there is an error message.\nIf an invalid type is passed, for example, DspSym(600, “lib1.genie1”, 1, 99), the error 274 “Invalid Argument Passed” is returned. ",
                "paramname": "iType"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise one of the following errors will be returned. A hardware alarm is also raised against DspSym when there is an error message.",
        "syntax": "DspSym(iAN, sSymbol [, iMode]  [, iType] )"
    },
    "dspsymanm": {
        "doc": "Animates a series of symbols at an AN. Sym1 displays first, then Sym2, Sym3 . . . Sym8 and then Sym1 displays again, etc. When the next symbol in the sequence is displayed, the current symbol is not erased, but is overwritten to provide a smoother animation. The symbols should all be the same size.\nThe frequency of changing the symbols is determined by the [Page]AnmDelay parameter.\nYou only need to call this function once to keep the animation going. To stop the animation call the DspDel() function, or call this function again with different symbols (to change the animation).",
        "example": "DspSymAnm(25,\"Pumps.Centrifuge\",\"Pumps.Floatation\");\n! Alternately displays the centrifuge symbol and the flotation symbol\n(from the pumps library) at AN25.",
        "name": "DspSymAnm",
        "params": [
            {
                "paramdescription": "The AN where the animation will occur.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The name of the first symbol to animate in the format <[LibName.]SymName>. If you do not specify the library name, a symbol from the Global library will display (if it exists). Sym1 needs to be specified.",
                "paramname": "Sym1"
            },
            {
                "paramdescription": "The names of the symbols to animate in frames 2 to 8 in the format <[LibName.]SymName>. If you do not specify the library name, a symbol from the Global library will display (if it exists).",
                "paramname": "Sym2..Sym8"
            },
            {
                "paramdescription": "Not used. Always set to -1, which means Soft animation. The background screen (a rectangular region beneath the symbol) is restored with the original image. Any objects that are within the rectangular region are destroyed when the background is restored. Use this mode when each animation symbol is a different size.",
                "paramname": "iDisplayMode"
            },
            {
                "paramdescription": "",
                "paramname": "Sym9"
            },
            {
                "paramdescription": "Not all symbols have to be specified. If for example, only two symbols are to display, specify Sym1 and Sym2.",
                "paramname": ""
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "DspSymAnm(nAN, Sym1 [, Sym2 ... Sym8] [, iDisplayMode] [, sSym9] )"
    },
    "dspsymanmex": {
        "doc": "Animates a series of symbols at an AN. Sym1 displays first, then Sym2, Sym3 . . . Sym9 and then Sym1 displays again, etc. When the next symbol in the sequence is displayed, the current symbol is not erased, but is overwritten to provide a smoother animation. The symbols should all be the same size.\nThe frequency of changing the symbols is determined by the [Page]AnmDelay parameter.\nYou only need to call this function once to keep the animation going. To stop the animation call this function again with a different Mode.",
        "example": "DspSymAnmEx(25,-1,\"Pumps.Centrifuge\",\"Pumps.Floatation\");\n! Alternately displays the centrifuge symbol and the flotation symbol\n(from the pumps library) at AN25.",
        "name": "DspSymAnmEx",
        "params": [
            {
                "paramdescription": "The AN where the animation will occur.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "Not used. Always set to -1, which means Soft animation. The background screen (a rectangular region beneath the symbol) is restored with the original image. Any objects that are within the rectangular region are destroyed when the background is restored. Use this mode when each animation symbol is a different size.",
                "paramname": "Mode"
            },
            {
                "paramdescription": "The name of the first symbol to animate in the format <[LibName.]SymName>. If you do not specify the library name, a symbol from the Global library will display (if it exists). Sym1 needs to be specified.",
                "paramname": "Sym1"
            },
            {
                "paramdescription": "The names of the symbols to animate in frames 2 to 9 in the format <[LibName.]SymName>. If you do not specify the library name, a symbol from the Global library will display (if it exists).\nNot all symbols have to be specified. If for example, only two symbols are to display, specify Sym1 and Sym2.",
                "paramname": "Sym2..Sym9"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "DspSymAnmEx(nAN, Mode, Sym1 [, Sym2 ... Sym9] )"
    },
    "dspsymatsize": {
        "doc": "Displays a symbol or a genie at the specified scale and offset from the AN position.\nBy calling this function continuously, you can move symbols or genies around the screen and change their size and shape, to simulate trippers, elevators, and so on. You change the PositionX, PositionY values to change the position of the symbol/genie, the SizeX, SizeY values to change its size, or the symbol/Genie itself to change its shape.\nYou can only use this function at a blank AN, or an AN with a symbol defined without symbols configured. The AN needs to not be attached to any other animation object.\nTo display a Genie, the Genie should be configured to be used with this function. See \"Create a New Genie\" topic for more information.",
        "example": "! Display tripper moving in x axis at normal size.\nDspSymAtSize(21, \"lib.tripper\", x, 0, 32000, 32000, 0);\n! Display elevator going up and down.\nDspSymAtSize(22, \"lib.elevator\", 0, y, 32000, 32000, 0);\n! Display can getting bigger and smaller.\nDspSymAtSize(23, \"lib.can\", 0, 0, size, size, 0);\n!Display genie1 50% smaller than its original size\nDspSymAtSize(24, \"lib.genie1\", 0, 0, 16000, 16000, 0, 1);",
        "name": "DspSymAtSize",
        "params": [
            {
                "paramdescription": "The AN where the symbol will be animated.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The name of the symbol to display, move, or size. If sSym is 0 (zero), any existing symbol at the AN is erased.",
                "paramname": "sSym"
            },
            {
                "paramdescription": "The horizontal offset position (from the AN) of the symbol (in pixels).",
                "paramname": "PositionX"
            },
            {
                "paramdescription": "The vertical offset position (from the AN) of the symbol (in pixels).",
                "paramname": "PositionY"
            },
            {
                "paramdescription": "The horizontal and vertical scaling factors for the symbol (0 - 32000). For example, if SizeX and SizeY are both 32000, the symbol is displayed at its normal size. Please be aware that symbols can only be reduced in size.",
                "paramname": "SizeX, SizeY"
            },
            {
                "paramdescription": "The mode of the display:",
                "paramname": "Mode"
            },
            {
                "paramdescription": "Symbol Type:",
                "paramname": "Type"
            },
            {
                "paramdescription": "",
                "paramname": "0 (zero) if successful, otherwise an error is returned."
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "DspSymAtSize(nAN, sSym, PositionX, PositionY, SizeX, SizeY, Mode [,Type]))"
    },
    "dsptext": {
        "doc": "Displays text at a specified AN location. This function does the same operation as DspStr(), however it uses a font number rather than a font name.",
        "example": "/* Displays \"Display this text\" at AN25 using the font defined as\nBigFont. */\nhBigFont=DspFontHnd(\"BigFont\");\nDspText(25,hBigFont,\"Display this text\");",
        "name": "DspText",
        "params": [
            {
                "paramdescription": " The AN where the text will be displayed.",
                "paramname": "hAN"
            },
            {
                "paramdescription": " The font number that is used to display the text. (To use the default font, set to -1.)",
                "paramname": "iFont"
            },
            {
                "paramdescription": " The text to display.",
                "paramname": "sText"
            },
            {
                "paramdescription": " Length of the Text to display, either in characters or pixels depending on Mode (default -1, no truncation).",
                "paramname": "iLength"
            },
            {
                "paramdescription": " The alignment of the text string:\n0 - Left Justified (default).\n1 - Right Justified.\n2 - Center Justified.",
                "paramname": "iAlignMode"
            },
            {
                "paramdescription": " The length mode of the text string:\n0 - Length as pixels truncated (default).\n1 - Length as pixels truncated with ellipsis.\n2 - Length interpreted as characters.",
                "paramname": "iLengthMode"
            },
            {
                "paramdescription": "Determines if the original text is provided as tool tip when the displayed text becomes truncated. \n0 - Tool tip is not available (default).\n1 - Tool tip is available.",
                "paramname": "bTooltip"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "DspText(hAN, iFont, sText [, iLength] [, iAlignMode] [, iLengthMode] [, bTooltip])"
    },
    "dsptipmode": {
        "doc": "Switches the display of tool tips on or off. This function overrides the setting in the [Page]TipHelp parameter.",
        "example": "DspTipMode(1);  //Switch on tool tips",
        "name": "DspTipMode",
        "params": [
            {
                "paramdescription": " The display mode:\n0 - Off\n1 - On\n2 - Toggle the tool tip mode\n3 - Do not change the mode, just return the current value",
                "paramname": "nMode"
            }
        ],
        "returnType": "The old mode.",
        "syntax": "DspTipMode(nMode)"
    },
    "dsptrend": {
        "doc": "Displays a trend at an AN. Values are plotted on the trend pens. You need to specify Value1, but Value2 to Value8 are optional. If more values (than configured pens) are specified, the additional values are ignored. If fewer values (than configured pens) are specified, the pens that have no values are not displayed.\nDspTrend() is optimized so that it will not display the trend until a full set of samples has been collected. For example, if you have defined 100 samples for your trend, the trend will not display until value 100 is entered.\nYou should use this function only if you want to control the display of trends directly. If you use the standard Trends (defined in the Trends database) this function is called automatically.\nDspTrend(nAN,Trend,Value1 [,Value2 ... Value8] )\nnAN:  \nTrend: \nValue1: \nValue2...8: \n0 (zero) if successful, otherwise an error is returned.",
        "example": "/* Using the main_loop trend (from the trends library) at AN25, \ndisplay a value of 10 on Pen1, 20 on Pen2, 30 on Pen3 and 40 on \nPen4 of the trend. */\nDspTrend(25,\"Trends.Main_Loop\",10,20,30,40);\n/* Using trend definition 5 (\nPlant SCADA\n Version 1.xx) \nat AN25, display a value of 10 on Pen1, 20 on Pen2, 30 on Pen3 and \n40 on Pen4 of the trend. */\nDspTrend(25,5,10,20,30,40);\n/* Using the loops trend (from the global library) at AN26, \ndisplay a value of 100 on Pen1 and 500 on Pen2 of the trend. */\nDspTrend(26,\"Loops\",100,500);\n/* Display a trend configured with 100 samples immediately. The \ndata for the first 100 samples is stored in an array - \nMyData[100]. On first display, grab all the data and call \nDspTrend().*/\nFOR i = 0 to 100 DO \n    DspTrend(AN, \"Loops\", MyData[i]);\nEND \n// display new samples every 300ms \nWHILE TRUE DO \n    // Shift MyData down and grab new sample \n    TableShift(MyData, 100, 1);\n    MyData[99] = MyFastData; \n    DspTrend(AN, \"Loops\", MyData[99]);\n    SleepMS(300);\nEND \n/* Display a trend configured with 100 samples immediately. Dummy \ndata is pushed into the first 100 samples to fill the trend. Once \nthese values are entered, the trend will be updated each time a \nnew sample value is entered.*/\n// fill up the trend.\nFOR i = 0 to 100 DO \n    DspTrend(AN, \"Loops\", 0);\nEND \n// display new samples every 300ms \nWHILE TRUE DO \n    DspTrend(AN, \"Loops\", MyFastData);\n    SleepMS(300);\nEND ",
        "name": "DspTrend",
        "params": [
            {
                "paramdescription": "The AN where the trend will be displayed.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The name of the trend to display in the format <[LibName.]TrnName>. If you do not specify the library name, a trend from the Global library will display (if it exists).\nTo display a Version 1.xx trend, specify the trend number (0 to 255). For example, if you specify trend 1, Plant SCADA displays the trend Global.Trn001.",
                "paramname": "Trend"
            },
            {
                "paramdescription": "The value to display on Pen 1 of the trend.",
                "paramname": "Value1"
            },
            {
                "paramdescription": "The values to display on Pen 2...Pen 8 of the trend (optional).",
                "paramname": "Value2...8"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "DspTrend(nAN,Trend,Value1 [,Value2 ... Value8] )"
    },
    "dsptrendinfo": {
        "doc": "Get information on a trend definition.",
        "example": "! get the number of samples for the main_loop trend (from the \ntrends library).\nnSamples = DspTrendInfo(\"Trends.Main_Loop\", 1);\n! get the number of samples for trend 3 (\nPlant SCADA\n \nVersion 1.xx).\nnSamples = DspTrendInfo(3, 1);",
        "name": "DspTrendInfo",
        "params": [
            {
                "paramdescription": " The name of the trend in the format <[LibName.]TrnName>. If you do not specify the library name, a trend from the Global library is assumed.\nTo get information on a Version 1.xx trend, specify the trend number (0 to 255). For example, if you specify trend 1, Plant SCADA obtains information from the trend Global.Trn001.",
                "paramname": "hTrend"
            },
            {
                "paramdescription": "",
                "paramname": "nType"
            },
            {
                "paramdescription": "0 - Type of trend:\n0 = line\n1 = bar\n1 - Number of samples in trend\n2 - Height of trend (in pixels)\n3 - Width of trend sample (in pixels)\n4 - Number of trend pens\n11 - Color of pen 1. If the pen uses flashing color, the initial color used. (Use type 19 to determine the secondary flashing color for pen 1.)\n12 - Color of pen 2. If the pen uses flashing color, the initial color used. (Use type 20 to determine the secondary flashing color for pen 2.)\n13 - Color of pen 3. If the pen uses flashing color, the initial color used. (Use type 21 to determine the secondary flashing color for pen 3.)\n14 - Color of pen 4. If the pen uses flashing color, the initial color used. (Use type 22 to determine the secondary flashing color for pen 4.)\n15 - Color of pen 5. If the pen uses flashing color, the initial color used. (Use type 23 to determine the secondary flashing color for pen 5.)\n16 - Color of pen 6. If the pen uses flashing color, the initial color used. (Use type 24 to determine the secondary flashing color for pen 6.)\n17 - Color of pen 7. If the pen uses flashing color, the initial color used. (Use type 25 to determine the secondary flashing color for pen 7.)\n18 - Color of pen 8. If the pen uses flashing color, the initial color used. (Use type 26 to determine the secondary flashing color for pen 8.)\n19 - The secondary color used for pen 1, if flashing color is used.\n20 - The secondary color used for pen 2, if flashing color is used.\n21 - The secondary color used for pen 3, if flashing color is used.\n22 - The secondary color used for pen 4, if flashing color is used.\n23 - The secondary color used for pen 5, if flashing color is used.\n24 - The secondary color used for pen 6, if flashing color is used.\n25 - The secondary color used for pen 7, if flashing color is used.\n26 - The secondary color used for pen 8, if flashing color is used.",
                "paramname": "Type of trend info"
            },
            {
                "paramdescription": " The AN where the trend is displayed.",
                "paramname": "nAN"
            }
        ],
        "returnType": "The trend information (as an integer). If Pen Color (Types 11 - 18) is requested from a bar trend, the return value is -1.",
        "syntax": "DspTrendInfo( hTrend, Type, AN)"
    },
    "dspwebcontentgeturl": {
        "doc": "Gets the current URL for a Web Content control on a graphics page.",
        "example": "No example found",
        "name": "DspWebContentGetURL",
        "params": [
            {
                "paramdescription": " The AN where the Web Content control is displayed. ",
                "paramname": "nAN"
            }
        ],
        "returnType": "The current URL of the specified Web Content control as a string. ",
        "syntax": "DspWebContentGetURL(INT nAN)"
    },
    "dspwebcontentseturl": {
        "doc": "Sets the URL for a Web Content control on a graphics page.\nDspWebContentSetURL(INT nAN, STRING sURL)\nnAN: \nsURL: \nDspWebContentGetURL\n",
        "example": "No example found",
        "name": "DspWebContentSetURL",
        "params": [
            {
                "paramdescription": " The AN where the Web Content control is displayed. ",
                "paramname": "nAN"
            },
            {
                "paramdescription": " A valid URL (maximum 255 characters). ",
                "paramname": "sURL"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "DspWebContentSetURL(INT nAN, STRING sURL)"
    },
    "dumpkernel": {
        "doc": "Dumps Kernel data to the KERNEL.DAT file. Instead of creating a new file subsequent calls to this function will append Kernel data to the KERNEL.DAT file.",
        "example": "DumpKernel(0x8000, \"\");\n!Dump the Kernel data",
        "name": "DumpKernel",
        "params": [
            {
                "paramdescription": " The Kernel data to dump:\nYou can select any one of the above modes or may add them together to get more than one type of information. For example, to dump driver and I/O device data in verbose mode, set iMode to 0x400c (0x0004 + 0x0008 + 0x4000). Using 0x4000 on its own will dump no data, it needs to be combined with another mode.",
                "paramname": "iMode"
            },
            {
                "paramdescription": "The queue or table name (if \"\", returns data for all queues or tables).Only valid if iMode is 0x0020 and 0x0040.",
                "paramname": "sName"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "DumpKernel(iMode, sName)"
    },
    "engtogeneric": {
        "doc": "Gets a variable in the Plant SCADA generic scale format. Plant SCADA uses this scale to display trends. It calls this function automatically for trends defined in the project. If you want to display a trend using Cicode you need to call this function.",
        "example": "/* Using trend definition 5 at AN20, display the value of Tag1 on \nPen1 of the trend. Tag1 has an engineering scale of 0 to 100. */\nDspBar(20,5,EngToGeneric(Tag1,0,100));",
        "name": "EngToGeneric",
        "params": [
            {
                "paramdescription": " The value to convert to the Plant SCADA generic scale format.",
                "paramname": "Value"
            },
            {
                "paramdescription": " The engineering units zero scale.",
                "paramname": "EngLow"
            },
            {
                "paramdescription": " The engineering units full scale.",
                "paramname": "EngHigh"
            }
        ],
        "returnType": "The variable (in the range 0 - 32000).",
        "syntax": "EngToGeneric(Value, EngLow, EngHigh)"
    },
    "entercriticalsection": {
        "doc": "Requests permission for the current thread to have access to a critical section (shared critical resource). If the critical section is already being accessed by another thread (using the EnterCriticalSection() function), the current thread will be granted access when the other thread relinquishes ownership using the LeaveCriticalSection() function.\nOnce a thread has ownership of a critical section, it can access the same sectionrepeatedly (using the EnterCriticalSection() function each time). Remember,however, that LeaveCriticalSection() needs to be called once for eachEnterCriticalSection() used.\nEnterCriticalSection(sName)\nsName: \nThis function does not return a value.",
        "example": "/* Request access to critical section, execute code and relinquish \nownership of critical section. */\nFUNCTION\nMyCriticalFunction()\n    EnterCriticalSection(\"MyCritical\");\n    // critical code is placed here\n    LeaveCriticalSection(\"MyCritical\");\nEND",
        "name": "EnterCriticalSection",
        "params": [
            {
                "paramdescription": " The name of the critical section. The name needs to be entered in quotation marks and follow the rules outlined in the topic Tag Name Syntax in the main help..",
                "paramname": "sName"
            }
        ],
        "returnType": "This function does not return a value.",
        "syntax": "EnterCriticalSection(sName)"
    },
    "equipbrowseclose": {
        "doc": "The EquipBrowseClose function terminates an active data browse session and cleans up resources associated with the session.\nThis function is a non-blocking function. It does not block the calling Cicode task.",
        "example": "No example found",
        "name": "EquipBrowseClose",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by aEquipBrowseOpen call.",
                "paramname": "Session"
            }
        ],
        "returnType": "0 (zero) if the equipment database browse session exists, otherwise an error code is returned.",
        "syntax": "INT EquipBrowseClose(LONG Session)"
    },
    "equipbrowsefirst": {
        "doc": "The EquipBrowseFirst function places the data browse cursor at the first record.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "EquipBrowseFirst",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by a EquipBrowseOpen call.",
                "paramname": "Session"
            }
        ],
        "returnType": "0 (zero) if the equipment database browse session exists, otherwise an error code is returned.",
        "syntax": "INT EquipBrowseFirst(LONG Session)"
    },
    "equipbrowsegetfield": {
        "doc": "The EquipBrowseGetField function retrieves the value of the specified field from the record the data browse cursor is currently referencing.\nThis function is a non-blocking function. It does not block the calling Cicode task.",
        "example": "STRING fieldValue = \"\";\nSTRING fieldName = \"TYPE\";\nINT errorCode = 0;\n...\nfieldValue = EquipBrowseGetField(iSession, sFieldName);\nIF fieldValue <> \"\" THEN\n    // Successful case\nELSE\n    // Function returned an error\nEND\n...",
        "name": "EquipBrowseGetField",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by aEquipBrowseOpen call.",
                "paramname": "Session"
            },
            {
                "paramdescription": "The name of the field that references the value to be returned.Supported fields are:\nSee Browse Function Field Reference for information about fields.",
                "paramname": "FieldName"
            }
        ],
        "returnType": "The value of the specified field as a string. An empty string may or may not be an indication that an error has been detected. The last error should be checked in this instance to determine if an error has actually occurred.",
        "syntax": "STRING EquipBrowseGetField(LONG Session, STRING FieldName)"
    },
    "equipbrowsenext": {
        "doc": "The EquipBrowseNext function moves the data browse cursor forward one record. If you call this function after you have reached the end of the records, error412 is returned (Databrowse session EOF).\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "EquipBrowseNext",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by a EquipBrowseOpen call.",
                "paramname": "Session"
            }
        ],
        "returnType": "0 (zero) if the equipment database browse session exists, otherwise an error is returned.",
        "syntax": "INT EquipBrowseNext(LONG Session)"
    },
    "equipbrowsenumrecords": {
        "doc": "The EquipBrowseNumRecords function returns the number of records that match the filter criteria.\nThis function is a non-blocking function. It does not block the calling Cicode task.",
        "example": "INT numRecords = 0;\n...\nnumRecords = EquipBrowseNumRecords(iSession);\nIF numRecords <> 0 THEN\n    // Have records\nELSE\n    // No records\nEND\n...",
        "name": "EquipBrowseNumRecords",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by a EquipBrowseOpen call.",
                "paramname": "Session"
            }
        ],
        "returnType": "The number of records that have matched the filter criteria. A value of 0 denotes that no records have matched. A value of -1 denotes that the browse session is unable to provide a fixed number. This may be the case if the data being browsed changed during the browse session.",
        "syntax": "LONG EquipBrowseNumRecords(LONG Session)"
    },
    "equipbrowseopen": {
        "doc": "The EquipBrowseOpen function initiates a new browse session and returns a handle to the new session that can be used in subsequent data browse function calls.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "INT iSession;\n...\niSession = EquipBrowseOpen(\"NAME=ABC*\", \"NAME,AREA\",\n\"ClusterA,ClusterB\");\nIF iSession <> -1 THEN\n    // Successful case\nELSE\n    // Function returned an error\nEND\n...",
        "name": "EquipBrowseOpen",
        "params": [
            {
                "paramdescription": "A filter expression specifying the records to return duringthe browse. An empty string indicates that all records will bereturned. Where a fieldname is not specified in the filter, it isassumed to be equipment name. For example, the filter \"AAA\" isequivalent to \"name=AAA\".\nThe following regular expressions are supported: *expr, expr*, and *expr*. To specify an exclusion filtering condition, use the NOT keyword after the = operator. ",
                "paramname": "Filter"
            },
            {
                "paramdescription": "Specifies via a comma delimited string the columns to bereturned during the browse. An empty string indicates thatthe server will return all available columns. Supported fieldsare:\nNAME, CLUSTER, TYPE, AREA, LOCATION, IODEVICE, PAGE, HELP, COMMENT, COMPOSITE, PARENT, ALIAS, CONTENT, HIDDEN, CUSTOM1, CUSTOM2, CUSTOM3, CUSTOM4, CUSTOM5, CUSTOM6, CUSTOM7, CUSTOM8.\nSee Browse Funtion Field Reference for information about fields.",
                "paramname": "Fields"
            },
            {
                "paramdescription": "An optional parameter that specifies via a comma delimitedstring the subset of the clusters to browse. An empty stringindicates that all connected clusters will be browsed.",
                "paramname": "Clusters"
            }
        ],
        "returnType": "Returns an integer handle to the browse session. Returns -1 when an error is detected.",
        "syntax": "LONG EquipBrowseOpen(STRING Filter, STRING Fields [, STRING Clusters] )"
    },
    "equipbrowseprev": {
        "doc": "The EquipBrowsePrev function moves the data browse cursor back one record.  If you call this function after you have reached the beginning of the records, error 412 is returned (Databrowse session EOF).\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "EquipBrowsePrev",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by aEquipBrowseOpen call.",
                "paramname": "Session"
            }
        ],
        "returnType": "0 (zero) if the equipment database browse session exists, otherwise an error is returned.",
        "syntax": "INT EquipBrowsePrev(LONG Session)"
    },
    "equipcheckupdate": {
        "doc": "The runtime environment will automatically check if the equipment database has been updated before each page open and before running an equipment browse open function (EquipBrowseOpen). It does this by checking the version of the database file. You may also update the database periodically in a background task to reload the database even if the page is not changed.\nThe EquipCheckUpdate function checks if the equipment database file has been updated, and provides the facility to reload it. The reload can only be performed if there are no open browse sessions. ",
        "example": "No example found",
        "name": "EquipCheckUpdate",
        "params": [
            {
                "paramdescription": "1 (TRUE) if you want to reload the database.\n0 (FALSE) checks the status of the database without reloading it.",
                "paramname": "Reload"
            },
            {
                "paramdescription": " The cluster name to check and/or reload the equipment database for. All clusters will be checked if omitted or an empty string is set.",
                "paramname": "Cluster"
            }
        ],
        "returnType": "0 (FALSE) if the equipment database has not changed, or 1 (TRUE) if it has been changed, otherwise an error is returned.",
        "syntax": "INT EquipCheckUpdate(INT Reload[, STRING sCluster])"
    },
    "equipgetparam": {
        "doc": "Reads a runtime parameter of an equipment database record from the EQPARAM.RDB database file.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "EquipGetParam",
        "params": [
            {
                "paramdescription": "The name of the cluster (optional for a single cluster system)",
                "paramname": "ClusterName"
            },
            {
                "paramdescription": "The name of the equipment from which to get information. The name of the equipment can be prefixed by the name of the cluster that is \"ClusterName.Equipment\".",
                "paramname": "EquipmentName"
            },
            {
                "paramdescription": "The name of the parameter for which to retrieve a value.",
                "paramname": "ParameterName"
            }
        ],
        "returnType": "The value of the specified parameter as a string. If the parameter is a tag reference, the value of the tag shall be returned.",
        "syntax": "EquipGetParameter(ClusterName, EquipmentName, ParameterName)"
    },
    "equipgetproperty": {
        "doc": "This function reads a property of an equipment database record from the EQUIP.RDB database file.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "EquipGetProperty",
        "params": [
            {
                "paramdescription": "The name of the equipment from which to get information. Thename of the equipment can be prefixed by the name of the cluster that is\"ClusterName.Equipment\".",
                "paramname": "Name"
            },
            {
                "paramdescription": "The field to read. Supported fields are:",
                "paramname": "Field"
            },
            {
                "paramdescription": "",
                "paramname": "Name, Cluster, Type, Area, Location, IODevice, Page, Parent, Composite, Help, Comment, Alias, Content, Hidden, Custom1, Custom2, Custom3, Custom4, Custom5, Custom6, Custom7, Custom8. Defstate, Scheduled"
            },
            {
                "paramdescription": "",
                "paramname": "Name — The name of the equipment (254 characters)."
            },
            {
                "paramdescription": "Type — The equipment-specific type of device (254 characters).\nArea — Area number (integer) (16 characters).\nLocation — Equipment specific field (254 characters).\nIODevice — I/O Device name(s) (254 characters).\nPage — Page name (254 characters).\nParent — The name of the parent equipment derived from the name of the equipment (maximum 254 characters).\nHelp — Help context (254 characters).\nComment — User comment (254 characters).\nCustom1..8 — User definable fields (254 characters each).\nComposite — The equipment specific composite name (maximum 254 characters).\nDefstate — The default state.\nScheduled — Specifies if the equipment participates in a schedule.\nAlias — Meaningful name of equipment (254 characters).\nContent — Workspace content associated with equipment instance.\nHidden — Hide from equipment tree at runtime.\nRuntime fields:",
                "paramname": "Cluster — The cluster to which the equipment belongs (16 characters)."
            },
            {
                "paramdescription": "DRMODE — the current DR mode level for the equipment. The value will be a positive integer to represent the current DR level or zero if inactive.\nSTATE — the current state of the equipment. Although you can only set state for equipment in Override mode, it is still possible to get state for equipment in normal and inherited override mode.",
                "paramname": "MODE — the current mode of the equipment. 0 = automatic; 1= Manual Inherited; 2= Manual."
            },
            {
                "paramdescription": "0 Block — values are retrieved from the report server, the value will also be stored in local memory cache.\n1 Cache — values are first retrieved from local memory cache, if the property is missing from the memory cache, a request will be sent to the report server and the result will then be cached. If the property is missing from the memory cache or if a previous request is in progress, an empty string will be returned.\n2 Local — values are retrieved from the local RDB. Error 348 (Property does not exist) will be returned if the property requested is not available. Requesting runtime fields will also return this error.\n3 CacheThenLocal — values are first retrieved from local memory cache, if the property is missing from the memory cache, a request will be sent to the report server and the result will then be cached. If the property is missing from the memory cache or if a previous request is in progress, the local RDB will be accessed to retrieve the property value.",
                "paramname": "Mode"
            },
            {
                "paramdescription": "",
                "paramname": "Cluster - The name of the cluster (optional for a single cluster system)."
            }
        ],
        "returnType": "The value of the specified field as a string. An empty string may or may not be an indication that an error has been detected. The last error should be checked in this instance to determine if an error has actually occurred.",
        "syntax": "STRING EquipGetProperty(STRING Name, STRING Field, INT Mode, STRING Cluster)"
    },
    "equiprefbrowseclose": {
        "doc": "The EquipRefBrowseClose function terminates an active data browse session and cleans up resources associated with the session.\nThis function is a non-blocking function. It does not block the calling Cicode task.",
        "example": "No example found",
        "name": "EquipRefBrowseClose",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by aEquipBrowseOpen call.",
                "paramname": "Session"
            }
        ],
        "returnType": "0 (zero) if the equipment database browse session exists, otherwise an error code is returned.",
        "syntax": "INT EquipRefBrowseClose(LONG Session)"
    },
    "equiprefbrowsefirst": {
        "doc": "The EquipRefBrowseFirst function places the reference browse cursor at the first record.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "EquipRefBrowseFirst",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by a EquipRefBrowseOpen call.",
                "paramname": "Session"
            }
        ],
        "returnType": "0 (zero) if the equipment database browse session exists, otherwise an error code is returned.",
        "syntax": "INT EquipRefBrowseFirst(LONG Session)"
    },
    "equiprefbrowsegetfield": {
        "doc": "The EquipRefBrowseGetField function retrieves the value of the specified field from the record the data browse cursor is currently referencing.\nThis function is a non-blocking function. It does not block the calling Cicode task.",
        "example": "STRING fieldValue = \"\";\nSTRING fieldName = \"TYPE\";\nINT errorCode = 0;\n...\nfieldValue = EquipRefBrowseGetField(iSession, sFieldName);\nIF fieldValue <> \"\" THEN\n    // Successful case\nELSE\n    // Function returned an error\nEND\n...",
        "name": "EquipRefBrowseGetField",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by aEquipRefBrowseOpen call.",
                "paramname": "Session"
            },
            {
                "paramdescription": "The name of the field that references the value to be returned.Supported fields are:\nSee Browse Function Field Reference for information about fields.",
                "paramname": "FieldName"
            }
        ],
        "returnType": "The value of the specified field as a string. An empty string may or may not be an indication that an error has been detected. The last error should be checked in this instance to determine if an error has actually occurred.",
        "syntax": "STRING EquipRefBrowseGetField(LONG Session, STRING FieldName)"
    },
    "equiprefbrowsenext": {
        "doc": "The EquipRefBrowseNext function moves the data browse cursor forward one record. If you call this function after you have reached the end of the records, error412 is returned (Databrowse session EOF).\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "EquipRefBrowseNext",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by a EquipRefBrowseNext call.",
                "paramname": "Session"
            }
        ],
        "returnType": "0 (zero) if the equipment reference database browse session exists, otherwise an error is returned.",
        "syntax": "INT EquipRefBrowseNext(LONG Session)"
    },
    "equiprefbrowsenumrecords": {
        "doc": "The EquipRefBrowseNumRecords function returns the number of records that match the filter criteria.\nThis function is a non-blocking function. It does not block the calling Cicode task.",
        "example": "INT numRecords = 0;\n...\nnumRecords = EquipRefBrowseNumRecords(iSession);\nIF numRecords <> 0 THEN\n    // Have records\nELSE\n    // No records\nEND\n...",
        "name": "EquipRefBrowseNumRecords",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by a EquipRefBrowseOpen call.",
                "paramname": "Session"
            }
        ],
        "returnType": "The number of records that have matched the filter criteria. A value of 0 denotes that no records have matched. A value of -1 denotes that the browse session is unable to provide a fixed number. This may be the case if the data being browsed changed during the browse session.",
        "syntax": "LONG EquipRefBrowseNumRecords(LONG Session)"
    },
    "equiprefbrowseopen": {
        "doc": "The EquipRefBrowseOpen function initiates a new browse session and returns a handle to the new session that can be used in subsequent equipment reference browse function calls.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "INT iSession;\n...\niSession = EquipRefBrowseOpen(\"NAME=ABC*\", \"NAME,AREA\",\n\"GROUP\");\nIF iSession <> -1 THEN\n    // Successful case\nELSE\n    // Function returned an error\nEND\n...",
        "name": "EquipRefBrowseOpen",
        "params": [
            {
                "paramdescription": "A filter expression specifying the records to return duringthe browse. An empty string indicates that all records will bereturned. Where a fieldname is not specified in the filter, it isassumed to be equipment name. For example, the filter \"AAA\" isequivalent to \"name=AAA\".\nAll string fields can be filtered based on regular expressions. Using an operator other than = will cause strings to not match the filter criteria. The following regular expressions are supported *expr, expr*, and *expr*.",
                "paramname": "Filter"
            },
            {
                "paramdescription": "Specifies via a comma delimited string the columns to bereturned during the browse. An empty string indicates thatthe server will return all available columns. Supported fieldsare:\n EQUIP, REFEQUIP, REFITEM, ORDER, COMMENT, CLUSTER, REFCLUST, REFCAT, CUSTOM1, CUSTOM2, CUSTOM3, CUSTOM4, CUSTOM5, CUSTOM6,CUSTOM7, CUSTOM8.\nSee Browse Function Field Reference for information about fields.",
                "paramname": "Fields"
            },
            {
                "paramdescription": "Comma delimited list of record fields to be returned in order of sorting preferences. For example(GROUP:D, ORDER:A)",
                "paramname": "Sort"
            }
        ],
        "returnType": "Returns an integer handle to the browse session. Returns -1 when an error is detected.",
        "syntax": "LONG EquipRefBrowseOpen(STRING Filter, STRING Fields [, STRING Sort] )"
    },
    "equiprefbrowseprev": {
        "doc": "The EquipRefBrowsePrev function moves the data browse cursor back one record.  If you call this function after you have reached the beginning of the records, error 412 is returned (Databrowse session EOF).\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "EquipRefBrowsePrev",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by aEquipRefBrowseOpen call.",
                "paramname": "Session"
            }
        ],
        "returnType": "0 (zero) if the equipment database browse session exists, otherwise an error is returned.",
        "syntax": "INT EquipRefBrowsePrev(LONG Session)"
    },
    "equipsetproperty": {
        "doc": "The EquipSetProperty function sets the property of an item of equipment.              \nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "EquipSetProperty",
        "params": [
            {
                "paramdescription": "The name of the equipment.",
                "paramname": "Name"
            },
            {
                "paramdescription": "Only properties coming from the scheduler engine can be set:\nMODE: (the current mode of the equipment)\nSTATE: (the current state of the equipment. The state only can be set for equipment in \"Override\" mode)\nDRMODE: (the DR mode of the equipment)",
                "paramname": "field"
            },
            {
                "paramdescription": "The value to be set:\nMODE: 0, automatic; 2 Manual\nSTATE: Any state configured in the system for this equipment, also the mode set the mode to Manual otherwise an error will be sent.\nDRMODE: the current DR mode level for the equipment. The value will be a positive integer to represent the current DR level or zero if inactive.",
                "paramname": "Value"
            },
            {
                "paramdescription": "The name of the cluster (optional)",
                "paramname": "cluster"
            }
        ],
        "returnType": "Returns 0 if successful otherwise it returns an error.",
        "syntax": "INT EquipSetProperty(STRING Name, STRING Field, STRING Value, STRING Cluster)"
    },
    "equipstatebrowseclose": {
        "doc": "The EquipStateBrowseClose function terminates a browsing session and cleans up the resources used by the session. This function uses iSession as the argument which is previously returned by the EquipStateBrowseOpen function.",
        "example": "No example found",
        "name": "EquipStateBrowseClose",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by a EquipStateBrowseOpen call",
                "paramname": "Session"
            }
        ],
        "returnType": "Returns 0 if the equipment state database browse session has been closed successfully, otherwise an error is returned.",
        "syntax": "INT EquipStateBrowseClose(LONG Session )"
    },
    "equipstatebrowsefirst": {
        "doc": "The EquipStateBrowseFirst function places the data browse cursor at the first record. \nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "EquipStateBrowseFirst",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by a EquipStateBrowseOpen call.",
                "paramname": "Session"
            }
        ],
        "returnType": "0 (zero) if the equipment state database browse session exists, otherwise an error is returned.",
        "syntax": "INT EquipBrowseFirst(LONG Session)"
    },
    "equipstatebrowsegetfield": {
        "doc": "The EquipStateBrowseGetField function returns the value of the particular field in a record to which the data browse cursor is currently referencing. This function uses the field name whose value needs to be returned.\nThis function is a non-blocking function. It does not block the calling Cicode task.",
        "example": "No example found",
        "name": "EquipStateBrowseGetField",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by aEquipStateBrowseOpen call.",
                "paramname": "Session"
            },
            {
                "paramdescription": "The name of the field that references the value to be returned.Available fields are:",
                "paramname": "Field"
            },
            {
                "paramdescription": "",
                "paramname": "The value of the specified field as a string. An empty string may or may not be an indication that an error has been detected. The last error should be checked in this instance to determine if an error has actually occurred."
            }
        ],
        "returnType": "The value of the specified field as a string. An empty string may or may not be an indication that an error has been detected. The last error should be checked in this instance to determine if an error has actually occurred.",
        "syntax": "STRING EquipStateBrowseGetField(LONG Session, STRING Field)"
    },
    "equipstatebrowsenext": {
        "doc": "The EquipStateBrowseNext function places the data browse cursor at the next available record.  This function will return an error if called when the data cursor is at end of the records.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "EquipStateBrowseNext",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by a EquipStateBrowseOpen call.",
                "paramname": "Session"
            }
        ],
        "returnType": "0 (zero) if the equipment state database browse session exists, otherwise an error is returned.",
        "syntax": "INT EquipStateBrowseNext(LONG Session)"
    },
    "equipstatebrowsenumrecords": {
        "doc": "The EquipStateBrowseNumRecords function returns the number of records that match the current filter criteria.\nThis function is a non-blocking function. It does not block the calling Cicode task.",
        "example": "No example found",
        "name": "EquipStateBrowseNumRecords",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by aEquipStateBrowseOpen call.",
                "paramname": "Session"
            }
        ],
        "returnType": "Returns the number of records which matches the current filter criteria. 0 means no records were found.",
        "syntax": "LONG EquipStateBrowseNumRecords(LONG Session)"
    },
    "equipstatebrowseopen": {
        "doc": "The EquipStateBrowseOpen function initiates a new session for browsing the equipment states configured. It returns a handle for the browsing session which can be used for further browsing operations.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "EquipStateBrowseOpen",
        "params": [
            {
                "paramdescription": "A filter expression specifying the records to return duringthe browse. An empty string indicates that every record will bereturned. Where a field name is not specified in the filter, it isassumed to be tagname. For example, the filter \"AAA\" isequivalent to \"name=AAA\".",
                "paramname": "Filter"
            },
            {
                "paramdescription": "Specifies via a comma delimited string the columns to bereturned during the browse. An empty string indicates thatthe server will return every available column. Available fields are:\nNAME – the state name\nEQUIPMENT – equipment name\nDELAY – entry command delay\nPERIOD – repeat command period\nPRIORITY – the state priority\nDESCRIPTION – state description\nDRMODE – demand-response mode of this state",
                "paramname": "Fields"
            },
            {
                "paramdescription": "An optional parameter that specifies via a comma delimitedstring the subset of the clusters to browse. An empty stringindicates that every connected clustes will be browsed.",
                "paramname": "Clusters"
            }
        ],
        "returnType": "Returns an integer handle to the browse session. Returns -1 when an error is detected.",
        "syntax": "LONG EquipStateBrowseOpen(STRING Filter, STRING Fields [, STRING Clusters] )"
    },
    "equipstatebrowseprev": {
        "doc": "The EquipStateBrowsePrev function places the data browse cursor at the previous record. This function will return an error if called when the data cursor is at beginning of the records.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "EquipStateBrowsePrev",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by aEquipStateBrowseOpen call.",
                "paramname": "Session"
            }
        ],
        "returnType": "0 (zero) if the equipment state browse session exists, otherwise an error is returned.",
        "syntax": "INT EquipStateBrowsePrev(LONG Session)"
    },
    "errcom": {
        "doc": "Gets the communication status for the current Cicode task. You can call this function in reports, Cicode that is associated with an object, and in any Cicode task.",
        "example": "IF ErrCom()<>0 THEN\n    Prompt(\"I/O device data is bad\");\nEND\n\n{CICODE}\nIF ErrCom()<>0 THEN\n    PrintLn(\"This Report contains bad data\");\nEND\n{END}",
        "name": "ErrCom",
        "params": [],
        "returnType": "0 (zero) if all I/O device data associated with the task is valid, otherwise an error is returned.",
        "syntax": "ErrCom()"
    },
    "errdrv": {
        "doc": "Gets a protocol-specific error message and native error code.",
        "example": "// Get the error message and number associated with error 108\nnError = 108;\nsError = ErrDrv(\"TIWAY\", \"MESSAGE\", nError);",
        "name": "ErrDrv",
        "params": [
            {
                "paramdescription": " The Plant SCADA protocol.",
                "paramname": "sProtocol"
            },
            {
                "paramdescription": " The field in the PROTERR.DBF database:",
                "paramname": "sField"
            },
            {
                "paramdescription": "MASK",
                "paramname": "PROTOCOL"
            },
            {
                "paramdescription": "MESSAGE\nREFERENCE\nACTION\nCOMMENT",
                "paramname": "ERROR"
            },
            {
                "paramdescription": " The protocol specific error code. This field needs to be a variable as it also the place where the returned error code is stored.\nSince the first 34 specific error codes are standard for all protocols, Plant SCADA may add 'masking' to make the error code unique. For example, if an I/O device returns errors 1 to 10 (which are already used), the driver may add 0x100000 to its error codes. When this function is called, the mask will be removed before the result is returned to this variable.",
                "paramname": "nError"
            }
        ],
        "returnType": "The error message (as a string), or an empty string (\"\") if the error is not found. The error code is returned into the nError variable.",
        "syntax": "ErrDrv(sProtocol, sField, nError)"
    },
    "errgethw": {
        "doc": "Gets the current hardware error status for an I/O device.\nI/O devices can be grouped into 2 distinct categories: Those that are created by the system engineer, and those that are created by Plant SCADA itself.\nI/O devices that are created by the system engineer include any I/O device listed in the Plant SCADA I/O devices database, and any device visible as a record in the I/O Device form in the Project Editor.\nI/O devices that are created by Plant SCADA include Generic, LAN, Cicode, Animation, Reports Server, Alarms Server, Trends Server, and I/O Server, and are those specifically not created by the system engineer.\nThe argument's values you supply in this function are used by Plant SCADA to determine which type of device hardware alarm you want to work with.",
        "example": "Error=ErrGetHw(3,0);\n! Sets Error to the current error status for the animation device.\nIF Error=0 THEN\n    DspText(4,0,\"\");\nELSE\n    DspText(4,0,\"Hardware error\");\nEND",
        "name": "ErrGetHw",
        "params": [
            {
                "paramdescription": " For I/O devices that are created by the system engineer,select the IODevNo as the argument value.\nTo determine the IODevNo of a physical I/O device in your project, use the I/O device record number from the I/O Device form in the Plant SCADA Studio. When using an IODevNo, the DeviceType argument needs to be set to 2.\nFor I/O devices that are created by Plant SCADA itself, select one of the following options as the argument value:\nGeneric\nLAN\nCicode\nAnimation\nReports Server\nAlarms Server\nTrends Server\nI/O Server",
                "paramname": "Device"
            },
            {
                "paramdescription": "Select a value from the following options to indicate the'Type of Device' used in the Device argument:\n0 - for I/O devices that are created by Plant SCADA itself (Generic, LAN, Cicode, Animation, etc).\n2 - for I/O devices that are created by the system engineer.\nThe DeviceType argument was added to this function in V5.40 and later. Earlier versions did not pass a value for the DeviceType argument (as it did not exist). Versions prior to V5.40 identified an I/O device by passing the IODevNo (masked with the value of 8192) to the function as the Device argument, in the structure:\nThis was for versions of Plant SCADA permitting a maximum limit of 4095 I/O devices.\nVersions prior to V5.20 masked the IODevNo with a value of 512. The backward compatibility flag for using this mask needs to be set in the Citect.INI file (see code parameter BackwardCompatibleErrHw.).",
                "paramname": "DeviceType"
            }
        ],
        "returnType": "The detected error.",
        "syntax": "ErrGetHw(Device, DeviceType)"
    },
    "errhelp": {
        "doc": "Displays information about a hardware error.",
        "example": "! Invokes the \nPlant SCADA\n Help with help on the \nhardware alarm.\niResult = ErrHelp(ErrMsg(IsError()));",
        "name": "ErrHelp",
        "params": [
            {
                "paramdescription": " The Cicode hardware error string (as returned by ErrMsg()).",
                "paramname": "Error"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error (274) is returned.",
        "syntax": "ErrHelp(Error)"
    },
    "errinfo": {
        "doc": "Gets extended error information on the last error that was detected.",
        "example": "! Get the animation number where the last error occurred\nAN = ErrInfo(0);",
        "name": "ErrInfo",
        "params": [
            {
                "paramdescription": "The type of error information. If type is 0 (zero), function returns the animation number where the error occurred.",
                "paramname": "nType"
            }
        ],
        "returnType": "The error information.",
        "syntax": "ErrInfo(nType)"
    },
    "errlog": {
        "doc": "Logs a message to the Plant SCADA system log file.\nThis function is useful for logging errors in user functions, and for debugging user functions. The Plant SCADA system log file 'SYSLOG.DAT' is created in the local Windows directory of the computer, %PROGRAMDATA%\\AVEVA Plant SCADA 2023\\Logs.",
        "example": "FUNCTION MyFunc(INT Arg)\n\tIF Arg<0 THEN\n\t\tErrLog(\"Invalid arg in Myfunc\");\n\t\tHalt();\n\tEND\nEND",
        "name": "ErrLog",
        "params": [
            {
                "paramdescription": " The message to log. This field can also contain control (such as /n) and formatting characters.",
                "paramname": "Message"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "ErrLog(Message)"
    },
    "errmsg": {
        "doc": "Gets the error message associated with a detected hardware error.",
        "example": "//Get the message of the last hardware error\nsMsg = ErrMsg(IsError());",
        "name": "ErrMsg",
        "params": [
            {
                "paramdescription": " The hardware error number returned from the IsError() function.",
                "paramname": "nError"
            }
        ],
        "returnType": "The error message (as a string). A null value is returned if nError is not in the range of Cicode errors.",
        "syntax": "ErrMsg(nError)"
    },
    "errset": {
        "doc": "Sets the error-checking mode. When Mode is set to 0 and an error occurs thatcauses a component to stop executing, Plant SCADA halts the execution of theCicode task that caused the error, and generates a hardware error.\nYou can perform error checking by setting Mode to 1 and using the IsError() function to trap errors. When the type of error is determined, you can control what happens under particular error conditions. Errset(1) can be used for parts of Cicode when task termination is undesirable, working around the underlying issue in the Cicode. After executing ErrSet(1), Plant SCADA will not automatically check for errors, and the user can manually check for errors using the Cicode function IsError() after a line of code is executed.\nThe operation of the ErrSet function is unique to each Cicode task. If you enable user error checking for one task, it does not enable error checking for any other tasks.\nIt is important to note that ErrSet(1) and ErrSet(0) are intended to be used in pairs. When a thread starts, the error check level is 0 (Plant SCADA will halt your code on errors). Each time ErrSet(1) is called, the level is incremented by 1 (with a maximum of 1000). When ErrSet(0) is called the level is decremented by 1 (with a minimum of 0). Plant SCADA will only halt your code on errors if the error check level equals 0. It does not cause a problem to call ErrSet(1) when the level is already 1000, or to call ErrSet(0) when the level is already 0. The code will just continue to run at the current error check level.\nIf each function calls ErrSet(1) and ErrSet(0) in pairs, there won't be a problem.  However, much user Cicode does not do this reliably. For example, if there are multiple RETURN statements in a function it would need to have an ErrSet(0) before each return to make sure the level was reset. It's also common practice to put ErrSet(1) at the beginning of each function with no corresponding ErrSet(0). To avoid problems, you can use the ErrSetLevel() function instead of ErrSet(). It allows you to set the level to any number (0 - 1000), but could be used to just set it to 0 or 1 to enable or disable Plant SCADA's automatic error checking instead of letting the error check level build up to higher numbers. ",
        "example": "ErrSet(1);\nTest=Var/0;",
        "name": "ErrSet",
        "params": [
            {
                "paramdescription": " Error-checking mode:\n0 - default - Plant SCADA will check for errors.\n1 - The user needs to check for errors.",
                "paramname": "Mode"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "ErrSet(Mode)"
    },
    "errsethw": {
        "doc": "Sets the hardware error status for a hardware device. Call this function to generate a hardware error.\nI/O devices can be grouped into two distinct categories: those created by the system engineer, and those created by Plant SCADA itself.\nI/O devices that are created by the system engineer, are any I/O device listed in the Plant SCADA I/O devices database, visible as records in the I/O Device form in the Project Editor.\nI/O devices that are created by Plant SCADA, including Generic, LAN, Cicode, Animation, Reports Server, Alarms Server, Trends Server, and I/O Server (are those specifically not created by the system engineer).\nThe arguments values you supply in this function are used by Plant SCADA to determine the type of device hardware alarm you want to work with.",
        "example": "ErrSetHw(4,273,0);\n! Generates a divide by zero error (273) on the report device.\nErrSetHw(3,0,0)\n! Resets any error on the animation device.",
        "name": "ErrSetHw",
        "params": [
            {
                "paramdescription": " For I/O devices that are created by the system engineer,select the IODevNo as the argument value.\nTo determine the IODevNo of a physical I/O device in your project, use the I/O device record number from the I/O Device form in the Plant SCADA Studio. When using an IODevNo, the DeviceType argument needs to be set to 2.\nFor I/O devices that are created by Plant SCADA itself, select one of the following options as the argument value:\n0 - Generic\n1 - LAN\n2 - Cicode\n3 - Animation\n4 - Reports Server\n5 - Alarms Server\n6 - Trends Server\n7 - I/O Server",
                "paramname": "Device"
            },
            {
                "paramdescription": " The error code.",
                "paramname": "Error"
            },
            {
                "paramdescription": " Select a value from the following options to indicate the'Type of Device' used in the Device argument:\n0 - For I/O devices that are created by Plant SCADA itself (Generic, LAN, Cicode, Animation, etc).\n2 - For I/O devices that are created by the system engineer.\nThe DeviceType argument was added to this function in V5.40 and later. Earlier versions did not pass a value for the DeviceType argument (as it did not exist). Versions prior to V5.40 identified an I/O device by passing the IODevNo (masked with the value of 8192) to the function as the Device argument, in the structure:\nThis was for versions of Plant SCADA that permitted a maximum limit of 4095 I/O devices.\nVersions prior to V5.20 masked the IODevNo with a value of 512. The backward compatibility flag for using this mask needs to be set in the Citect.INI file (see code parameter BackwardCompatibleErrHw).",
                "paramname": "DeviceType"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "ErrSetHw(Device, Error, DeviceType)"
    },
    "errsetlevel": {
        "doc": "Sets the nesting error level to enable Plant SCADA error checking inside a nested function (when Plant SCADA error checking has been disabled). This function returns the old error level and sets a new error level.\nThe nesting error level is incremented every time the ErrSet(1) function is called.",
        "example": "! ErrorLevel 0 defaults to ErrSet(0) - enables \nPlant SCADA\n error-checking.\nFUNCTION MainFn()\n\tErrSet(1);\n\t! ErrorLevel 1 - disables \nPlant SCADA\n error checking.\n\tFn1();\n\tErrSet(0);\n\t! Enables \nPlant SCADA\n error checking.\nEND\nFUNCTION Fn1()\n\tErrSet(1);\n\t! ErrorLevel 2 - disables \nPlant SCADA\n error checking.\n\tTest=Var/0;\n\tError=IsError();\n\t! Sets Error to 273 (divide by zero).\n\tFn2();\n\tErrSet(0);\n\t! Enables \nPlant SCADA\n error checking.\nEND\nFUNCTION Fn2()\n\tOldErrorLevel=ErrSetLevel(0);\n\t! Sets nesting error level to 0 to enable \nPlant SCADA\n error-checking.\n\tTest=Var/0;\n\t! Cicode halts and a hardware alarm is generated.\n\tErrSetLevel(OldErrorLevel)\n\t! Resets nesting error level to disable \nPlant SCADA\n error-checking.\nEND",
        "name": "ErrSetLevel",
        "params": [
            {
                "paramdescription": " The nesting error level.",
                "paramname": "Level"
            }
        ],
        "returnType": "Returns the old error level and sets a new error level.",
        "syntax": "ErrSetLevel(Level)"
    },
    "errtrap": {
        "doc": "Generates an error trap. If Plant SCADA error checking is enabled, this function will generate a hardware error and may halt Cicode execution (see bHalt argument). If user error checking is enabled, the user function specified in OnEvent(2,Fn) is called.",
        "example": "IF Tag=0 THEN\n    ErrTrap(273);    ! Traps a divide by zero error.\nELSE\n    Value=10/Tag;\nEND",
        "name": "ErrTrap",
        "params": [
            {
                "paramdescription": " The error number to trap.",
                "paramname": "Error"
            },
            {
                "paramdescription": " Determines whether the Cicode execution will be halted.\n0 - Cicode execution is not halted\n1 - Cicode execution is halted",
                "paramname": "bHalt"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "ErrTrap(Error, bHalt)"
    },
    "exec": {
        "doc": "Executes an application, LNK file or PIF file (32 bit system only). The application or command starts up and continues to run in parallel with Plant SCADA.\nThis function can return while the application is still starting up, so you should use the Sleep() function to allow the application enough time to start.\nExec(Command [, Mode] )\nCommand: \nMode: \n0 (zero) if successful, otherwise an error is returned.",
        "example": "Exec(\"c:\\winnt\\system32\\mspaint.exe\");\n! Starts up the Paint application with a normal window.\nExec(\"cmd /c mkdir c:\\test\");\n! Uses the DOS shell to create a new directory\nExec(PathToStr(\"^\"\" + \"[BIN]:\\Ctcicode\")+ \"^\" ^\"\" + \nPathToStr(\"[RUN]:\\cicode.ci\") + \"^\"\")",
        "name": "Exec",
        "params": [
            {
                "paramdescription": " The operating system command to execute (maximum of 255 characters).",
                "paramname": "Command"
            },
            {
                "paramdescription": " The mode of the window:\n1 - Normal\n3 - Maximized\n6 - Minimized\nIf you do not enter a mode, the default mode is 1. ",
                "paramname": "Mode"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "Exec(Command [, Mode] )"
    },
    "executedtspkg": {
        "doc": "Loads and executes a DTS (Data Transformation Services) package which initiates data transfer and transformations between OLE DB data sources.\nA DTS package is created using the DTS utility provided in Microsoft SQL Server 7.0. It can be saved in a COM structured file, a Microsoft Repository, or in an SQL Server Database.\nAll except the first of this function's parameters are optional, and their use will depend on your needs.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "/* File-based package with one package per file, where the package \nname is the same as the file name.*/\niResult = ExecuteDTSPkg(\"c:\\dtspackages\\package.dts\");\n/*SQL Server stored package with additional parameters */\niResult = ExecuteDTSPkg(\"Server1\", \"TestPackage\", \"Param1\", \"Param2\", \"Param3\",\n \"Param4\", \"Param5\", \"Fred\", \"1\", \"c:\\packages\\PkgLog.txt\", \"jsmith\", \"secret\");",
        "name": "ExecuteDTSPkg",
        "params": [
            {
                "paramdescription": "The path and name of the file containing the package (for file-based packages), or the SQL Server name (for SQL Server stored packages).",
                "paramname": "sFileOrSQLSvrName"
            },
            {
                "paramdescription": " The package name.",
                "paramname": "sPkgName"
            },
            {
                "paramdescription": "Five optional variables which may be used as global variables within the DTS package. The variables need to be named Param1, Param2, Param3, Param4, and Param5.",
                "paramname": "sParam1, ,sParam5"
            },
            {
                "paramdescription": "The package password.\nThe creator of the DTS package may have implemented a password so that unauthorized users cannot access it. In this case, you need to specify the package password. If no password has been implemented, you can omit this parameter.",
                "paramname": "sPkgPwd"
            },
            {
                "paramdescription": "The package version. If you don't specify a version, the most recent version is used.",
                "paramname": "sPkgVer"
            },
            {
                "paramdescription": "AN optional path and name for a log file. The log file can track activity such as:",
                "paramname": "sLogFile"
            },
            {
                "paramdescription": "The user name providing access to the SQL Server where the DTS package is stored. A user's account on the SQL Server consists of this user name and, in most cases, a password.\nThis parameter also determines which method is used to load the package.\nIf sSQLSvrUsr is specified, the package is assumed to be an SQL Server stored package. In this case, the package is loaded using the LoadFromSQLServer() method. Otherwise, the package is file-based and LoadFromStorageFile() is called.",
                "paramname": "sSQLSvrUsr"
            },
            {
                "paramdescription": "The password providing access to the SQL Server, if the user's account on the server requires a password.",
                "paramname": "sSQLSvrPwd"
            }
        ],
        "returnType": "0 (zero) if the package was executed successfully, otherwise a DTS error number is returned.",
        "syntax": "ExecuteDTSPkg(sFileOrSQLSvrName [, sPkgName] [, sParam1, ... , sParam5] [, sPkgPwd] [, sPkgVer] [, sLogFile] [, sSQLSvrUsr] [, sSQLSvrPwd])"
    },
    "exp": {
        "doc": "Calculates the exponential of a number (natural logarithm base e).",
        "example": "Variable=Exp(1);\n! Sets Variable to 2.7182...",
        "name": "Exp",
        "params": [
            {
                "paramdescription": " Any number.",
                "paramname": "Number"
            }
        ],
        "returnType": "The exponential of Number (to the base e).",
        "syntax": "Exp(Number)"
    },
    "fact": {
        "doc": "Calculates the factorial of a number.",
        "example": "Variable=Fact(6);\n! Sets Variable to 720 (that is 720=1x2x3x4x5x6).",
        "name": "Fact",
        "params": [
            {
                "paramdescription": " Any number.",
                "paramname": "Number"
            }
        ],
        "returnType": "The factorial of Number.",
        "syntax": "Fact(Number)"
    },
    "fileclose": {
        "doc": "Closes a file. All data written to the file is flushed to disk when the file is closed, and the file number becomes invalid.",
        "example": "File=FileOpen(\"C:\\Data\\Report.Txt\",\"r\");\n..\n! Do file operations.\n..\n! Close the file.\nFileClose(File);",
        "name": "FileClose",
        "params": [
            {
                "paramdescription": " The file number.",
                "paramname": "File"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "FileClose(File)"
    },
    "filecopy": {
        "doc": "Copies a file. You can use the DOS wild card characters (*) and (?) to copy groups of files. In asynchronous mode, this function will return immediately and the copy will continue in the background. Copying files does not interfere with the operation of other Plant SCADA tasks, because this function is time-sliced.\nIf synchronous mode is selected, this function becomes a blocking function. ",
        "example": "! Copy Report.Txt to Report.Bak.\nFileCopy (\"C:\\Data\\Report.Txt\", \"C:\\Data\\Report.Bak\",0);\n/* Copy AlarmLog.Txt to AlarmLog.Bak only if the file time is \ndifferent. Copy in the background. */\nFileCopy (\"AlarmLog.Txt\", \"AlarmLog.Bak\",1+2);",
        "name": "FileCopy",
        "params": [
            {
                "paramdescription": "The name of the source file to copy.",
                "paramname": "sSource"
            },
            {
                "paramdescription": "The name of destination file to copy to. To copy a file to the printer, specify the name as \"LPT1.DOS\".",
                "paramname": "sDest"
            },
            {
                "paramdescription": "The copy mode:\n0 - Normal\n1 - Copy only if the file time is different.\n2 - Copy in asynchronous mode.\nMultiple modes can be selected by adding them together (for example, set Mode to 3 to copy in asynchronous mode if the file time is different).",
                "paramname": "nMode"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned. However, if you copy in asynchronous mode, the return value does not reflect whether the copy operation was successful or not, because the function returns before the actual copy is complete.",
        "syntax": "FileCopy(sSource, sDest, nMode)"
    },
    "filedelete": {
        "doc": "Deletes a file.",
        "example": "! Delete old report file.\nFileDelete(\"C:\\Data\\Report.Txt\");",
        "name": "FileDelete",
        "params": [
            {
                "paramdescription": " The name of the file to delete.",
                "paramname": "Name"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "FileDelete(sName)"
    },
    "fileeof": {
        "doc": "Determines if the end of the file has been reached.",
        "example": "WHILE NOT FileEOF(File) DO\n    Str=FileReadLn(File);\nEND",
        "name": "FileEOF",
        "params": [
            {
                "paramdescription": " The file number.",
                "paramname": "File"
            }
        ],
        "returnType": "1 if the end of file has been reached, otherwise 0 (zero).",
        "syntax": "FileEOF(File)"
    },
    "fileexist": {
        "doc": "Checks if a file exists. If the return value is 1, the file exists.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "! Check if the file exists\nIF FileExist(\"C:\\Data\\Report.Txt\") THEN\n    ! The file exists\nEND",
        "name": "FileExist",
        "params": [
            {
                "paramdescription": " The name of the file to check.",
                "paramname": "Name"
            }
        ],
        "returnType": "TRUE (1) if the file exists, otherwise FALSE (0).",
        "syntax": "FileExist(sName)"
    },
    "filefind": {
        "doc": "Finds a file that matches a specified search criteria. To find a list of files, you need to first call this function with the required path and mode (to find the first file), then call the function again with an empty path and a mode of 0 (to find the remaining files). After the last file is found, an empty string is returned.\nIf the search is for multiple files, FileFindClose needs to be called if the search does not run to completion (for example, you do not run until an empty string is returned).",
        "example": "! Search for all dBase files in the run directory and make a backup\nsPath = FileFind(\"[run]:\\*.dbf\", 0);\nWHILE StrLength(sPath) > 0 DO\n    FileSplitPath(sPath, sDrive, sDir, sFile, sExt);\n    sBak = FileMakePath(sDrive, sDir, sFile, \"BAK\");\n    FileCopy(sPath, sBak, 0);\n    ! Find the next file\n    sPath = FileFind(\"\", 0);\nEND",
        "name": "FileFind",
        "params": [
            {
                "paramdescription": " The name of the file to check. To search for multiple files, the wildcards * and ? can be used to match multiple entries.",
                "paramname": "sPath"
            },
            {
                "paramdescription": " The type of file to check:\n0 - Normal files (includes files with read-only and archived attributes)\n1 - Read-only files only\n2 - Hidden files only\n4 - System files only\n16 - Subdirectories only\n32 - Archived files only\n128 - Files with no attributes only\nThese numbers can be added together to search for multiple types of files during one search.",
                "paramname": "nMode"
            }
        ],
        "returnType": "The full path and filename. If no files are found, an empty string is returned.",
        "syntax": "FileFind(sPath, nMode)"
    },
    "filefindclose": {
        "doc": "Closes a find (started with FileFind) that did not run to completion.",
        "example": "//Find the first dbf file starting with fred\nsPath = FileFind(\"[run]:\\fred*.dbf\", 0);\nIF (StrLength(sPath) > 0) THEN\n    //Do work here\n    FileFindClose();\nEND",
        "name": "FileFindClose",
        "params": [],
        "returnType": "0 if no error is detected, or a Cicode error code if an error occurred.",
        "syntax": "FileFindClose()"
    },
    "filegettime": {
        "doc": "Gets the time on a file.",
        "example": "File = FileOpen(\"[data]:report.txt\", \"r\");\n! Get the time of the file\niTime = FileGetTime(File);\nFileClose(File);",
        "name": "FileGetTime",
        "params": [
            {
                "paramdescription": " The file number.",
                "paramname": "File"
            }
        ],
        "returnType": "The file time of the file (in the Plant SCADA time/date variable format).",
        "syntax": "FileGetTime(File)"
    },
    "filemakepath": {
        "doc": "Creates a file path string from individual components.",
        "example": "No example found",
        "name": "FileMakePath",
        "params": [
            {
                "paramdescription": " The disk drive.",
                "paramname": "sDrive"
            },
            {
                "paramdescription": " The directory string.",
                "paramname": "sDir"
            },
            {
                "paramdescription": " The file name (without the extension).",
                "paramname": "sFile"
            },
            {
                "paramdescription": " The file extension.",
                "paramname": "sExt"
            }
        ],
        "returnType": "The full path as a string.",
        "syntax": "FileMakePath(sDrive, sDir, sFile, sExt)"
    },
    "fileopen": {
        "doc": "Opens a file and returns a file number that can be used by other file functions. The maximum file size supported is 1 Megabyte for displaying text files.\nYou can also use this function to check if a file exists, by opening the file in read-only mode. A return value of -1 indicates that the file cannot be opened.\nErrSet(1) needs to be in the previous line of your code, else the execution stops and a hardware error is generated. If ErrSet(1) is used then it doesn't halt, and -1 is returned.",
        "example": "! Open a file in read-only mode.\nErrSet(1);\nFile=FileOpen(\"C:\\Data\\Report.Txt\",\"r\");\nErrSet(0);",
        "name": "FileOpen",
        "params": [
            {
                "paramdescription": " The name of the file to open.",
                "paramname": "sName"
            },
            {
                "paramdescription": " The mode of the opened file:\n\"a\" - Append mode. Allows you to append to the file without removing the end of file marker. The file cannot be read. If the file does not exist, it will be created.\n\"a+\" - Append and read modes. Allows you to append to the file and read from it. The end of file marker will be removed before writing and restored when writing is complete. If the file does not exist, it will be created.\n\"r\" - Read-only mode. Allows you to (only) read from the file. If the file does not exist or cannot be found, the function call will return the value -1.\n\"r+\" - Read/write mode. Allows you to read from, and write to, the file. If the file already exists (before the function is called), its contents will be deleted. If the file does not exist or cannot be found, the function call will return the value -1.\n\"w\" - Write mode. Opens an empty file for writing. If the file already exists (before the function is called), its contents will be deleted. If the file does not exist or cannot be found, the file will be created.\n\"w+\" - Read/write mode. Opens an empty file for both reading and writing. If the file already exists (before the function is called), its contents will be deleted. If the file does not exist or cannot be found, the file will be created.",
                "paramname": "nMode"
            }
        ],
        "returnType": "The file number. If the file cannot be opened, -1 is returned and the code is halted.",
        "syntax": "FileOpen(sName, nMode)"
    },
    "fileprint": {
        "doc": "Prints a file on a device.",
        "example": "! Print a data file on the system printer.\nFilePrint(\"Printer_Device\",\"Data.txt\");",
        "name": "FilePrint",
        "params": [
            {
                "paramdescription": " The name of the target device.",
                "paramname": "Devicename"
            },
            {
                "paramdescription": " The name of the file to print on the device.",
                "paramname": "Filename"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "FilePrint(Devicename, Filename)"
    },
    "fileread": {
        "doc": "Reads a number of characters from a file. The string can contain less characters than requested if the end of file is reached. A maximum of 255 characters can be read in each call.",
        "example": "WHILE NOT FileEOF(File) DO\n    Str=FileRead(File,20);\nEND",
        "name": "FileRead",
        "params": [
            {
                "paramdescription": " The file number.",
                "paramname": "File"
            },
            {
                "paramdescription": " The number of characters to read.",
                "paramname": "Length"
            }
        ],
        "returnType": "The text from the file (as a string).",
        "syntax": "FileRead(File, Length)"
    },
    "filereadblock": {
        "doc": "Reads a number of characters from a file. The buffer can contain less characters than requested if the end of file is reached. A maximum of 255 characters can be read in each call. The data should be treated as a binary data and should not be passed to string functions. You may use StrGetChar() function to extract each character from the buffer, or pass the buffer to another function which will accept binary data.",
        "example": "// read binary file and copy to COM port\nlength = FileReadBlock(File, buf, 128);\nWHILE length > 0 DO\n    ComWrite(hPort, buf, length, 0);\n    length = FileReadBlock(File, buf, 128);\nEND",
        "name": "FileReadBlock",
        "params": [
            {
                "paramdescription": " The file number.",
                "paramname": "File"
            },
            {
                "paramdescription": " The buffer to return the binary data. This may be a string or a string packed with binary data. The string terminator is ignored and the length argument specifies the number of characters to write. Must be a string variable.",
                "paramname": "Buffer"
            },
            {
                "paramdescription": " The number of characters to read.",
                "paramname": "Length"
            }
        ],
        "returnType": "The number of characters read from the file. When the end of the file is found 0 will be returned. If an error occurs -1 will be returned and IsError() will return the error code.",
        "syntax": "FileReadBlock(File, Buffer, Length)"
    },
    "filereadln": {
        "doc": "Reads a line from a file. Up to 255 characters can be returned. The carriage return and newline characters are not returned. If the line is longer than 255 characters, the error overflow (code 275) is returned - you should call this function again to read the rest of the line.",
        "example": "sLine = FileReadLn(hFile);\n! do stuff with the string\nWHILE IsError() = 275 DO\n    ! read the rest of the line\n    sLine = FileReadLn(hFile);\n    ! do stuff with the rest of the line\nEND",
        "name": "FileReadLn",
        "params": [
            {
                "paramdescription": " The file number.",
                "paramname": "File"
            }
        ],
        "returnType": "The text, as a string.",
        "syntax": "FileReadLn(File)"
    },
    "filerename": {
        "doc": "Renames a file.",
        "example": "! Rename REPORT.TXT as REPORT.OLD.\nFileRename(\"C:\\Data\\Report.Txt\",\"C:\\Data\\Report.Old\");",
        "name": "FileRename",
        "params": [
            {
                "paramdescription": " The original name of the file.",
                "paramname": "Oldname"
            },
            {
                "paramdescription": " The new name of the file.",
                "paramname": "Newname"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "FileRename(Oldname, Newname)"
    },
    "filerichtextprint": {
        "doc": "Prints the rich text file sFilename to the printer given by sPortname.",
        "example": "// This would print the file [Data]\\richtext.rtf to LPT1. Remember\nthat the [Data] path is specified in the Citect.ini file. The file\nrichtext.rtf is the name of the output file for the report, as\nspecified in the Devices form. //\niResult = FileRichTextPrint(\"[Data]\\richtext.rtf\",\"LPT1:\");\n// This would print the file f:\\\nPlant SCADA\n\\data\\richtext.rtf to LPT1.\nThe file richtext.rtf is the name of the output file for the\nreport, as specified in the Devices form. //\niResult = \nFileRichTextPrint(\"f:\\\nPlant SCADA\n\\data\\richtext.rtf\",\"LPT1:\");",
        "name": "FileRichTextPrint",
        "params": [
            {
                "paramdescription": " The filename of the rich text format file. The filename needs to be entered in quotation marks \"\".\nRemember that the filename for a saved report comes from the File Name field in the Devices form. The location of the saved file needs to also be included as part of the filename. For example, if the filename in the Devices form listed [Data];RepDev.rtf, then you would need to enter \"[Data]\\repdev.rtf\" as your argument. Alternatively, you can manually enter the path, for example, \"c:\\MyApplication\\data\\repdev.rtf\".\nIf you are keeping a number of history files for the report, instead of using the extension rtf, you need to change it to reflect the number of the desired history file, for example, 001.",
                "paramname": "sFilename"
            },
            {
                "paramdescription": " The name of the printer port to which the rich text file will be printed. This name needs to be enclosed within quotation marks \"\". For example \"LPT1\", to print to the local printer, or \"\\\\Pserver\\canon1\" using UNC to print to a network printer.",
                "paramname": "PortName"
            }
        ],
        "returnType": "0 if successful, otherwise an error is returned.",
        "syntax": "FileRichTextPrint(sFilename, sPortName)"
    },
    "fileseek": {
        "doc": "Moves the file pointer to a specified position in a file.",
        "example": "! Seek to the start of the file.\nFileSeek(File,0);",
        "name": "FileSeek",
        "params": [
            {
                "paramdescription": " The file number.",
                "paramname": "File"
            },
            {
                "paramdescription": " The offset in bytes, from 0 to (maximum file size -1). This value needs to be >=0.",
                "paramname": "Offset"
            }
        ],
        "returnType": "The new file position, or -1 if an error is detected.",
        "syntax": "FileSeek(File, Offset)"
    },
    "filesettime": {
        "doc": "Sets the time on a file.",
        "example": "File = FileOpen(\"[data]:report.txt\", \"r+\");\n! set the file to the current time\nFileSetTime(File,TimeCurrent());\nFileClose(File);",
        "name": "FileSetTime",
        "params": [
            {
                "paramdescription": " The file number.",
                "paramname": "File"
            },
            {
                "paramdescription": " The new file time, in the Plant SCADA time/date variable format.",
                "paramname": "iTime"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "FileSetTime(File, iTime)"
    },
    "filesize": {
        "doc": "Gets the size of a file.",
        "example": "! Get the size of the file.\nSize=FileSize(File);",
        "name": "FileSize",
        "params": [
            {
                "paramdescription": " The file number.",
                "paramname": "File"
            }
        ],
        "returnType": "The size of the file, in bytes.",
        "syntax": "FileSize(File)"
    },
    "filesplitpath": {
        "doc": "Splits a file path into individual string components. You enter the full path string as sPath. The individual components of the path name are returned in the arguments sDrive, sDir, sFile, and sExt. Arguments must be declared as Cicode variables. If declared as local variables or tags, an \"Incompatible Types\" error will be returned.",
        "example": "No example found",
        "name": "FileSplitPath",
        "params": [
            {
                "paramdescription": " The full path string.",
                "paramname": "sPath"
            },
            {
                "paramdescription": " The disk drive. Must be a String type variable.",
                "paramname": "sDrive"
            },
            {
                "paramdescription": " The directory string. Must be a String type variable.",
                "paramname": "sDir"
            },
            {
                "paramdescription": " The file name (without the extension). Must be a String type variable.",
                "paramname": "sFile"
            },
            {
                "paramdescription": " The file extension. Must be a String type variable.",
                "paramname": "sExt"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "FileSplitPath(sPath, sDrive, sDir, sFile, sExt)"
    },
    "filewrite": {
        "doc": "Writes a string to a file. The string is written at the current file position. The maximum number of characters allowed is 255.",
        "example": "! Write to the file.\nFileWrite(File,\"Data\");",
        "name": "FileWrite",
        "params": [
            {
                "paramdescription": " The file number.",
                "paramname": "File"
            },
            {
                "paramdescription": " The string to write.",
                "paramname": "String"
            }
        ],
        "returnType": "The number of characters written.",
        "syntax": "FileWrite(File, String)"
    },
    "filewriteblock": {
        "doc": "Writes a string or buffer to a file. The data is written at the current file position. You may create the binary data by using the StrSetChar function or by reading the data from some other function. This function is similar to the FileWrite() function however you specify the length of data to write to the file. The FileWrite() function will send the data to the file until the sting terminator is found. FileWriteBlock() will ignore any string terminator and copy the length of bytes to the file. This allows this function to be used for binary data transfer.",
        "example": "No example found",
        "name": "FileWriteBlock",
        "params": [
            {
                "paramdescription": "The file number.",
                "paramname": "File"
            },
            {
                "paramdescription": "The data to write to the file. This may be a string or a string packed with binary data. The string terminator is ignored and the length argument specifies the number of characters to write. Must be a string variable.",
                "paramname": "Buffer"
            },
            {
                "paramdescription": " The number of characters to write. The maximum number of characters you may write in one call is 255. (If you use a string without a terminator in a function that expects a string, or in a Cicode expression, you could get invalid results.) To use the string to build up a buffer, you do not need the terminating 0 (zero).",
                "paramname": "Length"
            }
        ],
        "returnType": "The number of characters written to the file. If an error is detected -1 will be returned and IsError() will return the error code.",
        "syntax": "FileWriteBlock(File, Buffer, Length)"
    },
    "filewriteln": {
        "doc": "Writes a string to a file, followed by a newline character. The string is written at the current file position. The maximum number of characters allowed is 255.",
        "example": "! Write a line to the file.\nFileWriteLn(File,\"Line of file data\");",
        "name": "FileWriteLn",
        "params": [
            {
                "paramdescription": " The file number.",
                "paramname": "File"
            },
            {
                "paramdescription": " The string to write.",
                "paramname": "String"
            }
        ],
        "returnType": "The number of characters written (including the carriage return and newline characters).",
        "syntax": "FileWriteLn(File, String)"
    },
    "fmtclose": {
        "doc": "Closes a format template. After it is closed, the template cannot be used. Closing the template releases system memory.",
        "example": "FmtClose(hFmt);",
        "name": "FmtClose",
        "params": [
            {
                "paramdescription": " The format template handle, returned from the FmtOpen() function. The handle identifies the table where all data on the associated format template is stored.",
                "paramname": "hFmt"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "FmtClose(hFmt)"
    },
    "fmtfieldhnd": {
        "doc": "Gets the handle of a field in a format template. You can then use the field handle in the FmtGetFieldHnd() and FmtSetFieldHnd() functions. By using a handle, you only need to resolve the field name once and then call other functions as required (resulting in improved performance.)",
        "example": "!Resolve names at startup.\nhName=FmtFieldHnd(hFmt,\"Name\");\nhDesc=FmtFieldHnd(hFmt,\"Desc\");\n!Set field data.\nFmtSetFieldHnd(hFmt,hName,\"CV101\");",
        "name": "FmtFieldHnd",
        "params": [
            {
                "paramdescription": " The format template handle, returned from the FmtOpen() function. The handle identifies the table where all data on the associated format template is stored.",
                "paramname": "hFmt"
            },
            {
                "paramdescription": " The field name.",
                "paramname": "sName"
            }
        ],
        "returnType": "The handle of the format template field, or -1 if the field cannot be found.",
        "syntax": "FmtFieldHnd(hFmt, Name)"
    },
    "fmtgetfield": {
        "doc": "Gets field data from a format template. Use this function to extract data after a call to StrToFmt().",
        "example": "StrToFmt(hFmt,\"CV101 Raw Coal Conveyor\");\nStr=FmtGetField(hFmt,\"Name\");\n! Str will contain \"CV101\".",
        "name": "FmtGetField",
        "params": [
            {
                "paramdescription": " The format template handle, returned from the FmtOpen()function. The handle identifies the table where data on theassociated format template is stored.",
                "paramname": "hFmt"
            },
            {
                "paramdescription": " The field name.",
                "paramname": "sName"
            }
        ],
        "returnType": "The data (as a string). If the field does not contain any data, an empty string will be returned.",
        "syntax": "FmtGetField(hFmt, sName)"
    },
    "fmtgetfieldcount": {
        "doc": "Retrieves the number of fields in a format object.",
        "example": "No example found",
        "name": "FmtGetFieldCount",
        "params": [
            {
                "paramdescription": " The format template handle, returned from the FmtOpen() function. The handle identifies the table where data on the associated format template is stored.",
                "paramname": "hFmt"
            }
        ],
        "returnType": "Number of fields in the specified format.",
        "syntax": "FmtGetFieldCount(hFmt)"
    },
    "fmtgetfieldhnd": {
        "doc": "Gets field data from a format template. Use this function to extract data after a call to StrToFmt(). This function has the same effect as FmtGetField(), except that you use a field handle instead of the field name.",
        "example": "No example found",
        "name": "FmtGetFieldHnd",
        "params": [
            {
                "paramdescription": " The format template handle, returned from the FmtOpen() function. The handle identifies the table where all data on the associated format template is stored.",
                "paramname": "hFmt"
            },
            {
                "paramdescription": " The field handle.",
                "paramname": "hField"
            }
        ],
        "returnType": "The data (as a string). If the field does not contain any data, an empty string will be returned.",
        "syntax": "FmtGetFieldHnd(hFmt, hField)"
    },
    "fmtgetfieldname": {
        "doc": "Retrieves the name of a particular field in a format object.",
        "example": "No example found",
        "name": "FmtGetFieldName",
        "params": [
            {
                "paramdescription": " The format template handle, returned from the FmtOpen() function. The handle identifies the table where data on the associated format template is stored.",
                "paramname": "hFmt"
            },
            {
                "paramdescription": " The field handle.",
                "paramname": "hField"
            }
        ],
        "returnType": "Name of requested field",
        "syntax": "FmtGetFieldName(hFmt, hField)"
    },
    "fmtgetfieldwidth": {
        "doc": "Retrieves the width of a particular field in a format object.",
        "example": "No example found",
        "name": "FmtGetFieldWidth",
        "params": [
            {
                "paramdescription": " The handle to a format object. The handle identifies the table where data on the associated format template is stored.",
                "paramname": "hFmt"
            },
            {
                "paramdescription": " The field handle.",
                "paramname": "hField"
            }
        ],
        "returnType": "Width of the requested field.",
        "syntax": "FmtGetFieldWidth(hFmt, hField)"
    },
    "fmtopen": {
        "doc": "Creates a format template. After you create a template, you can use it for formatting data into strings or extracting data from a string. To format a template, use the same syntax as a device format, that is {<name>[,width[,justification]]}. The maximum number of formats that can be created in a project is 512. If you attempt to  create formats in excess of this number, an error code (code 258: CT_ERROR_BUFFER_OVERRUN) will be generated.\nINT FmtOpen(STRING Name, STRING Format, INT Mode)\nName: \nFormat: \nMode: \nThe format template handle, or -1 if the format cannot be created.",
        "example": "hFmt=FmtOpen(\"MyFormat\",\"{Name}{Desc,20}\",0);\nFmtSetField(hFmt,\"Name\", \"CV101\");\nFmtSetField(hFmt,\"Desc\",\"Raw Coal Conveyor\");\nStr =FmtToStr(hFmt);\n! Str will contain \"CV101 Raw Coal Conveyor\".\nFmtOpen(\"0\", \"\", 2);\n! Display Format from Alarm Category 0\nFmtOpen(\"0\", \"\", 3);\n! Summary Format from Alarm Category 0.",
        "name": "FmtOpen",
        "params": [
            {
                "paramdescription": " The name of the format template or Alarm Category.",
                "paramname": "Name"
            },
            {
                "paramdescription": " The format of the template, as{<name>[,width[,justification]]}. Not used for alarm format. See Format Templates for more information.",
                "paramname": "Format"
            },
            {
                "paramdescription": " The mode of the open:\n0 - Open the existing format.\n1 - Open a new format.\n2 - Open Summary Format from Alarm Category specified by Name.\n3 - Open Display Format from Alarm Category specified by Name.\n4 – Open SOE format from Alarm Category specified by Name.\n5 – Reopen a format. If the format name already exists, it will reopen with the specified format template. Otherwise, a new format will open.",
                "paramname": "Mode"
            }
        ],
        "returnType": "The format template handle, or -1 if the format cannot be created.",
        "syntax": "INT FmtOpen(STRING Name, STRING Format, INT Mode)"
    },
    "fmtsetfield": {
        "doc": "Sets data in a field of a format template. After you have set all the fields, you can build the formatted string with the FmtToStr() function.",
        "example": "hFmt=FmtOpen(\"MyFormat\",\"{Name}{Desc, 20}\",0);\nFmtSetField(hFmt,\"Name\", \"CV101\");\nFmtSetField(hFmt,\"Desc\",\"Raw Coal Conveyor\");\nStr =FmtToStr(hFmt);\n! Str will contain \"CV101 Raw Coal Conveyor\".",
        "name": "FmtSetField",
        "params": [
            {
                "paramdescription": " The format template handle, returned from the FmtOpen() function. The handle identifies the table where all data on the associated format template is stored.",
                "paramname": "hFmt"
            },
            {
                "paramdescription": " The name of the format template.",
                "paramname": "sName"
            },
            {
                "paramdescription": " Field data.",
                "paramname": "Data"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "FmtSetField(hFmt, Name, Data)"
    },
    "fmtsetfieldhnd": {
        "doc": "The fields you can build the formatted string with the FmtToStr() function. This function has the same effect as FmtSetField() except that you use a field handle instead of the field name.",
        "example": "hField=FmtFieldHnd(hFmt,\"Name\");\nFmtSetFieldHnd(hFmt,hField,\"CV101\");",
        "name": "FmtSetFieldHnd",
        "params": [
            {
                "paramdescription": " The format template handle, returned from the FmtOpen() function. The handle identifies the table where all data on the associated format template is stored.",
                "paramname": "hFmt"
            },
            {
                "paramdescription": " The field handle.",
                "paramname": "hField"
            },
            {
                "paramdescription": " Field data.",
                "paramname": "Data"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "FmtSetFieldHnd(hFmt, hField, Data)"
    },
    "fmttostr": {
        "doc": "Builds a formatted string from the current field data (in a format template).",
        "example": "! Get the formatted string.\nStr=FmtToStr(hFmt);",
        "name": "FmtToStr",
        "params": [
            {
                "paramdescription": " The format template handle, returned from the FmtOpen() function. The handle identifies the table where all data on the associated format template is stored.",
                "paramname": "hFmt"
            }
        ],
        "returnType": "The formatted string as defined in the format description.",
        "syntax": "FmtToStr(hFmt)"
    },
    "formactive": {
        "doc": "Checks if a form is currently active (displayed on the screen). This function is useful when forms are being displayed in asynchronous mode and another Cicode task is trying to access the form.",
        "example": "No example found",
        "name": "FormActive",
        "params": [
            {
                "paramdescription": " The form handle, returned from the FormNew() function. The form handle identifies the table where all data on the associated form is stored.",
                "paramname": "hForm"
            }
        ],
        "returnType": "TRUE (1) if the form is active or FALSE (0) if it is not.",
        "syntax": "FormActive(hForm)"
    },
    "formaddlist": {
        "doc": "Adds a text string to a list box or combo box. You should call this function only after the FormNew() function, and immediately after either the FormComboBox() or the FormListBox(), and before the FormRead() function otherwise an error is returned. The text is added at the end of the list box or combo box.\nTo add text to a form that is already displayed, use the FormListAddText() function, and use the FormListSelectText() function to highlight text on the list.",
        "example": "No example found",
        "name": "FormAddList",
        "params": [
            {
                "paramdescription": " The text string to add to the list box or combo box.",
                "paramname": "sText"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "FormAddList(sText)"
    },
    "formbutton": {
        "doc": "Adds a button to the current form. You can add buttons that run callback functions (specified in Fn) to perform any actions you need, as well as the standard buttons - an [OK] button to save the operator's entries and close the form, and a [Cancel] button to close the form but discard the changes.\nYou should call this function only after the FormNew() function and before the FormRead() function. The button is added to the form at the specified column and row position. The width of the button is automatically sized to suit the text.",
        "example": "! Create a form, add buttons and then display the form on the \ncurrent page\nFUNCTION FnMenu()\n\tFormNew(\"MENU\",20,6,1);\t\n\tFormButton(0 ,4 ,\"  FIND  \", FindMenu, 0);\n\tFormButton(10,4 ,\"  TAG   \", ShowTag, 0);\n\tFormButton(0 ,5 ,\" CANCEL \", KillForm, 0);\n\tFormButton(10,5 ,\"  GOTO  \", GotoPg, 0);\n\tFormRead(0);\t\nEND",
        "name": "FormButton",
        "params": [
            {
                "paramdescription": " The number of the column in which the button will be placed. Enter a number from 0 (column 1) to the form width - 1. For example, to place the button in column 8, enter 7.",
                "paramname": "Col"
            },
            {
                "paramdescription": " The number of the row in which the button will be placed. Enter a number from 0 (row 1) to the form height - 1. For example, to place the button in row 6, enter 5.",
                "paramname": "Row"
            },
            {
                "paramdescription": " The text to display on the button.",
                "paramname": "sText"
            },
            {
                "paramdescription": " The callback function to call when the button is selected. Set to 0 to call no function. Please be aware that the Fn parameter needs to be of type INT and the callback function cannot contain a blocking function.",
                "paramname": "Fn"
            },
            {
                "paramdescription": " Button mode:\n0 - Normal button. When this button is selected the callback function is called.\n1 - OK button. When this button is selected, the form is closed, and all operator-entered data is copied to buffers (specified by the other form functions). FormRead() returns 0 (zero) to indicate a successful read. The callback function specified in Fn is called. Be aware that this mode destroys the form.\n2 - Cancel button. When this button is selected, the form is closed and operator-entered data is discarded. FormRead() returns with an error 299. The callback function specified in Fn is called. Be aware that this mode destroys the form.\n3 - Disabled button. When this button is drawn, it will be shaded and not available for use.",
                "paramname": "Mode"
            }
        ],
        "returnType": "The field handle if the button is successfully added, otherwise -1 is returned.",
        "syntax": "FormButton(Col, Row, sText, Fn, Mode)"
    },
    "formcheckbox": {
        "doc": "Adds a check box to the current form. The check box is a form control that allows the operator to make individual selections. Each check box can be either checked (true) or cleared (false).\nYou should call this function only after the FormNew() function and before the FormRead() function. The check box is added to the form at the specified column and row position. The width of the button is automatically sized to suit the text.",
        "example": "! Create a form, add check boxes, and display the form.\n! The operator may select none or all of the check boxes.\nFUNCTION FnMenu()\n\tSTRING\t sNuts, sCherrys, sChocolate;\n\tsNuts\t\t= \"1\";\n\tsCherrys\t= \"0\";\n\tsChocolate\t= \"1\";\n\tFormNew(\"IceCream\",20,6,1);\t]\n\tFormCheckBox(2 ,2,\"Nuts\",\tsNuts);\n\tFormCheckBox(2, 3,\"Cherrys\",\tsCherrys);\n\tFormCheckBox(2 ,4,\"Chocolate\",\tsChocolate);\n\tFormRead(0);\t\n\tIf sNuts = \"1\" THEN\n\t\t! add the nuts\n\tEND\n\tIF sCherrys = \"1\" THEN\n\t\t! add the cherrys\n\tEND\n\tIF sChocolate = \"1\" THEN\n\t\t! add the chocolate\n\tEND\nEND",
        "name": "FormCheckBox",
        "params": [
            {
                "paramdescription": " The number of the column in which the check box will be placed. Enter a number from 0 (column 1) to the form width - 1. For example, to place the check box in column 8, enter 7.",
                "paramname": "Col"
            },
            {
                "paramdescription": " The number of the row in which the check box will be placed. Enter a number from 0 (row 1) to the form height - 1. For example, to place the check box in row 6, enter 5.",
                "paramname": "Row"
            },
            {
                "paramdescription": " The text associated with the check box.",
                "paramname": "sText"
            },
            {
                "paramdescription": " The string buffer in which to put the state of the check box. You should initialize this buffer to the state of the check box. When the form returns, this buffer will contain either '1' or '0' if the box is checked.",
                "paramname": "sBuf"
            }
        ],
        "returnType": "The field handle if the check box is successfully added, otherwise -1 is returned.",
        "syntax": "FormCheckBox(Col, Row, sText, sBuf)"
    },
    "formcombobox": {
        "doc": "Adds a combo box to the current form. A combo box is a form control that allows the operator to type a selection or make a single selection from a text list.\nYou should call this function only after the FormNew() function and before the FormRead() function. The combo box is added to the form at the specified column and row position with the specified width and height. If more items are placed in the list than the list can display, a scroll bar displays (to scroll to the hidden items).\nUse the FormAddList() function to add items for display in the list box. If the form is already displayed, you can use the FormListAddText() and FormListSelectText() functions to add (and highlight) text in the list box.",
        "example": "! Create a form, add combo box and then display the form\n! the operator may type in or select one of the items from the list\nFUNCTION FnMenu()\n\tSTRING\t sBuf;\n\tFormNew(\"Select Item\",20,6,1);\t\n\tFormComboBox(2 ,2, 15, 5, sBuf, 1);\n\tFormAddList(\"Item One\");\n\tFormAddList(\"Item two\");\n\tFormAddList(\"Item three\");\n\tFormRead(0);\t\n\t! sBuf should contain the selected item or entered text\nEND",
        "name": "FormComboBox",
        "params": [
            {
                "paramdescription": "The number of the column in which the combo box will be placed. Enter a number from 0 (column 1) to the form width - 1. For example, to place the combo box in column 8, enter 7.",
                "paramname": "Col"
            },
            {
                "paramdescription": "The number of the row in which the combo box will be placed. Enter a number from 0 (row 1) to the form height - 1. For example, to place the combo box in row 6, enter 5.",
                "paramname": "Row"
            },
            {
                "paramdescription": "The width of the list box, which should be wide enough to display your widest item. Items wider than the list box are clipped.",
                "paramname": "Width"
            },
            {
                "paramdescription": "The height of the list box (the number of items that can be seen in the list box without scrolling).",
                "paramname": "Height"
            },
            {
                "paramdescription": "The string buffer in which to store the selected item. The sBuf parameter can also hold the starting selection for the Combo box. For example if you set the sBuf string to \"HELLO\" before calling FormComboBox, HELLO will be displayed in the box upon opening the form. Must be a String type variable.",
                "paramname": "sBuf"
            },
            {
                "paramdescription": "The mode in which to create the combo box:\n0 - Sort the combo box elements alphabetically.\n1 - Place elements in combo box in the order they were added.\nDefault mode is 0.",
                "paramname": "Mode"
            }
        ],
        "returnType": "The field handle if the combo box is successfully added, otherwise -1 is returned.",
        "syntax": "FormComboBox(Col, Row, Width, Height, sBuf [, Mode] )"
    },
    "formcurr": {
        "doc": "Gets the form and field handles for the current form and field. You should call this function only from within a callback function. You can then use the same callback function for all forms and fields, regardless of how the boxes, buttons, etc. on the forms are used. You should use this function with the FormGetInst() function.",
        "example": "No example found",
        "name": "FormCurr",
        "params": [
            {
                "paramdescription": " Variable containing the form handle, returned from the FormNew() function. The form handle identifies the table where all data on the associated form is stored.",
                "paramname": "hForm"
            },
            {
                "paramdescription": " Variable containing the field handle of the field currently selected.",
                "paramname": "hField"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "FormCurr(hForm, hField)"
    },
    "formdestroy": {
        "doc": "Destroys a form that is removes it from the screen. Use this function (from an event) to close a form.",
        "example": "/* Display message to the operator. If after 10 seconds the \noperator has not selected OK, then destroy the form. */\nhForm=FormNew(\"Hello\",4,20,0);\nFormPrompt(1,1,\"Something bad has happened\");\nFormButton(5,2,\"OK\",0,1);\nFormRead(1);\n! Wait 10 seconds.\nSleep(10);\nIF FormActive(hForm) THEN\n    ! Destroy form.\n    FormDestroy(hForm);\nEND",
        "name": "FormDestroy",
        "params": [
            {
                "paramdescription": " The form handle, returned from the FormNew() function. The form handle identifies the table where all data on the associated form is stored.",
                "paramname": "hForm"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "FormDestroy(hForm)"
    },
    "formedit": {
        "doc": "Adds an edit field to the current form. You should call this function only after the FormNew() function and before the FormRead() function. A user input/edit box is added to the form at the specified column and row position. The operator can enter or edit the text in the edit box. This text is then passed to this function as Text.",
        "example": "STRING Recipe;\nFormNew(\"Recipe\",5,30,0);\n! Add edit field, default Recipe to \"Jam\".\nRecipe=\"Jam\";\nFormEdit(1,2,Recipe,20);\n! Read the form.\nFormRead(0);\n! Recipe will now contain the operator-entered data.",
        "name": "FormEdit",
        "params": [
            {
                "paramdescription": " The number of the column in which the edit field will be placed. Enter a number from 0 (column 1) to the form width - 1. For example, to place the edit field in column 8, enter 7.",
                "paramname": "Col"
            },
            {
                "paramdescription": " The number of the row in which the edit field will be placed. Enter a number from 0 (row 1) to the form height - 1. For example, to place the edit field in row 6, enter 5.",
                "paramname": "Row"
            },
            {
                "paramdescription": " Variable containing the text in the edit field. Text initially contains the default text (if any) for the operator to edit. When the function closes, this argument is passed back with the operator's input.",
                "paramname": "Text"
            },
            {
                "paramdescription": " The width of the edit field.",
                "paramname": "Width"
            },
            {
                "paramdescription": " The height of the edit field as measured using average character height. When value specified is less than 1 or not specified, it is default to 1 (single line). When multiple lines are specified, the content of the edit box will be word wrapped.",
                "paramname": "Height"
            },
            {
                "paramdescription": " Flag to indicate whether the edit box is read only. Default is FALSE if not specified.",
                "paramname": "bReadOnly"
            },
            {
                "paramdescription": "This optional parameter specifies the maximum length of input text. The default value is 0 meaning the string can havethe maximum length allowed in the system (Cicode allows strings of 255 characters).",
                "paramname": "maxTextLength"
            }
        ],
        "returnType": "The field handle if the string is successfully added, otherwise -1 is returned.",
        "syntax": "FormEdit(Col, Row, Text, Width Height, bReadOnly [, maxTextLength] )"
    },
    "formfield": {
        "doc": "Adds a field control device (such as a button , check box, or edit field) to the current form. You should call this function only after the FormNew() function and before the FormRead() function. This function allows you to specify a control device with more detail than the other field functions.",
        "example": "! Display a form with check boxes to start\n!! specific motors.\nFUNCTION SelectMotor()\n\tINT hform;\n\tSTRING check1 = \"0\";\n\tSTRING check2 = \"0\";\n\tSTRING check3 = \"0\";\n\thform = FormNew(\"Selection Menu\", 26, 22, 6);\n\tFormField(16, 1, 12, 1, 9, check1, \"Primary  \", 0);\n\tFormField(16, 2, 12, 1, 9, check2, \"Secondary\", 0);\n\tFormField(16, 3, 12, 1, 9, check3, \"backup   \", 0);\n\tFormButton( 9, 20, \" &Cancel \", 0, 2);\n\tIF FormRead(0) = 0 THEN\n\t\tIF check1 = \"1\" THEN\n\t\t\tStartMotor(MOTOR_1);\n\t\tEND\n\t\tIF check2 = \"1\" THEN\n\t\t\tStartMotor(MOTOR_2);\n\t\tEND\n\t\tIF check3 = \"1\" THEN\n\t\t\tStartMotor(MOTOR_3);\n\t\tEND\n\tEND\nEND",
        "name": "FormField",
        "params": [
            {
                "paramdescription": " The number of the column in which the control will beplaced. Enter a number from 0 (column 1) to the form width -1. For example, to place the control in column 8, enter 7.",
                "paramname": "Col"
            },
            {
                "paramdescription": " The number of the row in which the control will be placed.Enter a number from 0 (row 1) to the form height - 1. Forexample, to place the control in row 6, enter 5.",
                "paramname": "Row"
            },
            {
                "paramdescription": " The width of the control device.",
                "paramname": "Width"
            },
            {
                "paramdescription": " The height of the control device.",
                "paramname": "Height"
            },
            {
                "paramdescription": " The type of control device:\n0 - None\n1 - Edit\n2 - Edit Password\n3 - Text\n4 - Button\n5 - OK button\n6 - Cancel button\n7 - Group box\n8 - Radio button\n9 - Check box",
                "paramname": "nType"
            },
            {
                "paramdescription": "The output buffer for the field string. The default value of thecontrol device is initialized to the value of the buffer. If youspecify a Radio button or Check box, you should initializethe buffer to \"0\" or \"1\". The result of the field will also be setto \"0\" or \"1\".",
                "paramname": "Buffer"
            },
            {
                "paramdescription": "The display label for a button, or the default label for an edit field",
                "paramname": "Label"
            },
            {
                "paramdescription": "The callback function to call when the button is selected. Setto 0 to call no function. Please be aware that the Fn parameter needs to be oftype INT, and the callback function cannot contain ablocking function. For types other than 4,5, and 6, set thisargument to 0.",
                "paramname": "Fn"
            },
            {
                "paramdescription": "This optional parameter specifies the maximum length of input text for edit fields (this parameter is ignored for other controls). The default value is 0 meaning the string can havethe maximum length allowed in the system (Cicode allows strings of 255 characters).",
                "paramname": "maxTextLength"
            }
        ],
        "returnType": "The field handle if the field is successfully added, otherwise it will return -1.",
        "syntax": "FormField(Col, Row, Width, Height, Type, Buffer, Label, Fn [, maxTextLength] )"
    },
    "formgetcurrinst": {
        "doc": "Extracts data associated with a field (set by the FormSetInst() function). You should call this function only from within a field callback function. This function is the same as calling the FormCurr() function and then the FormGetInst() function.",
        "example": "INT\nFUNCTION GetNextRec()\n\tINT hDev;\n\tSTRING Str;\n\tFormGetCurrInst(hDev,Str);\n\tDevNext(hDev);\n\tRETURN 0;\nEND",
        "name": "FormGetCurrInst",
        "params": [
            {
                "paramdescription": "Variable containing integer data.",
                "paramname": "iData"
            },
            {
                "paramdescription": " Variable containing string data.",
                "paramname": "sData"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "FormGetCurrInst(iData, sData)"
    },
    "formgetdata": {
        "doc": "Gets all data associated with a form and puts it into the output string buffers. Normally the field data is copied to the output string buffers only when the user selects the [OK] button. If you want to use the data while the form is displayed, call this function to get the data. You should call this function only while the form is displayed otherwise an error is returned, for example, from a field callback function.",
        "example": "! Field callback to save data.\nFUNCTION Save()\n\tINT hForm,hField;\n\tFormCurr(hForm,hField);\n\tFormGetData(hForm);\n\t! Access all data.\n\t..\nEND",
        "name": "FormGetData",
        "params": [
            {
                "paramdescription": " The form handle, returned from the FormNew() function. The form handle identifies the table where all data on the associated form is stored.",
                "paramname": "hForm"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "FormGetData(hForm)"
    },
    "formgetinst": {
        "doc": "Extracts the data associated with a field (set by the FormSetInst() function). You would normally use this function in a field callback function. It allows single callback functions to know that the form and field are associated.",
        "example": "INT\nFUNCTION GetNextRec()\n\tINT hDev,hForm,hField;\n\tSTRING Str;\n\t! Get field data, for example, the hDev value.\n\t..\n\tFormCurr(hForm,hField);\n\tFormGetInst(hForm,hField,hDev,Str);\n\tDevNext(hDev);\n\t! Display new record in form.\n\t..\n\tRETURN 0;\nEND",
        "name": "FormGetInst",
        "params": [
            {
                "paramdescription": " The form handle, returned from the FormNew() function. The form handle identifies the table where all data on the associated form is stored.",
                "paramname": "hForm"
            },
            {
                "paramdescription": " The field handle of the field currently selected.",
                "paramname": "hField"
            },
            {
                "paramdescription": " Integer data.",
                "paramname": "iData"
            },
            {
                "paramdescription": " Variable containing string data.",
                "paramname": "sData"
            }
        ],
        "returnType": "The data (as a string).",
        "syntax": "FormGetInst(hForm, hField, iData, sData)"
    },
    "formgettext": {
        "doc": "Gets the current text from a form field. You should call this function only while the form is displayed; for example,, from a field callback function.",
        "example": "FUNCTION Search()\n\tINT hForm,hField;\n\tSTRING Recipe;\n\tFormCurr(hForm,hField);\n\tRecipe=FormGetText(hForm,hField);\n\t! Go and find recipe.\n\t..\nEND",
        "name": "FormGetText",
        "params": [
            {
                "paramdescription": " The form handle, returned from the FormNew() function. The form handle identifies the table where all data on the associated form is stored.",
                "paramname": "hForm"
            },
            {
                "paramdescription": " The field handle of the field currently selected.",
                "paramname": "hField"
            }
        ],
        "returnType": "The field text (as a string).",
        "syntax": "FormGetText(hForm, hField)"
    },
    "formgoto": {
        "doc": "Goes to a specified form. The form is displayed on top of all windows and the keyboard focus is set to this form.",
        "example": "FormGoto(hForm);",
        "name": "FormGoto",
        "params": [
            {
                "paramdescription": " The form handle, returned from the FormNew() function. The form handle identifies the table where all data on the associated form is stored.",
                "paramname": "hForm"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "FormGoto(hForm)"
    },
    "formgroupbox": {
        "doc": "Adds a group box to the current form. A group box is a form control box drawn to the specified size. If the box contains radio buttons, they are grouped together. You should call this function only after the FormNew() function and before the FormRead() function.\nThe group box is added to the form at the specified column and row position with the specified width and height. Use the FormRadioButton() function to add the radio buttons to the box, and call this function between each group of radio buttons.",
        "example": "! Create a form, add to radio buttons groups and then display the \nform\n! The operator may select one of the radio buttons from each group\nFUNCTION FnMenu()\n\tSTRING sFast, sSlow, sMedium;\n\tSTRING sNorth, sSouth, sEast, sWest;\n\tFormNew(\"Select Item\",40,7,1);\t\n\tFormGroupBox(1 ,1, 15, 5, \"Speed\");\n\tFormRadioButton(2 ,2,\"Fast\",  sFast);\n\tFormRadioButton(2, 3,\"Medium\", sMedium);\n\tFormRadioButton(2 ,4,\"Slow\",  sSlow);\n\tFormGroupBox(19 ,2, 15, 6, \"Direction\");\n\tFormRadioButton(20 ,2,\"North\", sNorth);\n\tFormRadioButton(20, 3,\"South\", sSouth);\n\tFormRadioButton(20 ,4,\"East\", sEast);\n\tFormRadioButton(20 ,5,\"West\", sWest);\n\tFormRead(0);\t\nEND",
        "name": "FormGroupBox",
        "params": [
            {
                "paramdescription": " The number of the column in which the group box will be placed. Enter a number from 0 (column 1) to the form width - 1. For example, to place the group box in column 8, enter 7.",
                "paramname": "Col"
            },
            {
                "paramdescription": " The number of the row in which the group box will be placed. Enter a number from 0 (row 1) to the form height - 1. For example, to place the group box in row 6, enter 5.",
                "paramname": "Row"
            },
            {
                "paramdescription": " The width of the group box, which should be wide enough to display your widest item.",
                "paramname": "Width"
            },
            {
                "paramdescription": " The height of the group box.",
                "paramname": "Height"
            },
            {
                "paramdescription": " The text to display as the group box label.",
                "paramname": "Text"
            }
        ],
        "returnType": "The field handle if the group box is successfully added, otherwise -1 is returned.",
        "syntax": "FormGroupBox(Col, Row, Width, Height [, Text] )"
    },
    "forminput": {
        "doc": "Adds a prompt and edit field to the current form. You should call this function only after the FormNew() function and before the FormRead() function. When FormRead() is called, the form will display with the prompt and edit box. The operator's input is passed back as a string (Text).",
        "example": "FormInput(1,2,\"Recipe\",Recipe,20);",
        "name": "FormInput",
        "params": [
            {
                "paramdescription": " The number of the column in which the prompt will be placed. Enter a number from 0 (column 1) to the form width - 1. For example, to place the prompt in column 8, enter 7.",
                "paramname": "Col"
            },
            {
                "paramdescription": " The number of the row in which the prompt will be placed. Enter a number from 0 (row 1) to the form height - 1. For example, to place the prompt in row 6, enter 5.",
                "paramname": "Row"
            },
            {
                "paramdescription": " The prompt string.",
                "paramname": "Prompt"
            },
            {
                "paramdescription": " Variable containing the output text string containing the operator's input.",
                "paramname": "Text:  - Output Parameter"
            },
            {
                "paramdescription": " The width of the edit field.",
                "paramname": "Width"
            },
            {
                "paramdescription": "This optional parameter specifies the maximum length of input text. The default value is 0 meaning the string can havethe maximum length allowed in the system (Cicode allows strings of 255 characters).",
                "paramname": "maxTextLength"
            }
        ],
        "returnType": "The field handle if it is added successfully, otherwise -1 is returned.",
        "syntax": "FormInput(Col,Row,Prompt,Text,Width [, maxTextLength] )"
    },
    "formlistaddtext": {
        "doc": "Adds a new text entry to a combo box or a list box while the form is displayed. It only adds the text to the list - it does not select it. Use the FormListSelectText() function to select (highlight) an entry. Call this function only when the form is displayed, for example, from a field callback function.",
        "example": "/* create a form with a list */\nhForm = FormNew(\"Ingredients\", 40, 10, 1);\nhField = FormListBox(2,2,20,5,sBuf);\nFormAddList(\"Flour\");\nFormAddList(\"Water\");\nFormAddList(\"Salt\");\nFormAddList(\"Sugar\");\n/* Display the form */\nFormRead(1);    \n..\n/*Add Milk to list */\nFormListAddText(hForm, hField, \"Milk\");\n..",
        "name": "FormListAddText",
        "params": [
            {
                "paramdescription": " The form handle, returned from the FormNew() function. The form handle identifies the table where all data on the associated form is stored.",
                "paramname": "hForm"
            },
            {
                "paramdescription": " The field handle of the field currently selected.",
                "paramname": "hField"
            },
            {
                "paramdescription": " The output text string containing the operator's input.",
                "paramname": "Text"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "FormListAddText(hForm, hField, Text)"
    },
    "formlistbox": {
        "doc": "Adds a list box to the current form. The list box is a form control that allows the operator to select from a list of items. You should call this function only after the FormNew() function and before the FormRead() function.\nThe list box is added to the form at the specified column and row position with the specified width and height. If more items are placed in the list than the list can display, a scroll bar displays for scrolling to the hidden items.\nUse the FormAddList() function to add items for display in the list box. If the form is already displayed, you can use the FormListAddText() and FormListSelectText() functions to add (and highlight) text in the list box.",
        "example": "! Create a form, add list box and then display the form.\n! The operator may select one of the items from the list.\nSTRING sBuf;\nFUNCTION FnMenu()\n\tFormNew(\"Select Item\",20,6,1);\t\n\tFormListBox(2 ,2, 15, 5, sBuf, 1);\n\tFormAddList(\"Item One\");\n\tFormAddList(\"Item two\");\n\tFormAddList(\"Item three\");\n\tFormButton(0,0,\" OK \",0,1);\n\tFormButton(5,0,\" CANCEL \",0,2);\n\tFormRead(0);\n\tSELECTION= sBuf;\nEND",
        "name": "FormListBox",
        "params": [
            {
                "paramdescription": " The number of the column in which the list box will be placed. Enter a number from 0 (column 1) to the form width - 1. For example, to place the list box in column 8, enter 7.",
                "paramname": "Col"
            },
            {
                "paramdescription": " The number of the row in which the list box will be placed. Enter a number from 0 (row 1) to the form height - 1. For example, to place the list box in row 6, enter 5.",
                "paramname": "Row"
            },
            {
                "paramdescription": " The width of the list box, in characters. Width should be wide enough to display your widest item. Items wider than the list box are clipped.",
                "paramname": "Width"
            },
            {
                "paramdescription": " The height of the list box, as the number of items that can be seen in the list box without scrolling.",
                "paramname": "Height"
            },
            {
                "paramdescription": " The string buffer in which to store the selected item. Must be a String type variable.",
                "paramname": "sBuf"
            },
            {
                "paramdescription": " The mode in which to create the list box:\n0 - Sort the list box elements alphabetically.\n1 - Place elements in list box in the order they were added.",
                "paramname": "Mode"
            },
            {
                "paramdescription": "",
                "paramname": "Mode 0 is the default."
            }
        ],
        "returnType": "The field handle if the list box is successfully added, otherwise -1 is returned.",
        "syntax": "FormListBox(Col, Row, Width, Height, sBuf [, Mode] )"
    },
    "formlistdeletetext": {
        "doc": "Deletes an existing text entry from a combo box or a list box while the form is displayed. It only deletes the text from the list - it does not change the selection. Call this function only when the form is displayed, for example, from a field callback function.",
        "example": "/* create a form with a list */\nhForm = FormNew(\"Ingredients\", 40, 10, 1);\nhField = FormListBox(2,2,20,5,sBuf);\nFormAddList(\"Flour\");\nFormAddList(\"Water\");\nFormAddList(\"Salt\");\nFormAddList(\"Sugar\");\n/* Display the form */\nFormRead(1);    \n..\n/*Remove Sugar from the list */\nFormListDeleteText(hForm, hField, \"Sugar\");\n..",
        "name": "FormListDeleteText",
        "params": [
            {
                "paramdescription": " The form handle, returned from the FormNew() function. The form handle identifies the table where all data on the associated form is stored.",
                "paramname": "hForm"
            },
            {
                "paramdescription": " The field handle of the field currently selected.",
                "paramname": "hField"
            },
            {
                "paramdescription": " The text to delete.",
                "paramname": "Text"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "FormListDeleteText(hForm, hField, Text)"
    },
    "formlistselecttext": {
        "doc": "Selects (highlights) a text entry in a Combo box or a List box while the form is displayed. The text to be selected needs to exist in the list. (Use the FormListAddText() function to add a text entry to a list.) Call this function only when the form is displayed, for example, from a field callback function.",
        "example": "/* Create a form with a list */\nhForm = FormNew(\"Ingredients\", 40, 10, 1);\nhField = FormListBox(2,2,20,5,sBuf);\nFormAddList(\"Flour\");\nFormAddList(\"Water\");\nFormAddList(\"Salt\");\nFormAddList(\"Sugar\");\n/* Display the form */\nFormRead(1);    \n..\n/*Select Flour */\nFormListSelectText(hForm, hField, \"Flour\");",
        "name": "FormListSelectText",
        "params": [
            {
                "paramdescription": " The form handle, returned from the FormNew() function. The form handle identifies the table where all data on the associated form is stored.",
                "paramname": "hForm"
            },
            {
                "paramdescription": " The field handle of the field currently selected.",
                "paramname": "hField"
            },
            {
                "paramdescription": " The text to be selected. If this text is not present in the list, then no item will be selected (and this text will not be added).",
                "paramname": "Text"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "FormListSelectText(hForm, hField, Text)"
    },
    "formnew": {
        "doc": "Creates a new data entry form and defines its size and mode. After the form is created, you can add fields, and then display the form.\nBefore you can display a form on the screen, you need to call this function to set the size and mode of the form, and then call the various form field functions, FormInput(), FormButton(), FormEdit() etc to add user input fields to the form. To display the form on the screen (to allow the user to enter data) call the FormRead() function.",
        "example": "FormNew(\"Recipe\",30,5,0);\nFormInput(1,1,\"Recipe No\",Recipe,20);\nFormInput(1,2,\"Amount\",Amount,10);\nFormRead(0);",
        "name": "FormNew",
        "params": [
            {
                "paramdescription": " The title of the form.",
                "paramname": "Title"
            },
            {
                "paramdescription": " The character width of the form (1 to 131).",
                "paramname": "Width"
            },
            {
                "paramdescription": " The character height of the form (1 to 131).",
                "paramname": "Height"
            },
            {
                "paramdescription": " The mode of the form:\n0 - Default font and text spacing\n1 - Small font\n2 - Fixed pitch font\n4 - Static text compression where the vertical spacing is reduced. This can cause formatting errors if buttons are too close, because the vertical spacing will be less than the height of a button.\n8 - Keep the form on top of the Plant SCADA window.\n16 - The current window cannot be changed or closed until the form is finished or cancelled.\n32 - Makes a form with no caption.\n128 - The form will not close if the ESC or ENTER key is pressed, unless you specifically define at least one button on the form which acts as an OK or Cancel button. For a form with no buttons, the ENTER key normally closes the form; this mode disables that behavior.\n256 – Makes a from with no system-menu (mostly appears as a single close button X) .\nMultiple modes can be selected by adding them (for example, to use Modes 4 and 2, specify Mode 6).",
                "paramname": "Mode"
            }
        ],
        "returnType": "The form handle if the form is created successfully, otherwise -1 is returned. The form handle identifies the table where all data on the associated form is stored.",
        "syntax": "FormNew(Title, Width, Height, Mode)"
    },
    "formnumpad": {
        "doc": "Provides a keypad form for the operator to add numeric values. You can customize the standard form as a mathematical keypad, with the +, -, and / operators and the decimal point. For a time keypad, use the AM, PM, and : (hour/minute divider) buttons. You can also include a password edit field.",
        "example": "/* Set defaults first, then four keypad forms to adjust recipe. */\nQty_Flour=FormNumPad(\"Add Flour\", Qty_Flour, 17);\nQty_Water=FormNumPad(\"Add Water\", Qty_Water, 17);\nQty_Salt=FormNumPad(\"Add Salt\", Qty_Salt, 17);\nQty_Sugar=FormNumPad(\"Add Sugar\", Qty_Sugar, 17);",
        "name": "FormNumPad",
        "params": [
            {
                "paramdescription": " The title to display on the number pad form.",
                "paramname": "Title"
            },
            {
                "paramdescription": " The existing or default value. This value is returned if the form is cancelled or accepted without changes.",
                "paramname": "Input"
            },
            {
                "paramdescription": " The buttons to include on the keypad form. The Mode can be a combination of the following:\n0 - Standard keypad\n1 - Password edit field\n2 - not used\n4 - With +/- button\n8 - With / button\n16 - With . button\n32 - With : button\n64 - With AM, PM buttons\n128 - with Now button\n512 - with 1hr, 2hr and 8hr buttons\nMultiple modes can be selected by adding them. For example, to include +/- buttons and a . button, specify Mode 20 (16+4).",
                "paramname": "Mode"
            }
        ],
        "returnType": "The string value entered by the operator. The IsError() function returns 0 (zero). If the form was cancelled, the value of Input is returned, and the IsError() function returns error number 299.",
        "syntax": "FormNumPad(Title, Input, Mode)"
    },
    "formopenfile": {
        "doc": "Displays a File Open dialog box.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "// Display the Open File dialog with the following filter list:\n// All Files (*.*)\n// Exe Files (*.EXE)\n// Cicode Files (*.CI)\nsFilename = FormOpenFile(\"Open\", \"*.CI\", \"All Files (*.*)|*.*|Exe \nFiles (*.EXE)|*.EXE|Cicode Files (*.CI)|*.CI|\");",
        "name": "FormOpenFile",
        "params": [
            {
                "paramdescription": " The name of the default file to display in the \"File Name\" field.",
                "paramname": "sFileName"
            },
            {
                "paramdescription": " A title to display at the top of the form.",
                "paramname": "sTitle"
            },
            {
                "paramdescription": " A file filter list to display in the \"List Files of Type\" field. The file filter list has the following format:\n<File Type>|<Filter>|\nwhere:\nFile Type is the text that displays in the drop-down box, for example All Files (*.*). Filter is the file type, for example *.CI",
                "paramname": "sFilter"
            },
            {
                "paramdescription": "Boolean parameter. When set forces the path to reset to the default path specified.\nTrue = default path specified\nFalse = last file specified\ne.g. FormOpenFile(sTitle, sFileName, sFilter [, bResetToDefault = FALSE])",
                "paramname": "bResetToDefault"
            }
        ],
        "returnType": "The name and full path of the selected file (as a string) or an empty string (\"\") if the Cancel button is selected.",
        "syntax": "FormOpenFile(sTitle, sFileName, sFilter, [bResetToDefault])"
    },
    "formpassword": {
        "doc": "Adds both a password prompt and edit field to the current form. You should call this function only after the FormNew() function and before the FormRead() function. When FormRead() is called, the form will also display the password prompt and edit field.\nThe operator's input is not echoed in the field; a single asterisk (*) is displayed for each character.",
        "example": "! Add Password input.\nFormPassword(1,2,\"Enter Password\",Password,10);",
        "name": "FormPassword",
        "params": [
            {
                "paramdescription": " The number of the column in which the prompt will be placed. Enter a number from 0 (column 1) to the form width - 1. For example, to place the prompt in column 8, enter 7.",
                "paramname": "Col"
            },
            {
                "paramdescription": " The number of the row in which the prompt will be placed. Enter a number from 0 (row 1) to the form height - 1. For example, to place the prompt in row 6, enter 5.",
                "paramname": "Row"
            },
            {
                "paramdescription": " The prompt string.",
                "paramname": "Prompt"
            },
            {
                "paramdescription": " Variable containing the password entered by the operator.",
                "paramname": "Password"
            },
            {
                "paramdescription": " The width of the edit field.",
                "paramname": "Width"
            }
        ],
        "returnType": "The field handle if it is added successfully, otherwise -1 is returned.",
        "syntax": "FormPassword(Col, Row, Prompt, Password, Width)"
    },
    "formposition": {
        "doc": "Sets the position of a form on the screen, before it is displayed. You should call this function only after the FormNew() function and before the FormRead() function.",
        "example": "hForm = FormNew(\"title\", 20, 5, 0);\n! display form at x=100, y=50\nFormPosition(100, 50, 0);",
        "name": "FormPosition",
        "params": [
            {
                "paramdescription": " The x and y pixel coordinates of the form.",
                "paramname": "X, Y"
            },
            {
                "paramdescription": " Not used, set it to 0.",
                "paramname": "Mode"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "FormPosition(X, Y, Mode)"
    },
    "formprompt": {
        "doc": "Adds a prompt field to the current form. You should call this function only after the FormNew() function and before the FormRead() function.",
        "example": "FormPrompt(1,2,\"Enter Recipe\");",
        "name": "FormPrompt",
        "params": [
            {
                "paramdescription": " The number of the column in which the prompt will be placed. Enter a number from 0 (column 1) to the form width - 1. For example, to place the prompt in column 8, enter 7.",
                "paramname": "Col"
            },
            {
                "paramdescription": " The number of the row in which the prompt will be placed. Enter a number from 0 (row 1) to the form height - 1. For example, to place the prompt in row 6, enter 5.",
                "paramname": "Row"
            },
            {
                "paramdescription": " The prompt string.",
                "paramname": "Prompt"
            },
            {
                "paramdescription": "The width of the area that the prompt string will wrap within (measured using average character width). For this setting to be applied, you also need to specify a value for Height. ",
                "paramname": "Width"
            },
            {
                "paramdescription": " The height of the area that the prompt string will display within (measured using average character height). For this setting to be applied, you also need to specify a value for Width. ",
                "paramname": "Height"
            }
        ],
        "returnType": "The field handle if it is added successfully, otherwise -1 is returned.",
        "syntax": "FormPrompt(Col, Row, Prompt [,Width] [,Height])"
    },
    "formradiobutton": {
        "doc": "Adds a radio button to the current form, allowing the operator to make a selection from a multiple choice list. You should call this function only after the FormNew() function and before the FormRead() function.\nThe radio button is added to the form at the specified column and row position. The width of the button will be sized to suit the text.\nBy default, all radio buttons are placed into the one group. If you require separate groups, use this function in conjunction with the FormGroupBox() function.",
        "example": "! Create a form, add radio buttons and then display the form.\n! The operator may only select one radio button , either Fast, \nMedium or Slow\nFUNCTION FnMenu()\n\tSTRING\tsFast, sSlow, sMedium;\n\tsFast  = \"1\";\n\tsMedium = \"0\";\n\tsSlow  = \"0\";\n\tFormNew(\"Speed\",20,6,1);\t\n\tFormRadioButton(2 ,2,\"Fast\",  sFast);\n\tFormRadioButton(2, 3,\"Medium\", sMedium);\n\tFormRadioButton(2 ,4,\"Slow\",  sSlow);\n\tFormRead(0);\t\n\tIf sFast = \"1\" THEN\n\t\t! do fast stuff\n\tELSE\n\tIF sMedium = \"1\" THEN\n\t\t! do Medium stuff\n\tELSE\n\tIF sSlow = \"1\" THEN\n\t\t! do slow stuff\n\tEND\nEND",
        "name": "FormRadioButton",
        "params": [
            {
                "paramdescription": " The number of the column in which the button will be placed. Enter a number from 0 (column 1) to the form width - 1. For example, to place the button in column 8, enter 7.",
                "paramname": "Col"
            },
            {
                "paramdescription": " The number of the row in which the button will be placed. Enter a number from 0 (row 1) to the form height - 1. For example, to place the button in row 6, enter 5.",
                "paramname": "Row"
            },
            {
                "paramdescription": " The text associated with the radio button.",
                "paramname": "sText"
            },
            {
                "paramdescription": " The string buffer in which to put the state of the radio button. You should initialize this buffer to the state of the button. When the form returns, this buffer will contain either '1' or '0' if the radio button is checked.",
                "paramname": "sBuf"
            }
        ],
        "returnType": "The field handle if the radio button is successfully added, otherwise -1 is returned.",
        "syntax": "FormRadioButton(Col, Row, sText, sBuf)"
    },
    "formread": {
        "doc": "Displays the current form (created with the FormNew() function), with all the fields that were added (with the form field functions).\nYou can display the form and wait for the user to finish entering data by setting the Mode to 0. This mode is the most commonly used, with [OK] and [Cancel] buttons to either save or discard operator entries and to close the form.\nTo display the form and return before the user has finished, use Mode 1. This mode is used to animate the data on the form or to perform more complex operations.\nThis function is a blocking function. It will block the calling Cicode task until the operation is complete.",
        "example": "! Display the form and wait for the user.\nFormRead(0);\n! Display the form and do not wait for the user.\nFormRead(1);\n! While the form is displayed, update the time every second.\nWHILE FormActive(hForm) DO\n    FormSetText(hForm,hField,Time());\n    Sleep(1);\nEND",
        "name": "FormRead",
        "params": [
            {
                "paramdescription": "",
                "paramname": "Mode"
            },
            {
                "paramdescription": "0 - Wait for the user.\n1 - Do not wait for the user.",
                "paramname": "Mode of the form"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "FormRead(Mode)"
    },
    "formsaveasfile": {
        "doc": "Displays a File Save As dialog box.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "// Display the SaveAs dialog with the following filter list:\n// All Files (*.*)\n// Exe Files (*.EXE)\n// Cicode Files (*.CI)\nsFilename = FormSaveAsFile(\"Save As\", \"Alarms\", \"All Files \n(*.*)|*.*|Exe Files (*.EXE)|*.EXE|Cicode Files (*.CI)|*.CI|\", \n\"ci\");",
        "name": "FormSaveAsFile",
        "params": [
            {
                "paramdescription": "A title to display at the top of the form.",
                "paramname": "sTitle"
            },
            {
                "paramdescription": "The name of the default file to display in the \"File Name\" field.",
                "paramname": "sFileName"
            },
            {
                "paramdescription": "A file filter list to display in the \"List Files of Type\" field. The file filter list has the following format:\n<File Type>|<Filter>|\nwhere:\nFile Type is the text that displays in the drop-down box, for example All Files (*.*). Filter is the file type, for example *.CI",
                "paramname": "sFilter"
            },
            {
                "paramdescription": "The file extension that will be used as a default when you use the FormSaveAsFile() function. If you do not specify a default extension, files will be saved without an extension.",
                "paramname": "sDefExt"
            }
        ],
        "returnType": "The name and full path of the selected file (as a string) or an empty string (\"\") if the Cancel button is selected.",
        "syntax": "FormSaveAsFile(sTitle, sFileName, sFilter [, sDefExt] )"
    },
    "formsecurepassword": {
        "doc": "Adds both a password prompt and edit field to the current form. You should call this function only after the FormNew() function and before the FormRead() function. When FormRead() is called, the form will also display the password prompt and edit field.\nThe operator's input is not echoed in the field; a single asterisk (*) is displayed for each character. The function does not return the password as a plaintext, it returns an  encrypted password string. The user can send this string to the UserLogin or UserVerify functions.",
        "example": "! Add Password input.\nFormSecurePassword(1,2,\"Enter Password\",Password,10);",
        "name": "FormSecurePassword",
        "params": [
            {
                "paramdescription": " The number of the column in which the prompt will be placed. Enter a number from 0 (column 1) to the form width - 1. For example, to place the prompt in column 8, enter 7.",
                "paramname": "Col"
            },
            {
                "paramdescription": " The number of the row in which the prompt will be placed. Enter a number from 0 (row 1) to the form height - 1. For example, to place the prompt in row 6, enter 5.",
                "paramname": "Row"
            },
            {
                "paramdescription": " The prompt string. Must be a String type variable.",
                "paramname": "Prompt"
            },
            {
                "paramdescription": " The encrypted password entered by the operator.",
                "paramname": "Password"
            },
            {
                "paramdescription": " The width of the edit field.",
                "paramname": "Width"
            }
        ],
        "returnType": "The field handle if it is added successfully, otherwise -1 is returned.",
        "syntax": "FormSecurePassword(Col, Row, Prompt, Password, Width)"
    },
    "formselectprinter": {
        "doc": "Displays the Select Printer dialog box.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "// Display the Select Printer dialog\nsPrinter = FormSelectPrinter();",
        "name": "FormSelectPrinter",
        "params": [],
        "returnType": "The name of the selected printer (as a string) or an empty string (\"\") if the Cancel button is selected.",
        "syntax": "FormSelectPrinter()"
    },
    "formsetdata": {
        "doc": "Sets all the edit data from the string buffers into the form. You should call this function only while the form is active.",
        "example": "INT\nFUNCTION MyNextRec()\n\tINT hForm,hField;\n\tFormCurr(hForm,hField);\n\tFormSetData(hForm);\n\tRETURN 0;\nEND",
        "name": "FormSetData",
        "params": [
            {
                "paramdescription": " The form handle, returned from the FormNew() function. The form handle identifies the table where all data on the associated form is stored.",
                "paramname": "hForm"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "FormSetData(hForm)"
    },
    "formsetinst": {
        "doc": "Associates an integer and string value with each field on a form. This data could then be used by a callback function. You can use a single callback function for all fields, and use the data to perform different operations for each field.",
        "example": "! Open recipe database.\nhDev=DevOpen(\"Recipe\", 0);\nhForm=FormNew(\"Recipe\",20,5,0);\nhField=FormButton(5,2,\"Next\",GetNextRec,0);\nFormSetInst(hForm,hField,hDev,\"\");\n/* The device handle hDev is put into the next button , so when the \nbutton is selected it can get hDev and get the next record. */",
        "name": "FormSetInst",
        "params": [
            {
                "paramdescription": " The form handle, returned from the FormNew() function. The form handle identifies the table where all data on the associated form is stored.",
                "paramname": "hForm"
            },
            {
                "paramdescription": " The field handle of the field currently selected.",
                "paramname": "hField"
            },
            {
                "paramdescription": " Integer data.",
                "paramname": "iData"
            },
            {
                "paramdescription": " String data.",
                "paramname": "sData"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "FormSetInst(hForm, hField, iData, sData)"
    },
    "formsettext": {
        "doc": "Sets new field text on a field. This function allows you to change field text while the form is displayed. Call this function only when the form is displayed, for example, from a field callback function.\nIf you are using this function on a Combo box or a List box, it will select the text from the Combo box or List box list. If no text exists in the Combo box or List box list, the function will add it.",
        "example": "/* Create a form with a field */\nhForm = FormNew(\"Ingredients\", 40, 10, 1);\nhField = FormPrompt(2,2,\"Motor1:\");\n/* Display the form*/\nFormRead(1); \n..\n/* Change the text in the field */\nFormSetText(hForm, hField, \"Pump1:\");\n..",
        "name": "FormSetText",
        "params": [
            {
                "paramdescription": " The form handle, returned from the FormNew() function. The form handle identifies the table where all data on the associated form is stored.",
                "paramname": "hForm"
            },
            {
                "paramdescription": " The field handle of the field currently selected. If the hField is a handle to the secure edit field created with FormSecurePassword, the text in the secure edit field will not be changed. However, when an empty string is passed to FormSetText(), the contents of the secure editfield will be cleared.",
                "paramname": "hField"
            },
            {
                "paramdescription": " New field text.",
                "paramname": "Text"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "FormSetText(hForm, hField, Text)"
    },
    "formwndhnd": {
        "doc": "Gets the window handle for the given form. The window handle may be used by 'C' programs and Plant SCADAWnd... functions. You should call this function only after the FormRead() function.\nThe window handle is not the same as the Plant SCADA window number and cannot be used with functions that expect the Plant SCADA window number (the Win... functions).",
        "example": "/* Create a form with a field */\nhForm  = FormNew(\"Ingredients\", 40, 10, 1);\nhField = FormPrompt(2,2,\"Motor1:\");\n/* Display the form*/\nFormRead(1);\n/* Get the form's window number for future reference */\nhWnd     = FormWndHnd(hForm);",
        "name": "FormWndHnd",
        "params": [
            {
                "paramdescription": " The form handle, returned from the FormNew() function.The form handle identifies the table where data on theassociated form is stored.",
                "paramname": "hForm"
            }
        ],
        "returnType": "The window handle if successful, otherwise a 0 is returned.",
        "syntax": "FormWndHnd(hForm)"
    },
    "fullname": {
        "doc": "Gets the full name of the user who is currently logged on to the system. The user can be a Plant SCADA or a Windows user. For a Plant SCADA user the full name is the one defined in the users form. For a Windows user the full name is in the format of <DomainName>\\<UserName>.When there is no one logged in or the logged in user is a \"system user\" this function returns an empty string.",
        "example": "/* Display the full name of the current user at AN20. */\nDspText(20, 0, FullName());",
        "name": "FullName",
        "params": [],
        "returnType": "The user name (as a string).",
        "syntax": "FullName()"
    },
    "fuzzyclose": {
        "doc": "Frees all memory and information for the specified instance. After the fuzzy instance is closed, the handle given in the hFuzzy parameter is no longer valid.",
        "example": "No example found",
        "name": "FuzzyClose",
        "params": [
            {
                "paramdescription": " The fuzzy instance handle (and integer greater than 0).",
                "paramname": "hFuzzy"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "FuzzyClose(hFuzzy)"
    },
    "fuzzygetcodevalue": {
        "doc": "Gets a value for the specified input of the specified instance.",
        "example": "No example found",
        "name": "FuzzyGetCodeValue",
        "params": [
            {
                "paramdescription": " The fuzzy instance handle (and integer greater than 0).",
                "paramname": "hFuzzy"
            },
            {
                "paramdescription": " Specifies the variable to receive the value. The I/O-Indices start with 0 and increment by 1 for each variable. To find the correct index for a specific variable, the variables need to be sorted in alpha-numerical order, first the inputs and then the outputs.",
                "paramname": "iIOIndex"
            },
            {
                "paramdescription": " Variable to receive the new value of the No-hit-flag. The No-hit-flag is TRUE if no rule was active for the variable specified by iIOIndex, otherwise it is FALSE. Must be an Integer type variable - it cannot be a constant or PLC variable tag.",
                "paramname": "NoHitFlag"
            }
        ],
        "returnType": "The code value if the function was successful, otherwise -1. Use IsError() to find\nthe  error number if the function does not succeed.",
        "syntax": "FuzzyGetCodeValue(hFuzzy, iIOIndex, NoHitFlag)"
    },
    "fuzzygetshellvalue": {
        "doc": "Gets a value for the specified input of the specified instance. The variables in the instance needs to have the data type REAL (floating point values).",
        "example": "No example found",
        "name": "FuzzyGetShellValue",
        "params": [
            {
                "paramdescription": " The fuzzy instance handle (and integer greater than 0).",
                "paramname": "hFuzzy"
            },
            {
                "paramdescription": " Specifies the variable to receive the value. The I/O-Indices start with 0 and increment by 1 for each variable. To find the correct index for a specific variable, the variables need to be sorted in alpha-numerical order, first the inputs and then the outputs.",
                "paramname": "iIOIndex"
            },
            {
                "paramdescription": " Variable to receive the new value of the No-hit-flag. The No-hit-flag is TRUE if no rule was active for the variable specified by iIOIndex, otherwise it is FALSE. Must be an Integer type variable - it cannot be a constant or PLC variable tag.",
                "paramname": "NoHitFlag"
            }
        ],
        "returnType": "The shell value if the function was successful. Use IsError() to find the error number if the function does not succeed.",
        "syntax": "FuzzyGetShellValue(hFuzzy, iIOIndex, NoHitFlag)"
    },
    "fuzzyopen": {
        "doc": "This function loads a *.FTR file, allocates memory and creates a handle for this fuzzy instance. To use the FuzzyTech functions you need to be a registered user of one or more of the following fuzzyTech products: fuzzyTECH Online Edition, fuzzyTECH Precompiler Edition, or fuzzyTECH for Business PlusC. And you need to only use fuzzyTECH to generate the *.FTR file for FTRUN.\nThe application needs to call the FuzzyClose function to delete each fuzzy instance handle returned by the FuzzyOpen function.",
        "example": "INT hFuzzy;\nINT NoHitFlag;\nINT Status;\nREAL MemOutput;\n// open the Fuzzy Tech runtime instance\nhFuzzy = FuzzyOpen\n(\"%PROGRAMFILES(X86)%\\\nAVEVA\nPlant SCADA\n\\Bin\\traffic.ftr\");\nStatus = IsError();\nIF hFuzzy <> -1 THEN\n    MemOutput = PLCOutput;\n    WHILE Status = 0 DO\n        FuzzySetShellValue(hFuzzy, 0, 42.0);\n        FuzzySetShellValue(hFuzzy, 1, 3.14150);\n        MemOutput = FuzzyGetShellValue(hFuzzy, 2, NoHitFlag);\n        Status = IsError();\n        // Only write to PLC if output changes.\n        // This reduces load on PLC communication.\n        IF MemOutput <> PLCOutput THEN\n            PLCOutput = MemOutput;\n        END\n        SleepMS(500);\n    END\n    FuzzyClose(hFuzzy);\nEND",
        "name": "FuzzyOpen",
        "params": [
            {
                "paramdescription": " Specifies the filename of the .FTR file to load.",
                "paramname": "sFile"
            }
        ],
        "returnType": "The handle to the fuzzy instance, or -1 if the function cannot complete the operation. Use IsError() to find the error number.",
        "syntax": "FuzzyOpen(sFile)"
    },
    "fuzzysetcodevalue": {
        "doc": "Sets a value for the specified input of the specified instance.",
        "example": "No example found",
        "name": "FuzzySetCodeValue",
        "params": [
            {
                "paramdescription": " The fuzzy instance handle (and integer greater than 0).",
                "paramname": "hFuzzy"
            },
            {
                "paramdescription": " Specifies the variable to receive the value. The I/O-Indices start with 0 and increment by 1 for each variable. To find the correct index for a specific variable, the variables need to be sorted in alpha-numerical order, first the inputs and then the outputs.",
                "paramname": "iIOIndex"
            },
            {
                "paramdescription": " The value to be copied to the variable specified by iIOIndex.",
                "paramname": "iCodeValue"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "FuzzySetCodeValue(hFuzzy, iIOIndex, iCodeValue)"
    },
    "fuzzysetshellvalue": {
        "doc": "Sets a value for the specified input of the specified instance.",
        "example": "No example found",
        "name": "FuzzySetShellValue",
        "params": [
            {
                "paramdescription": " The fuzzy instance handle (and integer greater than 0).",
                "paramname": "hFuzzy"
            },
            {
                "paramdescription": " Specifies the variable to receive the value. The I/O-Indices start with 0 and increment by 1 for each variable. To find the correct index for a specific variable, the variables need to be sorted in alpha-numerical order, first the inputs and then the outputs.",
                "paramname": "iIOIndex"
            },
            {
                "paramdescription": " The value to be copied to the variable specified by iIOIndex.",
                "paramname": "rShellValue"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "FuzzySetShellValue(hFuzzy, iIOIndex, rShellValue)"
    },
    "fuzzytrace": {
        "doc": "Controls the trace process (starting and stopping) of the specified instance.",
        "example": "No example found",
        "name": "FuzzyTrace",
        "params": [
            {
                "paramdescription": " The fuzzy instance handle (and integer greater than 0).",
                "paramname": "hFuzzy"
            },
            {
                "paramdescription": " Specifies whether to start or to stop a trace process for the Fuzzy instanse specified by hFuzzy. If this parameter is TRUE (1), the trace process is started. If this parameter is FALSE (0), the trace process is stopped.",
                "paramname": "TraceOn"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "FuzzyTrace(hFuzzy, TraceOn)"
    },
    "getarea": {
        "doc": "Gets the current logged-in areas.",
        "example": "! If the current areas are 1, 5 and 20:\n\nhGrp=GetArea();\n\nStr=GrpToStr(hGrp);\n\n! sets Str to \"1,5,20\".",
        "name": "GetArea",
        "params": [],
        "returnType": "The login area groups as an integer that represents a group handle. If this group is modified, the actual login areas do not change.",
        "syntax": "GetArea()"
    },
    "getbluevalue": {
        "doc": "Returns the Blue component of a packed RGB color.",
        "example": "No example found",
        "name": "GetBlueValue",
        "params": [
            {
                "paramdescription": " The packed RGB color.",
                "paramname": "nPackedRGB"
            }
        ],
        "returnType": "The red value (0-255) - if successful, otherwise an error is returned.",
        "syntax": "GetBlueValue(nPackedRGB)"
    },
    "getenv": {
        "doc": "Gets a DOS environment variable.",
        "example": "/* Get the current DOS path. */\nsPath = GetEnv(\"Path\");",
        "name": "GetEnv",
        "params": [
            {
                "paramdescription": " The name of the environment variable. The length of the name should not exceed 255 characters.",
                "paramname": "sName"
            }
        ],
        "returnType": "The DOS environment variable (as a string).The return value returns up to 255 characters and is truncated if exceeds.",
        "syntax": "GetEnv(sName)"
    },
    "getevent": {
        "doc": "Gets the function handle of the existing callback event handler. You can use this function handle in the ChainEvent() function to chain call the existing event function, or in the SetEvent() function to restore the event handler.",
        "example": "! Get existing event handler.\nhFn=GetEvent(0);\n! Trap mouse movements.\nOnEvent(0,MouseFn);\n..\n! Restore old event handler.\nSetEvent(0,hFn);\nINT\nFUNCTION MouseFn()\n\t..\n\t! Chain call old event handler.\n\tRETURN ChainEvent(hFn);\nEND",
        "name": "GetEvent",
        "params": [
            {
                "paramdescription": "The type of event:\n0 - The mouse has moved. When the mouse moves the callback function is called. The return value must be 0.\n1 - A key has been pressed. When the user presses a key, the callback function is called after Plant SCADA checks for hot keys. If the return value is 0, Plant SCADA checks for key sequences. If the return value is not 0, Plant SCADA assumes that you will process the key and does not check the key sequence. It is up to you to remove the key from the key command line.\nIf you are using a right mouse button click as an event, you should read about the ButtonOnlyLeftClick parameter.\n2 - Error event. This event is called if an error is detected in Cicode, so you can write a single error function to check for your errors. If the return value is 0, Plant SCADA continues to process the error and generates a hardware error - it may then halt the Cicode task. If the return value is not 0, Plant SCADA assumes that you will process the error, and continues the Cicode without generating a hardware error.\n3 - Page user communication error. A communication error has been detected in the data required for this page. If the return value is 0 (zero), Plant SCADA still animates the page. If the return value is not zero, it does not update the page.\n4 - Page user open. A new page is being opened. This event allows you to define a single function that is called when all pages are opened. The return value must be 0.\n5 - Page user close. The current page is being closed. This event allows you to define a single function that is called when all pages are closed. The return value must be 0.\n6 - Page user always. The page is active. This event allows you to define a single function that is called when all pages are active. The return value must be 0.\n7 - Page communication error. A communication error has been detected in the data required for this page. Reserved for use by Plant SCADA.\n8 - Page open. This event is called each time a page is opened. Reserved for use by Plant SCADA.\n9 - Page close. This event is called each time a page is closed. Reserved for use by Plant SCADA.\n10 - Page always. This event is called while a page is active. Reserved for use by Plant SCADA.\n11..17 - Undefined.\n18 - Report start. The report server is about to start a new report. This event is called on the report server. The return value must be 0.\n19 - Device history. A device history has just completed. The return value must be 0.\n20 - Login. A user has just logged in.\n21 - Logout. A user has just logged out.\n22 - Trend needs repainting. This event is called each time Plant SCADA re-animates a real-time trend or scrolls an historical trend. You should use this event to add additional animation to a trend, because Plant SCADA deletes all existing animation when a trend is re-drawn. (For example, if you want to display extra markers, you must use this event.)\n23 - Hardware error has been detected.\n24 - Keyboard cursor moved. This event is called each time the keyboard command cursor moves. The cursor can be moved by the cursor keys, the mouse, or the Cicode function KeySetCursor(). Note that you can find where the keyboard command cursor is located by calling the function KeyGetCursor().\n25 - Network shutdown. A Shutdown network command has been issued.\n26 - Runtime system shutdown and restart. (Required because of configuration changes.)\n27 - Event. An event has occurred.\n28 - Accumulator. An accumulator has logged a value.\n29 - Slider. A slider has been selected.\n30 - Slider. A slider has moved.\n31 - Slider. A slider has been released (that is stopped moving).\nWhile responding to slider events 29, 30, and 31, you can set any variables but you cannot call functions that cause immediate changes to animations on the page (for example, DspText() and DspSym()). Types 29, 30, & 31 relate only to V3.xx and V4.xx animations, and will be superseded in future releases.\n32 - Shutdown. Plant SCADA is being shutdown.\n33 - Reserved for Plant SCADA internal use.\n34 - 41 - Plant SCADA Confirmation Events. Reserved for Plant SCADA internal use. For the confirmation events, two sets of event type code are defined. The runtime calls the Plant SCADA event handler first, and conditionally proceed to the user's event handler depending on the return value of the Plant SCADA event handler. \n34 -Plant SCADA Event: Child Window Close Confirmation.\n35 - Plant SCADA Event: Main Window Close Confirmation.\n36 - Plant SCADA Event: Maximize Window Confirmation.\n37 - Plant SCADA Event: Minimize Window Confirmation.\n38 - Plant SCADA Event: Restore Window Confirmation.\n39 - Plant SCADA Event: Move Window Confirmation.\n40 - Plant SCADA Event: Size Window Confirmation.\n41 - Plant SCADA Event: Shutdown Confirmation Confirmation.\n42 to 49 - User Confirmation Events. These functions are called when a specific event (mainly from Window title bar) occur and before the runtime performs the intended action. This gives a chance for the user to decide what to do with the event. If the return value is 0, the event will be passed on to the default handler so the intended action will be performed. If the return value is not 0, the event will be ignored and no further action will be taken.\n42 - Child Window Close Confirmation, when the close button of the windows' title bar is clicked or an equivalent Windows' message is received.\n43 - Main Window Close Confirmation, when close button of the windows' title bar is clicked which will cause the process to shutdown.\n44 - Maximize Window Confirmation, when the maximize button of the windows' title bar is clicked or an equivalent Windows' message is received.\n45- Minimize Window Confirmation, when the minimize button of the windows' title bar is licked or an equivalent Windows' message is received.\n46 - Restore Window Confirmation, when the restore button of the windows' title bar is clicked or an equivalent Windows' message is received.\n47 - Move Window Confirmation, when the window is being dragged or an equivalent Windows' message is received.\n48 - Size Window Confirmation, when the windows is being resized or an equivalent Windows' message is received.\n49 - Shutdown Confirmation, when shutdown() function is called.\n50 - 127 - Reserved for future Plant SCADA use.\n128 - 256 - User-defined events. These events are for your own use.",
                "paramname": "Type"
            }
        ],
        "returnType": "The function handle of the existing callback event handler, or -1 if there are no event handlers.",
        "syntax": "GetEvent(nType)"
    },
    "getgreenvalue": {
        "doc": "Returns the green component of a packed RGB color.",
        "example": "No example found",
        "name": "GetGreenValue",
        "params": [
            {
                "paramdescription": " The packed RGB color.",
                "paramname": "nPackedRGB"
            }
        ],
        "returnType": "The red value (0-255) - if successful, otherwise an error is returned.",
        "syntax": "GetGreenValue(nPackedRGB)"
    },
    "getlanguage": {
        "doc": "Gets the language currently used on the display client.",
        "example": "// login a user -> Login(\"ConfigUsers\",\"SCADA\",1,\"German(Germany)\")\nSTRING sLanguage;\nsLanguage = GetLanguage(0)  //  will return German(Germany)\nsLanguage = GetLanguage(1)  //  will return de-DE",
        "name": "GetLanguage",
        "params": [
            {
                "paramdescription": "The type of language information to be returned:\n0 (default) — the name of the current language as defined in the project. For example, \"English (United States)\" or \"French (France)\".\n1 — the country language code of the current language. Includes the language code (ISO-639) and country code (ISO-3166), for example: \n\"en-US\" for English (United States)",
                "paramname": "iType"
            }
        ],
        "returnType": "The specified information describing the language that is currently in use.",
        "syntax": "STRING GetLanguage(INT iType)"
    },
    "getlogging": {
        "doc": "Gets the current value for logging parameters.\nThe parameters you can query include the following:",
        "example": "No example found",
        "name": "GetLogging",
        "params": [
            {
                "paramdescription": " The INI section name.",
                "paramname": "Section"
            },
            {
                "paramdescription": " The system parameter name.",
                "paramname": "sName"
            }
        ],
        "returnType": "If the function succeeds, the value is returned as a string. An empty string is returned if an error occurs. To get extended error information, call IsError().",
        "syntax": "GetLogging(Section, Name)"
    },
    "getpriv": {
        "doc": "Checks if the current user has a privilege for a specified area. With this function, you can write your own Cicode functions to control user access to the system.",
        "example": "/* User needs to have privilege 2, or cannot do operation. */\nIF GetPriv(2, 0) THEN\n    ! Do operation here\nELSE\n    Prompt(\"No privilege for command\");\nEND",
        "name": "GetPriv",
        "params": [
            {
                "paramdescription": " The privilege level (1..8).",
                "paramname": "Priv"
            },
            {
                "paramdescription": " The area of privilege (0..255).",
                "paramname": "Area"
            }
        ],
        "returnType": "Returns 1 if the user has the specified privilege in the area, or 0 (zero) if the user does not have the privilege.",
        "syntax": "GetPriv(Priv, Area)"
    },
    "getredvalue": {
        "doc": "Returns the red component of a packed RGB color.",
        "example": "No example found",
        "name": "GetRedValue",
        "params": [
            {
                "paramdescription": " The packed RGB color.",
                "paramname": "nPackedRGB"
            }
        ],
        "returnType": "The red value (0-255) - if successful, otherwise an error is returned.",
        "syntax": "GetRedValue(nPackedRGB)"
    },
    "getwintitle": {
        "doc": "Returns the name of the active window as a string.",
        "example": "No example found",
        "name": "GetWinTitle",
        "params": [],
        "returnType": "The title of the active window as a string if successful; otherwise, an error is returned.",
        "syntax": "GetWinTitle()"
    },
    "grpclose": {
        "doc": "Closes a group. The group is destroyed and the group handle becomes invalid. You should close a group when it is not in use, to release the associated memory. Plant SCADA closes all groups on shutdown.",
        "example": "hGrp=GrpOpen(\"MyGrp\",1);\n..\nGrpClose(hGrp);",
        "name": "GrpClose",
        "params": [
            {
                "paramdescription": " The group handle, returned from the GrpOpen() function. The group handle identifies the table where all data on the associated group is stored.",
                "paramname": "hGrp"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "GrpClose(hGrp)"
    },
    "grpdelete": {
        "doc": "Deletes a single element or all elements from a group. You can also delete another group from within the group.",
        "example": "! Delete 10 and 14 from a group.\nGrpDelete(hGrp,10);\nGrpDelete(hGrp,14);",
        "name": "GrpDelete",
        "params": [
            {
                "paramdescription": " The group handle, returned from the GrpOpen() function. The group handle identifies the table where all data on the associated group is stored.",
                "paramname": "hGrp"
            },
            {
                "paramdescription": " The element to delete from the group, from 0 to 16375.\nSet Value to -1 to delete all elements from the group.\nSet Value to a group handle to delete another group from this group.\n0 (zero) if successful, otherwise an error is returned.",
                "paramname": "Value"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "GrpDelete(hGrp, Value)"
    },
    "grpfirst": {
        "doc": "Gets the value of the first element in a group. The first element in the group is the element with the lowest value. You can follow this function with a GrpNext() call, to get the value of all the elements in a group.",
        "example": "Value=GrpFirst(hGrp);\nIF Value<>-1 THEN\n    Prompt(\"First value is \"+Value:###);\nEND",
        "name": "GrpFirst",
        "params": [
            {
                "paramdescription": " The group handle, returned from the GrpOpen() function. The group handle identifies the table where all data on the associated group is stored.",
                "paramname": "hGrp"
            }
        ],
        "returnType": "The value of the first element in a group or -1 if the group is empty.",
        "syntax": "GrpFirst(hGrp)"
    },
    "grpin": {
        "doc": "Determines if an element is in a group.",
        "example": "IF GrpIn(hGrp,10) THEN\n    Prompt(\"Area 10 in this group\");\nEND",
        "name": "GrpIn",
        "params": [
            {
                "paramdescription": " The group handle, returned from the GrpOpen() function. The group handle identifies the table where all data on the associated group is stored.",
                "paramname": "hGrp"
            },
            {
                "paramdescription": " The element to locate, from 0 to 16375.\nSet Value to a group handle to check if another group exists in the group.\n1 if the element is in the group, otherwise 0 is returned.",
                "paramname": "Value"
            }
        ],
        "returnType": "1 if the element is in the group, otherwise 0 is returned.",
        "syntax": "GrpIn(hGrp, Value)"
    },
    "grpinsert": {
        "doc": "Adds an element (or another group) to a group.",
        "example": "! Add 10 and 14 to a group.\nGrpInsert(hGrp,10);\nGrpInsert(hGrp,14);",
        "name": "GrpInsert",
        "params": [
            {
                "paramdescription": " The group handle, returned from the GrpOpen() function. The group handle identifies the table where all data on the associated group is stored.",
                "paramname": "hGrp"
            },
            {
                "paramdescription": " The element to add to the group, from 0 to 16375.\nSet Value to -1 to add all elements (0 to 16375) to the group.\nSet Value to a group handle to insert another group into the group.\n0 (zero) if successful, otherwise an error is returned.",
                "paramname": "Value"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "GrpInsert(hGrp, Value)"
    },
    "grpmath": {
        "doc": "Performs mathematical operations on two groups, and stores the result in another group. You can add the two groups, subtract one from the other, or perform Boolean AND, NOT, and XOR operations on the two groups.",
        "example": "hOne=GrpOpen(\"Plantwide\",0);\nhTwo=GrpOpen(\"Section1\",0);\nhResult=GrpOpen(\"Result\",0);\n! Subtract Section1 from Plantwide and place in Result.\nGrpMath(hResult,hOne,hTwo,1);",
        "name": "GrpMath",
        "params": [
            {
                "paramdescription": "The group number where the result is placed.",
                "paramname": "hResult"
            },
            {
                "paramdescription": "Number of first group used in the mathematical operation.",
                "paramname": "hOne"
            },
            {
                "paramdescription": "Number of the second group used in the mathematical operation.",
                "paramname": "hTwo"
            },
            {
                "paramdescription": "",
                "paramname": "nType"
            },
            {
                "paramdescription": "0 - Add groups one and two.\n1 - Subtract group two from group one.\n2 - AND groups one and two.\n3 - NOT groups one and two.\n4 - XOR groups one and two.",
                "paramname": "Type of mathematical operation"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "GrpMath(hResult, hOne, hTwo, Type)"
    },
    "grpname": {
        "doc": "Gets the name of a group from a group handle.",
        "example": "! Get the current group name.\nsName=GrpName(hGrp);",
        "name": "GrpName",
        "params": [
            {
                "paramdescription": " The group handle, returned from the GrpOpen() function. The group handle identifies the table where all data on the associated group is stored.",
                "paramname": "hGrp"
            }
        ],
        "returnType": "The name of the group (as a string).",
        "syntax": "GrpName(hGrp)"
    },
    "grpnext": {
        "doc": "Gets the value of the next element in a group. You can get the value of all the elements in a group. Call the GrpFirst() function to get the value of the first element, and then call this function in a loop.",
        "example": "! Count all values in a group.\nCount=0;\nValue=GrpFirst(hGrp);\nWHILE Value<>-1 DO\n    Count=Count+1;\n    Value=GrpNext(hGrp,Value);\nEND\nPrompt(\"Number of values in group is \"+Count:###);",
        "name": "GrpNext",
        "params": [
            {
                "paramdescription": " The group handle, returned from the GrpOpen() function. The group handle identifies the table where all data on the associated group is stored.",
                "paramname": "hGrp"
            },
            {
                "paramdescription": " The value returned from GrpFirst() or the latest GrpNext() call.",
                "paramname": "Value"
            }
        ],
        "returnType": "The value of the next element in a group, or -1 if the end of the group has been found.",
        "syntax": "GrpNext(hGrp, Value)"
    },
    "grpopen": {
        "doc": "Creates a group and returns a group handle, or gets the group handle of an existing group. After you open a group, you can use the group number in functions that use groups, for example, SetArea() and AlarmSetInfo(). You can open a group that is specified in the Groups database. You can also create groups at runtime.\nWhen you open a group that is defined in the database, a copy of the group is made - the original group is not used. You can therefore change the values in the group without affecting other facilities that use this group.",
        "example": "! Open Plantwide group defined in the database.\nhGrp=GrpOpen(\"Plantwide\",0);\n! Set current user area to Plantwide.\nSetArea(hGrp);\nGrpClose(hGrp);\n! Set area to 1...10, 20 and 25 by creating a new group.\nhGrp=GrpOpen(\"MyGrp\",1);\nStrToGrp(hGrp,\"1..10,20,25\");\nSetArea(hGrp);\nGrpClose(hGrp);",
        "name": "GrpOpen",
        "params": [
            {
                "paramdescription": " The name of the group to open.",
                "paramname": "sName"
            },
            {
                "paramdescription": " The mode of the open:\n0 - Open an existing group\n1 - Create a new group\n2 - Attempts to open an existing group. If the group does not exist, it will create it.",
                "paramname": "Mode"
            }
        ],
        "returnType": "The group handle , or -1 if the group cannot be created or opened. The group handle identifies the table where data on the associated group is stored.",
        "syntax": "GrpOpen(sName, nMode)"
    },
    "grptostr": {
        "doc": "Converts a group into a string of values separated by \" , \" and \" .. \". You can then display the group on the screen or in a report.",
        "example": "! Display current areas.\nhGrp=GetArea();\nStr=GrpToStr(hGrp);\nDspStr(21,\"WhiteFont\",Str);",
        "name": "GrpToStr",
        "params": [
            {
                "paramdescription": " The group handle, returned from the GrpOpen() function. The group handle identifies the table where all data on the associated group is stored.",
                "paramname": "hGrp"
            }
        ],
        "returnType": "The group (as a string).",
        "syntax": "GrpToStr(hGrp)"
    },
    "halt": {
        "doc": "Stops the execution of the current Cicode task and returns to Plant SCADA. This function does not affect any other Cicode tasks that are running.\nUse this function to stop execution in nested function calls. When Halt() is called, Cicode returns to Plant SCADA and does not execute any return function calls.",
        "example": "INT\nFUNCTION\nMyFunc(INT Arg)\n\tIF Arg<0 THEN\n\t\tPrompt(\"Invalid Arg\");\n\t\tHalt();\n\tEND\n\t...\nEND",
        "name": "Halt",
        "params": [],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "Halt()"
    },
    "hextostr": {
        "doc": "Converts a number into a hexadecimal string. The string is the width specified (padded with zeros).",
        "example": "Variable=HexToStr(123, 4);\n! Sets Variable to \"007b\".\nVariable = HexToStr(0x12ABFE, 8);\n! Sets Variable to \"0012abfe\"",
        "name": "HexToStr",
        "params": [
            {
                "paramdescription": " The number to convert.",
                "paramname": "Number"
            },
            {
                "paramdescription": " The width of the string (0 to 8). \nNote that the function does not truncate the result if it is longer than the value specified. ",
                "paramname": "Width"
            }
        ],
        "returnType": "A string containing the converted number.",
        "syntax": "HexToStr(Number, Width)"
    },
    "highbyte": {
        "doc": "Gets the high-order byte of a two-byte integer.",
        "example": "Variable=HighByte(0x5678);\n! Sets Variable to 0x56.",
        "name": "HighByte",
        "params": [
            {
                "paramdescription": " A two-byte integer.",
                "paramname": "TwoByteInteger"
            }
        ],
        "returnType": "The high-order byte (that is | X | - |)",
        "syntax": "HighByte(TwoByteInteger)"
    },
    "highword": {
        "doc": "Gets the high-order word of a four-byte integer.",
        "example": "Variable=HighWord(0x12345678);\n! Sets Variable to 0x1234.",
        "name": "HighWord",
        "params": [
            {
                "paramdescription": " A four-byte integer.",
                "paramname": "FourByteInteger"
            }
        ],
        "returnType": "The high-order word (that is | X | X | - | - |)",
        "syntax": "HighWord(FourByteInteger)"
    },
    "hwalarmque": {
        "doc": " Returns the handle of the hardware alarm queue.The Alarms Server writes hardware alarm information into this queue as eachhardware alarm occurs.  To read events from this queue, use the QueRead() orQuePeek() functions.  The data written into the queue is the hardware alarmformat, and is stored in the Str field.\nTo use this function, you need to enable the hardware alarm queue by specifying  the [Alarm]HwAlarmQueMax parameter. This parameter specifies the maximum length  that the queue can grow to.   The [Alarm]HwAlarmFmt parameter defines the format of the data placed into the  string field.  If HwAlarmFmt is not specified then the format defaults to \"Time: {Time,12} Date:{Date,11} Desc:{Desc,40}\".\nThe following format fields are relevant to hardware alarms:\nFor a description of the fields see the \"Alarm Display Fields\" help page.\nThe number of buffers available for user queues is controlled bythe [Code]Queue parameter.  Each entry in any user queue consumes one buffer.When all buffers have been used the Alarms Server will not be able to add newhardware alarms to the queue, and the error message \"Out Of Buffers Usr.Que\"will be written to syslog.dat.\nHwAlarmQue()",
        "example": "\thQue = HwAlarmQue()\n\tWHILE TRUE DO\n\tQueRead(hQue, nAlarmType, sHwAlarmString, 1);\n\t/* do what ever with the alarm information */\n\t....\n\tSleep(0);\n\tEND\n\t\t\t",
        "name": "HwAlarmQue",
        "params": [],
        "returnType": "The handle of the hardware alarm queue, or -1 if the queue cannot be opened.\n",
        "syntax": "HwAlarmQue()"
    },
    "infoform": {
        "doc": "Displays graphics object information for the object under the mouse pointer. If there is no object directly under the mouse pointer, it displays information for the nearest object. Each tag associated with the object is displayed, along with its raw and engineering values and a button that displays the details from the Variable Tags form. The function also displays the Cicode expression, with any result that the expression has generated.\nThis function only supports the display of simple Cicode expressions.\nInfoForm(Mode)\nMode: \n0 (zero) if successful, otherwise an error is returned.",
        "example": "No example found",
        "name": "InfoForm",
        "params": [
            {
                "paramdescription": "For security purposes, the Write button on the informationform displayed by this function can be disabled.\n0 - The Write button on the displayed information form will be available and will function normally.\n1 - The Write button will not be shown.\nIf you omit the mode, the default mode is 0. ",
                "paramname": "Mode"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "InfoForm(Mode)"
    },
    "infoforman": {
        "doc": "Displays graphics object information for a specified AN. This function displays each tag associated with the object, along with its raw and engineering values and a button that displays the details from the Variable Tags form. The function also displays the Cicode expression, with any result that the expression has generated.\nInfoFormAn(AN [, Mode] )\nnAN:  \nMode: \n0 (zero) if successful, otherwise an error is returned.",
        "example": "No example found",
        "name": "InfoFormAn",
        "params": [
            {
                "paramdescription": "The AN of the graphics object for which information isdisplayed.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "For security purposes, the Write button on the informationform displayed by this function can be disabled.\n0 - The Write button on the displayed information form will be available and will function normally.\n1 - The Write button will not be shown.\nIf you omit the mode, the default mode is 0.",
                "paramname": "Mode"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "InfoFormAn(AN [, Mode] )"
    },
    "input": {
        "doc": "Displays a dialog box in which an operator can input a single value. The dialog box has a title, a prompt, and a single edit field. For multiple inputs, use the Form functions.\nThis function is a blocking function. It will block the calling Cicode task until the operation is complete.",
        "example": "/* Shut down \nPlant SCADA\n if the user inputs \"Yes\". */\nSTRING sStr;\nsStr=Input(\"Shutdown\",\"Do you wish to shutdown?\",\"Yes\");\nIF sStr=\"Yes\" THEN\n    Shutdown();\nEND",
        "name": "Input",
        "params": [
            {
                "paramdescription": " The title of the input box.",
                "paramname": "Title"
            },
            {
                "paramdescription": " The prompt text.",
                "paramname": "Prompt"
            },
            {
                "paramdescription": " The default text that the operator can edit or replace.",
                "paramname": "Default"
            }
        ],
        "returnType": "The edit field entry (as a string). If the user presses the Cancel button , an empty string is returned and the IsError() function returns the error code 299.",
        "syntax": "Input(Title, Prompt, Default)"
    },
    "inttoreal": {
        "doc": "Converts an integer into a real (floating point) number.\nWhen calling statements such as comparison or arithmetic operations that involve a mixture of variables of REAL and INT data types, there is no need to explicitly convert the variable of INT data type to REAL data type using the IntToReal function. Plant SCADA will automatically convert variables of INT data type to REAL data type before the operation is carried out.\nHowever, if the expression only consists of variables of INT data type, the result of the expression will remain as INT data type and be subjected to its limitations such as integer overflow and wraparound. This does not change even if the expression is to be assigned to a variable of REAL data type. \nIf you want to increase the range of the expression, you will need to convert at least one of its operands to REAL data type using the IntToReal function (see Example 2 below). ",
        "example": "! Sets Variable to 45.0\nVariable=IntToReal(45);\n! Sets Variable to -45.0\nVariable=IntToReal(-45);\n\nINT nVar1 = 1000000001;\nINT nVar2 = 2000000002;\nREAL rVar1 = 1.000001;\nREAL rVar2 = 0.0;\n\n\n// rVar2 = 1000000002.000001, IntToReal is not needed when operands are mixture of INT and REAL data types\nrVar2 = nVar1 + rVar1;\n\n// rVar2 = -1294967293.0, result is wrapped around due to range overflow of integer data type\nrVar2 = nVar1 + nVar2;\n\n// rVar2 = 3000000003.0, result is prompted to REAL data type when one of the INT operands is converted\nrVar2 = nVar1 + IntToReal(nVar2);",
        "name": "IntToReal",
        "params": [
            {
                "paramdescription": " The integer to convert.",
                "paramname": "Number"
            }
        ],
        "returnType": "The real number.",
        "syntax": "IntToReal(Number)"
    },
    "inttostr": {
        "doc": "Converts a number into a string.",
        "example": "Variable=IntToStr(5);\n! Sets Variable to \"5\".",
        "name": "IntToStr",
        "params": [
            {
                "paramdescription": " The number to convert.",
                "paramname": "Number"
            }
        ],
        "returnType": "A string containing the converted number.",
        "syntax": "IntToStr(Number)"
    },
    "iodevicecontrol": {
        "doc": "Provides control of individual I/O devices. You might need to call this function several times. If you use incompatible values for the various options of this function, you might get unpredictable results.\nThis function can only be used if the I/O Server is on the current machine. When the I/O Server is not in the calling process, this function will become blocking and cannot be called from a foreground task. In this case, the return value will be undefined and a Cicode hardware alarm will be raised.",
        "example": "IODeviceControl(4, 1, 1); ! Disable  I/O device 4",
        "name": "IODeviceControl",
        "params": [
            {
                "paramdescription": "The number or name of the I/O device. If you call this function from an I/O server, you can use the I/O device name. If you call this function from a client, you may use either the I/O device number or name. To specify all I/O devices, use \"*\" (asterisk) or -1.",
                "paramname": "IODevice"
            },
            {
                "paramdescription": "The type of control action:\n0 - No longer supported.\n1 - Enable/Disable the I/O device on the I/O server. If disabled, attempts to read and write from the I/O device are ignored. (If another I/O device is configured as a standby I/O server, Plant SCADA switches communications to that I/O device.) The I/O server does not attempt to communicate with the I/O device until it is re-enabled. When the I/O device is re-enabled, the I/O server attempts to re-establish communication immediately. Mode 1 can only be called by the I/O Server which is associated with this device.\n2 - No longer supported. An invalid argument error is returned if this option is specified.\n3 - No longer supported. An invalid argument error is returned if this option is specified.\n4 - The data in the associated I/O device cache is flushed. This allows flushing of the data from the I/O device without waiting for the aging time. This is useful when you have long cache time and you want to force a read from the I/O device.\nThe Data value is ignored with this mode.\n5 - (For scheduled and remote I/O devices). The I/O device is added to the bottom of the list of I/O devices to be contacted. I/O devices already in the list (already waiting to be contacted) are given priority over this I/O device.\n6 - (For scheduled and remote I/O devices). The I/O device is added to the top of the list of I/O devices to be contacted; it is given high priority. If there are already I/O devices at the top of the list with high priority, then this I/O device will be added to the list after them (that is it will be contacted after them). For dial-up remote I/O devices, if the modem is already in use - connected to another I/O device - this I/O device will not be dialled until that connection has been terminated.\n7 - (For scheduled and remote I/O devices). The I/O device is added to the top of the list of I/O devices to be contacted, and it is given top priority. For dial-up remote I/O devices, if the modem is currently connected to another I/O device, the connection will be cancelled, and the top priority I/O device will be dialled. It will also stay connected until manually disconnected with another call to IODeviceControl().\nNote: This mode will not attempt to disconnect any other persistent connections. Persistent connections can only be disconnected using mode 8.\n8 - (For scheduled and remote I/O devices). Disconnect an I/O device. Current requests will be completed before the I/O device is disconnected.\n9 - (For scheduled I/O devices). The communication schedule for the I/O device is disabled. This is to minimize the likelihood that the I/O device will be contacted when its scheduled dial-time occurs.\n10 - (For scheduled I/O devices). Puts the I/O device into Write On Request mode. That is, as soon as a write request is made, the I/O device will be added to the list of I/O devices to be contacted. It is given priority over existing read requests, but not over existing write requests.\nIn this situation, there will be a delay while the I/O device is contacted. Do not mistake this pause for inactivity (for example, do not continually execute a command during this delay).\n11 - Change the I/O device cache timeout. If the I/O Server is restarted, the cache timeout will return to its original value. (For scheduled I/O devices, this value can be checked using the Kernel Page Unit command. For all other I/O devices, this value is configured in the Cache Time field at the I/O Devices Properties form.)\n12 - The time of day at which to add the I/O device to the list of I/O devices to be contacted. Set the time in Data in seconds from midnight (for example, specify 6 p.m. as 18 * 60 * 60). Use Type 12 to specify a one-timecommunication.\n13 - The communication period (the time between successive communication attempts). The value you specify represents different periods, depending on what type of schedule you are using (that is daily, weekly, monthly, or yearly. This is set using Type 15.). You can choose to specify the communication period either in seconds from midnight, day of week (0 to 6, Sunday = 0), month (1 to 12), or year. Enter the value in Data. For example, if your schedule is weekly, and you set Data = 3, you are specifying each Wednesday. If your schedule is monthly, Data = 3 indicates March. For daily communication, set the period in Data in seconds from midnight; for example, set Data to 6 * 60 * 60 to contact the I/O device every 6 hours.\n14 - The time at which the I/O Server will first attempt to communicate with the I/O device. Set the time in Data in seconds from midnight, for example, to synchronize at 10a.m., set Data to 10 * 60 * 60.\n15 - Type of schedule. Set Data to one of the following:\n1 - Daily\n2 - Weekly\n3 - Monthly\n4 - Yearly\n16 - (For remote I/O devices) Read all tags from the I/O device. Data is unused - set it to 0 (zero).\n18 - Set Control Inhibit (Control Mode) for all tags of the I/O device.",
                "paramname": "nType"
            },
            {
                "paramdescription": "",
                "paramname": "Data"
            },
            {
                "paramdescription": "",
                "paramname": "Data for the control operation*"
            },
            {
                "paramdescription": "Disable the I/O device (Disable Write On Request mode for Type 10)\nSet Control Inhibit to ON (mode for type 18)",
                "paramname": "1"
            },
            {
                "paramdescription": "Enable the I/O device (Enable Write On Request mode for Type 10) or the I/O device name (for Type 2 or 3).\nSet Control Inhibit to OFF (mode for type 18)\n* For Type 5-8, Data is ignored; enter 0 (zero).",
                "paramname": "0"
            },
            {
                "paramdescription": "Specifies the name of the cluster in which the I/O Server resides. This is optional if you have one cluster or are resolving the I/O server via the current cluster context. The argument is enclosed in quotation marks \"\".",
                "paramname": "sClusterName"
            },
            {
                "paramdescription": "Specifies the name of the the I/O Server. This parameter is only required if you are running more than one I/O server process from the same cluster on the same computer and need to instruct the system which process to redirect to. The argument is enclosed in quotation marks \"\".",
                "paramname": "ServerName"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "IODeviceControl(IODevice, nType, Data [, sClusterName] [, ServerName]    )"
    },
    "iodeviceinfo": {
        "doc": "Gets information about a specified I/O device.\nApart from when Type is set to 3 or 17, this function can only be used if the I/O Server is on the current machine, otherwise the function will not succeed and will return empty string. When the I/O Server is not in the calling process, this function will become blocking and cannot be called from a foreground task. In this case, the return value will be undefined and a Cicode hardware alarm will be raised.\nIf both the primary and standby I/O devices are on the same server and they have the same I/O device name, you can get information about them individually by specifying the following:\nwhere P represents the primary I/O device and S the standby I/O device.\nIf you have more than one standby device on the same server, there is currently no way of using this function for other than the first standby device.",
        "example": "IODeviceInfo(\"PLC1,P\",1); // for the Primary\nIODeviceInfo(\"PLC1,S\",1); // for the Standby\n\n//Using the IODevice Number\nsName = IODeviceInfo(20, 0); ! Get the name of  I/O device 20\nsName = IODeviceInfo(2, 1); ! Get the protocol of  I/O device 2\n//Using the IODevice Name\nsName = IODeviceInfo(\"IODev\",10); ! Get the I/O Server State\nsName = IODeviceInfo(\"IODev1\",3); ! Get the State of IODev1",
        "name": "IODeviceInfo",
        "params": [
            {
                "paramdescription": "The I/O device number, or the I/O devicename enclosed in double quotes.",
                "paramname": "IODevice"
            },
            {
                "paramdescription": "The type of information:\n0 - Name of I/O device\n1 - Protocol of I/O device\n2 - Protocol address\n3 - Client I/O device state\n1 = Running - Client is either talking to an online I/O device or talking to a scheduled device that is not currently connected but has a valid cache\n2 = Standby - Client is talking to an online standby I/O device\n4 = Starting - Client is talking to an I/O device that is attempting to come online\n8 = Stopping - Client is talking to an I/O device that is in the process of stopping\n16 = Offline - Client is pointing to an I/O device that is currently offline\n32 = Disabled - Client is pointing to a device that is disabled\n66 = Standby write - client is talking to an I/O device configured as a standby write device\n4 - Current generic error number (decimal)\n5 - Current driver error number (decimal)\n6 - Disabled flag\n7 - Statistics, minimum read time\n8 - Statistics, maximum read time\n9 - Statistics, average read time\n10 - I/O server I/O device state\n1 = Running - I/O device for this I/O server is online or a scheduled device that is not currently connected but has a valid cache\n2 = Standby - I/O device for this I/O server is online and a standby unit\n4 = Starting - I/O device for this I/O server is attempting to come online. Starting may be combined with either Offline or Remote such as: 20 = Starting(4) + Offline(16) or 132 = Starting(4) + Remote(128).\n8 = Stopping - I/O device for this I/O server is currently in the process of stopping\n16 = Offline (only valid on an I/O server) - I/O device for this I/O server is currently offline\n32 = Disabled - I/O device for this I/O server is disabled\n66 = Standby write - I/O device for this I/O server is configured as a standby write device\n128 = Remote (returned in combination with another value specified above - see Starting - I/O device for this I/O server is a scheduled device but not currently connected\n11 - Unit number\n12 - Configured I/O server name\n13 - Configured Port name\n14 - Configured startup mode\n15 - Configured comment\n16 - The primary I/O server name the client uses to communicate to this device\n17 - The I/O Server the client is using to communicate to this device. Will be Standby if the Primary is down.\n18 - State of the remote unit:\n0 = Remote unit is disconnected and OK\n1 = Remote unit is connected and online\n2 = Remote unit is in the dial queue\n16 = Remote unit is disconnected and offline\n32 = Remote unit is disconnected and disabled\nThis mode causes redirection to the I/O server if running in separate processes.\n19 - Number of successful attempts to communicate with the scheduled I/O device.\n20 - Number of unsuccessful attempts to communicate with the scheduled I/O device.\n21 - Write mode: Write On Request, and normal (as per schedule defined in the Express Communications Wizard).\n22 - Number of queued read requests for the scheduled I/O device. (This mode causes redirection to the I/O server if running in separate processes.)\n23 - Number of queued write requests for the scheduled I/O device. (This mode causes redirection to the I/O server if running in separate processes.)\n24 - The cache timeout (in milliseconds).\n26 - The name of the line device (for example, modem) you are using to connect to the I/O device. (This mode causes redirection to the I/O server if running in separate processes.)\n27 - The call_status of a currently connected remote I/O device.",
                "paramname": "nType"
            },
            {
                "paramdescription": "(This mode causes redirection to the I/O server if running in separate processes.)\n28 - The call rate (in bits per second) which may be the DTE or DCE connection speed depending on the server modem settings. (This mode causes redirection to the I/O server if running in separate processes.)\n30 - The last time an I/O device from the remote I/O device redundantgroup was connected (primary or any standbys).\n31 -The state of the remote I/O device redundant group: \n0 = not connected (none of the redundant I/O devices connected)\n1 =connected (one of the redundant I/O devices is connected)\n32 - The next time the specified I/O device is scheduled to connect (unless a higherpriority I/O device comes online).",
                "paramname": ""
            },
            {
                "paramdescription": "Specifies the name of the cluster in which the I/O Serverresides. This is optional if you have one cluster or areresolving the I/O server via the current cluster context. Theargument is enclosed in quotation marks \"\".",
                "paramname": "sClusterName"
            },
            {
                "paramdescription": "Specifies the name of the I/O Server. This parameter is only required if you are running more than one I/O server process from the same cluster on the same computer and need to instruct the system which process to redirect to. The argument is enclosed in quotation marks \"\".",
                "paramname": "ServerName"
            }
        ],
        "returnType": "The type of information (as a string).",
        "syntax": "IODeviceInfo(IODevice, Type [, sClusterName] [, ServerName])"
    },
    "iodevicestats": {
        "doc": "Gets statistical information for all I/O devices, and displays the information in a dialog box. \nIODeviceStats()",
        "example": "IODeviceStats(); ! display all  I/O device information",
        "name": "IODeviceStats",
        "params": [],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "IODeviceStats()"
    },
    "iserror": {
        "doc": "Gets the current error value. The error value is set when any error is detected, and is reset after this function is called. You can call this function if user error-checking is enabled or disabled.\nYou should call this function as soon as possible after the operation to be checked, because the error code could be changed by the next error.",
        "example": "! Enable user error-checking.\nErrSet(1);\n! Invalid ArcSine.\nAc=ArcSin(20.0);\n! Sets ErrorVariable to 274 (invalid argument passed).\nErrorVariable=IsError()",
        "name": "IsError",
        "params": [],
        "returnType": "The current error value. The current error is reset to 0 after this function is called.",
        "syntax": "IsError()"
    },
    "kercmd": {
        "doc": "Executes a command in a Kernel window.",
        "example": "No example found",
        "name": "KerCmd",
        "params": [
            {
                "paramdescription": " The name of the Kernel window.",
                "paramname": "Window"
            },
            {
                "paramdescription": " The command to execute in the Kernel window.",
                "paramname": "sCommand"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "KerCmd(Window, sCommand)"
    },
    "kernelqueuelength": {
        "doc": "Obtains the number of records in a queue.",
        "example": "No example found",
        "name": "KernelQueueLength",
        "params": [
            {
                "paramdescription": " The name of the queue, which can be enumerated by the page queue kernel command.",
                "paramname": "sName"
            }
        ],
        "returnType": "This function returns the Length value of the page queue command.",
        "syntax": "KernelQueueLength(sName)"
    },
    "kerneltableinfo": {
        "doc": "Provides a consistent method of accessing items within Kernel Table.",
        "example": "No example found",
        "name": "KernelTableInfo",
        "params": [
            {
                "paramdescription": "The name of the table. The following tables are supported:",
                "paramname": "sTable"
            },
            {
                "paramdescription": " The key to a column in the table depending on the sTable parameter.",
                "paramname": "sRecord"
            },
            {
                "paramdescription": " The key to a column in the table depending on the sTable parameter.",
                "paramname": "sField"
            }
        ],
        "returnType": "Returns the content of a field of the given table in the format of a Cicode STRING.",
        "syntax": "KernelTableInfo(sTable, sRecord, sField)"
    },
    "kerneltableitemcount": {
        "doc": "Obtains the number of rows in a Kernel Table.",
        "example": "No example found",
        "name": "KernelTableItemCount",
        "params": [
            {
                "paramdescription": "The name of the table that can be enumerated by the page table kernel command.",
                "paramname": "sName"
            }
        ],
        "returnType": "Returns the number of active records in the table (not the length value displayed by the page table kernel command).",
        "syntax": "KernelTableItemCount(sName)"
    },
    "keyallowcursor": {
        "doc": "Allows (or disallows) the command cursor to move to the specified AN or to all ANs. The command cursor normally moves only to ANs that have commands defined.",
        "example": "KeyAllowCursor(20,1);\n! Allows the command cursor to move to AN20.\nKeyAllowCursor(0,1);\n! Allows the command cursor to move to any AN.",
        "name": "KeyAllowCursor",
        "params": [
            {
                "paramdescription": " The AN where the command cursor can move. If 0, all ANs are implied.",
                "paramname": "nAN"
            },
            {
                "paramdescription": " Allow state:\n0 - Do not allow the cursor to move to this AN.\n1 - Allow the cursor to move to this AN.",
                "paramname": "State"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "KeyAllowCursor(nAN, State)"
    },
    "keybs": {
        "doc": "Removes the last key from the key command line. If the key command line is empty, this function will not perform any action.\nYou should call this function using a \"Hot Key\" command (as shown in the example below), otherwise the backspace character is placed into the key command line and the command does not execute. A \"Hot Key\" command is a command that executes as soon as it is placed into the key command line.",
        "example": "/* If  \"START  A  B  C\" is in the key command line and \"START\" is \nthe Key Name for the \"F1\" key: */\nKeyBs();\n! Removes ASCII \"C\".\nKeyBs();\n! Removes ASCII \"B\".\nKeyBs();\n! Removes ASCII \"A\".\nKeyBs();\n! Removes Key_F1.\nKeyBs();\n! Performs no action.",
        "name": "KeyBs",
        "params": [],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "KeyBs()"
    },
    "keydown": {
        "doc": "Moves the command cursor down the page to the closest AN. If an AN-Down cursor override is specified (in the Page Keyboard database) for the graphics page, the command cursor moves to that AN instead.",
        "example": "No example found",
        "name": "KeyDown",
        "params": [],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "KeyDown()"
    },
    "keyget": {
        "doc": "Gets the last key code from the key command line. The key is removed from the command line. Use this function to process the operator key commands directly. You should call this function from the keyboard event function.",
        "example": "/* If  \"START  A  B  C\" is in the key command line and \"START\" is \nthe Key Name for the \"F1\" key: */\nVariable=KeyGet();\n! Sets Variable to 67 (ASCII \"C\").\nVariable=KeyGet();\n! Sets Variable to 66 (ASCII \"B\").\nVariable=KeyGet();\n! Sets Variable to 65 (ASCII \"A\").\nVariable=KeyGet();\n! Sets Variable to 170 (the ASCII value of the F1 key (Key_F1)).\nVariable=KeyGet();\n! Sets Variable to 0.",
        "name": "KeyGet",
        "params": [],
        "returnType": "The last key code from the key command line. If the key command line is empty, 0 (zero) is returned.",
        "syntax": "KeyGet()"
    },
    "keygetcursor": {
        "doc": "Gets the AN at the position of the command cursor. \nIf this function is called from within a larger piece of code, the cursor may have moved away from where it was originally positioned when the larger piece of code was started.\nIf you are using groups, and there are currently two command cursors, the AN for the innermost will be returned. For example, if there is a cursor for a group as well as a cursor for one of its objects, the AN for the object will be returned.",
        "example": "! If the command cursor is on AN25:\nAN=KeyGetCursor();\n! Sets AN to 25.",
        "name": "KeyGetCursor",
        "params": [],
        "returnType": "The AN at the position of the command cursor. If no cursor is visible, -1 is returned.",
        "syntax": "KeyGetCursor()"
    },
    "keyleft": {
        "doc": "Moves the command cursor left (across the page) to the closest AN. If an AN-Left cursor override is specified (in the Page Keyboard database) for the graphics page, the command cursor moves to that AN instead.",
        "example": "No example found",
        "name": "KeyLeft",
        "params": [],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "KeyLeft()"
    },
    "keymove": {
        "doc": "Moves the command cursor in a specified direction to the closest AN. If an AN cursor override is specified, the command cursor moves to that AN directly. This function is equivalent to the KeyUp(), KeyDown(), KeyLeft(), and KeyRight() functions.",
        "example": "KeyMove(1);\n! Moves the cursor left.",
        "name": "KeyMove",
        "params": [
            {
                "paramdescription": "",
                "paramname": "Direction"
            },
            {
                "paramdescription": "0 - Do not move\n1 - Left\n2 - Right\n3 - Up\n4 - Down",
                "paramname": "Direction to move the cursor"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "KeyMove(Direction)"
    },
    "keypeek": {
        "doc": "Gets the ascii key code from the key command line (at a specified offset), without removing the key from the key command line. An offset of 0 returns the key code from the last position in the key command line.",
        "example": "! If \"A B C\" is in the key command line:\nVariable=KeyPeek(0);\n! Sets Variable to 67 (ASCII \"C\")\nVariable=KeyPeek(2);\n! Sets Variable to 65 (ASCII \"A\")",
        "name": "KeyPeek",
        "params": [
            {
                "paramdescription": "The offset from the end of the key command line",
                "paramname": "Offset"
            }
        ],
        "returnType": "The ASCII key code.",
        "syntax": "KeyPeek(Offset)"
    },
    "keyput": {
        "doc": "Puts an ASCII key code or Keyboard key code into the last position of the key command line. If this key completes any command, that command will execute.",
        "example": "KeyPut(Key_F1);\n/* Puts \"Key_F1\" (the Key Code for the \"F1\" key) into the last \nposition of the key command line. If \"START\" is the Key Name for \nthe \"F1\" key, this would be equivalent to \nKeyPutStr(\"START\"). In either case, \"START\" will display on the \nkey command line. */\nKeyPut(StrToChar(\"A\"));\n/* Puts the Key Code for the \"A\" key into the last position of the \nkey command line. */",
        "name": "KeyPut",
        "params": [
            {
                "paramdescription": "The key code to put into the key command line.",
                "paramname": "KeyCode"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "KeyPut(KeyCode)"
    },
    "keyputstr": {
        "doc": "Puts a string at the end of the key command line. The string can contain either key names or data characters. If this string completes any command, that command will execute.",
        "example": "KeyPutStr(\"START ABC\");\n! Places \"START ABC\" at the end of the key command line.\nKeyPutStr(\"TURN PUMP 1 ON\");\n! Places \"TURN PUMP 1 ON\" at the end of the key command line.",
        "name": "KeyPutStr",
        "params": [
            {
                "paramdescription": " The string to put into the key command line.",
                "paramname": "String"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "KeyPutStr(String)"
    },
    "keyreplay": {
        "doc": "Replays the last key sequence (except for the last key, which would execute the command). This function is useful when a command is to be repeated. To call this function from the keyboard, use a Hot Key \"*\" (asterisk) command, otherwise the KeyReplay() function itself is replayed.",
        "example": "\"START ABC ENTER\"\nKeyReplay();\n! Replays \"START ABC\".",
        "name": "KeyReplay",
        "params": [
            {
                "paramdescription": "Number of characters to subtract before replay. Default value is 1.",
                "paramname": "sub"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "KeyReplay(sub)"
    },
    "keyreplayall": {
        "doc": "Replays the last key sequence and executes the command. To call this function from the keyboard, use a Hot Key \" * \" (asterisk) command, otherwise the KeyReplayAll() function itself is replayed.",
        "example": "\"START ABC ENTER\"\nKeyReplayAll();\n! Replays \"START ABC ENTER\" and executes the command.",
        "name": "KeyReplayAll",
        "params": [],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "KeyReplayAll()"
    },
    "keyright": {
        "doc": "Moves the command cursor right (across the page) to the closest AN. If an AN-Right cursor override is specified (in the Page Keyboard database) for the graphics page, the command cursor moves to that AN instead.",
        "example": "No example found",
        "name": "KeyRight",
        "params": [],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "KeyRight()"
    },
    "keysetcursor": {
        "doc": "Displays the command cursor at a specified AN. A keyboard command needs to exist, or you need to first call the KeyAllowCursor() function (at the AN) to allow the cursor to move to the AN. If the AN does not exist, or if a command does not exist at that AN, or if KeyAllowCursor() has not been called, the command cursor does not move.",
        "example": "! Move the command cursor to AN20.\nKeySetCursor(20);",
        "name": "KeySetCursor",
        "params": [
            {
                "paramdescription": " The AN where the command cursor will be displayed.",
                "paramname": "nAN"
            }
        ],
        "returnType": "If the AN does not exist, or if a command does not exist at that AN, or if KeyAllowCursor() has not been called, the return value is 1. Otherwise, the function will return 0.",
        "syntax": "KeySetCursor(nAN)"
    },
    "keysetseq": {
        "doc": "Adds a keyboard sequence to the current page at runtime. The key sequence is only added to the current window. When the page is closed, the keyboard sequence is deleted.",
        "example": "/* Set the key sequence and call the \"Callback\" function when the \nsequence is found. */\nKeySetSeq(\"F2 ### Enter\", 0, Callback);\n! This function is called when the key sequence is found.\nINT\nFUNCTION CallBack()\n\tINT Value;\n\t! Get user data.\n\tValue=Arg1;\n\t..\n\tRETURN 0;\nEND",
        "name": "KeySetSeq",
        "params": [
            {
                "paramdescription": " The keyboard sequence.",
                "paramname": "sKeySeq"
            },
            {
                "paramdescription": " The AN where the keyboard sequence will apply. If you set AN to 0 (zero), the keyboard sequence will apply to all ANs on the page.",
                "paramname": "nAN"
            },
            {
                "paramdescription": " The function to call when the keyboard sequence matches. This function needs to be a callback function.",
                "paramname": "Fn"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "KeySetSeq(sKeySeq, AN, Fn)"
    },
    "keyup": {
        "doc": "Moves the command cursor up the page to the closest AN. If an AN-Up cursor override is specified (in the Page Keyboard database) for the graphics page, the command cursor moves to that AN.",
        "example": "No example found",
        "name": "KeyUp",
        "params": [],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "KeyUp()"
    },
    "languagefiletranslate": {
        "doc": "Translates an ASCII file into a local language. Use this function to translate RTF reports for viewing on client screens.\nThe local language used by this function is specified by the [Language]LocalLanguage parameter. You need to set this parameter accordingly.",
        "example": "/* Translates the text in Shift.RTF and saves it in LShift.RTF. */\nLanguageFileTranslate(\"c:\\MyApplication\\data\\Shift.RTF\",\"c:\\MyApplication\\data\\\nLShift.RTF\");\n/* Translates the text in [Data]:Shift.RTF and saves it in \n[LocalData]:LShift.RTF.  */\nLanguageFileTranslate(\"[Data]:Shift.RTF\",\"[LocalData]:LShift.RTF\"\n);",
        "name": "LanguageFileTranslate",
        "params": [
            {
                "paramdescription": " The name of the ASCII file containing multi-language text, which will be copied and translated. You should specify the full path or use path substitution. The path and name should be contained within quotation marks.",
                "paramname": "sSourceFile"
            },
            {
                "paramdescription": " The name of the destination file which will be created/replaced with the local/translated version of the source file. You should specify the full path or use path substitution. The path and name should be contained within quotation marks.",
                "paramname": "sDestFile"
            }
        ],
        "returnType": "1 if successful, otherwise 0.",
        "syntax": "LanguageFileTranslate(sSourceFile, sDestFile)"
    },
    "leavecriticalsection": {
        "doc": "Relinquishes the current thread's ownership of a critical section (shared critical resource). Once ownership is relinquished, access to the critical section is available to the next thread that requests it (using the EnterCriticalSection() function). If a thread has been waiting for access, it will be granted at this point.\nLeaveCriticalSection() needs to be called once for each EnterCriticalSection() used.",
        "example": "/* Request access to critical section, execute code and relinquish \nownership of critical section. */\nFUNCTION\nMyCriticalFunction()\n    EnterCriticalSection(\"MyCritical\");\n    // critical code is placed here\n    LeaveCriticalSection(\"MyCritical\");\nEND",
        "name": "LeaveCriticalSection",
        "params": [
            {
                "paramdescription": " The name of the critical section. The name needs to be entered in quotation marks.",
                "paramname": "sName"
            }
        ],
        "returnType": "This function does not return a value.",
        "syntax": "LeaveCriticalSection(sName)"
    },
    "libalarmfilterform": {
        "doc": "Displays a generic alarm filter pop-up for specifying filtering criteria for either an alarm list or a named filter. This function uses the AlarmFilterEdit family of Cicode functions to set the filter.\nINT LibAlarmFilterForm([INT FormType [, STRING FilterSrc [, STRING Title [, INT Mode [, STRING AppliedCallbackFn]]]]])\nType of alarm filter form:\n1 if filter has been applied, 0 if filter has been cleared, or -1 if no change is made",
        "example": "No example found",
        "name": "LibAlarmFilterForm",
        "params": [
            {
                "paramdescription": "Type of alarm filter form:\n-1 – (Default) auto detect if the FilterSrc is set to a valid alarm list AN\n0 – active alarm\n1 – alarm summary\n2 – disabled alarms\n3 – sequence of events (SOE)",
                "paramname": "nFormType"
            },
            {
                "paramdescription": "The source where the filter will be applied to. It can either be the Animation Number (AN) of an alarm list or the name of a filter created via the AlarmFilterOpen() Cicode function. If it is not specified, it is defaulted to -1 which refers to all alarm lists on the current page. If the FilterSrc cannot be opened, it will prompt the user to create the filter source.",
                "paramname": "sFilterSrc"
            },
            {
                "paramdescription": "The title for the filter form. If it is not specified or left blank, the title is determined by the form type:\n0 – Active Alarm Filter\n1 – Summary Alarm Filter\n2 – Disabled Alarm Filter\n3 – SOE Filter\nAny other value – (<FilterSrc> - Alarm Filter)",
                "paramname": "sTitle"
            },
            {
                "paramdescription": "The mode of the form:\n0 – (Default) Displays form in synchronous mode. The function waits for the user to close the form before returning. Under this mode, the \"Apply\" button is not shown on the form.\n1 – Display form in asynchronous mode. The function does not wait for the user to close the form and returns immediately. Under this mode, the \"Apply\" button is shown on the form. Using this button, the user can apply filter to the alarm list(s) multiple times without closing the form.",
                "paramname": "nMode"
            },
            {
                "paramdescription": "The callback function statement to be called when the criteria (rules) specified in the form is applied either via the OK or Apply buttons. Like other callback functions available to other library controls genie. The callback function supports keyword substitutions during callback:\n#Filter - The FilterSrc specified when showing the form\n#Result – The result of the filter application. See return value for details.",
                "paramname": "sAppliedCallbackFn"
            }
        ],
        "returnType": "1 if filter has been applied, 0 if filter has been cleared, or -1 if no change is made",
        "syntax": "INT LibAlarmFilterForm([INT FormType [, STRING FilterSrc [, STRING Title [, INT Mode [, STRING AppliedCallbackFn]]]]])"
    },
    "ln": {
        "doc": "Calculates the natural (base e) logarithm of a number.",
        "example": "Variable=Ln(2);\n! Sets Variable to 0.6931...",
        "name": "Ln",
        "params": [
            {
                "paramdescription": " Any number.",
                "paramname": "Number"
            }
        ],
        "returnType": "The natural (base e) logarithm of Number. ",
        "syntax": "Ln(Number)"
    },
    "log": {
        "doc": "Calculates the base 10 logarithm of a number.",
        "example": "Variable=Log(100);\n! Sets Variable to 2 (that is 100=10 to the power of 2).",
        "name": "Log",
        "params": [
            {
                "paramdescription": " Any number.",
                "paramname": "Number"
            }
        ],
        "returnType": "The base 10 logarithm of Number. ",
        "syntax": "Log(Number)"
    },
    "login": {
        "doc": "Not available when logged in as Windows user.\nLogs a user into the Plant SCADA system, using         Plant SCADA security and gives users access to the areas and privileges assigned to them in the Users database, and uses the locale language defined for that user. Only one user can be logged into a computer at any one time. If a user is already logged in when a second user logs in, the first user is automatically logged out.\nWhen using Windows security use UserLogin to limit Windows credentials being exposed as plain text.\nAt startup, or when the user logs out, a default user is active, with access to area 0 (zero) and privilege 0 (zero) only. Use the LoginForm() function to display a form for logging in to the system.",
        "example": "/*  \n** Log in a user whose user name is \"FRED\" and whose password\n** is \"ABC\". \n** \n** The language of the logged in user session will be set to\n** the default language.\n*/\nLogin(\"FRED\", \"ABC\");\n\n/*  \n** Log in a user whose user name is \"FRED\" and whose password\n** is \"ABC\". \n** \n** The language of the logged in user session will be set to\n** English.\n*/\nLogin(\"FRED\", \"ABC\", 0, \"English\");\n\t\t\t\t\n/*  \n** Log in a user whose user name is \"FRED\" and whose password\n** is \"ABC\". \n** \n** The language of the logged in user session will be set to\n** French.\n*/\nLogin(\"FRED\", \"ABC\", 0, \"French(France)\");\n\t\t\t\t\n/*  \n** Log in a user whose user name is \"FRED\" and whose password\n** is \"ABC\". \n** \n** The language of the logged in user session will be set to\n** Chinese.\n*/\nLogin(\"FRED\", \"ABC\", 0, \"Chinese(Simplified, PRC)\");\n\t\t\t\t\n\n        ",
        "name": "Login",
        "params": [
            {
                "paramdescription": " The user's name, as defined in the Users database.",
                "paramname": "sUserName"
            },
            {
                "paramdescription": " The user's password, as defined in the Users database.",
                "paramname": "sPassword"
            },
            {
                "paramdescription": " Optionally specifies whether the function operates in blocking or non-blocking mode. If set to 1 blocks caller until login is complete. If set to 0 (default) does not block caller.",
                "paramname": "bSync"
            },
            {
                "paramdescription": "The specified language needs to be one of the languages defined in the Languages view in Plant SCADA Studio's Setup activity. If the specified language is undefined, the default language is used by the login user, and a message \"Undefined language\" is shown in the prompt line.\nAn empty string (i.e. \"\") can be specified to indicate that the default language is used by the login user. The default language defined by [Language]LocalLanguage INI parameter.\nThe default value of this parameter is \"\".",
                "paramname": "sLanguage"
            }
        ],
        "returnType": "0 (zero) if successful.",
        "syntax": "Login(sUserName, sPassword [, bSync][, sLanguage])"
    },
    "loginform": {
        "doc": "Displays a form in which a user can log in to the Plant SCADA system by entering their name and password and local language. If the login is correct, the user is logged into the Plant SCADA system with the area(s) and privilege(s) assigned to them in the Users database.\nFrom version 7.10 this form can be pre-filled by the caller. Both Plant SCADA and Windows users are supported.\nThis function is a blocking function. It will block the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "LoginForm",
        "params": [
            {
                "paramdescription": "Optionally, the user's name, as defined in the Users database.",
                "paramname": "sUserName"
            },
            {
                "paramdescription": "Optionally, the user's password, as defined in the Users database.",
                "paramname": "sPassword"
            },
            {
                "paramdescription": "The specified language must be one of the languages defined in the Languages view in Plant SCADA Studio's Setup activity. If the specified language is undefined, the default language is used by the login user, and a message \"Undefined language\" is shown in the prompt line.\nAn empty string (i.e. \"\") can be specified to indicate that the default language is used by the login user. The default language defined by [Language]LocalLanguage INI parameter.\nThe default value of this parameter is \"\".\n0 (zero) if successful, otherwise an error is returned.",
                "paramname": "sLanguage"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "LoginForm([sUserName [, sPassword [, sLanguage]]])"
    },
    "logout": {
        "doc": "Logs the current user out of the Plant SCADA system. Plant SCADA continues to run, but with access to area 0 (zero) and privilege 0 (zero) only. If the current page requires access for a specified area (as defined by the page's area property), the system returns to the home page as specified by the parameter[Page]HomePage, and if unsuccessful that returns to the startup page.  When multiple pages are currently displayed, this occurs for each open window.\nCalling this function to logout the logged on user will cause an automatically logged in user to be logged back on. If there is no user logged in, calling this function will return an error.When the logged on user is an automatically logged in user, calling this function will return an error.",
        "example": "/* Log the current user out of the system. */\nLogout();",
        "name": "Logout",
        "params": [],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "Logout()"
    },
    "logoutidle": {
        "doc": "Sets an idle time for logging out the current user. If the current user does not execute a command within the specified idle time, a prompt is displayed. If the prompt is ignored, then the user is logged out. For every user to have the same idle time, you would call this function at startup. Otherwise, you can call the function from the Users database to specify an idle time for each user. This function will not log out an automatically logged on user.\nUntil reset LogoutIdle remains active. To reset call LogoutIdle (-1) from the Exit command of the Users database record.",
        "example": "No example found",
        "name": "LogoutIdle",
        "params": [
            {
                "paramdescription": " The number of minutes the user needs to be idle before logoutwill occur. Set Idle to -1 to disable the current logout timeout.",
                "paramname": "Idle"
            }
        ],
        "returnType": "No return value.",
        "syntax": "LogoutIdle(Idle)"
    },
    "lowbyte": {
        "doc": "Gets the low-order byte of a two-byte integer.",
        "example": "Variable=LowByte(0x5678);\n! Sets Variable to 0x78.",
        "name": "LowByte",
        "params": [
            {
                "paramdescription": " A two-byte integer.",
                "paramname": "TwoByteInteger"
            }
        ],
        "returnType": "The low-order byte (that is | - | X |)",
        "syntax": "LowByte(TwoByteInteger)"
    },
    "lowword": {
        "doc": "Gets the low-order word of a four-byte integer.",
        "example": "Variable=LowWord(0x12345678);\n! Sets Variable to 0x5678",
        "name": "LowWord",
        "params": [
            {
                "paramdescription": " A four-byte integer.",
                "paramname": "FourByteInteger"
            }
        ],
        "returnType": "The low-order word (that is | - | - | X | X |)",
        "syntax": "LowWord(FourByteInteger)"
    },
    "mailerror": {
        "doc": "Gets the last mail error code. The error code is extracted from the MAPI mail system, and explains what caused the MAPI error.",
        "example": "! Logon to the mail system\nIF MailLogon(\"RodgerG\", \"password\", 0) THEN\n    error = MailError();\n    !do what is required\nEND",
        "name": "MailError",
        "params": [],
        "returnType": "0 (zero) if successful, otherwise an error is returned. Refer also to MAPI errors.",
        "syntax": "MailError()"
    },
    "maillogoff": {
        "doc": "Logs off from the mail system. You should log off the mail system when all mail operations are complete. Plant SCADA automatically logs off the mail system on shutdown.",
        "example": "! Send the report to Rodger\nMailLogon(\"Andrew\", \"password\", 0);\nMailSend(\"Rodger Gaff\", \"Report\", \"This is the weekly report\", \n\"[data]:weekly.txt\", 0);\nMailLogoff();",
        "name": "MailLogoff",
        "params": [],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "MailLogoff()"
    },
    "maillogon": {
        "doc": "Logs on to the mail system. You need to call this function before any other mail function.\nThe mail system uses the MAPI standard interface, so you can use any mail system that supports this standard.\nYou should log on to the mail system when Plant SCADA starts, and log off only at shutdown. (The logon procedure can take a few seconds to complete.) You can only log on as one user at a time for each computer, so you can only read mail for this user name.",
        "example": "! Send the report to James\nMailLogon(\"RodgerG\", \"password\", 0);\nMailSend(\"James Glover\", \"Report\", \"This is the weekly report\", \n\"[data]:weekly.txt\", 0);\nMailLogoff();",
        "name": "MailLogon",
        "params": [
            {
                "paramdescription": " The name of the mail user. This name is the user's mail box name (the unique shorthand name, not the full user's name).",
                "paramname": "sName"
            },
            {
                "paramdescription": " The password of the mail user.",
                "paramname": "sPassword"
            },
            {
                "paramdescription": " The mode of the logon:\n0 - Normal logon.\n2 - Get unique logon, do not share existing mail client logon.",
                "paramname": "iMode"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "MailLogon(sName, sPassword, iMode)"
    },
    "mailread": {
        "doc": "Reads a standard mail message. The mail message can contain text, an attached file, or both.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.\nBefore you can use this function, you need to use the MailLogon() function to log on to the mail system. You can only read mail sent to the user name specified in the MailLogon() function.",
        "example": "! Logon to the mail system\nMailLogon(\"RodgerG\", \"password\", 0);\n! Read a message. Don't wait if no message\nIF MailRead(sName, sSubject, sNote, sFileName, 1) = 0 THEN\n    ! got message now do something with it\nEND\nWHILE TRUE DO\n    ! wait for a mail message\n    MailRead(sName, sSubject, sNote, sFileName, 0);\nEND;\nMailLogoff();",
        "name": "MailRead",
        "params": [
            {
                "paramdescription": " The name of the mail user who sent the message. Must be a String type variable.",
                "paramname": "sName"
            },
            {
                "paramdescription": " The subject text of the mail message. Must be a String type variable.",
                "paramname": "sSubject"
            },
            {
                "paramdescription": " The note section of the message. If the message is longer than 255 characters, Plant SCADA will save the message in a file and return the file name in sNote. Use the file functions to read the message. The name of the file will be in the form CTxxxxx where x is a unique number. You need to delete the file after you have finished with the mail message. Must be a String type variable.",
                "paramname": "sNote"
            },
            {
                "paramdescription": " The name of any attached file. If there is no attached file in the message, specify sFileName as an empty string \"\". Must be a String type variable.",
                "paramname": "sFileName"
            },
            {
                "paramdescription": " The mode of the read:\n0 - Read a message. If no message is available, wait for a message.\n1 - Read a message. If no message is available, return with an error code.",
                "paramname": "iMode"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "MailRead(sName, sSubject, sNote, sFileName, iMode)"
    },
    "mailsend": {
        "doc": "Sends a standard mail message. The mail message can contain text, an attached file, or both.\nBefore you can use this function, you need to use the MailLogon() function to log on to the mail system. You can only send mail from the user name specified in the MailLogon() function. You can send mail to any mail user or to another Plant SCADA client.",
        "example": "! Logon to the mail system\nMailLogon(\"Wombat\", \"password\", 0);\n! send the report to Andrew\nMailSend(\"Andrew Bennet\", \"Report\", \"Attached is the weekly report\",\n \"[data]:weekly.txt\", 0);\n! send hello message to JR\nMailSend(\"Jack Russell\", \"Hello\", \"You've only got yourself to blame!\", \"\", 0);\n! send a big note to Nigel\nMailSend(\"Nigel Colless\", \"Big Message\", \"[data]:message.txt\", \"\", 1);\nMailLogoff();",
        "name": "MailSend",
        "params": [
            {
                "paramdescription": " The name of the mail user who will receive the message. This name is the user's full name (not their mailbox name).",
                "paramname": "sName"
            },
            {
                "paramdescription": " The subject text of the mail message (a short description of what the message is about).",
                "paramname": "sSubject"
            },
            {
                "paramdescription": " The note section of the message (the main section of the message text). You can enter up to 255 characters, or a file name for longer messages. If you enter a file name, set iMode to 1.",
                "paramname": "sNote"
            },
            {
                "paramdescription": " The name of any attached file. If there is no attached file in the message, set sFileName to an empty string \"\".",
                "paramname": "sFileName"
            },
            {
                "paramdescription": " The mode of the send:\n0 - Normal mail message.\n1 - The sNote argument is the name of a text file to send as the note.",
                "paramname": "iMode"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "MailSend(sName, sSubject, sNote, sFileName, iMode)"
    },
    "makecolour": {
        "doc": "Creates a color from red, green and blue component parts.\nMakeColour(nRed,nGreen,nBlue)\nnRed: \nnGreen: \nnBlue: \nAn integer that is an encoded representation of the color created.",
        "example": "! creates the color red\nMakeColour(255,0,0)\n! creates the color white\nMakeColour(255,255,255)",
        "name": "MakeColour",
        "params": [
            {
                "paramdescription": "The color value for red, from 0-255",
                "paramname": "nRed"
            },
            {
                "paramdescription": "The color value for green, from 0-255",
                "paramname": "nGreen"
            },
            {
                "paramdescription": "The color value for blue, from 0-255",
                "paramname": "nBlue"
            }
        ],
        "returnType": "An integer that is an encoded representation of the color created.",
        "syntax": "MakeColour(nRed,nGreen,nBlue)"
    },
    "mapclear": {
        "doc": "Clears all entries in a map and returns the error status. ",
        "example": "! Demonstrate MapClear.\nSTRING sMapName = MapOpen();\n! sMapName is a randomly generated text that uniquely identifies the map\nINT iMapValueSetResult = MapValueSet(sMapName, “SomeKey”, “SomeValue”);\n! iMapValueSetResult will be set to 0 (NO ERROR)\nINT iMapKeyCountResultExpectOne = MapKeyCount(sMapName);\n! iMapKeyCountResultExpectOne will be set to 1\nINT iMapClearResult = MapClear(sMapName);\n! iMapClearResult will be set to 0 (NO ERROR)\nINT iMapKeyCountResultExpectZero = MapKeyCount(sMapName);\n! iMapKeyCountResultExpectZero will be set to 0\nINT iMapCloseResult = MapClose(sMapName);\n! iMapCloseResult will be set to 0 (NO ERROR)\n! The map that is identified by sMapName is now closed and unavailable\n\t\t\t\t",
        "name": "MapClear",
        "params": [
            {
                "paramdescription": "Name of the map to be cleared.",
                "paramname": "sMapName"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned. ",
        "syntax": "INT MapClear(STRING sMapName)"
    },
    "mapclose": {
        "doc": "Closes a  map and returns the error status. \nINT MapClose(STRING sMapName)\nsMapName: \n0 (zero) if successful, otherwise an error code is returned. \nIf the map name is empty an “Invalid argument” error (274) will be raised and returned.\nIf the map does not exist a “Record not found” error (536) will be returned.",
        "example": "! Demonstrate MapClose.\nSTRING sMapName = MapOpen();\n! sMapName is a randomly generated text that uniquely identifies the map\nINT iMapCloseResult = MapClose(sMapName);\n! iMapCloseResult will be set to 0 (NO ERROR)\n! The map that is identified by sMapName is now closed and unavailable\t\t\n\t\t\t\t",
        "name": "MapClose",
        "params": [
            {
                "paramdescription": "Name of the map to be closed.",
                "paramname": "sMapName"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned. ",
        "syntax": "INT MapClose(STRING sMapName)"
    },
    "mapexists": {
        "doc": "Checks for the existence of the map.",
        "example": "! Demonstrate MapExists.\nSTRING sMapName = MapOpen();\n! sMapName is a randomly generated text that uniquely identifies the map\nINT iMapExistsResultExpectTrue = MapExists(sMapName);\n! iMapExistsResultExpectTrue will be set to TRUE (non-zero)\nINT iMapCloseResult = MapClose(sMapName);\n! The map that is identified by sMapName is now closed and unavailable\nINT iMapExistsResultExpectFalse = MapExists(sMapName);\n! iMapExistsResultExpectFalse will be set to FALSE (zero)\n\t\t\n\t\t\t\t\n\t\t\t\t",
        "name": "MapExists",
        "params": [
            {
                "paramdescription": "Name of the map.",
                "paramname": "sMapName"
            }
        ],
        "returnType": "TRUE if the map exists, or FALSE if not.\n",
        "syntax": "INT MapExists(STRING sMapName)"
    },
    "mapkeycount": {
        "doc": "Use this function to retrieve the number of keys in a map.  ",
        "example": "! Demonstrate MapKeyCount.\nSTRING sMapName = MapOpen();\n! sMapName is a randomly generated text that uniquely identifies the map\nINT iMapKeyCountResultExpectZero = MapKeyCount(sMapName);\n! iMapKeyCountResultExpectZero will be set to 0\nINT iMapValueSetResult = MapValueSet(sMapName, “SomeKey”, “SomeValue”);\nINT iMapKeyCountResultExpectOne = MapKeyCount(sMapName);\n! iMapKeyCountResultExpectOne will be set to 1\nINT iMapCloseResult = MapClose(sMapName);\n! The map that is identified by sMapName is now closed and unavailable\t\t\t",
        "name": "MapKeyCount",
        "params": [
            {
                "paramdescription": "Name of the map.",
                "paramname": "sMapName"
            }
        ],
        "returnType": "The number of keys in the map, or a value less than 0 if an error is encountered. ",
        "syntax": "INT MapKeyCount(STRING sMapName)"
    },
    "mapkeydelete": {
        "doc": "Use this function to delete a  key and value from a map.  ",
        "example": "! Demonstrate MapKeyDelete.\nSTRING sMapName = MapOpen();\n! sMapName is a randomly generated text that uniquely identifies the map\nINT iMapValueSetResult = MapValueSet(sMapName, “SomeKey”, “SomeValue”);\nINT iMapKeyCountResultExpectOne = MapKeyCount(sMapName);\n! iMapKeyCountResultExpectOne will be set to 1\nINT iMapKeyDeleteResult = MapKeyDelete(sMapName, “SomeKey”);\nINT iMapKeyCountResultExpectZero = MapKeyCount(sMapName);\n! iMapKeyCountResultExpectZero will be set to 0\nINT iMapCloseResult = MapClose(sMapName);\n! The map that is identified by sMapName is now closed and unavailable",
        "name": "MapKeyDelete",
        "params": [
            {
                "paramdescription": "Name of map.",
                "paramname": "sMapName"
            },
            {
                "paramdescription": "Name of key and value to be deleted.",
                "paramname": "sKeyName"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned. ",
        "syntax": "INT MapKeyDelete(STRING sMapName, STRING sKeyName)"
    },
    "mapkeyexists": {
        "doc": "Use this function to check if a  key exists in a map.  ",
        "example": "! Demonstrate MapKeyExists.\nSTRING sMapName = MapOpen();\n! sMapName is a randomly generated text that uniquely identifies the map\nINT iMapKeyExistsResultExpectFalse = MapKeyExists(sMapName, “SomeKey”);\n! iMapKeyExistsResultExpectFalse will be set to FALSE (zero)\nINT iMapValueSetResult = MapValueSet(sMapName, “SomeKey”, “SomeValue”);\nINT iMapKeyExistsResultExpectTrue = MapKeyExists(sMapName, “SomeKey”);\n! iMapKeyExistsResultExpectTrue will be set to TRUE (non-zero)\nINT iMapCloseResult = MapClose(sMapName);\n! The map that is identified by sMapName is now closed and unavailable\t\t",
        "name": "MapKeyExists",
        "params": [
            {
                "paramdescription": "Name of map to get the value from.",
                "paramname": "sMapName"
            },
            {
                "paramdescription": "Name of the key to get the value from.",
                "paramname": "sKeyName"
            }
        ],
        "returnType": "TRUE if the map exists, or FALSE if not.\n",
        "syntax": "INT MapKeyExists(STRING sMapName, STRING sKeyName)"
    },
    "mapkeyfirst": {
        "doc": "Use this function to retrieve the first  key in a map so that all the keys in a map can be discovered.",
        "example": "! Demonstrate MapKeyFirst.\nSTRING sMapName = MapOpen();\n! sMapName is a randomly generated text that uniquely identifies the map\nINT iMapSetValueResult1 = MapSetValue(sMapName, “somekey”, “somevalue”);\nINT iMapSetValueResult2 = MapSetValue(sMapName, “SomeKey”, “SomeValue”);\nSTRING sMapKeyFirstResult = MapKeyFirst(sMapName);\n! sMapKeyFirstResult will be set to “SomeKey”\n! This shows that the keys are visited in alphabetical order, and that\n! the keys are case sensitive\nINT iMapCloseResult = MapClose(sMapName);\n! The map that is identified by sMapName is now closed and unavailable\t\t",
        "name": "MapKeyFirst",
        "params": [
            {
                "paramdescription": "Name of map to get the value from.",
                "paramname": "sMapName"
            }
        ],
        "returnType": "The first key  in the map, if there are no keys in the map and empty string is returned. ",
        "syntax": "STRING MapKeyFirst(STRING sMapName)"
    },
    "mapkeynext": {
        "doc": "Use this function to retrieve the next  key after the supplied  key in a map so that all the keys in a map can be discovered ",
        "example": "! Demonstrate MapKeyNext.\nSTRING sMapName = MapOpen();\n! sMapName is a randomly generated text that uniquely identifies the map\nINT iMapSetValueResult1 = MapSetValue(sMapName, “somekey”, “somevalue”);\nINT iMapSetValueResult2 = MapSetValue(sMapName, “SomeKey”, “SomeValue”);\nSTRING sMapKeyFirstResult = MapKeyFirst(sMapName);\n! sMapKeyFirstResult will be set to “SomeKey”\nSTRING sMapKeyNextResult = MapKeyNext(sMapName, sMapKeyFirstResult);\n! sMapKeyNextResult will be set to “somekey”\n! This shows that the keys are visited in ordinal order, and that\n! the keys are case sensitive\nINT iMapCloseResult = MapClose(sMapName);\n! The map that is identified by sMapName is now closed and unavailable\t\t",
        "name": "MapKeyNext",
        "params": [
            {
                "paramdescription": "Name of map to retrieve the value from.",
                "paramname": "sMapName"
            },
            {
                "paramdescription": "Name of the key to retrieve the value for.",
                "paramname": "sKeyName"
            }
        ],
        "returnType": "The next key if successful or, an empty string if no next key exists. ",
        "syntax": "STRING MapKeyNext(STRING sMapName, STRING sKeyName)"
    },
    "mapopen": {
        "doc": "Use this function to create a new map or to open an existing map. \nSTRING MapOpen(STRING sMapName, INT nOpenMode, STRING sCloseCallback)\nsMapName: \nnOpenMode: \nsCloseCallback: \nName of map if successful, otherwise an empty string will be returned.\nIf the map name is empty an “Invalid argument” error (274) will be raised.\nIf the open mode is less than 0 or greater than 2, an “Invalid argument” error (274) will be raised.\nIf an empty map name is supplied along with open mode 1, an “Invalid argument” error (274) will be raised.",
        "example": "! Demonstrate MapOpen.\nSTRING sMapName = MapOpen();\n! sMapName is a randomly generated text that uniquely identifies the map\nINT iMapCloseResult = MapClose(sMapName);\n! The map that is identified by sMapName is now closed and unavailable\n \n! Demonstrate MapOpen with a close callback\nSTRING sMapName = MapOpen(“”, 0, “MyCloseCallback”);\n! sMapName is a randomly generated text that uniquely identifies the map\nINT iMapCloseResult = MapClose(sMapName);\n! The map that is identified by sMapName is now closed and unavailable\n! The function MyCloseCallback is called, but it may or may not be\n! completed before the MapClose function returns.\n\n! This is a MapClose callback function\n! The callback must take one string argument which is the name of the\n! map that is being closed.\nFUNCTION MyCloseCallback(STRING sMapName)\n! sMapName is a valid map for the duration of the callback, at the\n! exit of the callback the memory is released and any subsequent\n! use of the map will result in an error.\nEND\n\t\n\t\t\t",
        "name": "MapOpen",
        "params": [
            {
                "paramdescription": "Name of the map to create or open. The default name is an empty string. If name is empty, it will generate an available random name.",
                "paramname": "sMapName"
            },
            {
                "paramdescription": "Indicates the open or create mode of the map. Modes include:\nMode 0 - Create a new map. If a map with the same name exists an “Out of handles” error (271) will be raised.\nMode 1 - Opens an existing map. if there is no map with that name a “Record not found” error (536) will be raised.\nMode 2 – Open an existing map , or creates a new map if the map name does not exist. The error codes from modes 0 and 1 can occur.",
                "paramname": "nOpenMode"
            },
            {
                "paramdescription": "The function to call when this instance is closed.",
                "paramname": "sCloseCallback"
            }
        ],
        "returnType": "Name of map if successful, otherwise an empty string will be returned.",
        "syntax": "STRING MapOpen(STRING sMapName, INT nOpenMode, STRING sCloseCallback)"
    },
    "mapvalueget": {
        "doc": "Use this function to retrieve the value from a key in a map.  ",
        "example": "! Demonstrate MapValueGet.\nSTRING sMapName = MapOpen();\n! sMapName is a randomly generated text that uniquely identifies the map\nINT iMapValueSetResult = MapValueSet(sMapName, “SomeKey”, “SomeValue”);\nSTRING sMapValueGetResult = MapValueGet(sMapName, “SomeKey”);\n! sMapValueGetResult will be set to “SomeValue”\nINT iMapCloseResult = MapClose(sMapName);\n! The map that is identified by sMapName is now closed and unavailable\t\t",
        "name": "MapValueGet",
        "params": [
            {
                "paramdescription": "Name of map.",
                "paramname": "sMapName"
            },
            {
                "paramdescription": "Name of the key to retrieve the value from.",
                "paramname": "sKeyName"
            }
        ],
        "returnType": "Value returned is a VARIANT that also contains QUALITY and TIMESTAMP components, otherwise an error code is returned.",
        "syntax": "VARIANT MapValueGet(STRING sMapName, STRING sKeyName)"
    },
    "mapvalueset": {
        "doc": "Use this function to set a value of a map key. ",
        "example": "! Demonstrate MapValueSet.\nSTRING sMapName = MapOpen();\n! sMapName is a randomly generated text that uniquely identifies the map\nINT iMapValueSetResult = MapValueSet(sMapName, “SomeKey”, “SomeValue”);\nSTRING sMapValueGetResult = MapValueGet(sMapName, “SomeKey”);\n! sMapValueGetResult will be set to “SomeValue”\nINT iMapCloseResult = MapClose(sMapName);\n! The map that is identified by sMapName is now closed and unavailable\t\t",
        "name": "MapValueSet",
        "params": [
            {
                "paramdescription": "Name of the map to create or open. ",
                "paramname": "sMapName"
            },
            {
                "paramdescription": "Name of the key to set.",
                "paramname": "sKeyName"
            },
            {
                "paramdescription": "Name of the value to be set",
                "paramname": "Value"
            },
            {
                "paramdescription": "0 - Create a new property\n1- Override an existing property\n2 - Assign the value whether the key already exists or not. This is the default mode.",
                "paramname": "nSetMode"
            }
        ],
        "returnType": "If the value is set correctly, the result is “No Error” (0), otherwise an error code is returned.",
        "syntax": "INT MapValueSet(STRING sMapName, STRING sKeyName, VARIANT Value INT nSetMode)"
    },
    "mapvaluesetquality": {
        "doc": "Use this function to set the quality of a property in a map.",
        "example": "! Demonstrate MapValueSetQuality.\nSTRING sMapName = MapOpen();\n! sMapName is a randomly generated text that uniquely identifies the map\nINT iMapValueSetResult = MapValueSet(sMapName, “SomeKey”, “SomeValue”);\nQUALITY qVariableQualityResultExpectGood =\nVariableQuality(MapValueGet(sMapName, “SomeKey”));\n! qVariableQualityResultExpectGood is set to GOOD QUALITY (checked below)\nINT iQualityIsGoodResultExpectTrue =\nQualityIsGood(qVariableQualityResultExpectGood);\n! iQualityIsGoodResultExpectTrue is set to TRUE (non-zero)\nINT iMapValueSetQualityResult =\nMapValueSetQuality(sMapName, “SomeKey”, QualityCreate(QUAL_BAD));\n! iMapValueSetQualityResult will be set to 0 (NO ERROR)\nQUALITY qVariableQualityResultExpectBad =\nVariableQuality(MapValueGet(sMapName, “SomeKey”));\n! qVariableQualityResultExpectBad is set to BAD QUALITY (checked below)\nINT iQualityIsGoodResultExpectFalse =\nQualityIsGood(qVariableQualityResultExpectBad);\n! iQualityIsGoodResultExpectFalse is set to FALSE (zero)\nINT iMapCloseResult = MapClose(sMapName);\n! The map that is identified by sMapName is now closed and unavailable\t\t\t",
        "name": "MapValueSetQuality",
        "params": [
            {
                "paramdescription": "Name of the map.",
                "paramname": "sMapName"
            },
            {
                "paramdescription": "Name of the key to override the quality for",
                "paramname": "sKeyName"
            },
            {
                "paramdescription": "",
                "paramname": "Quality"
            },
            {
                "paramdescription": "",
                "paramname": "Quality to override in an existing value. There is no default value. The QUALITY type is created using the QualityCreate function."
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned. ",
        "syntax": "INT MapValueSetQuality(STRING sMapName, STRING sKeyName, QUALITY Quality)"
    },
    "max": {
        "doc": "Gets the higher of two numbers.",
        "example": "Variable=Max(24,12);\n! Sets Variable to 24.",
        "name": "Max",
        "params": [
            {
                "paramdescription": " The first number.",
                "paramname": "Number1"
            },
            {
                "paramdescription": " The second number.",
                "paramname": "Number2"
            }
        ],
        "returnType": "The higher of numbers Number1 and             Number2.",
        "syntax": "Max(Number1, Number2)"
    },
    "menugetchild": {
        "doc": "Returns the handle to the child node with the specified name.",
        "example": "No example found",
        "name": "MenuGetChild",
        "params": [
            {
                "paramdescription": "Handle to the parent node in the menu tree.",
                "paramname": "hParent"
            },
            {
                "paramdescription": "The name of the child Menu node requested.",
                "paramname": "sName"
            }
        ],
        "returnType": "The handle of the child node with the requested name, or -1 if unsuccessful.",
        "syntax": "MenuGetChild(hParent, sName)"
    },
    "menugetfirstchild": {
        "doc": "Returns the handle to the first child of a menu node.",
        "example": "No example found",
        "name": "MenuGetFirstChild",
        "params": [
            {
                "paramdescription": "The handle to the parent node in the menu tree.",
                "paramname": "hNode"
            }
        ],
        "returnType": "The handle to the first child node of a menu node, or -1 if unsuccessful.",
        "syntax": "MenuGetFirstChild(hNode)"
    },
    "menugetgenericnode": {
        "doc": "Returns the handle to the base node of the menu tree for the generic pages. Its child nodes represent the menu items that do not have a page specified in the menu configuration database.",
        "example": "No example found",
        "name": "MenuGetGenericNode",
        "params": [
            {
                "paramdescription": "Determines if the node should be created if it does not exist. Defaults to 0, do not create. ",
                "paramname": "bCreate"
            }
        ],
        "returnType": "The handle to the base node of the menu tree, or -1 if it cannot find the node.",
        "syntax": "MenuGetGenericNode([bCreate])"
    },
    "menugetnextchild": {
        "doc": "Returns the next node that shares the same parent.",
        "example": "No example found",
        "name": "MenuGetNextChild",
        "params": [
            {
                "paramdescription": "Handle to the current node in the menu tree",
                "paramname": "hChild"
            }
        ],
        "returnType": "The handle to next node that shares the same parent, or -1 if unsuccessful.",
        "syntax": "MenuGetNextChild(hChild)"
    },
    "menugetnodebypath": {
        "doc": "Returns a menu handle corresponding to a menu item expressed as a string path in the format  <level>.<level>.<level>.<level>.",
        "example": "No example found",
        "name": "MenuGetNodeByPath",
        "params": [
            {
                "paramdescription": "The menu to which the specified menu path belongs. Root menu node returned from MenuGetPageNode().",
                "paramname": "hMenuNode"
            },
            {
                "paramdescription": "The menu path for which to get the handle.",
                "paramname": "sMenuPath"
            }
        ],
        "returnType": "Returns a menu handle for use with other Plant SCADA menu functions.",
        "syntax": "MenuGetNodeByPath(INT hMenuNode, STRING sMenuPath)"
    },
    "menugetpagenode": {
        "doc": "Returns the handle to the menu tree for a specified page. Its child nodes represent the menu items that have the particular page specified in the menu configuration database.",
        "example": "No example found",
        "name": "MenuGetPageNode",
        "params": [
            {
                "paramdescription": "The name of the page for which to return the menu tree handle.",
                "paramname": "sPage"
            },
            {
                "paramdescription": "The mode to use for generating the menu handle for the page:\n0 - Return the base node for the menu tree for the specified page if it exists, otherwise return -1 (do not create). Default value.",
                "paramname": "nMode"
            }
        ],
        "returnType": "The handle of the menu tree, or -1 if no menu tree exists for a specified page.",
        "syntax": "MenuGetPageNode(sPage [, nMode])"
    },
    "menugetparent": {
        "doc": "Returns the parent node of the menu item.",
        "example": "No example found",
        "name": "MenuGetParent",
        "params": [
            {
                "paramdescription": "Handle to the current node in the menu tree.",
                "paramname": "hNode"
            }
        ],
        "returnType": "The handle to parent menu node of the given menu item, or -1 if unsuccessful.",
        "syntax": "MenuGetParent(hNode)"
    },
    "menugetprevchild": {
        "doc": "Returns the previous node that shares the same parent.",
        "example": "No example found",
        "name": "MenuGetPrevChild",
        "params": [
            {
                "paramdescription": "Handle to the current node in the menu tree.",
                "paramname": "hChild"
            }
        ],
        "returnType": "The handle to previous node that shares the same parent, or -1 if unsuccessful.",
        "syntax": "MenuGetPrevChild(hChild)"
    },
    "menugetwindownode": {
        "doc": "Returns the handle to the root node for a given window. This menu node is dynamically created for each page instance. Its child nodes represent the menu items for the generic pages merged with the ones specific to this page.",
        "example": "No example found",
        "name": "MenuGetWindowNode",
        "params": [
            {
                "paramdescription": "The window number of the desired window. You can call WinNumber() to get the window number of the page that calls this Cicode function.",
                "paramname": "hWin"
            }
        ],
        "returnType": "The handle to the root node of a given window, or -1 if unsuccessful.",
        "syntax": "MenuGetWindowNode(hWin)"
    },
    "menunodeaddchild": {
        "doc": "Dynamically add a new item to the menu at runtime. Be reminded that the changes are for the current session only and will not be persisted to the _Pagemen.RDB file.\nBe reminded that changes made to the menu tree will not be persisted back to the menu configuration database.",
        "example": "No example found",
        "name": "MenuNodeAddChild",
        "params": [
            {
                "paramdescription": "Handle of the parent node to add the new menu item under.",
                "paramname": "hParent"
            },
            {
                "paramdescription": "The string label of the new menu item.",
                "paramname": "sName"
            },
            {
                "paramdescription": "Specifies the name of the Cicode function to run.",
                "paramname": "sCommandName"
            },
            {
                "paramdescription": "Specifies the parameters of the Cicode function to run.",
                "paramname": "sCommandArgs"
            },
            {
                "paramdescription": "The symbol to be associated with the menu item.",
                "paramname": "sSymbol"
            },
            {
                "paramdescription": "The relative position in the menu for new item.",
                "paramname": "iOrder"
            }
        ],
        "returnType": "The handle of the new node, or -1 if unsuccessful.",
        "syntax": "MenuNodeAddChild(hParent, sName, sCommandName [, sCommandArgs] [, sSymbol] [, iOrder])"
    },
    "menunodegetcurr": {
        "doc": "Each menu node can have a Command associated with it when a menu is configured. This function allows you to get the  handle of the menu node when this associated command is called. \nMenuNodeGetCurr( )",
        "example": "No example found",
        "name": "MenuNodeGetCurr",
        "params": [],
        "returnType": "The handle of the menu node. ",
        "syntax": "MenuNodeGetCurr( )"
    },
    "menunodegetdepth": {
        "doc": "Returns the depth of a specified menu node within a menu hierarchy.",
        "example": "No example found",
        "name": "MenuNodeGetDepth",
        "params": [
            {
                "paramdescription": "Handle of the menu node.",
                "paramname": "hNode"
            }
        ],
        "returnType": "The depth of the specified node  within the menu hierarchy. For example, 0 indicates it is on the root node of the menu, 1 indicates one level below the root node, and so on.",
        "syntax": "MenuNodeGetDepth(hNode)"
    },
    "menunodegetexpanded": {
        "doc": "Gets the expansion state value of the specified menu node in number. The expansion state value is user defined can be any integer value. The value is set by MenuNodeSetExpanded function and the initial value is zero(0).",
        "example": "MenuNodeSetExpanded(100, 99)\n//Put 99 as an expansion state of the menu node handle 100",
        "name": "MenuNodeGetExpanded",
        "params": [
            {
                "paramdescription": "Handle to the current node in the menu tree.",
                "paramname": "hNode"
            }
        ],
        "returnType": "The expansion state value to set for the Menu node or -1 if unsuccessful. ",
        "syntax": "MenuNodeGetExpanded(hNode)"
    },
    "menunodegetproperty": {
        "doc": "Return the item value of the specified menu node.",
        "example": "No example found",
        "name": "MenuNodeGetProperty",
        "params": [
            {
                "paramdescription": "Handle to the current node in the menu tree.",
                "paramname": "hNode"
            },
            {
                "paramdescription": "Field for which you want the value:\n0 - Name of menu item.\n1 - Icon symbol to be associated with the menu item.\n2 - Privilege level required to run the command, otherwise the menu item is disabled.\n3 - Area level required to run the command, otherwise the menu item is disabled.\n4 - Disabled Style. Allows different display style for a disabled menu item.\n5 - Checked setting. Whether the menu item will display a check box next to the label.\n6 - Width. Specifies the menu item width in pixels.\n7 - Comment.\n8 - Cluster.\n9 - Equipment.\n10 - Expansion state value stored by MenuNodeSetExpanded.\n11 - Order.\n12 - Page.\n13 - Target page of the menu item.\n101-108 - Custom 1 to Custom 8.",
                "paramname": "iField"
            }
        ],
        "returnType": "The value for the specified menu node field.",
        "syntax": "MenuNodeGetProperty(hNode, iField)"
    },
    "menunodegettargetpage": {
        "doc": "Returns the target page for a specified menu node.",
        "example": "No example found",
        "name": "MenuNodeGetTargetPage",
        "params": [
            {
                "paramdescription": "Handle of the menu node. If not specified, the handle of the menu node will be determined through it's association with the command that is currently being called. Each menu node can have a Command associated with it when a menu is configured.",
                "paramname": "hNode"
            }
        ],
        "returnType": "The name of the target page for the specified node.",
        "syntax": "MenuNodeGetTargetPage(hNode)"
    },
    "menunodehascommand": {
        "doc": "Checks whether the menu node has a valid Cicode command associated with it.",
        "example": "No example found",
        "name": "MenuNodeHasCommand",
        "params": [
            {
                "paramdescription": "Handle of node to check.",
                "paramname": "hNode"
            }
        ],
        "returnType": "1 if the menu node has a valid Cicode command, 0 if the menu node has no Cicode command.",
        "syntax": "MenuNodeHasCommand(hNode)"
    },
    "menunodeisdisabled": {
        "doc": "Checks whether the menu node is disabled by evaluating its DisabledWhen Cicode expression.",
        "example": "INT hNode = MenuNodeFirstChild(hParent);\nIF (MenuNodeIsDisabled(hNode)) THEN\n\t! set the menu item graphic state to disabled\nEND",
        "name": "MenuNodeIsDisabled",
        "params": [
            {
                "paramdescription": "Handle of node to check.",
                "paramname": "hNode"
            }
        ],
        "returnType": "1 if menu node DisabledWhen expression evaluates to true, 0 if menu node DisabledWhen expression evaluates to false.",
        "syntax": "MenuNodeIsDisabled(hNode)"
    },
    "menunodeishidden": {
        "doc": "Checks whether the menu node is hidden by evaluating its HiddenWhen Cicode expression.",
        "example": "INT hNode = MenuNodeFirstChild(hParent);\nIF (MenuNodeIsHidden(hNode)) THEN\n\t! set the menu item graphic state to hidden\nEND",
        "name": "MenuNodeIsHidden",
        "params": [
            {
                "paramdescription": "Handle of node to check.",
                "paramname": "hNode"
            }
        ],
        "returnType": "1 if menu node HiddenWhen expression evaluates to true, 0 if menu node HiddenWhen expression evaluates to false.",
        "syntax": "MenuNodeIsHidden(hNode)"
    },
    "menunoderemove": {
        "doc": "Remove the menu node from the menu tree.\nBe reminded that changes made to the menu tree will not be persisted back to the menu configuration database.",
        "example": "No example found",
        "name": "MenuNodeRemove",
        "params": [
            {
                "paramdescription": "Handle of node to remove.",
                "paramname": "hNode"
            }
        ],
        "returnType": "Zero (0) if node successfully removed. -1 if hNode is an invalid menu handle.",
        "syntax": "MenuNodeRemove(hNode)"
    },
    "menunoderuncommand": {
        "doc": "Run the associated command for a menu node.",
        "example": "No example found",
        "name": "MenuNodeRunCommand",
        "params": [
            {
                "paramdescription": "Handle of node to run command.",
                "paramname": "hNode"
            }
        ],
        "returnType": "No error(0) on success. Bad handle specified (269) if hNode does not refer to a valid node.",
        "syntax": "MenuNodeRunCommand(hNode)"
    },
    "menunodesetdisabledwhen": {
        "doc": "Set the DisabledWhen expression for a newly added node. Be aware this function only works for menu nodes added with MenuNodeAddChild(). The DisabledWhen expression may only be set once for a node.\nBe reminded that changes made to the menu tree will not be persisted back to the menu configuration database.",
        "example": "INT hNode = MenuNodeAddChild((hParent, \"LogIn\", \"LogIn\");\nINT Error = MenuNodeSetDisabledWhen(hNode, \"UserInfo\", \"0\", 1);",
        "name": "MenuNodeSetDisabledWhen",
        "params": [
            {
                "paramdescription": "Handle of node to run command",
                "paramname": "hNode"
            },
            {
                "paramdescription": "Cicode function for DisabledWhen expression. The function needs to return an INT.",
                "paramname": "sDisabledWhenName"
            },
            {
                "paramdescription": "Cicode parameters for DisabledWhen expression. Only supports static arguments.",
                "paramname": "sDisabledWhenArgs"
            },
            {
                "paramdescription": "Disabled Style. Allows different display styles for a disabled menu item.",
                "paramname": "iDisabledStyle"
            }
        ],
        "returnType": "No Error(0) on success, Bad handle specified (269) if hNode does not refer to a valid node, Invalid argument passed (274) if DisabledWhen Cicode has already been set or is not a valid expression.",
        "syntax": "MenuNodeSetDisabledWhen(hNode, sDisabledWhenName [, sDisabledWhenArgs] [, iDisabledStyle])"
    },
    "menunodesetexpanded": {
        "doc": "Set the expansion state value of the specified menu node in number. The expansion state value is defined by project designer and can be any integer value. The initial value is zero(0). It is not recommended to use -1 for the expansion state value though because this number indicates an error for MenuNodeGetExpanded function.\nMenuNodeSetExpanded(hNode. iValue)\nhNode: \niValue: \nZero (0) if successful. -1 if hNode is invalid or an error code for any other error. ",
        "example": "MenuNodeSetExpanded(100, 99)\n//Put 99 as an expansion state of the menu node handle 100",
        "name": "MenuNodeSetExpanded",
        "params": [
            {
                "paramdescription": "Handle to the current node in the menu tree.",
                "paramname": "hNode"
            },
            {
                "paramdescription": "The expansion state value to set for the Menu node. ",
                "paramname": "iValue"
            }
        ],
        "returnType": "Zero (0) if successful. -1 if hNode is invalid or an error code for any other error. ",
        "syntax": "MenuNodeSetExpanded(hNode. iValue)"
    },
    "menunodesethiddenwhen": {
        "doc": "Set the HiddenWhen expression for a newly added node. Be aware this function only works for menu nodes added with MenuNodeAddChild(). The HiddenWhen expression may only be set once for a node.\nBe reminded that changes made to the menu tree will not be persisted back to the menu configuration database.",
        "example": "INT hNode = MenuNodeAddChild(hParent, \"LogIn\", \"LogIn\");\nINT Error = MenuNodeSetHiddenWhen(hNode, \"UserInfo\", \"0\");",
        "name": "MenuNodeSetHiddenWhen",
        "params": [
            {
                "paramdescription": "Handle of node to run command.",
                "paramname": "hNode"
            },
            {
                "paramdescription": "Cicode function for HiddenWhen expression. The function needs to return an INT.",
                "paramname": "sHiddenWhenName"
            },
            {
                "paramdescription": "Cicode parameters for HiddenWhen expression. Only supports static arguments.",
                "paramname": "sHiddenWhenArgs"
            }
        ],
        "returnType": "No Error (0) on success, Bad handle specified (269) if hNode does not refer to a valid node, or Invalid argument passed (274) if HiddenWhen Cicode has already been set or is not a valid expression.",
        "syntax": "MenuNodeSetHiddenWhen(hNode, sHiddenWhenName [, sHiddenWhenArgs])"
    },
    "menunodesetproperty": {
        "doc": "Set the item value of the specified menu node.\nBe reminded that changes made to the menu tree will not be persisted back to the menu configuration database.",
        "example": "No example found",
        "name": "MenuNodeSetProperty",
        "params": [
            {
                "paramdescription": "Handle to the current node in the menu tree.",
                "paramname": "hNode"
            },
            {
                "paramdescription": "Field for which you want to set the value:\n0 - Name of menu item.\n1 - Icon symbol to be associated with the menu item.\n2 - Privilege level required to run the command, otherwise the menu item is disabled.\n3 - Area level required to run the command, otherwise the menu item is disabled.\n4 - Disabled Style. Allows different display style for a disabled menu item.\n5 - Checked setting. Whether the menu item will display a check box next to the label.\n6 - Width. Specifies the menu item width in pixels.\n7 - Comment.\n8 - Cluster.\n9 - Equipment.\n10 - Expansion state value.\n13 - Target page for the menu item.\n101 to108 - Custom 1 to Custom 8.",
                "paramname": "iField"
            },
            {
                "paramdescription": "The item value to set for the Menu node.",
                "paramname": "sValue"
            }
        ],
        "returnType": "Zero (0) if successful. -1 if hNode or iField is invalid. An error code for others.",
        "syntax": "MenuNodeSetProperty(hNode, iField, sValue)"
    },
    "menureload": {
        "doc": "Reload base Menu Configuration from the compiled database.\nBe reminded that the menu configuration loaded on the currently displayed page will not change until the page is refreshed. By default, menu configuration is automatically reloaded whenever a page is displayed.",
        "example": "No example found",
        "name": "MenuReload",
        "params": [],
        "returnType": "None.",
        "syntax": "MenuReload()"
    },
    "message": {
        "doc": "Displays a message box on the screen and waits for the user to select the OK or Cancel button.\nThis function is a blocking function. It will block the calling Cicode task until the operation is complete.\nThis function will be blocked if called from a non-client process, as well as from kernel window of a client process if [Client]DisableDisplay is set to TRUE.",
        "example": "/* Display an error message in a message box. */\nIF Total<>100 THEN\n    Message(\"Error\",\"Total not 100%\",48);\nEND",
        "name": "Message",
        "params": [
            {
                "paramdescription": " The title of the message box. The maximum length is 254 chars. ",
                "paramname": "Title"
            },
            {
                "paramdescription": " The prompt displayed in the message box.",
                "paramname": "Prompt"
            },
            {
                "paramdescription": " The mode of the message box:\n0 - OK button\n1 - OK and Cancel button\n16 - Stop Icon\n32 - Question Icon\n48 - Exclamation Icon\n64 - Information Icon\nSelect more than one mode by adding the modes. For example, set Mode to 33 to display the OK and Cancel buttons and the Question icon. You can only display one icon for the message box.",
                "paramname": "Mode"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned. If the user presses the Cancel button the function returns an error code of 299.",
        "syntax": "Message(Title, Prompt, Mode)"
    },
    "min": {
        "doc": "Returns the lower of two numbers.",
        "example": "Variable=Min(24,12);\n! Sets Variable to 12.",
        "name": "Min",
        "params": [
            {
                "paramdescription": " The first number.",
                "paramname": "Number1"
            },
            {
                "paramdescription": " The second number.",
                "paramname": "Number2"
            }
        ],
        "returnType": "The lower of numbers Number1 and             Number2.",
        "syntax": "Min(Number1, Number2)"
    },
    "msgbrdcst": {
        "doc": "Broadcasts a message to all the clients of a server. You should call this function only on a Plant SCADA server. The message is only received by clients that have a current message session (opened with the MsgOpen() function).",
        "example": "! Send a message to all alarm clients.\nMsgBrdcst(\"Alarm\",0,\"Alarm Occurred\");",
        "name": "MsgBrdcst",
        "params": [
            {
                "paramdescription": " The name of the Plant SCADA server.",
                "paramname": "sName"
            },
            {
                "paramdescription": " The message number.",
                "paramname": "nType"
            },
            {
                "paramdescription": " The message text.",
                "paramname": "Str"
            },
            {
                "paramdescription": "The name of the cluster to which the server being communicated withbelongs. This is optional if you have one cluster.",
                "paramname": "sClusterName"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "MsgBrdcst(Name, Type, Str [, sClusterName])"
    },
    "msgclose": {
        "doc": "Closes a message. After the message is closed, the message post function (the callback function specified in the MsgOpen() function) is not called if a message is received. When the server side is closed, all clients are closed. When the client side is closed, only the specified client is closed.",
        "example": "MsgClose(\"Alarm\",hMsg);",
        "name": "MsgClose",
        "params": [
            {
                "paramdescription": " The name of the Plant SCADA server.",
                "paramname": "sName"
            },
            {
                "paramdescription": " The message handle, returned from the MsgOpen() function. The message handle identifies the table where all data on the associated message is stored.",
                "paramname": "hMsg"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "MsgClose(Name, hMsg)"
    },
    "msggetcurr": {
        "doc": "Gets the handle of the client message that called the report or remote procedure that is currently running. You can call this function only in a report or a remote procedure call.\nIf the report was called by a client, this function returns that client message handle. The report can then send a message back to the client. If a function was called remotely by MsgRPC(), this function returns the message handle for the remote client.",
        "example": "! Send message back to the client.\nhMsg=MsgGetCurr();\nIF hMsg<>-1 THEN\n    MsgRPC(hMsg,\"Prompt\",\"^\"Hello Client from Report Server^\"\",1);\nEND",
        "name": "MsgGetCurr",
        "params": [],
        "returnType": "The handle for the client message. The message handle identifies the table where all data on the associated message is stored. The function returns -1 if no client called the report or function.",
        "syntax": "MsgGetCurr()"
    },
    "msgopen": {
        "doc": "Opens a message session with a Plant SCADA server. You can specify a message post function - a callback function that is automatically called when a message arrives. In this function you can call MsgRead() to get the message, and perform other tasks common to your message sessions. You can then call MsgWrite() to send a message back to the caller, MsgRPC() to call a procedure on the caller, and so on.\nA logged on user is required for this function to be successful.\nMsgOpen(Name, Mode, Fn [, sClusterName] )\nYou should use MsgState() to check the return value of MsgOpen(), unless you are using mode 1. The message post function is set effectively only if MsgState() returns 1, which means the message session is online.\nYou can open a client-server message session or a session between redundant servers. This function does not create extra network sessions; it uses Plant SCADA's existing sessions, so you create sessions to the alarm server, report server, trend server, or a named I/O server.\nsName: \nMode: \nFn: \nsClusterName: \nThe message handle, or -1 if the session cannot be opened. The message handle identifies the table where data on the associated message is stored. The exception to this is mode 1 where the handle 4096 will be returned if the session can be opened.\nYou should use MsgState() to check the return value of MsgOpen(), unless you are using mode 1. The message post function is set effectively only if MsgState() returns 1, which means the message session is online.\nYou can open a client-server message session or a session between redundant servers. This function does not create extra network sessions; it uses Plant SCADA's existing sessions, so you create sessions to the alarm server, report server, trend server, or a named I/O server.",
        "example": "INT hClient = -1;\nINT hServer = -1;\n// Open message session on the client, connecting using the\n//existing message session to the current Alarm server\nFUNCTION\nMsgClientOpen()\n     INT nState;\n     hClient = MsgOpen(\"Alarm\", 0, MsgPostClient);\n     IF hClient <> -1 THEN\n          nState = MsgState(hClient);\n          SELECT CASE nState\n          CASE 1\n               Prompt(\"Client Message session is online!\");\n          CASE -1\n               Prompt(\"Client Message session handle is invalid!\");\n          CASE 0\n               Prompt(\"Client Message session is offline!\");\n          CASE 2\n               Prompt(\"Client Message session is connecting!\");\n          CASE 3\n               Prompt(\"Client Message session is disconnecting!\");\n          CASE ELSE\n               Prompt(\"Client Message session has unknown status!\");\n          END SELECT\n     ELSE\n          Prompt(\"Client Message session could not be opened!\");\n     END\nEND\n// Open message session on the server\nFUNCTION\nMsgServerOpen()\n     INT nState;\n     hServer = MsgOpen(\"Alarm\", 1, MsgPostServer);\n     // Opening a server connection will result in returning 4096 (if successfully opened)\n     // and should not be checked via MsgState\n     IF hServer <> 4096 THEN\n          ErrLog(\"Server Message session could NOT be opened!\");\n     ELSE\n          ErrLog(\"Server Message session is online!\");\n     END\nEND\n// This function is called when the server receives a message from\n//the client\nINT\nFUNCTION\nMsgPostServer()\n     INT Type;\n     INT hCurr;\n     STRING Str;\n     // Record the returned handle from the read to use it for the write\n     hCurr = MsgRead(Type,Str);\n     ErrLog(\"Server recieved Message: Type = \"+Type:###+\" Str = \"+Str);\n     MsgServerWrite(hCurr);\n     RETURN 0;\nEND\n// This function is called when the client receives a message from\n//the server\nINT\nFUNCTION\nMsgPostClient()\n     INT Type;\n     INT replyHandle;\n     STRING Str;\n     MsgRead(Type,Str);\n     Prompt(\"Client recieved message: Type = \"+Type:###+\" Str = \"+Str);\n     RETURN 0;\nEND\n// Write a message to the server\nFUNCTION\nMsgClientWrite()\n     Prompt(\"Client Write\");\n     MsgWrite(hClient, 1, \"MyClientMessage\");\nEND\n// Write a message to the client\nFUNCTION\nMsgServerWrite(INT hCurr)\n     MsgWrite(hCurr, 1, \"MyServerMessage\");\nEND",
        "name": "MsgOpen",
        "params": [
            {
                "paramdescription": " The name of the server to open, either:\nFor Mode 0, 1, or 3: \"Alarm\", \"Report\", \"Trend\", or the name of an I/O server.\nFor Mode 2: The default computer name, as set in the [LAN]Node parameter.",
                "paramname": "sName"
            },
            {
                "paramdescription": " The mode of the message session to open:\n0 - Open the client side.\n1 - Open the server side.\n2 - Open a session from a server to the default computer name. Set Name to the computer name of the computer, as defined by the [LAN]Node parameter.\n3 - Open a message session between redundant servers. (Clients cannot tell which server they are connected to or if something has changed on the server. Changes should be performed on the redundant server as well.)\n4 - Open a message session from the calling process to the client process. The Name and Fn are ignored in this mode. The message session opened in this mode does not need to call MsgClose.",
                "paramname": "Mode"
            },
            {
                "paramdescription": "The message post function, that is a callback function for themessage event. Set Fn to 0 if no event callback function isrequired.",
                "paramname": "Fn"
            },
            {
                "paramdescription": "The name of the cluster the server being communicated withbelongs to, this is used when mode is 0, 1 or 3. This is notrequired if the client is connected to only one clustercontaining a server of the type set in the name parameter.",
                "paramname": "sClusterName"
            }
        ],
        "returnType": "The message handle, or -1 if the session cannot be opened. The message handle identifies the table where data on the associated message is stored. The exception to this is mode 1 where the handle 4096 will be returned if the session can be opened.",
        "syntax": "MsgOpen(Name, Mode, Fn [, sClusterName] )"
    },
    "msgread": {
        "doc": "Reads a message from a message session. You can call this function only in a message post function (the callback function specified in the MsgOpen() function), to read the current message.\nThe nType and Str variables of this function return the message number and the text of the message. The return value of this function is the message handle (allowing a response to be sent back if required).\nyou need to open the message session using the MsgOpen() function, to enable the callback function.",
        "example": "/* This function will read a message from the session and if \nType=1, will display the string as a prompt. If Type=2 then the \nspeaker beeps and an acknowledgment is sent back to the caller. */\nINT\nFUNCTION\nMsgPostClient()\n    INT Type;\n    STRING Str;\n    INT hMsg;\n    hMsg=MsgRead(Type,Str);\n    IF Type=1 THEN\n        Prompt(\"Message\"+Str);\n    ELSE\n        IF Type=2 THEN\n            Beep();\n            MsgWrite(hMsg,2,\"DONE\");\n        END\n    END\nEND",
        "name": "MsgRead",
        "params": [
            {
                "paramdescription": "The message number. Must be a Long type variable.",
                "paramname": "nType"
            },
            {
                "paramdescription": "The message text. Must be a String type variable.",
                "paramname": "Str"
            }
        ],
        "returnType": "The message handle of the message being read.",
        "syntax": "MsgRead(Type, Str)"
    },
    "msgrpc": {
        "doc": "Calls a remote procedure on another Plant SCADA computer. You can call any of the built-in Cicode functions remotely, or your own functions. You pass the sName of the function as a string, not as the function tag, and pass all the arguments for that function in Arg.\nYou can call the function in synchronous or asynchronous Mode. In synchronous mode, MsgRPC() does not return until the remote function is called and the result is returned. In asynchronous mode, MsgRPC() returns before the function is called, and the result cannot be returned.\nMsgRPC(hMsg, sName, Arg, Mode)\nhMsg: \nsName: \nArg: \nMode: \nThe result of the remote function call (as a string). If the function is called in asynchronous mode the result of the remote function cannot be returned, so an empty string is returned.\nMsgOpen, MsgClose, MsgRead, MsgWrite",
        "example": "! Call remote procedure, call MyRPC() on server. Wait for result\nStr=MsgRPC(hMsg,\"MyRPC\",\"Data\",0);\n! Call remote procedure, pass two strings. Don't wait for call to complete.\n! be careful of your string delimiters as shown.\nMsgRPC(hMsg,\"MyStrFn\",\"^\"First string^\",^\"Second string^\"\",1);\n! Call remote procedure, pass Cicode string. Don't wait for call to complete.\nSTRING sMessage = \"this is a message\";\nMsgRPC(hMsg,\"MyStrFn\",\"^\"\" + sMessage + \"^\"\",1);\n! These functions could be used to acknowledge an alarm by record \nfrom any \nPlant SCADA\n Client on the network.\n! The AlmAck() function is initialized by the Control Client \n(Don't forget that servers are also Control Clients.)\n! The Alarm tag is passed into the function as a string and a \nmessage is sent to the Alarms Server to initialize\n! the AlmAckMsg() function.\nFUNCTION\nAlmAck(String AlmTag)\n    INT hAlarm1;\n    hAlarm1 = MsgOpen(\"Alarm\", 0, 0);\n    MsgRPC(hAlarm1,\"AlmAckMsg\",AlmTag,1);\n    MsgClose(\"Alarm\", hAlarm1);\nEND\n! The AlmAckMsg() function is executed on the Alarms Server that \nthe client is connected to. This could be\n! either the primary or standby Alarms Server. The function \nperforms the alarm acknowledge.\nFUNCTION\nAlmAckMsg(String AlmTag)\n    AlarmAckRec(AlarmFirstTagRec(AlmTag,\"\",\"\"));\nEND",
        "name": "MsgRPC",
        "params": [
            {
                "paramdescription": " The message handle, returned from the MsgOpen() function. The message handle identifies the table where all data on the associated message is stored.",
                "paramname": "hMsg"
            },
            {
                "paramdescription": " The name of the function to call remotely, as a string.\nIf this function returns an error, you should confirm that the name you have used is not a label instead of the actual function name. Some functions are aliased using a label, for example, the function _AlarmGetFieldRec is defined in the labels database as \"AlarmGetFieldRec\". In this case, only \"_AlarmGetFieldRec\" should be passed to MsgRPC.",
                "paramname": "sName"
            },
            {
                "paramdescription": " The arguments to pass to the function, separated by commas (,). Enclose string arguments in quotes \"\" and use the string escape character (^) around strings enclosed within a string. If you do not enclose the string in quotes, then the string is only the first tag found.",
                "paramname": "Arg"
            },
            {
                "paramdescription": " The mode of the call:\n0 - Blocking mode - synchronous.\n1 - Non-blocking mode - asynchronous.",
                "paramname": "Mode"
            }
        ],
        "returnType": "The result of the remote function call (as a string). If the function is called in asynchronous mode the result of the remote function cannot be returned, so an empty string is returned.",
        "syntax": "MsgRPC(hMsg, sName, Arg, Mode)"
    },
    "msgstate": {
        "doc": "Verifies the status of a message session. Use MsgState() to check the return value of MsgOpen(). A message post function is set effectively only if MsgState() returns 1, which means the message session is online.",
        "example": "INT hClient = -1;\n       \n // Open message session on the client, connecting using the \nexisting \n // message session to the current Alarm server \n               FUNCTION\nMsgClientOpen()\n    INT nState;\n    hClient = MsgOpen(\"Alarm\", 0, MsgPostClient);\n    IF hClient <> -1 THEN\n        nState = MsgState(hClient);\n        SELECT CASE nState\n        CASE 1\n            Prompt(\"Message session is online!\");\n            //Send a message to the server\n            MsgWrite(hClient, 1, \"MyMessage\");\n        CASE -1\n            Prompt(\"Message session handle is invalid!\");\n        CASE 0\n            Prompt(\"Message session is offline!\");\n        CASE 2\n            Prompt(\"Message session is connecting!\");\n        CASE 3\n            Prompt(\"Message session is disconnecting!\");\n        CASE ELSE\n            Prompt(\"Message session has unknown status!\");\n        END SELECT\n    ELSE\n        Prompt(\"Message session could not be opened!\");\n    END\nEND",
        "name": "MsgState",
        "params": [
            {
                "paramdescription": " The message handle, returned from the MsgOpen() function. The message handle identifies the table where all data on the associated message is stored.",
                "paramname": "hMsg"
            }
        ],
        "returnType": "This function has the following possible return values:",
        "syntax": "MsgState(hMsg)"
    },
    "msgwrite": {
        "doc": "Writes a message to a message session. The message is sent to the remote computer's callback function and can be read by calling MsgRead(). If the remote computer has not opened the session, this message is disregarded.\nThis function returns immediately after passing the message to Plant SCADA. Plant SCADA sends the message over the LAN in the background.\nyou need to first open the message session using the MsgOpen() function, to obtain the message handle.",
        "example": "MsgWrite(hMsg,10,\"MyMsg\");",
        "name": "MsgWrite",
        "params": [
            {
                "paramdescription": " The message handle, returned from the MsgOpen() function. The message handle identifies the table where all data on the associated message is stored.",
                "paramname": "hMsg"
            },
            {
                "paramdescription": " The integer message data, that is the message number.",
                "paramname": "nType"
            },
            {
                "paramdescription": " The message text.",
                "paramname": "Str"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "MsgWrite(hMsg, Type, Str)"
    },
    "multimonitorstart": {
        "doc": "Displays a Plant SCADA window on each of the configured monitors when a display client starts up. It sets up the windows according to the Multi-Monitor Parameters [MultiMonitors]Monitors and [MultiMonitors]StartPage#.",
        "example": "No example found",
        "name": "MultiMonitorStart",
        "params": [],
        "returnType": "None.",
        "syntax": "MultiMonitorStart()"
    },
    "multisignatureform": {
        "doc": "Displays a form that allows up to four users to have their credentials verifiedin order to approve an operation.  The usernames can be Plant SCADA or Windowsusers.    ",
        "example": "// This example sets the page integer to indicate the approval status, but\n// it can be used to perform any logic necessary to trigger the operation \n// that was approved.\n\nPageSetInt(1, MultiSignatureForm(\"Shut down plant\", \"ApprovalLog\",\n\"shiftsupervisor\", \"DOMAIN\\mike.manager\", \"\", \"\"));",
        "name": "MultiSignatureForm",
        "params": [
            {
                "paramdescription": " A description of the operation that requires approval. This string will bedisplayed on the signature form and logged to the log device if the operationis approved.",
                "paramname": "sOperationDescription"
            },
            {
                "paramdescription": " The name of a log device if logging is required, otherwise pass an emptystring.",
                "paramname": "sLogDevice"
            },
            {
                "paramdescription": "Each sUser argument needs to be either a Plant SCADA user name, a Windows user name(including domain\\ prefix) or a blank string. Even though the sUser arguments are numbered 1 through 4, this only controls the order in which users are displayed on the multi-signature form. You can pass empty strings for any of these arguments, but at least one user needs to be specified.",
                "paramname": "sUser1..4"
            }
        ],
        "returnType": "TRUE (1) if the operation approved (that is all users' credentials were verified\nand the operator clicked the \"Approve\" button, otherwise FALSE (0).  ",
        "syntax": "MultiSignatureForm(sOperationDescription, sLogDevice, sUser1, sUser2, sUser3,sUser4)"
    },
    "multisignaturetagwrite": {
        "doc": "Displays a form that allows up to four users to have their credentials verified in order\t\tto approve a write of a specific value to a specific tag.  If all users are verified\t\tsuccessfully, the write to the tag is performed by this function before it returns.\t\tThe usernames can be Plant SCADA or Windows users.    ",
        "example": "// This example generates a form to request two users to approve the tag write\noperation.\n// When approved, the PLC_VAR1 tag is written with the value 123 and a page string\n// is set to indicate the approval status.\nIF\n(MultiSignatureTagWrite(\"PLC_VAR1\", \"123\", \"\", \"John Smith\", \"Angela Huth\", \"\", \"\")) \nTHEN\n\tPageSetStr(1, \"TagWrite Successful\");\nELSE\n\tPageSetStr(1, \"TagWrite Not Successful\");\nEND",
        "name": "MultiSignatureTagWrite",
        "params": [
            {
                "paramdescription": " The name of the tag to which a write needs to be approved.",
                "paramname": "sTagName"
            },
            {
                "paramdescription": "The value to write to the tag if approval succeeds.",
                "paramname": "sValuetoWrite"
            },
            {
                "paramdescription": " The name of a log device if logging is required, otherwise pass an emptystring.",
                "paramname": "sLogDevice"
            },
            {
                "paramdescription": "Each sUser argument needs to be either a Plant SCADA user name, a Windows user name(including domain\\ prefix) or an empty string. Even though the sUser arguments are numbered 1 through 4, this only controls the order in which users are displayed on the multi-signature form. You can pass empty strings for any of these arguments, but at least one user needs to be specified.",
                "paramname": "sUser"
            }
        ],
        "returnType": "TRUE (1) if the operation was approved (that is all users' credentials were verified\nand the operator clicked the \"Approve\" button, otherwise FALSE (0).",
        "syntax": "MultiSignatureTagWrite(sTagName, sValueToWrite, sLogDevice, sUser1, sUser2, sUser3,sUser4)"
    },
    "name": {
        "doc": "Gets the name of the operator who is currently logged on to the display system. The user can be a Plant SCADA or a windows user. If this function is called on a server, it returns the name of the local operator. If there is no one logged on, or the logged on user is a \"system user\" this function returns an empty string.",
        "example": "/* Display the user name of the current user at AN20. */\nDspText(20,0,Name());",
        "name": "Name",
        "params": [
            {
                "paramdescription": "",
                "paramname": "bIncludeDomain"
            },
            {
                "paramdescription": "",
                "paramname": "bIncludeDomain = 0: Return Windows user name only"
            },
            {
                "paramdescription": "The name of the user as a string. If the user is logged on as a Windows user the name will be the Windows user account name.",
                "paramname": "bIncludeDomain = 1: (Default) Return Windows user name with domain name"
            }
        ],
        "returnType": "The name of the user as a string. If the user is logged on as a Windows user the name will be the Windows user account name.",
        "syntax": "Name([bIncludeDomain])"
    },
    "objectassociateevents": {
        "doc": "Allows you to change the ActiveX object's event class. If you have inserted an object on a graphics page using Graphics Builder, it allows you to change the event class to something other than the default of PageName_ObjectName\nsClass: \nThe class of the object. You can use the object's humanreadable name, its program ID, or its GUID. If the class doesnot exist, the function will report an error.",
        "example": "// This function redefines the event class for the ActiveX sludge\ntank controller at AN35 to \"SludgeTank\". //\nObjectAssociateEvents (\"SludgeTank\", ObjectByName(\"AN35\"));\n..",
        "name": "ObjectAssociateEvents",
        "params": [
            {
                "paramdescription": " The class of the object. You can use the object's humanreadable name, its program ID, or its GUID. If the class doesnot exist, the function will report an error.",
                "paramname": "sClass"
            },
            {
                "paramdescription": " The source object firing the events which are to be handledby the event handler.\nFor example:",
                "paramname": "hSource"
            },
            {
                "paramdescription": "",
                "paramname": "0 (zero) if successful, otherwise an error is returned."
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "ObjectAssociateEvents(sEventClass, hSource)"
    },
    "objectassociatepropertywithtag": {
        "doc": "Establishes an association between an ActiveX property and a variable tag. This means that any changes made to an ActiveX object property will be mirrored in the variable tag.\nGenerally, ActiveX objects issue \"property change notifications\" to Plant SCADA whenever a change occurs to a specific property value. This notification tells Plant SCADA when to read the property value.",
        "example": "No example found",
        "name": "ObjectAssociatePropertyWithTag",
        "params": [
            {
                "paramdescription": " The object instance that associates a property with a tag.",
                "paramname": "sObject"
            },
            {
                "paramdescription": " The name of the ActiveX property to associate with the tag.",
                "paramname": "sPropertyName"
            },
            {
                "paramdescription": " The name of the Plant SCADA variable tag to associate with the property.",
                "paramname": "sTagName"
            },
            {
                "paramdescription": " The name of the \"on change\" event that informs Plant SCADA of a change to the ActiveX object. This is required where the ActiveX object does not automatically generate a property change notification. Choose an event that happens to be fired whenever the ActiveX object property changes, for example, the MS Calendar Control fires an AfterUpdate event whenever a day button is pressed.",
                "paramname": "sOnChangeEvent"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "ObjectAssociatePropertyWithTag(sObject, sPropertyName, sTagName [, sOnChangeEvent] )"
    },
    "objectbyname": {
        "doc": "Retrieves an ActiveX object. This is useful when you know the object by name only (this will often be the case for objects created during configuration, rather than those created at runtime using a Cicode function).",
        "example": "No example found",
        "name": "ObjectByName",
        "params": [
            {
                "paramdescription": " The name used to access the object, as specified when creating it in Cicode. For objects created in the Graphics Builder, the object name is set in the Access (Identification) tab, and defaults to \"AN\" followed by its AN number, for example, \"AN35\". The Name argument should be enclosed in quotes \"\".\n \"\".",
                "paramname": "Name"
            }
        ],
        "returnType": "The requested object, if successful, otherwise an error is generated.",
        "syntax": "ObjectByName(STRING Name)"
    },
    "objecthasinterface": {
        "doc": "Queries the ActiveX component to determine if its specific interface is supported. (Refer to the ActiveX object's documentation for details of its interfaces.)",
        "example": "hPen = _ObjectGetProperty(hControl, \"Pen\");\nIF ObjectHasInterface(hPen, \"IDigitalPen\") THEN\n    //Fill is only supported on digital pen\n    _ObjectSetProperty(hPen, \"Fill\", 0)\nEND ",
        "name": "ObjectHasInterface",
        "params": [
            {
                "paramdescription": " The handle for the object (as returned by the ObjectByName() function).",
                "paramname": "hObject"
            },
            {
                "paramdescription": " The name of the interface (case sensitive).",
                "paramname": "sInterface"
            }
        ],
        "returnType": "0 if the interface is not supported, otherwise 1.",
        "syntax": "ObjectHasInterface(hObject, sInterface)"
    },
    "objectisvalid": {
        "doc": "Determines if the given handle for an object is a valid handle. This function is useful for programmatically checking that an object was returned for a call.",
        "example": "hFont = _ObjectGetProperty(hControl, \"Font\");\nIF ObjectIsValid(hFont) THEN\n    _ObjectSetProperty(hFont, \"Size\", 22)\nEND",
        "name": "ObjectIsValid",
        "params": [
            {
                "paramdescription": " The handle for the object (as returned by the ObjectByName() function).",
                "paramname": "hObject"
            }
        ],
        "returnType": "0 if the handle is not valid, otherwise 1.",
        "syntax": "ObjectIsValid(hObject)"
    },
    "objecttostr": {
        "doc": "Converts an object handle to a string. This means you can print the object handle in a trace message, which allows you confirm if the handle is valid. ",
        "example": "No example found",
        "name": "ObjectToStr",
        "params": [
            {
                "paramdescription": "The handle for the object (as returned by the ObjectByName() function).",
                "paramname": "hObject"
            }
        ],
        "returnType": "A string containing the converted object handle",
        "syntax": "ObjectToStr(hObject)"
    },
    "oledatetotime": {
        "doc": "Converts an OLE DATE value (stored in a REAL) to a Plant SCADA time/date value.",
        "example": "Real = TimeToOLEDate(TimeCurrent(), 1);\n! Sets Real to the local date/time value\nTimeVariable = OLEDateToTime(Real, 1);\n! Sets TimeVariable to the value of Real when interpreted as Local \ntime.",
        "name": "OLEDateToTime",
        "params": [
            {
                "paramdescription": "The OLE DATE value to convert (stored as a REAL).",
                "paramname": "OLEDate"
            },
            {
                "paramdescription": "0 - OleDate represents a UTC time.\n1 - OleDate represents a Local time.",
                "paramname": "Local"
            }
        ],
        "returnType": "Returns a Plant SCADA time/date value.",
        "syntax": "OLEDateToTime(OLEDate, Local)"
    },
    "onevent": {
        "doc": "Sets an event callback function for an event type. The callback function is called when the event occurs.\nUsing callback functions removes the need for polling or checking for events. Callback functions have no arguments and needs to return an integer. They also need to be non-blocking.\nPlant SCADA starts running the function immediately, without reading any data from the I/O devices. Any I/O device variable that you use will contain either 0 (zero) or bad quality. Only local variables are supported. \nThe return value of the callback will depend on the type of the event. Set the Fn argument to 0 (zero) to disable the event. \nNotes",
        "example": "OnEvent(1,KeyFn);\nINT\nFUNCTION KeyFn()\n\tINT Key;\n\tKey=KeyPeek(0);\n\tIF Key=27 THEN\n\t\tPrompt(\"ESC pressed\");\n\t\tRETURN 1;\n\tELSE\n\t\tRETURN 0;\n\tEND\nEND\nOnEvent(0,MouseFn);\nINT\nFUNCTION MouseFn()\n\tINT X,Y;\n\tDspGetMouse(X,Y);\n\tRETURN 0;\nEND\n\nsFUNCTION XyZStartup()\n\tOnEvent(43, ConfirmShutdown);\nEND\n\nINT FUNCTION ConfirmShutdown()\n\tTaskNew(\"_ShutdownDlg\", \"\", 2+8);\n\tRETURN 1;\nEND\n\nFUNCTION _ShutdownDlg()\n\tSTRING\tsMsg = \"Are you sure ?\";\n\tINT\t\tnRC;\n\n\tnRC = Message(\"Close this window and shutdown\", sMsg, 1+32);\n\n\tIF nRC = 0 THEN\n\t\tShutdown(\"\",\"\",1,\"\",0);\n\tEND\nEND",
        "name": "OnEvent",
        "params": [
            {
                "paramdescription": "The type of event:\n0 - The mouse has moved. When the mouse moves the callback function is called. The return value must be 0.\n1 - A key has been pressed. When the user presses a key, the callback function is called after Plant SCADA checks for hot keys. If the return value is 0, Plant SCADA checks for key sequences. If the return value is not 0, Plant SCADA assumes that you will process the key and does not check the key sequence. It is up to you to remove the key from the key command line.\nIf you are using a right mouse button click as an event, you should read about the ButtonOnlyLeftClick parameter.\n2 - Error event. This event is called if an error is detected in Cicode, so you can write a single error function to check for your errors. If the return value is 0, Plant SCADA continues to process the error and generates a hardware error - it may then halt the Cicode task. If the return value is not 0, Plant SCADA assumes that you will process the error, and continues the Cicode without generating a hardware error.\n3 - Page user communication error. A communication error has been detected in the data required for this page. If the return value is 0 (zero), Plant SCADA still animates the page. If the return value is not zero, it does not update the page.\n4 - Page user open. A new page is being opened. This event allows you to define a single function that is called when all pages are opened. The return value must be 0.\n5 - Page user close. The current page is being closed. This event allows you to define a single function that is called when all pages are closed. The return value must be 0.\n6 - Page user always. The page is active. This event allows you to define a single function that is called when all pages are active. The return value must be 0.\n7 - Page communication error. A communication error has been detected in the data required for this page. Reserved for use by Plant SCADA.\n8 - Page open. This event is called each time a page is opened. Reserved for use by Plant SCADA.\n9 - Page close. This event is called each time a page is closed. Reserved for use by Plant SCADA.\n10 - Page always. This event is called while a page is active. Reserved for use by Plant SCADA.\n11..17 - Undefined.\n18 - Report start. The report server is about to start a new report. This event is called on the report server. The return value must be 0.\n19 - Device history. A device history has just completed. The return value must be 0.\n20 - Login. A user has just logged in.\n21 - Logout. A user has just logged out.\n22 - Trend needs repainting. This event is called each time Plant SCADA re-animates a real-time trend or scrolls an historical trend. You should use this event to add additional animation to a trend, because Plant SCADA deletes all existing animation when a trend is re-drawn. (For example, if you want to display extra markers, you must use this event.)\n23 - Hardware error has been detected.\n24 - Keyboard cursor moved. This event is called each time the keyboard command cursor moves. The cursor can be moved by the cursor keys, the mouse, or the Cicode function KeySetCursor(). Note that you can find where the keyboard command cursor is located by calling the function KeyGetCursor().\n25 - Network shutdown. A Shutdown network command has been issued.\n26 - Runtime system shutdown and restart. (Required because of configuration changes.)\n27 - Event. An event has occurred.\n28 - Accumulator. An accumulator has logged a value.\n29 - Slider. A slider has been selected.\n30 - Slider. A slider has moved.\n31 - Slider. A slider has been released (that is stopped moving).\nWhile responding to slider events 29, 30, and 31, you can set any variables but you cannot call functions that cause immediate changes to animations on the page (for example, DspText() and DspSym()). Types 29, 30, & 31 relate only to V3.xx and V4.xx animations, and will be superseded in future releases.\n32 - Shutdown. Plant SCADA is being shutdown.\n33 - Reserved for Plant SCADA internal use.\n34 - 41 - Plant SCADA Confirmation Events. Reserved for Plant SCADA internal use. For the confirmation events, two sets of event type code are defined. The runtime calls the Plant SCADA event handler first, and conditionally proceed to the user's event handler depending on the return value of the Plant SCADA event handler. \n34 -Plant SCADA Event: Child Window Close Confirmation.\n35 - Plant SCADA Event: Main Window Close Confirmation.\n36 - Plant SCADA Event: Maximize Window Confirmation.\n37 - Plant SCADA Event: Minimize Window Confirmation.\n38 - Plant SCADA Event: Restore Window Confirmation.\n39 - Plant SCADA Event: Move Window Confirmation.\n40 - Plant SCADA Event: Size Window Confirmation.\n41 - Plant SCADA Event: Shutdown Confirmation Confirmation.\n42 to 49 - User Confirmation Events. These functions are called when a specific event (mainly from Window title bar) occur and before the runtime performs the intended action. This gives a chance for the user to decide what to do with the event. If the return value is 0, the event will be passed on to the default handler so the intended action will be performed. If the return value is not 0, the event will be ignored and no further action will be taken.\n42 - Child Window Close Confirmation, when the close button of the windows' title bar is clicked or an equivalent Windows' message is received.\n43 - Main Window Close Confirmation, when close button of the windows' title bar is clicked which will cause the process to shutdown.\n44 - Maximize Window Confirmation, when the maximize button of the windows' title bar is clicked or an equivalent Windows' message is received.\n45- Minimize Window Confirmation, when the minimize button of the windows' title bar is licked or an equivalent Windows' message is received.\n46 - Restore Window Confirmation, when the restore button of the windows' title bar is clicked or an equivalent Windows' message is received.\n47 - Move Window Confirmation, when the window is being dragged or an equivalent Windows' message is received.\n48 - Size Window Confirmation, when the windows is being resized or an equivalent Windows' message is received.\n49 - Shutdown Confirmation, when shutdown() function is called.\n50 - 127 - Reserved for future Plant SCADA use.\n128 - 256 - User-defined events. These events are for your own use.",
                "paramname": "Type"
            },
            {
                "paramdescription": "The function to call when the event occurs. This callback function needs to have no arguments, so you specify the function with no parentheses (). The callback function needs to return INT as its return data type. You cannot specify a Plant SCADA built-in function as a callback function.\nSet Fn to 0 to disable the event.",
                "paramname": "Fn"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "OnEvent(Type, Fn)"
    },
    "packedrgb": {
        "doc": "Returns a packed RGB color based on specified red, green, and blue values.",
        "example": "No example found",
        "name": "PackedRGB",
        "params": [
            {
                "paramdescription": "The red component of the desired packed RGB color.",
                "paramname": "nRed"
            },
            {
                "paramdescription": "The green component of the desired packed RGB color.",
                "paramname": "nGreen"
            },
            {
                "paramdescription": "The blue component of the desired packed RGB color.",
                "paramname": "nBlue"
            }
        ],
        "returnType": "The packed RGB color value - if successful, otherwise an error is returned.",
        "syntax": "PackedRGB(nRed, nGreen, nBlue)"
    },
    "packedrgbtocitectcolour": {
        "doc": "Converts a packed RGB color into a calculated Plant SCADA color value.",
        "example": "No example found",
        "name": "PackedRGBToCitectColour",
        "params": [
            {
                "paramdescription": " The packed RGB color.",
                "paramname": "nPackedRGB"
            }
        ],
        "returnType": "The Plant SCADA color value if successful; otherwise an error is returned.",
        "syntax": "PackedRGBToCitectColour(nPackedRGB)"
    },
    "pagealarm_ciref": {
        "doc": "Displays a category of active alarms on the alarm page. \nTo use this function, you need to have a page in your project that was created usingthe Alarm template. By default, the name of the page is expected to be \"Alarm\". However, you can use an alarm page with a different name by adjusting the setting for the INIparameter [Page]AlarmPage.\nNotes",
        "example": "No example found",
        "name": "PageAlarm_CIREF",
        "params": [
            {
                "paramdescription": " The alarm category to display. Set to 0 (the default) todisplay all alarm categories.",
                "paramname": "Category"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "PageAlarm( [Category] )"
    },
    "pageback": {
        "doc": "Displays the previously displayed page in the Window.",
        "example": "No example found",
        "name": "PageBack",
        "params": [
            {
                "paramdescription": "Optional parameter to specify the number of pages to move back. Default value is 1.",
                "paramname": "iCount"
            }
        ],
        "returnType": "No Error (0) on success. Bad handle specified (269) if current window handle does not correspond to a valid window. Invalid argument passed (274) if count is outside of allowable bounds.",
        "syntax": "PageBack([iCount])"
    },
    "pagedisabled": {
        "doc": "Displays a category of disabled alarms on the disabled alarms page. \nTo use this function, you need to have a page in your project that was created usingthe Disabled template. By default, the name of the page is expected to be \"Disabled\". However, you can use a page with a different name by adjusting the setting for the INIparameter [Page]DisabledPage.\nNotes",
        "example": "No example found",
        "name": "PageDisabled",
        "params": [
            {
                "paramdescription": " The alarm category to display. Set to 0 (the default) todisplay all alarm categories.",
                "paramname": "Category"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "PageDisabled( [Category] )"
    },
    "pagedisplay": {
        "doc": "Displays a graphics page in the active window. The page needs to be in one of the operator's current areas. The page to be displayed is identified by its Page Name or the Page Number.\nWhen this function is executed, it tests whether or not the identified page is based on a CSV_Include project template. If it is, the function uses TaskNew to run a CSV version of the PageDisplay function, \"CSV_MM_PageDisplay\". This confirms if multi-monitor support is required. As TaskNew is used to execute this function, no return value becomes available to PageDisplay. Under these circumstances, PageDisplay will return zero (0).\nIf this function is called to change the page in a pop-up window of a CSV_Include project, the page displayed by the base window will change. To change this default behaviour, set the [Page]NewPageInBase parameter to 0. Then a pop-up window can be changed with this function in single monitor mode.\nYou can specify if the page operates within the context of a particular cluster in a multiple cluster project. When the page launches during runtime, the ClusterName argument is used to resolve any tags that have a cluster omitted.\nPlant SCADA stores the current page  before it displays the required page. You can call PageLast() to re-display the pagesin the page navigation history.\nYou cannot call this function from the Exit command field (see Page Properties) or a Cicode Object.",
        "example": "PageDisplay(\"MIMIC1\");\n! Displays page \"MIMIC1\".\nPageDisplay(\"MIMIC2\");\n/* Displays page \"MIMIC2\" and places page \"MIMIC1\" onto the\npage navigation history. */\nPageDisplay(\"10\");\n/* Displays page \"10\" and places page \"MIMIC2\" onto the page navigation history. */\nPageLast();\n/* Displays the last page, that is page \"MIMIC2\" and\nremoves it from the page navigation history. */",
        "name": "PageDisplay",
        "params": [
            {
                "paramdescription": " The name or page number of the page to display (in quotation marks \"\"). Can be prefixed by the name of a host cluster, that is \"ClusterName.Page\". This will take precedence over the use of the ClusterName parameter if the two differ.",
                "paramname": "Page"
            },
            {
                "paramdescription": " The name of the cluster that will accommodate the page at runtime (in quotation marks \"\"). The specified cluster is used to resolve any tags that have a cluster omitted. If the Page parameter is prefixed with the name of a cluster, this parameter will not be used.\n This parameter is optional, however if you omit a cluster context in the Page properties, then any tags which omit an explicit Cluster. TagName will be ambiguous and become unresolved if you have multiple clusters defined in the project. Note that this ambiguity and resulting unresolved state will only occur if the parameter [General]TagDB is set to \"0\" which disables variable tag database loading.",
                "paramname": "ClusterName"
            }
        ],
        "returnType": "0 (zero) if the page is successfully displayed, otherwise an error is returned.",
        "syntax": "PageDisplay(Page,[ClusterName])"
    },
    "pageexists": {
        "doc": "Use this function to check  if a particular page exists in your project.",
        "example": "No example found",
        "name": "PageExists",
        "params": [
            {
                "paramdescription": " The name of the page to check for.",
                "paramname": "sPageName"
            }
        ],
        "returnType": "1 if the page does exist, 0 if the page does not.",
        "syntax": "INT PageExists(STRING[sPageName])"
    },
    "pagefile": {
        "doc": "Displays a file on the page. After the file is displayed, you can scroll up and down through the file. To use this function, you need to use the Graphics Builder to create a page called \"File\" (using the file template).\nNotes",
        "example": "No example found",
        "name": "PageFile",
        "params": [
            {
                "paramdescription": " The name of the file to display.",
                "paramname": "sName"
            }
        ],
        "returnType": "0 (zero) if the file is successfully displayed, otherwise an error is returned.",
        "syntax": "PageFile(sName)"
    },
    "pagefileinfo": {
        "doc": "Returns the width or height of an unopened page.",
        "example": "No example found",
        "name": "PageFileInfo",
        "params": [
            {
                "paramdescription": " The name of the page you would like to retrieve size information for.",
                "paramname": "sPageName"
            },
            {
                "paramdescription": " Retrieves either the width or the height of the specified page in pixels.\n0 - returns the page width\n1 - returns the page height",
                "paramname": "nMode"
            }
        ],
        "returnType": "The height or width of the specified page in pixels, depending on the value set for nMode.",
        "syntax": "PageFileInfo(sPageName, nMode)"
    },
    "pagefileinfoex": {
        "doc": "Returns the width, height, content type, parent or title of an unopened page.",
        "example": "No example found",
        "name": "PageFileInfoEx",
        "params": [
            {
                "paramdescription": " The name of the page for which you would like to retrieve information.",
                "paramname": "sPageName"
            },
            {
                "paramdescription": "Determines if the width, height, content type, parent or title is returned for the specified page.\n0 - returns the page width.\n1 - returns the page height.\n2- returns the content type of the page.\n3 - returns the parent page of the page.\n4 - returns the configured page title of the page.",
                "paramname": "nMode"
            }
        ],
        "returnType": "The height, width, content type, parent or title of the specified page, depending on the value set for nMode.",
        "syntax": "PageFileInfoEx(sPage, nMode)"
    },
    "pageforward": {
        "doc": "If PageBack() is called, PageForward() will restore the previously displayed page in the window. PageForward requires PageBack to have been called and no other page display functions to have been called in between. Calling the display functions PageDisplay or PageGoto will remove the forward pages from the Page Navigation History.",
        "example": "No example found",
        "name": "PageForward",
        "params": [
            {
                "paramdescription": "Optional parameter to specify the number of pages to move forward. Default value is 1.",
                "paramname": "iCount"
            }
        ],
        "returnType": "No Error (0) on success.  Bad handle specified (269) if current window handle does not correspond to a valid window. Invalid argument passed (274) if count is outside of allowable bounds.",
        "syntax": "PageForward([iCount])"
    },
    "pagegetint": {
        "doc": "Returns the integer value associated with a variable name on a particular page. If two or more windows are displayed, each window has a unique copy of the variable. You can use these variables in Cicode to keep track of variables unique to each window.\nNotes",
        "example": "No example found",
        "name": "PageGetInt",
        "params": [
            {
                "paramdescription": " String name of the variable to return",
                "paramname": "sLabel"
            },
            {
                "paramdescription": " Window number of the page. Default is current window.",
                "paramname": "iWinNum"
            }
        ],
        "returnType": "Integer stored in variable sLabel.",
        "syntax": "PageGetInt(sLabel [, iWinNum])"
    },
    "pagegetstr": {
        "doc": "Gets the string associated with a variable name on a particular page. Page-based variables are local to each display page. If two or more windows are displayed, each window has a unique copy of the variable. You can use these variables in Cicode to keep track of variables unique to each window.",
        "example": "No example found",
        "name": "PageGetStr",
        "params": [
            {
                "paramdescription": " String name of the variable to return",
                "paramname": "sLabel"
            },
            {
                "paramdescription": " Window number of the page. Default is current window.",
                "paramname": "iWinNum"
            }
        ],
        "returnType": "Value stored in variable sLabel.",
        "syntax": "PageGetStr(sLabel [, iWinNum])"
    },
    "pagegoto": {
        "doc": "Displays a graphics page in the active window. The page needs to be in one of the operator's current areas. You can specify either the Page Name or the Page Number of the graphics page.\nYou can also specify if the page operates within the context of a particular cluster in a multiple cluster project. When the page launches during runtime, the ClusterName argument is used to resolve any tags that have the cluster name omitted.\nThis function is similar to PageDisplay(), however PageGoto() does not put the current page into the page navigation history.\nYou cannot call this function from the Exit command field (see Page Properties) or a Cicode Object.",
        "example": "PageDisplay(\"MIMIC1\");\n! Displays page \"MIMIC1\".\nPageDisplay(\"MIMIC2\");\n/* Displays page \"MIMIC2\" and places page \"MIMIC1\" onto the\npage navigation history. */\nPageGoto(\"10\");\n/* Displays page \"10\". Page \"MIMIC2\" is not placed onto the\npage navigation history. */",
        "name": "PageGoto",
        "params": [
            {
                "paramdescription": " The name or page number of the page to display (inquotation marks \"\"). Can be prefixed by the name of a hostcluster, that is \"ClusterName.Page\". This will take precedenceover the use of the ClusterName parameter if the two differ.",
                "paramname": "Page"
            },
            {
                "paramdescription": " The name of the cluster that will accommodate the page atruntime (in quotation marks \"\"). The specified cluster is usedto resolve any tags that have the cluster name omitted. If the Page parameter is prefixed with the name of acluster, this parameter will not be used.",
                "paramname": "sClusterName"
            }
        ],
        "returnType": "0 (zero) if the page is successfully displayed, otherwise an error is returned.",
        "syntax": "PageGoto(Page,ClusterName)"
    },
    "pagehardware": {
        "doc": "Displays the active hardware alarms on the hardware alarms page. \nTo use this function, you need to have a page in your project that was created usingthe Hardware template. By default, the name of the page is expected to be \"Hardware\". However, you can use a page with a different name by adjusting the setting for the INIparameter [Page]HardwarePage.\nNotes\nPageHardware()",
        "example": "No example found",
        "name": "PageHardware",
        "params": [],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "PageHardware()"
    },
    "pagehistorydspmenu": {
        "doc": "Displays a pop-up menu which lists the page history of current window. The user can select any page in the history to recall the page. When full page history is specified, the currently displayed page will also be listed and marked in the menu.",
        "example": "No example found",
        "name": "PageHistoryDspMenu",
        "params": [
            {
                "paramdescription": "The type of page history to be listed:\n0 - full history (default)\n1 - back history\n2 - forward history",
                "paramname": "iType"
            }
        ],
        "returnType": "Zero (0) if the function is executed successfully. Otherwise an error is returned. ",
        "syntax": "PageHistoryDspMenu([iType])"
    },
    "pagehistoryempty": {
        "doc": "Used to determine if the page history of the current window is empty. The currently displayed page is not counted as history.",
        "example": "No example found",
        "name": "PageHistoryEmpty",
        "params": [
            {
                "paramdescription": "The type of page history to be checked:\n0 - full history (default)\n1 - back history\n2 - forward history",
                "paramname": "iType"
            }
        ],
        "returnType": "1 if page history of specified type is empty, or 0 if it is not empty.",
        "syntax": "PageHistoryEmpty([iType])"
    },
    "pagehome": {
        "doc": "Displays the predefined home page in the window.",
        "example": "No example found",
        "name": "PageHome",
        "params": [
            {
                "paramdescription": "Optional parameter to the Cluster to associate the page being opened with. Default value \"\".",
                "paramname": "sCluster"
            }
        ],
        "returnType": "No eerror(0) on success. Bad handle specified (269) if current window handle does not correspond to a valid window. Bad handle specified (274) if INI parameter [Page]HomePage is not set. ",
        "syntax": "PageHome([sCluster])"
    },
    "pageinfo": {
        "doc": "Gets information about the current page.",
        "example": "! If currently on page \"MIMIC1\";\nVariable=PageInfo(0);\n! Sets Variable to \"MIMIC1\".",
        "name": "PageInfo",
        "params": [
            {
                "paramdescription": "The type of page information required.\n0 — Page name.\n1 — Page number.\n2 — Page title.\n3 — Display file name.\n4 — Symbol file name.\n5 — Next page name.\n6 — Previous page name\n7 — Previous display count, incremented at each page scan. The page scan rate defaults to the value of the Citect.ini parameter [Page]ScanTime, and can be overridden per page by changing the scan time setting in the General tab of the page properties in Graphics Builder.\n8 — Parent window number. Returns -1 if there is no parent.\n9 — First child window number. Returns -1 if there are no children.\n10 — Next child in child link. Returns -1 for the end of the list.\n11 — Window mode (set by the WinNewAt() function).\n12 — Width of window. If the target is a pinned window, the return value will represent the width of the window as it is on the unscaled version of the page that hosts it.\n13 — Height of window. If the target is a pinned window, the return value will represent the height of the window as it is on the unscaled version of the page that hosts it.\n14 — X position of window. If the target is a pinned window, the value will reflect the coordinates for the window based on its location on the unscaled version of the page that hosts it.\n15 — Y position of window. If the target is a pinned window, the value will reflect the coordinates for the window based on its location on the unscaled version of the page that hosts it.\n16 — Dynamic window horizontal scale.\n17 — Dynamic window vertical scale.\nTypes 16 and 17 return a real number between 0 and 1 (as a STRING) and will be identical, as the dynamic scaling does not allow a change in the aspect ratio.\n18 — Flashing color state. Type 18 returns one of the following:\n\"0\" — the palette does not flash.\n\"1\" — the palette is primary now.\n\"2\" — the palette is secondary now.\n19 — In animation cycle. Returns a 1 (true) or 0 (false).\n20 — In communications cycle. Returns a 1 (true) or 0 (false).\n21 — Width of background page.\n22 — Height of background page.\n23 — Returns the highest AN.\n24 — Returns the number of ANs.\n25 — Indicates when the page's \"On Page Shown\" event has been triggered. Returns 1 if triggered, 0 if it has not.\n26 — The cluster that has been specified to host the page. Returns the cluster name, or an empty string if no cluster has been specified.\n27 — Indicates whether the Cicode library used by the page is different from the currently loaded library. Returns 1 if different, 0 if the versions are the same.\n28 — Return X Coordinate of Client rectangle origin.\n29 — Return Y Coordinate of Client rectangle origin.\n30 — Returns the name of the monitor the current page is displayed on at runtime. For example, in a project where three monitors \"Screen 1\", \"Primary\", and \"Screen 2\" have been configured as part of a multi-monitor screen profile, PageInfo(30) has been set on the monitor named \"Left\" which means \"Left\" would be displayed at runtime. \nFor more information refer to the topic Screen Profiles in the main help.\n31 — Returns the \"Content Type\" configured for that page. ",
                "paramname": "nType"
            }
        ],
        "returnType": "The information (as a string).",
        "syntax": "PageInfo(nType)"
    },
    "pagekeyboardcommandsput": {
        "doc": "Allows you to assign keyboard commands to an object or group. A keyboard command is a particular key sequence which executes a command when it is typed in by the operator at runtime.",
        "example": "No example found",
        "name": "PageKeyboardCommandsPut",
        "params": [
            {
                "paramdescription": "Position of the keyboard command (as you can define more than one).",
                "paramname": "nIndex"
            },
            {
                "paramdescription": "Key sequences that the operator can enter to execute a command.",
                "paramname": "bstrKeySequence"
            },
            {
                "paramdescription": "The commands (set of instructions) to be executed immediately when the selected key sequence is entered. The commands can be a maximum of 253 characters long.",
                "paramname": "bstrCommand"
            },
            {
                "paramdescription": "Use this to assign the keyboard command to the same area as the object/group.",
                "paramname": "nArea"
            },
            {
                "paramdescription": "Use this to assign the keyboard command the same privilege as the object/group.",
                "paramname": "nPrivilege"
            },
            {
                "paramdescription": "Enables sending a log message to the Log Device. \nReturn Value\nHRESULT - Indicates success or failure. 0 indicates success.\n \nPublished August 2022",
                "paramname": "bstrLogging"
            }
        ],
        "returnType": "HRESULT - Indicates success or failure. 0 indicates success.",
        "syntax": "HRESULT PageKeyboardCommandsPut(nINdex, bstrKeySequence, bstrCommand, nArea, nPrivilege, bstrLogging)"
    },
    "pagelast": {
        "doc": "Displays the graphics page that was last displayed. With this function, you can successively recall the last ten pages that were displayed.\nGraphics pages displayed using this command cannot be subsequently recalled.\nYou cannot call this function from the Exit command field (see Page Properties) or a Cicode Object.",
        "example": "PageDisplay(\"MIMIC1\");\n! Displays page \"MIMIC1\".\nPageDisplay(\"MIMIC2\");\n/* Displays page \"MIMIC2\" and places page \"MIMIC1\" onto the \npage navigation history. */\nPageDisplay(\"10\");\n! Displays page \"10\" and places page \"MIMIC2\" onto the page navigation history. */\nPageLast();\n/* Displays the last page, that is page \"MIMIC2\" and \nremoves it from the \npage navigation history. */\nPageLast();\n/* Displays the last page, that is page \"MIMIC1\" and \nremoves it from the \npage navigation history. */\nPageLast();\n/* Returns an \"Out of range\" error code as there are no more pages in the\npage navigation history.*/",
        "name": "PageLast",
        "params": [],
        "returnType": "0 (zero) if the page is successfully displayed, otherwise an error is returned.",
        "syntax": "PageLast()"
    },
    "pagelistcount": {
        "doc": "Gets number of pages in the page list of the current window.\nSee the Citect.ini parameter [Page]MaxList",
        "example": "\t\t\nINT count;\nINT index;\nINT error;\nSTRING PageName;\n\t\t\t\t\n// While 4 entries will be added to page history, only 3 unique pages will be added to page list\nPageDisplay(Page1);\nPageDisplay(Page2);\t\t\t\nPageDisplay(Page1);\nPageDisplay(Page3);\n\t\t\t\t\t\t\t\t\n// iterate the pages in the list\ncount=PageListCount()\t\t//count=3\nPageName=PageListInfo(0,0);\t//PageName=Page1\nPageName=PageListInfo(1,0);\t//PageName=Page2\nPageName=PageListInfo(2,0);\t//PageName=Page3\nindex=PageListCurrent();\t//index=2,as Page3 is currently displayed\npageName=PageListInfo(index,0); //PageName=Page3\nerror-PageListDisplay(1);\t//recall Page2, error=0\nindex=PageListCurrent();\t//index=1, as current index is moved as part of the \n\t\t\t\trecall\nPageName=PageInfo(0);\t\t//PageName=Page2 as it becomes the current page\nerror=PageListDelete(index);\t//remove current page, i.e. Page2, error=0\nPageName=PageInfo(0);\t\t//PageName=Page3, next page in the list is displayed\nindex=PageListCurrent();\t//index=1, current index is not changed while the list\n \t\t\t\tis reduced\ncount=PageListCount();\t\t//count=2, only 2 pages left in the list",
        "name": "PageListCount",
        "params": [],
        "returnType": "Number of pages in the list",
        "syntax": "PageListCount()"
    },
    "pagelistcurrent": {
        "doc": "Gets Index of the current page in the page list of current window.",
        "example": "\t\t\t\t\nINT count;\nINT index;\nINT error;\nSTRING PageName;\n\t\t\t\t\n// While 4 entries will be added to page history, only 3 unique pages will be added to page list\nPageDisplay(Page1);\nPageDisplay(Page2);\t\t\t\nPageDisplay(Page1);\nPageDisplay(Page3);\n\t\t\t\t\t\t\t\t\n// iterate the pages in the list\ncount=PageListCount()\t\t//count=3\nPageName=PageListInfo(0,0);\t\t//PageName=Page1\nPageName=PageListInfo(1,0);\t\t//PageName=Page2\nPageName=PageListInfo(2,0);\t\t//PageName=Page3\nindex=PageListCurrent();\t\t//index=2,as Page3 is currently displayed\npageName=PageListInfo(index,0);\t//PageName=Page3\nerror-PageListRecall(1);\t\t//recall Page2, error=0\nindex=PageListCurrent();\t\t//index=1, as current index is moved as \n\t\t\t\t\tpart of the recall\nPageName=PageInfo(0);\t\t//PageName=Page2 as it becomes the current page\nerror=PageListDelete(index);\t//remove current page, i.e. Page2, error=0\nPageName=PageInfo(0);\t\t//PageName=Page3, next page in the list is displayed\nindex=PageListCurrent();\t//index=1, current index is not changed while the\n\t\t\t\tlist is reduced\ncount=PageListCount();\t\t//count=2, only 2 pages left in the list",
        "name": "PageListCurrent",
        "params": [],
        "returnType": "List index (0 to list size -1), or -1 if unable to get index",
        "syntax": "PageListCurrent()"
    },
    "pagelistdelete": {
        "doc": "Removes a page at the specific index from the page list of the current window. This function will return an error if only one page is in the list. If the page is currently displayed, the next page will be displayed. If there is no next page, the previous page will be displayed.",
        "example": "\t\t\t\t\nINT count;\nINT index;\nINT error;\nSTRING PageName;\n\t\t\t\t\n// While 4 entries will be added to page history, only 3 unique pages will be added to page list\nPageDisplay(Page1);\nPageDisplay(Page2);\t\t\t\nPageDisplay(Page1);\nPageDisplay(Page3);\n\t\t\t\t\t\t\t\t\n// iterate the pages in the list\ncount=PageListCount()\t\t//count=3\nPageName=PageListInfo(0,0);\t\t//PageName=Page1\nPageName=PageListInfo(1,0);\t\t//PageName=Page2\nPageName=PageListInfo(2,0);\t\t//PageName=Page3\nindex=PageListCurrent();\t\t//index=2,as Page3 is currently displayed\npageName=PageListInfo(index,0);\t//PageName=Page3\nerror-PageListDisplay(1);\t\t//recall Page2, error=0\nindex=PageListCurrent();\t\t//index=1, as current index is moved as part \n\t\t\t\t\tof the recall\nPageName=PageInfo(0);\t\t//PageName=Page2 as it becomes the current page\nerror=PageListDelete(index);\t//remove current page, i.e. Page2, error=0\nPageName=PageInfo(0);\t\t//PageName=Page3, next page in the list is displayed\nindex=PageListCurrent();\t//index=1, current index is not changed while the\n\t\t\t\tlist is reduced\ncount=PageListCount();\t\t//count=2, only 2 pages left in the list",
        "name": "PageListDelete",
        "params": [
            {
                "paramdescription": "",
                "paramname": "Index"
            },
            {
                "paramdescription": "",
                "paramname": "Index to the page list (valid range 0 to list size minus 1)"
            }
        ],
        "returnType": "0 (zero) if the page is successfully removed, otherwise an error is returned.",
        "syntax": "PageListDelete(INT index)"
    },
    "pagelistdisplay": {
        "doc": "Recalls (displays) a page at the specific index in the page list of current window, and moves the current index to the page. When a page is recalled, the original parameters (such as cluster context, supergenie associations, PageTask arguments if applicable) used to display the page will be restored.\n(See the Citect.ini parameter [Page]MaxList.",
        "example": "\t\t\t\t\nINT count;\nINT index;\nINT error;\nSTRING PageName;\n\t\t\t\t\n// While 4 entries will be added to page history, only 3 unique pages will be added to page list\nPageDisplay(Page1);\nPageDisplay(Page2);\t\t\t\nPageDisplay(Page1);\nPageDisplay(Page3);\n\t\t\t\t\t\t\t\t\n// iterate the pages in the list\ncount=PageListCount()\t\t//count=3\nPageName=PageListInfo(0,0);\t\t//PageName=Page1\nPageName=PageListInfo(1,0);\t\t//PageName=Page2\nPageName=PageListInfo(2,0);\t\t//PageName=Page3\nindex=PageListCurrent();\t\t//index=2,as Page3 is currently displayed\npageName=PageListInfo(index,0);\t//PageName=Page3\nerror-PageListDisplay(1);\t//recall Page2, error=0\nindex=PageListCurrent();\t//index=1, as current index is moved as part of the\n \t\t\t\trecall\nPageName=PageInfo(0);\t\t//PageName=Page2 as it becomes the current page\nerror=PageListDelete(index);\t//remove current page, i.e. Page2, error=0\nPageName=PageInfo(0);\t\t//PageName=Page3, next page in the list is displayed\nindex=PageListCurrent();\t//index=1, current index is not changed while the\n\t\t\t\tlist is reduced\ncount=PageListCount();\t\t//count=2, only 2 pages left in the list",
        "name": "PageListDisplay",
        "params": [
            {
                "paramdescription": "",
                "paramname": "Index"
            },
            {
                "paramdescription": "",
                "paramname": "Index to the page list (valid range 0 to list size minus 1)"
            }
        ],
        "returnType": "0 (zero) if the page is successfully displayed, otherwise an error is returned.",
        "syntax": "PageListDisplay(INT index)"
    },
    "pagelistinfo": {
        "doc": "Gets information of a page at the specific index in the page list of the current window.",
        "example": "\t\t\t\t\nINT count;\nINT index;\nINT error;\nSTRING PageName;\n\t\t\t\t\n// While 4 entries will be added to page history, only 3 unique pages will be added to page list\nPageDisplay(Page1);\nPageDisplay(Page2);\t\t\t\nPageDisplay(Page1);\nPageDisplay(Page3);\n\t\t\t\t\t\t\t\t\n// iterate the pages in the list\ncount=PageListCount()\t\t//count=3\nPageName=PageListInfo(0,0);\t\t//PageName=Page1\nPageName=PageListInfo(1,0);\t\t//PageName=Page2\nPageName=PageListInfo(2,0);\t\t//PageName=Page3\nindex=PageListCurrent();\t\t//index=2,as Page3 is currently displayed\npageName=PageListInfo(index,0);\t//PageName=Page3\nerror=PageListDisplay(1);\t\t//recall Page2, error=0\nindex=PageListCurrent();\t//index=1, as current index is moved as part of the recall\nPageName=PageInfo(0);\t\t//PageName=Page2 as it becomes the current page\nerror=PageListDelete(index);\t//remove current page, i.e. Page2, error=0\nPageName=PageInfo(0);\t\t//PageName=Page3, next page in the list is displayed\nindex=PageListCurrent();\t//index=1, current index is not changed while the list isreduced\ncount=PageListCount();\t\t//count=2, only 2 pages left in the list",
        "name": "PageListInfo",
        "params": [
            {
                "paramdescription": "",
                "paramname": "Index"
            },
            {
                "paramdescription": "",
                "paramname": "Index to the page list (valid range 0 to list size minus 1)"
            },
            {
                "paramdescription": "Information to return:\n0- Page name (default)\n1- Configured Page Title\n2- Active Page Title",
                "paramname": "Type"
            }
        ],
        "returnType": "String value of the requested information, or empty string if no valid information can be found",
        "syntax": "PageListInfo(INT index,[ INT type])"
    },
    "pagemenu": {
        "doc": "Displays a menu page with page selection buttons. A page goto button is displayed for each of the first 40 pages defined in the project.",
        "example": "No example found",
        "name": "PageMenu",
        "params": [],
        "returnType": "0 (zero) if the page is successfully displayed, otherwise an error is returned.",
        "syntax": "PageMenu()"
    },
    "pagenext": {
        "doc": "Displays the next page as specified in the project.\nYou cannot call this function from the Exit command field (see Page Properties) or a Cicode Object.",
        "example": "/* If graphics page 1 is currently displayed, and the graphics \npage 1 has Next Page Name=10. */\nPageNext();\n! Displays graphics page 10.",
        "name": "PageNext",
        "params": [],
        "returnType": "0 (zero) if the page is successfully displayed, otherwise an error is returned.",
        "syntax": "PageNext()"
    },
    "pagepeekcurrent": {
        "doc": "Return the index in the page navigation history for the current page.",
        "example": "No example found",
        "name": "PagePeekCurrent",
        "params": [],
        "returnType": "Index in the page navigation history for the current page. -1 indicates that current window handle does not correspond to a valid window. ",
        "syntax": "PagePeekCurrent()"
    },
    "pagepeeklast": {
        "doc": "Gets information about a Page at an offset in the page navigation history.",
        "example": "No example found",
        "name": "PagePeekLast",
        "params": [
            {
                "paramdescription": "Pages are navigated using page navigation history. iOffset is used to indicate the position in that history. An iOffset value of \"0\" represents the currently viewed page. Positive increments of iOffset indicate previous pages visited in the navigation history. Negative values of iOffset are used to indicate pages in the future of the navigation history (negative iOffsets exist only if the user has used the back button to revisit earlier pages in the history).\nFor example:\nIf you navigate pages in the sequence A, B, C, D, E, and then remain on Page E. The iOffset value indicates the following pages:\nIf you then navigate \"Back\" twice the iOffset value indicates the following pages:\nIf you further navigate to pages F then G the iOffset value indicates the following pages:",
                "paramname": "iOffset"
            },
            {
                "paramdescription": "An enumeration representing the type of information required. The default value is 0.\n0 - Page Name\n1 - Configured Page Title\n2 - Active Page Title",
                "paramname": "iType"
            }
        ],
        "returnType": "String value of the requested information, or empty string if no valid result for given arguments. ",
        "syntax": "PagePeekLast(iOffset [, iType] )"
    },
    "pagepoplast": {
        "doc": "Gets the Page Name of the last item in the page navigation history and removes the page from the history.",
        "example": "PageDisplay(\"MIMIC1\");\n! Displays page \"MIMIC1\".\nPageDisplay(\"MIMIC2\");\n/* Displays page \"MIMIC2\" and places page \"MIMIC1\" onto the page navigation history. */\nPageDisplay(\"10\");\n! Displays page \"10\" and places page \"MIMIC2\" onto the page navigation history.\nVariable=PagePopLast();\n/* Sets Variable to \"MIMIC2\" and removes \"MIMIC2\" from the page navigation history. */\nPageLast();\n! Displays page \"MIMIC1\".",
        "name": "PagePopLast",
        "params": [],
        "returnType": "The page name or an empty string if there is no last page.",
        "syntax": "PagePopLast()"
    },
    "pagepopup": {
        "doc": "Display pop up window at the mouse position. If the mouse position is not known then the pop up will display in the centre of the screen. The window is displayed with no resize and will be closed if the page is changed.",
        "example": "No example found",
        "name": "PagePopUp",
        "params": [
            {
                "paramdescription": " The name of the page (drawn with the Graphics Builder).",
                "paramname": "sPage"
            },
            {
                "paramdescription": "The name of the cluster that will accommodate the page at runtime (in quotation marks \"\"). The specified cluster is used to resolve any tags that have a cluster omitted. If the Page parameter is prefixed with the name of a cluster, this parameter will not be used.\nThis parameter is optional, however if you omit a cluster context in the Page properties, then any tags which omit an explicit Cluster. TagName will be ambiguous and become unresolved if you have multiple clusters defined in the project. Note that this ambiguity and resulting unresolved state will only occur if the parameter [General]TagDB is set to \"0\" which disables variable tag database loading.",
                "paramname": "sClusterName"
            }
        ],
        "returnType": "",
        "syntax": "PagePopUp(sPage, [, sClusterName])"
    },
    "pageprev": {
        "doc": "Displays the previous page as specified in the project.\nYou cannot call this function from the Exit command field (see Page Properties) or a Cicode Object.",
        "example": "/* If graphics page 10 is currently displayed, and graphics page \n10 has Prev Page Name=1. */\nPagePrev();\n! Displays graphics page 1.",
        "name": "PagePrev",
        "params": [],
        "returnType": "0 (zero) if the page is successfully displayed, otherwise an error is returned.",
        "syntax": "PagePrev()"
    },
    "pageprocessanalyst": {
        "doc": "Displays a Process Analyst page (in the same window) preloaded with the pre-defined Process Analyst View (PAV) file.",
        "example": "No example found",
        "name": "PageProcessAnalyst",
        "params": [
            {
                "paramdescription": "The name of the page that contains Process Analyst object(s). For example, pages based on the Process Analyst templates found in the Tab_Style_Include project.",
                "paramname": "sPage"
            },
            {
                "paramdescription": "Name of the 1st PAV file",
                "paramname": "sPAVFile1"
            },
            {
                "paramdescription": "PAV file location code for the 1st PAV file, see PA doc LoadFromFile() for details.",
                "paramname": "iFileLocation1"
            },
            {
                "paramdescription": "Bit mask for removing command buttons from the 1st PA, bit flags as shown below:\n1 - Load View\n2 - Save View\n4 - Print\n8 - Copy to Clipboard\n16 - Copy to File\n32 - Add Pens\n64 - Remove Pens\n128 - Show Properties\n256 - Help",
                "paramname": "iButtonMask1"
            },
            {
                "paramdescription": "Name of the PA object on the given Page where the 1st PAV file will be loaded. If this parameter is not specified or empty string, it is defaulted to the object name used in the tab style templates, that is \"_templatePA1\".",
                "paramname": "sObjName1"
            },
            {
                "paramdescription": "Name of the 2nd PAV file",
                "paramname": "sPAVFile2"
            },
            {
                "paramdescription": "PAV file location code for the 2nd PAV file",
                "paramname": "iFileLocation2"
            },
            {
                "paramdescription": "Bit mask for removing command buttons from the 2nd PA, refer iButtonMask1 for details",
                "paramname": "iButtonMask2"
            },
            {
                "paramdescription": "Name of the PA object on the given Page where the 2nd PAV file will be loaded. If this parameter is not specified or empty string, it is defaulted to the object name used in the tab style templates, that is \"_templatePA2\".",
                "paramname": "sObjName2"
            }
        ],
        "returnType": "Zero (0) if the page is successfully displayed. Otherwise an error is returned.",
        "syntax": "PageProcessAnalyst(sPage, sPAVFile1 [, iFileLocation1 [, iButtonMask1 [, sObjName1 [, sPAVFile2 [, iFileLocation2 [, iButtonMask2 [, sObjName2 ]]]]]]])"
    },
    "pageprocessanalystpens": {
        "doc": "Display a page and add the specified pens to the first pane of the specified PA object on the page. If a PAV file is also specified, it will be loaded first, and the pens in the first pane will be removed before the specified pens are created on the PA.",
        "example": "No example found",
        "name": "PageProcessAnalystPens",
        "params": [
            {
                "paramdescription": "The name of the page that displays the PA.",
                "paramname": "sPage"
            },
            {
                "paramdescription": "Up to 8 Trend tags can be added to the PA.",
                "paramname": "sTag1..sTag8"
            },
            {
                "paramdescription": "Mask to remove button(s) from the main tool bar of PA. The following values can be combined to remove multiple buttons:",
                "paramname": "iButtonMask"
            },
            {
                "paramdescription": "The name of the PA object. If not specified it is defaulted to \"_templatePA1\" which is the name used by the built-in templates.",
                "paramname": "sObjName"
            },
            {
                "paramdescription": "The pane in PA where the trend or variable tags are added. If this is not specified or less than 1, it is defaulted to 1 (the 1st pane). If the specified pane does not exist in the PA object, a new pane will be created.",
                "paramname": "iPane"
            },
            {
                "paramdescription": "Optional Process Analyst View file to be loaded, default =\"\".",
                "paramname": "sPAVFile"
            },
            {
                "paramdescription": "Optional location of the PAV file. The allowed values are:",
                "paramname": "iFileLocation"
            },
            {
                "paramdescription": "",
                "paramname": "0 (zero) if successful, otherwise an error is returned."
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "PageProcessAnalystPens(sPage, sTag1 [, sTag2..sTag8 [, iButtonMask [, sObjName [, iPane [, sPAVFile [, iFileLocation ]]]]]])"
    },
    "pagepushlast": {
        "doc": "Places a page at the end of the page navigation history.",
        "example": "PageDisplay(\"MIMIC1\");\n! Displays page \"MIMIC1\".\nPageDisplay(\"MIMIC2\");\n/* Displays page \"MIMIC2\" and places page \"MIMIC1\" onto the page navigation history. */\nPageDisplay(\"10\");\n! Displays page \"10\" and places page \"MIMIC2\" onto the page navigation history.\nPagePushLast(\"TREND1\");\n! Places page \"TREND1\" onto the page navigation history.\nPageLast();\n/* Displays the last page, that is page \"TREND1\" and removes it from the page navigation history. */\nPageLast();\n/* Displays the last page, that is page \"MIMIC2\" and removes it from the page navigation history. */",
        "name": "PagePushLast",
        "params": [
            {
                "paramdescription": " The Page Name or Page Number (of the page) to place at theend of the page navigation history.",
                "paramname": "Page"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "PagePushLast(Page)"
    },
    "pagerecall": {
        "doc": "Displays the page at a specified depth in the page navigation history.",
        "example": "No example found",
        "name": "PageRecall",
        "params": [
            {
                "paramdescription": "The index into the page navigation history of the Page to be displayed. To get the index for the currentlydisplayed page, call PagePeekCurrent(). Then increment it to access pages in the forward history, ordecrement it to access pages in the backward history. Be reminded that youcannot recall the page that is currently displayed.",
                "paramname": "iIndex"
            }
        ],
        "returnType": "No error(0) on success. Bad handle specified (269) if current window handle does not correspond to a valid window. Bad handle specified (274) if index is outside of allowable bounds.",
        "syntax": "PageRecall(iIndex)"
    },
    "pagerichtextfile": {
        "doc": "This function creates a rich edit object, and loads a copy of the rich text file Filename into that object. The rich text object will be rectangular in shape, with dimensions determined by nHeight, and nWidth. If you do not specify nHeight and nWidth, nAN will define the position of one corner, and (AN + 1) the position of the diagonally opposite corner. This function would often be used as a page entry function.",
        "example": "PageRichTextFile(108,\"f:\\\nPlant SCADA\n\\data\\richtext.rtf\",0);\n// This function would produce a rich text object at animation\npoint 108. Into this object a copy of f:\\\nPlant SCADA\n\\data\\richtext.rtf\nwould then be loaded. Remember, richtext.rtf is the name of the\noutput file for the report, as specified in the Devices form.\nBecause 0 was specified as the nMode for this example, the\ncontents of this object will be display only. //\nPageRichTextFile(53,\"[Data]\\richtext.rtf\",1);\n//This function would produce a rich text object at animation\npoint 53. Into this object a copy of [Data]\\richtext.rtf would\nthen be loaded. It will be possible to select and copy the\ncontents of the object, but not make changes. //",
        "name": "PageRichTextFile",
        "params": [
            {
                "paramdescription": " The animation point at which to display the rich text object.",
                "paramname": "nAN"
            },
            {
                "paramdescription": " The name of the file to be copied and loaded into the rich text object. The filename needs to be entered in quotation marks \"\".\nIf you are loading a copy of an RTF report, the report needs to have already been run and saved to a file.\nRemember that the filename for the saved report comes from the File Name field in the Devices form. The location of the saved file needs to also be included as part of the filename. For example, if the filename in the Devices form listed [Data];RepDev.rtf, then you would need to enter \"[Data]\\repdev.rtf\" as your argument. Alternatively, you can manually enter the path, for example, \"c:\\MyApplication\\data\\repdev.rtf\".\nIf you are keeping a number of history files for the report, instead of using the rtf extension, you need to change it to reflect the number of the desired history file, for example, 001.",
                "paramname": "Filename"
            },
            {
                "paramdescription": " The display mode for the rich text object. The mode can be any combination of:\n0 - Disabled - should be used if the rich text object is to be used for display purposes only.\n1 - Enabled - allows you to select and copy the contents of the RTF object (for instance an RTF report), but you will not be able to make changes.\n2 - Read/Write - allows you to edit the contents of the RTF object. Remember, however, that the object needs to be enabled before it can be edited. If it has already been enabled, you can just enter Mode 2 as your argument. If it is not already enabled, you will need to enable it. By combining Mode 1 and Mode 2 in your argument (3), you can enable the object, and make it read/write at the same time.\nBecause the content of the rich text object is just a copy of the original file, changes will not affect the actual file, until saved using the DspRichTextSave function.",
                "paramname": "nMode"
            },
            {
                "paramdescription": " The height of the rich text object in pixels. The height is established by measuring down from the animation point.\nIf you do not enter a height and width, the size of the object will be determined by the position of nAN and AN+1.",
                "paramname": "nHeight"
            },
            {
                "paramdescription": " The width of the rich text object in pixels. The width is established by measuring across to the right of the animation point.\nIf you do not enter a height and width, the size of the object will be determined by the position of nAN and AN+1.",
                "paramname": "nWidth"
            }
        ],
        "returnType": "None",
        "syntax": "PageRichTextFile(nAN, Filename, nMode [, nHeight] [, nWidth] )"
    },
    "pageselect": {
        "doc": "Displays a dialog box with a list of graphics pages defined in the project. AN operator can select a page name for display.",
        "example": "PageSelect();\n! Displays the page selection dialog box.",
        "name": "PageSelect",
        "params": [],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "PageSelect()"
    },
    "pagesetint": {
        "doc": "Associates an integer variable with a particular page. Page-based variables are stored in an array, local to each display page. This function allows you to save integer variables in temporary storage.\nNotes",
        "example": "No example found",
        "name": "PageSetInt",
        "params": [
            {
                "paramdescription": "String name of the variable which will contain sValue.",
                "paramname": "sLabel"
            },
            {
                "paramdescription": "The integer to store.",
                "paramname": "sVar"
            },
            {
                "paramdescription": "Window number of the page. Default is current window.",
                "paramname": "iWinNum"
            }
        ],
        "returnType": "No error(0) on success. 269 if WinNum handle does not correspond to a valid window. 274 if Label or Var is not a valid variable.",
        "syntax": "PageSetInt(sLabel, sVar [, iWinNum])"
    },
    "pagesetstr": {
        "doc": "Stores a local page-based string and associates the string with the page. Page-based variables are stored in an array, local to each display page. This function allows you to save string variables in temporary storage.",
        "example": "No example found",
        "name": "PageSetStr",
        "params": [
            {
                "paramdescription": "String name of the variable which will contain sVar.",
                "paramname": "sLabel"
            },
            {
                "paramdescription": "The string to store. The string length is 128 characters.",
                "paramname": "sVar"
            },
            {
                "paramdescription": "Window number of the page. Default is current window.",
                "paramname": "iWinNum"
            }
        ],
        "returnType": "No error(0) on success. 269 if WinNum handle does not correspond to a valid window. 274 if Label or Var is not a valid variable.",
        "syntax": "PageSetStr(sLabel, sVar [, iWinNum])"
    },
    "pagesoe": {
        "doc": "Displays a category of sequence of events (SOE) entries on the SOE page.\nTo use this function, you need to have a page in your project that was created using the SOE template. By default, the name of the page is expected to be \"SOE\". However, you can use an alarm page with different name by adjusting the setting for the INI parameter [Page]SOEPage.",
        "example": "No example found",
        "name": "PageSOE",
        "params": [
            {
                "paramdescription": "The category number for the alarms you want to display their events",
                "paramname": "Category"
            },
            {
                "paramdescription": "Whether to display the Summary page instead if the SOE page does not exist. If not specified it defaults to FALSE (0).",
                "paramname": "Fallback"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "PageSOE(INT Category, INT Fallback)"
    },
    "pagesummary": {
        "doc": "Displays a category of alarm summary entries on the alarms summary page. \nTo use this function, you need to have a page in your project that was created usingthe Summary template. By default, the name of the page is expected to be \"Summary\". However, you can use an alarm page with a different name by adjusting the setting for the INIparameter [Page]SummaryPage.\nNotes",
        "example": "No example found",
        "name": "PageSummary",
        "params": [
            {
                "paramdescription": "The category number for the alarms you want to summarise.",
                "paramname": "Category"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "PageSummary(Category)"
    },
    "pagetask": {
        "doc": "PageTask() is used for running preliminary Cicode before displaying a page in a window. It makes it possible for the same Cicode to be run if the page is re-entered by navigating forward or back. PageTask() is similar to TaskNew().\nPageTask() returns a handle to a code task the first time it is run. The custom Cicode of the sFunctionName parameter needs to call PageDisplay() in order to display the page. When the page changes, the function and its parameters will be pushed onto the Page Navigation History. The Cicode fnTask will be called again when the page is navigated to using the PageForward or PageBackward functions.",
        "example": "FUNCTION DisplayAlarmLog()\n\tPageTask(WinNumber(), \"_DisplayAlarmLog\", \"\");\nEND\n\nFUNCTION _DisplayAlarmLog()\t\n\tPageFile(\"[Data]:AlarmLog.Txt\");\n\tDspFile(21,DspFont(\"Courier\",-10,Black,Transparent),24,120);\n\tWinTitle(\"@(Alarm History)\");\nEND\n\t\n\t\t\t\n\t\t\t\n\t\t\t",
        "name": "PageTask",
        "params": [
            {
                "paramdescription": "The Window number of the window in which to display the page.",
                "paramname": "iWinNum"
            },
            {
                "paramdescription": "String representing the Cicode function to run each time the page is navigated to using the forward and backward navigation functions.",
                "paramname": "sFunctionName"
            },
            {
                "paramdescription": "String representing the parameters to use with function fnTask.",
                "paramname": "sFunctionArg"
            }
        ],
        "returnType": "A handle to a code task the first time it is run. \tBAD_HANDLE (-1) if the function did not complete. ",
        "syntax": "PageTask(iWinNum, sFunctionName, sFunctionArg)"
    },
    "pagetransformcoords": {
        "doc": " Converts Page coordinates to absolute screen coordinates.",
        "example": "No example found",
        "name": "PageTransformCoords",
        "params": [
            {
                "paramdescription": "Page handle of the relevant Window.",
                "paramname": "hPage"
            },
            {
                "paramdescription": " X coordinate of page coordinate.",
                "paramname": "PageX"
            },
            {
                "paramdescription": "Y coordinate of page coordinate.",
                "paramname": "iPageY"
            },
            {
                "paramdescription": "Output parameter: Transformed X coordinate. Must be a Long type variable.",
                "paramname": "iDisplayX"
            },
            {
                "paramdescription": "Output parameter: Transformed Y coordinate. Must be a Long type variable.",
                "paramname": "iDisplayY"
            },
            {
                "paramdescription": "The value of output coordinate:\n0 - Absolute screen coordinates\n1 - Coordinates relative to Window origin\n2 - Coordinates relative to Client rectangle origin",
                "paramname": "iType"
            }
        ],
        "returnType": "0 - Success",
        "syntax": "PageTransformCoords(hPage, iPageX, iPageY , iDisplayX, iDisplayY, iType)"
    },
    "pagetrend": {
        "doc": "Displays a trend page with the specified trend pens. Use this function to display trends in a single cluster system with a single trend page. You need to create the trend page with the Graphics Builder and set the pen names to blank. Then display that page by calling this function and passing the required trend tags. Call this function from a menu of trend pages.",
        "example": "PageTrend(\"MyTrend\", \"PV1\", \"PV2\", \"PV3\")\n/* Display three trend tags on a single trend page. */",
        "name": "PageTrend",
        "params": [
            {
                "paramdescription": "Name of the trend page (drawn with the Graphics Builder).",
                "paramname": "sPage"
            },
            {
                "paramdescription": "The first trend tag to display on the page.",
                "paramname": "sTag1"
            },
            {
                "paramdescription": "Optionally trend tags 2 to 8 to display on the page.",
                "paramname": "sTag2..sTag8"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "PageTrend(sPage, sTag1 [, sTag2..sTag8] )"
    },
    "pagetrendex": {
        "doc": "Displays a trend page of a specified cluster in a multi-cluster system with the specified trend pens. Use this function to display trends in a mult-cluster system with a single trend page. You need to create the trend page with the Graphics Builder and set the pen names to blank. Then display that page by calling this function and passing the required trend tags. Call this function from a menu of trend pages. This function can also be used in a single cluster system, the sCluster argument is optional in such a case.",
        "example": "PageTrendEx(\"MyTrend\", \"MyCluster\", \"PV1\", \"PV2\", \"PV3\")\n/* Display three trend tags on a single trend page on the\nspecified cluster. */",
        "name": "PageTrendEx",
        "params": [
            {
                "paramdescription": "Name of the trend page (drawn with the Graphics Builder).",
                "paramname": "sPage"
            },
            {
                "paramdescription": "Name of the cluster in which the trend page is located.",
                "paramname": "sCluster"
            },
            {
                "paramdescription": "The first trend tag to display on the page.",
                "paramname": "sTag1"
            },
            {
                "paramdescription": "Optionally trend tags 2 to 8 to display on the page.",
                "paramname": "sTag2..sTag8"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "PageTrendEx(sPage, sCluster, sTag1 [, sTag2..sTag8] )"
    },
    "parameterget": {
        "doc": "Gets the value of a system parameter. The system parameter can exist in the CITECT.INI file and/or in the Parameters database.\nIf the system parameter does not exist in the CITECT.INI file or the database, the default value is returned. If the system parameter exists in both CITECT.INI and the database, the value of the system parameter is taken from CITECT.INI.",
        "example": "Variable=ParameterGet(\"Page\",\"Windows\",\"4\");",
        "name": "ParameterGet",
        "params": [
            {
                "paramdescription": "The section name.",
                "paramname": "Section"
            },
            {
                "paramdescription": "The system parameter name.",
                "paramname": "sName"
            },
            {
                "paramdescription": "The default value of the parameter.\nThe parameter (as a string).",
                "paramname": "Default"
            }
        ],
        "returnType": "The parameter (as a string).",
        "syntax": "ParameterGet(Section, Name, Default)"
    },
    "parameterput": {
        "doc": "Updates a system parameter in the CITECT.INI file. If the system parameter does not exist, it is added to the CITECT.INI file.",
        "example": "/* Changes the [Page] Windows system parameter in CITECT.INI to \"4\". */\nParameterPut(\"Page\",\"Windows\",\"4\");",
        "name": "ParameterPut",
        "params": [
            {
                "paramdescription": "The section name.",
                "paramname": "Section"
            },
            {
                "paramdescription": "The system parameter name.",
                "paramname": "sName"
            },
            {
                "paramdescription": "The value to put in the system parameter.",
                "paramname": "Value"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "ParameterPut(Section, Name, Value)"
    },
    "pathtostr": {
        "doc": "Converts a Plant SCADA path into a string. The path string can contain one of the standard Plant SCADA path operators, BIN, DATA, RUN, USER or a user-configured path. If the string does not contain a Plant SCADA path, it is unchanged.",
        "example": "Variable=PathToStr(\"[data]:test.txt\");\n! Sets Variable to \"c:\\MyApplication\\data\\test.txt\".\n! assuming that DATA=C:\\MyApplication\\DATA",
        "name": "PathToStr",
        "params": [
            {
                "paramdescription": "The Plant SCADA path to convert.",
                "paramname": "sPath"
            }
        ],
        "returnType": "A string containing the converted path.",
        "syntax": "PathToStr(sPath)"
    },
    "pi": {
        "doc": "Gets the value of pi (the ratio of the circumference of a circle to its diameter).",
        "example": "Variable=Pi();\n! Sets Variable to 3.1415...",
        "name": "Pi",
        "params": [],
        "returnType": "The value of pi.",
        "syntax": "Pi()"
    },
    "plotclose": {
        "doc": "Displays the plot on screen or sends it to the printer (depending on the output device you specified in the PlotOpen() function), then closes the plot. Once the plot is closed, it cannot be used.",
        "example": "No example found",
        "name": "PlotClose",
        "params": [
            {
                "paramdescription": "The plot handle, returned from the PlotOpen() function. The plot handle identifies the table where all data on the plot is stored.",
                "paramname": "hPlot"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "PlotClose(hPlot)"
    },
    "plotdraw": {
        "doc": "Constructs drawings on your plot. Use the coordinates (X1,Y1) and (X2,Y2) to define a point, line, rectangle, square, circle, or ellipse. You can specify the style, color, and width of the pen, and a fill color for a box or circular shape.\nyou need to call the PlotOpen() function first, to get the handle for the plot (hPlot) and to specify the output device.",
        "example": "No example found",
        "name": "PlotDraw",
        "params": [
            {
                "paramdescription": "The plot handle, returned from the PlotOpen() function. Theplot handle identifies the table where data on the plot isstored.",
                "paramname": "hPlot"
            },
            {
                "paramdescription": "The type of drawing:",
                "paramname": "nType"
            },
            {
                "paramdescription": "The style of the pen used to draw:",
                "paramname": "PenStyle"
            },
            {
                "paramdescription": "The color of the pen (flashing color is not supported). Select acolor from the list of Predefined Color Names and Codes orcreate an RGB-based color using the functionMakeColour.",
                "paramname": "PenCol"
            },
            {
                "paramdescription": "Pen width in pixels. If the width is thicker than one pixel,you need to use a solid pen (PenStyle = 0). Maximum width is32.",
                "paramname": "PenWidth"
            },
            {
                "paramdescription": "The fill color of the rectangle, square, circle, or ellipse(flashing color is not supported). Select a color from the listof predefined color names and codes or create an RGB-basedcolor using the function MakeColour. For a point orline, nFill is ignored.",
                "paramname": "nFill"
            },
            {
                "paramdescription": "X and y coordinates (in pixels) of the upper-left corner of thedrawing (the origin).",
                "paramname": "X1, Y1"
            },
            {
                "paramdescription": "X and y coordinates (in pixels) of the lower-right corner ofthe drawing.\nFor a point, (X1,Y1) and (X2,Y2) are assumed to be the same, so (X2,Y2) is ignored. To draw a circle or ellipse, enter the coordinates for a square or rectangle; the circle or ellipse is automatically drawn within the box.\nIf the plot is for display on the screen, coordinates are relative to the AN specified in the PlotOpen() function. If the output device is a printer, coordinates are relative to the point (0,0).",
                "paramname": "X2, Y2"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "PlotDraw(hPlot, Type, PenStyle, PenCol, PenWidth, nFill, X1, Y1, X2, Y2)"
    },
    "plotgetmarker": {
        "doc": "Gets the marker number of a symbol. The symbol needs to be a symbol and registered with the PlotSetMarker() function.",
        "example": "/*Assume that the symbol was registered by PlotSetMarker function */\nPlotSetMarker(20,\"Global.Hourglass\");\n/*Later on, this symbol can be used as shown below*/\nhPlot = PlotOpen(36,\"Display\",1);\n..\n/* Display red hourglass as marker at point (100,200) on AN36. */\nMarkerNo = PlotGetMarker(\"Global.Hourglass\");\nPlotMarker(hPlot,MarkerNo,red,1,1,100,200);\n..\nPlotClose(hPlot);",
        "name": "PlotGetMarker",
        "params": [
            {
                "paramdescription": "The library name and symbol name (\"Library.Symbol\") of the symbol that is registered as a marker.",
                "paramname": "sSymbolName"
            }
        ],
        "returnType": "The marker number if successful, otherwise -1 is returned.",
        "syntax": "PlotGetMarker(sSymbolName)"
    },
    "plotgrid": {
        "doc": "Defines a frame and draws horizontal and vertical grid lines within this frame. These grid lines can then be used by the PlotLine(), PlotXYLine(), and PlotScaleMarker() functions. You need to define the frame for a plot before you can plot points with the PlotLine() and PlotXYLine() functions. nSamples specifies the maximum number of samples that can be plotted for a single line. If you set FrameWidth to 0 (zero), the frame will be defined but not displayed (however, the plot will still be displayed).\nYou can specify the number of grid lines and their color, as well as the background color which will fill the frame. If nHorGrid and nVerGrid are set to 0 (zero), then the grid lines will not be drawn.\nyou need to call the PlotOpen() function, first, to get the handle for the plot (hPlot), and to specify the output device. Then call this function to set up the frame and grid. You can then call the PlotScaleMarker() function to draw scale lines beside the frame, and call the PlotLine() or PlotXYLine() to plot a set of data points.",
        "example": "No example found",
        "name": "PlotGrid",
        "params": [
            {
                "paramdescription": "Plot handle, returned from the PlotOpen() function. The plothandle identifies the table where data on the plot isstored.",
                "paramname": "hPlot"
            },
            {
                "paramdescription": "The maximum number of samples that can be plotted for asingle line in this grid (valid values between 2 and 16000 inclusive). For example, if you set nSamples to 10,then plot 2 lines in this grid (using the PlotLine() function),each line will be plotted with a maximum of 10 samples. Forthis example, a line can possess less than 10 samples, but if ithas more, it will be shortened to 10 samples.",
                "paramname": "nSamples"
            },
            {
                "paramdescription": "The x and y coordinates of the upper-left corner of the framecontaining the grid lines.",
                "paramname": "X1, Y1"
            },
            {
                "paramdescription": "The x and y coordinates of the lower-right corner of theframe containing the grid lines.\nIf the plot is for display on the screen, you should set (X1,Y1) to (0,0). The origin of the frame is then positioned at the AN specified in the PlotOpen() function.\nIf the output device is a printer, both (X1,Y1) and (X2,Y2) are relative to the point (0,0).",
                "paramname": "X2, Y2"
            },
            {
                "paramdescription": "The number of rows (formed by the horizontal grid lines) todraw within the frame. If there is no need of grid lines, setnHorGrid to 0 (zero) and HorGridCol to 0. nHorGrid cannot exceed the pixel width of the plot.",
                "paramname": "nHorGrid"
            },
            {
                "paramdescription": "The color of the horizontal grid lines (flashing color is notsupported). Select a color from the list of Predefined ColorNames and Codes or create an RGB-based color using thefunction MakeCitectColour.",
                "paramname": "HorGridCol"
            },
            {
                "paramdescription": "The number of columns (formed by the vertical grid lines) todraw within the frame. If there is no need of grid lines, setnVerGrid to 0 (zero) and VerGridCol to 0. nVerGrid cannot exceed the pixel height of the plot.",
                "paramname": "nVerGrid"
            },
            {
                "paramdescription": "The color of the vertical grid lines (flashing color is notsupported). Select a color from the list of Predefined ColorNames and Codes or create an RGB-based color using thefunction MakeColour.",
                "paramname": "VerGridCol"
            },
            {
                "paramdescription": "The width (also called pen width) of the frame enclosing thegrid, in pixels. To define the frame without drawing itsboundaries, set FrameWidth to 0 (zero) and FrameCol to 0.The maximum is 32.",
                "paramname": "FrameWidth"
            },
            {
                "paramdescription": "The color of the frame enclosing the grid (flashing color isnot supported). Select a color from the list of PredefinedColor Names and Codes or create an RGB-based color usingthe function MakeColour.",
                "paramname": "FrameCol"
            },
            {
                "paramdescription": "The background color for the frame (flashing color is notsupported). Select a color from the list of Predefined ColorNames and Codes or create an RGB-based color using thefunction MakeColour.",
                "paramname": "nFill"
            },
            {
                "paramdescription": "The mode of the plot. For future use only - set it to 0 (zero).",
                "paramname": "nMode"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "PlotGrid(hPlot, nSamples, X1, Y1, X2, Y2, nHorGrid, HorGridCol, nVerGrid, VerGridCol, FrameWidth, FrameCol, nFill, nMode)"
    },
    "plotinfo": {
        "doc": "Gets information about the plot. You can call this function to determine the number of pixels per page or inch, the resolution of a plot, and the size and spacing of characters for a specified text font. You can also check whether a printer can print rotated text. (See PlotText().)\nyou need to first call the PlotOpen() function to get the handle for the plot (hPlot) and specify the output device.",
        "example": "hPlot = PlotOpen(36,\"Display\",1);\n:\n/* Print text in upward direction but first check if printer \nsupports text rotation. Set default text orientation to left to \nright (just in case). */\nOrient = 0;\nIF PlotInfo(hPlot,9) THEN\n    Orient = 1;\nEND\nPlotText(hPlot,hFont,Orient,100,100,\"scale\");\n..\n/* Print text \"\nPlant SCADA\n Graph\" centred horizontally at top of page.*/\nPageWidth = PlotInfo(hPlot,0);          ! Get width of page\nhFont = DspFont(\"Courier\",14,black,-1);\nTextWidth = PlotInfo(hPlot,8,hFont);    ! Get width of each character\nTextPosn = (PageWidth - TextWidth * 12) / 2    ! Get start of 1st character\nPlotText(hPlot,hFont,0,TextPosn,0,\"\nPlant SCADA\n Graph\");\n..\nPlotClose(hPlot);",
        "name": "PlotInfo",
        "params": [
            {
                "paramdescription": "The plot handle, returned from the PlotOpen() function. The plot handle identifies the table where all data on the plot is stored.",
                "paramname": "hPlot"
            },
            {
                "paramdescription": "The type of plot information to get:\n0 - Horizontal pixels on a printout page\n1 - Vertical pixels on a printout page\n2 - Horizontal pixels per inch\n3 - Vertical pixels per inch\n4 - Horizontal resolution\n5 - Vertical resolution\n6 - Height of the font used\n7 - External leading of the font used\n8 - Character width of the font used\n9 - Rotatable text is allowed or not\n10 - Indicates whether or not a font is supported\n11 - Horizontal size of a page in millimeters\n12 - Vertical size of a page in millimeters",
                "paramname": "nType"
            },
            {
                "paramdescription": "The font handle (hFont), returned from the DspFont() function. Useful only for Type 6, 7, 8, or 10.",
                "paramname": "sInput"
            }
        ],
        "returnType": "The attributes of the plot as a string.",
        "syntax": "PlotInfo(hPlot, Type [, sInput] )"
    },
    "plotline": {
        "doc": "Draws a line (in the Plant SCADA plot system) for a set of data points. You specify the data points in the table pTable, and plot these points between the LoScale and HiScale values. The line is drawn inside the frame defined by the PlotGrid() function.\nFor each line on a plot, you can specify a different pen style, color, and width, and a different marker style and color. You can draw lines either from left to right or from right to left.\nyou need to first call the PlotOpen() function to get the handle for the plot (hPlot) and specify the output device. You should then use the PlotGrid() function to set up the frame and grid, before you call this function to plot the line.",
        "example": "No example found",
        "name": "PlotLine",
        "params": [
            {
                "paramdescription": "The plot handle, returned from the PlotOpen() function. Theplot handle identifies the table where all data on the plot isstored.",
                "paramname": "hPlot"
            },
            {
                "paramdescription": "The style of the pen used to draw:\n0 - Solid\n1 - Dash ( - - - - - )\n2 - Dot (...............................)\n3 - Dash and dot ( - . - . - . - . - )\n4 - Dash, dot, dot ( - . . - . . - . . - )\n5 - Hollow",
                "paramname": "PenStyle"
            },
            {
                "paramdescription": "The color of the pen (flashing color is not supported). Select acolor from the list of Predefined Color Names and Codes orcreate an RGB-based color using the functionMakeColour.",
                "paramname": "PenCol"
            },
            {
                "paramdescription": "The width of the pen, in pixels. If the width is thicker thanone pixel, you need to use a solid pen (PenStyle = 0). Themaximum width is 32.",
                "paramname": "PenWidth"
            },
            {
                "paramdescription": "The style of the markers:\n0 - No markers\n1 - Triangle\n2 - Square\n3 - Circle\n4 - Diamond\n5 - Filled triangle\n6 - Filled square\n7 - Filled circle\n8 - Filled diamond\n20 - 32000 - User-defined markers. You can register any symbol as a marker with the PlotSetMarker() function. Call the PlotGetMarker() function if the number of markers you have previously registered are unknown.",
                "paramname": "MarkerStyle"
            },
            {
                "paramdescription": "The color of the markers (flashing color is not supported).Select a color from the list of predefined color names andcodes or create an RGB-based color using the functionMakeColour.",
                "paramname": "MarkerCol"
            },
            {
                "paramdescription": "The number of samples between markers.",
                "paramname": "nMarker"
            },
            {
                "paramdescription": "The length of the array, that is, the number of points in the tablepTable for PlotLine(), or in tables xTable and yTable forPlotXYLine().\nFor every line you draw with the PlotLine() and PlotXYLine() functions within a plot, you need to add the Length arguments for each call, and pass the total to the PlotGrid() function (in the nSamples argument).",
                "paramname": "Length"
            },
            {
                "paramdescription": "The points to be plotted (as an array of floating-point values).",
                "paramname": "pTable"
            },
            {
                "paramdescription": "The lowest value that will be displayed on the plot (that is thevalue assigned to the origin of your grid). The LoScale andHiScale values determine the scale of your grid. This scale isused to plot values. for example, If LoScale = 0 (zero) and HiScale =100, a value of 50 will be plotted half way up the Y-axis ofyour grid. LoScale needs to be in the same units as the values inpTable.",
                "paramname": "LoScale"
            },
            {
                "paramdescription": "The highest value that will be displayed on the plot. TheLoScale and HiScale values determine the scale of your grid.This scale is used to plot values. for example, If LoScale = 0 (zero) andHiScale = 100, a value of 50 will be plotted half way up the Y-axis of your grid. HiScale needs to be in the same units as thevalues in pTable.",
                "paramname": "HiScale"
            },
            {
                "paramdescription": "The origin of your grid, and the direction of the plotted line:\n1 - Origin is bottom-left, x is left to right, y is upwards\n2 - Origin is bottom-right, x is right to left, y is upwards\n4 - Origin is top-left, x is left to right, y is downwards\n8 - Origin is top-right, x is right to left, y is downwards",
                "paramname": "Mode"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "PlotLine(hPlot, PenStyle, PenCol, PenWidth, MarkerStyle, MarkerCol, nMarker, Length, pTable, LoScale, HiScale, Mode)"
    },
    "plotmarker": {
        "doc": "Draws markers on a plotted line or at a specified point. You can plot any one of the standard markers, or use a symbol of your choice. (you need to first register your symbol as a marker, by using the PlotSetMarker() function.)\nTo draw a single marker at a specified point, set X and Y to the coordinates of the point, and set Length to 1.\nYou can draw markers on a plotted line when you draw the line, that is within the PlotLine() or PlotXYLine() function. You would use the PlotMarker() function only if you need to draw a second set of markers on the same line. Call PlotMarker() immediately after the line is drawn. Set X and Y to -1 and Length to the number of data points (specified in the Length argument of the PlotLine() or PlotXYLine() function).\nyou need to first call the PlotOpen() function to get the handle for the plot (hPlot) and specify the output device.",
        "example": "hPlot=PlotOpen(36,\"Display\",1);\n..\n/* Draw a filled red square marker at the point (X=100,Y=200). */\nPlotMarker(hPlot,6,red,1,1,100,200);\n..\n/* Draw 10 black triangles and 5 green cylinders along a plot\nline. */\nPlotLine(hPlot,0,black,3,5,black,10,100,Buf2[0],0,100,2);\nPlotSetMarker(20,\"Global.Cylinder\");\nPlotMarker(hPlot,20,green,5,100,-1,-1)\n..\nPlotClose(hPlot);",
        "name": "PlotMarker",
        "params": [
            {
                "paramdescription": "The plot handle, returned from the PlotOpen() function. Theplot handle identifies the table where data on the plot isstored.",
                "paramname": "hPlot"
            },
            {
                "paramdescription": "The style of the markers:\n0 - No markers\n1 - Triangle\n2 - Square\n3 - Circle\n4 - Diamond\n5 - Filled triangle\n6 - Filled square\n7 - Filled circle\n8 - Filled diamond\n20 - 32000: User-defined markers. You can register any symbol as a marker with the PlotSetMarker() function. Call the PlotGetMarker() function if the number of markers you have previously registered are unknown.",
                "paramname": "MarkerStyle"
            },
            {
                "paramdescription": "The color of the marker (flashing color is not supported).Select a color from the list of Predefined Color Names andCodes or create an RGB-based color using the functionMakeColour.",
                "paramname": "MarkerCol"
            },
            {
                "paramdescription": "The number of samples between markers.",
                "paramname": "nMarker"
            },
            {
                "paramdescription": "The length of the array (the number of line points in the tablepTable) plotted in the PlotLine() or PlotXYLine() function. Todraw only one marker at a specified point, set Length to 1.",
                "paramname": "Length"
            },
            {
                "paramdescription": "The x and y coordinates, in pixels, of the point where themarker is to be drawn. If the plot is for display on the screen,the coordinates are relative to the AN specified in thePlotOpen() function. If the output device is a printer, thecoordinates are relative to the point (0,0).\nTo draw the markers on a plotted line, set both X and Y to -1, and set Length to the same value as the Length passed in the PlotLine() or PlotXYLine() function.",
                "paramname": "X, Y"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "PlotMarker(hPlot, MarkerStyle, MarkerCol, nMarker, Length, X, Y)"
    },
    "plotopen": {
        "doc": "Opens a new plot, sets its output device, and returns its plot handle. You can send the plot to any one of your system printers, or display it on screen at the specified AN.\nyou need to call this function before you can call the other plot functions.",
        "example": "hPlot=PlotOpen(0,\"LPT2:\",1);\nIF hPlot <> -1 THEN\n    /* Set up a black frame with red & blue grid lines. */    \n    PlotGrid(hPlot,18,450,800,1850,1600,5,red,10,blue,4,black,white,0);\n    /* Draw a scale line to the left of the frame. */\n    PlotScaleMarker(hPlot,400,1600,6,1,black,0);\n    /* Plot a simple line in green for a table of 10 values. */\n    PlotLine(hPlot,0,green,3,6,green,2,10,Buf1,0,100,1);\n    /* Plot a line in yellow (with black markers) for tables of 8 X and Y values. */    \n    PlotXYLine(hPlot,0,yellow,4,3,black,2,8,Buf2,0,150,Buf3,0,100,1);\n    /* Draw a title box above the plot frame, with the heading \"\nPlant SCADA\n Graph\". */\n    PlotDraw(hPlot,1,0,black,1,grey,900,250,1400,400);\n    hFont = DspFont(\"Times\",-60,black,grey);\n    PlotText(hPlot,hFont,0,950,350,\"\nPlant SCADA\n Graph\");\n    PlotClose(hPlot);\nEND\n\nPlotOpen(0,\"LPT1:\",1)    // opens a new plot to be sent to printer \nPlotOpen(20,\"DISPLAY\",17)    // normal plot with soft animation\nPlotOpen(20,\"DISPLAY\",257)    // normal plot with overlap animation\nPlotOpen(20,\"DISPLAY\",1)    // normal plot with overlap animation\n(for default animation mode is overlap animation)\nPlotOpen(20,\"DISPLAY\",16)    // INVALID \n(does not specify whether it is normal or Version 2.xx mode).\nPlotOpen(20,\"DISPLAY\",2)    // INVALID for Version 2.xx graph system \n(does not support display as output).",
        "name": "PlotOpen",
        "params": [
            {
                "paramdescription": "The animation point (AN) where the plot will display. Set the AN to 0 (zero) when sOutput is a printer.\nDo not use an animation point number at which a graphic object exists as this will prevent the PlotOpen() function from succeeding.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The output device where the plot is sent, for example:\n\"Display\" - Display on screen. The plot is recorded in a metafile and displayed (at the specified AN) when the plot system is closed.\n\"LPT1:\" - Send to printer LPT1.\n\"LPT2:\" - Send to printer LPT2.\n\"\\\\ABC\\Printers\\Color1\" - Send to UNC port (and so on for any output device)",
                "paramname": "sOutput"
            },
            {
                "paramdescription": "When a plot is removed or updated, the portion of the background screen beneath it is blanked out. The mode determines how the background screen is restored. The mode of the plot system:\n1 - Normal mode\n2 - Use for compatibility with the old graph functions\n17 - Soft (valid for normal mode). The background screen (a rectangular region beneath the plot) is restored with the original image. Any objects that are within the rectangular region are destroyed when the background is restored.\n33 - Hard (valid for normal mode). The background screen (a rectangular region beneath the plot) is painted with the color at the AN.\n65 - Persistent (valid for normal mode). The plot is not erased. As the plot is updated, it is re-displayed on top. This mode provides fast updates. Transparent color is supported in this mode.\n129 - Opaque animation (valid for normal mode). The plot is not erased. As the plot is updated, it is re-displayed on top. This mode provides the fastest updates. Transparent color is not supported in this mode.\n257 - Overlapped animation (valid for normal mode). The background screen (the rectangular region beneath the plot) is completely repainted.",
                "paramname": "Mode"
            }
        ],
        "returnType": "The plot handle if the plot is opened successfully, otherwise -1 is returned. The plot handle identifies the table where all data on the associated plot is stored.",
        "syntax": "PlotOpen(nAN, sOutput, Mode)"
    },
    "plotscalemarker": {
        "doc": "Draws scale lines beside the grid on your plot (if there is one) and places markers on them. The height of the scale line is automatically set to the height of the frame set in the PlotGrid() function.\nyou need to first call the PlotOpen() function to get the handle for the plot (hPlot) and specify the output device. You should then use the PlotGrid() function to set up the frame and grid, before you call this function to draw the scale lines.",
        "example": "No example found",
        "name": "PlotScaleMarker",
        "params": [
            {
                "paramdescription": "The plot handle, returned from the PlotOpen() function. Theplot handle identifies the table where data on the plot isstored.",
                "paramname": "hPlot"
            },
            {
                "paramdescription": "The x and y coordinates of the point where the scale linestarts. The end coordinates of the scale line are automaticallydefined by the size of the frame (set in the PlotGrid()function).\nIf the plot is for display on the screen, coordinates are relative to the AN specified in the PlotOpen() function. If the output device is a printer, coordinates are relative to the point (0,0).",
                "paramname": "X, Y"
            },
            {
                "paramdescription": "The number of markers on the scale line.",
                "paramname": "nMarker"
            },
            {
                "paramdescription": "The width of the scale line, in pixels.",
                "paramname": "PenWidth"
            },
            {
                "paramdescription": "The color of the pen (flashing color is not supported). Select acolor from the list of Predefined Color Names and Codes orcreate an RGB-based color using the functionMakeColour.",
                "paramname": "PenCol"
            },
            {
                "paramdescription": "The mode of the markers:\n0 - Both sides of the scale line\n1 - Left of the scale line\n2 - Right of the scale line",
                "paramname": "Mode"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "PlotScaleMarker(hPlot, X, Y, nMarker, PenWidth, PenCol, Mode)"
    },
    "plotsetmarker": {
        "doc": "Registers a symbol as a marker. You can then draw the new marker at points and on plotted lines, by specifying the MarkerNo of the symbol as the MarkerStyle in the PlotMarker() function. Call the PlotGetMarker() function if you do not know the number of a marker.",
        "example": "hPlot=PlotOpen(30,\"Display\",1);\n..\n/* Display red hourglass as marker at point (100,200). */\nPlotSetMarker(20,\"Global.Hourglass\");\nPlotMarker(hPlot,20,red,1,1,100,200);\n..\nPlotClose(hPlot);",
        "name": "PlotSetMarker",
        "params": [
            {
                "paramdescription": "The number of the marker, to be used as the MarkerStyle in the PlotMarker() function. Your marker numbers need to be greater than or equal to 20 (to a maximum of 32000).",
                "paramname": "MarkerNo"
            },
            {
                "paramdescription": "The name and path of the symbol to be defined as a marker.",
                "paramname": "sSymbolName"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "PlotSetMarker(MarkerNo, sSymbolName)"
    },
    "plottext": {
        "doc": "Prints text on a plot. You can specify the font, position, and orientation of the text. If you specify an orientation other than 'left-to-right', you need to check that the font (and the printer) supports the orientation.\nyou need to first call the PlotOpen() function to get the handle for the plot (hPlot) and specify the output device. You also needs to call the DspFont() function to get a handle for the font (hFont).",
        "example": "No example found",
        "name": "PlotText",
        "params": [
            {
                "paramdescription": "The plot handle, returned from the PlotOpen() function. The plot handle identifies the table where all data on the plot is stored.",
                "paramname": "hPlot"
            },
            {
                "paramdescription": "The font handle, returned from the DspFont() function. The font handle identifies the table where details of that font are stored.",
                "paramname": "hFont"
            },
            {
                "paramdescription": "The orientation of the text:\n0 - Left-to-right\n1 - Upwards\n2 - Right-to-left\n3 - Downwards\nYou should check that the font supports rotation (where Orientation = 1, 2, or 3). Most true type and vector fonts support rotation. If the PlotInfo(hPlot, 9) function returns false, you need to specify an Orientation of 0 (zero).",
                "paramname": "Orientation"
            },
            {
                "paramdescription": "The x and y coordinates (in pixels) of the start of the text. If the plot is for display on the screen, the coordinates are relative to the AN specified in the PlotOpen() function. If the output device is a printer, the coordinates are relative to the point (0,0).",
                "paramname": "X, Y"
            },
            {
                "paramdescription": "The text string to be plotted.",
                "paramname": "sText"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "PlotText(hPlot, hFont, Orientation, X, Y, sText)"
    },
    "plotxyline": {
        "doc": "Plots values from two different tables. Values from one table are considered X coordinates, and values from the other are considered Y coordinates. Points are plotted between the low and high scale values specified for x and y. The line is plotted inside the frame defined by the PlotGrid() function.\nFor each line, you can specify a different pen style, color, and width, and a different marker style and color. You can draw lines either from left to right or from right to left. You need to first call the PlotOpen() function to get the handle for the plot (hPlot) and specify the output device. You should then use the PlotGrid() function to set up the frame and grid, before you call this function to plot the line.",
        "example": "No example found",
        "name": "PlotXYLine",
        "params": [
            {
                "paramdescription": "The plot handle, returned from the PlotOpen() function. Theplot handle identifies the table where all data on the plot isstored.",
                "paramname": "hPlot"
            },
            {
                "paramdescription": "The style of the pen used to draw:\n0 - Solid\n1 - Dash ( - - - - - )\n2 - Dot (...............................)\n3 - Dash and dot ( - . - . - . - . - )\n4 - Dash, dot, dot ( - . . - . . - . . - )\n5 - Hollow",
                "paramname": "PenStyle"
            },
            {
                "paramdescription": " The color of the pen (flashing color is not supported). Select acolor from the list of Predefined Color Names and Codes orcreate an RGB-based color using the functionMakeColour.",
                "paramname": "PenCol"
            },
            {
                "paramdescription": " The width of the pen, in pixels. If the width is thicker thanone pixel, you need to use a solid pen (PenStyle = 0). Themaximum width is 32.",
                "paramname": "PenWidth"
            },
            {
                "paramdescription": " The style of the markers:\n0 - No markers\n1 - Triangle\n2 - Square\n3 - Circle\n4 - Diamond\n5 - Filled triangle\n6 - Filled square\n7 - Filled circle\n8 - Filled diamond\n20 - 32000 - User-defined markers. You can register any symbol as a marker with the PlotSetMarker() function. Call the PlotGetMarker() function to recall the number of a marker you have previously registered.",
                "paramname": "MarkerStyle"
            },
            {
                "paramdescription": " The color of the markers (flashing color is not supported).Select a color from the list of Predefined Color Names andCodes or create an RGB-based color using the functionMakeColour.",
                "paramname": "MarkerCol"
            },
            {
                "paramdescription": " The number of samples between markers.",
                "paramname": "nMarker"
            },
            {
                "paramdescription": " The length of the array, that is the number of points in the tablepTable for PlotLine(), or in tables xTable and yTable forPlotXYLine().\nFor every line you draw with the PlotLine() and PlotXYLine() functions within a plot, you need to add the Length arguments for each call, and pass the total to the PlotGrid() function (in the nSamples argument).",
                "paramname": "Length"
            },
            {
                "paramdescription": " The x coordinates for the points in the line, as an array offloating point values.",
                "paramname": "xTable"
            },
            {
                "paramdescription": " The lowest X-axis value that will be displayed on the plot (that isthe X-coordinate of the origin of your grid). The LoXScaleand HiXScale values determine the scale of your grid. Thisscale is used to plot values. for example, If LoXScale = 0 (zero) andHiXScale = 100, a value of 50 will be plotted half way alongthe X-axis of your grid.",
                "paramname": "LoXScale"
            },
            {
                "paramdescription": "",
                "paramname": "LoXScale needs to be in the same units as the values in xTable."
            },
            {
                "paramdescription": " The highest X-axis value that will be displayed on the plot.The LoXScale and HiXScale values determine the scale ofyour grid. This scale is used to plot values. for example, If LoXScale =0 (zero) and HiXScale = 100, a value of 50 will be plotted halfway along the X-axis of your grid.",
                "paramname": "HiXScale"
            },
            {
                "paramdescription": "",
                "paramname": "HiXScale needs to be in the same units as the values in xTable."
            },
            {
                "paramdescription": " The y coordinates for the points in the line, as an array offloating point values.",
                "paramname": "yTable"
            },
            {
                "paramdescription": " The lowest Y-axis value that will be displayed on the plot (that isthe Y-coordinate of the origin of your grid). The LoYScaleand HiYScale values determine the scale of your grid. Thisscale is used to plot values. for example, If LoYScale = 0 (zero) andHiYScale = 100, a value of 50 will be plotted half way up theY-axis of your grid.",
                "paramname": "LoYScale"
            },
            {
                "paramdescription": "",
                "paramname": "LoYScale needs to be in the same units as the values in xTable."
            },
            {
                "paramdescription": " The highest Y-axis value that will be displayed on the plot.The LoYScale and HiYScale values determine the scale ofyour grid. This scale is used to plot values. for example, If LoYScale =0 (zero) and HiYScale = 100, a value of 50 will be plotted halfway up the Y-axis of your grid.",
                "paramname": "HiYScale"
            },
            {
                "paramdescription": "",
                "paramname": "HiYScale needs to be in the same units as the values in xTable."
            },
            {
                "paramdescription": "The origin of your grid, and the direction of the plotted line:\n1 - Origin is bottom-left, x is left to right, y is upwards\n2 - Origin is bottom-right, x is right to left, y is upwards\n4 - Origin is top-left, x is left to right, y is downwards\n8 - Origin is top-right, x is right to left, y is downwards",
                "paramname": "Mode"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error is returned.",
        "syntax": "PlotXYLine(hPlot, PenStyle, PenCol, PenWidth, MarkerStyle, MarkerCol, nMarker, Length, xTable, LoXScale, HiXScale, YTable, LoYScale, HiYScale, Mode)"
    },
    "pow": {
        "doc": "Calculates x to the power of y.",
        "example": "Variable=Pow(5,3);\n! Sets Variable to 125.",
        "name": "Pow",
        "params": [
            {
                "paramdescription": "The base number.",
                "paramname": "X"
            },
            {
                "paramdescription": "The exponent.",
                "paramname": "Y"
            }
        ],
        "returnType": "X to the power of Y.",
        "syntax": "Pow(X, Y)"
    },
    "print": {
        "doc": "Prints a string on the current device. You should call this function only in a report. The output is sent to the device (or group of devices) defined in the Reports database (in the output device field).",
        "example": "! Print \"Testvar\" and stay on the same line.\nPrint(\"Value of Testvar=\"+Testvar:##.#);",
        "name": "Print",
        "params": [
            {
                "paramdescription": " The string (data) to print.",
                "paramname": "String"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "Print(String)"
    },
    "printfont": {
        "doc": "Changes the printing font on the current device. You should call this function only in a report. It will change the font style for the device (or group of devices) defined in the Reports database (output device field). It has effect only on reports being printed to a PRINTER_DEV - it has no effect on other types of devices, such as ASCII_DEV and dBASE_DEV.",
        "example": "{! example.rpt }\n-------------------------------------\n        AN example Report\n-------------------------------------\n{CICODE}\n    PrintFont(\"HeadingFont\");\n{END}\n    Plant Area 1\n{CICODE}\n    PrintFont(\"ReportFont\");\n{END}\n{Time(1) }     {Date(2) }\nPV_1        {PV_1:#####.##}\nPV_2        {PV_2:#####.##}\n----------End of Report---------------",
        "name": "PrintFont",
        "params": [
            {
                "paramdescription": "The Plant SCADA font (defined in the Fonts database).",
                "paramname": "Font"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "PrintFont(Font)"
    },
    "println": {
        "doc": "Prints a string on the current device, followed by a newline character. You should call this function only in a report. The output will be sent to the device or group of devices defined in the Reports database (in the output device field).",
        "example": "! Print \"Testvar\" followed by a new line.\nPrintLn(\"Value of Testvar=\"+Testvar:##.#);",
        "name": "PrintLn",
        "params": [
            {
                "paramdescription": "The string (data) to print.",
                "paramname": "String"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "PrintLn(String)"
    },
    "processanalystloadfile": {
        "doc": "Loads the specified PAV file to a Process Analyst object, which is identified by parameter ObjName.",
        "example": "No example found",
        "name": "ProcessAnalystLoadFile",
        "params": [
            {
                "paramdescription": "Name of the PAV file",
                "paramname": "sPAVFile"
            },
            {
                "paramdescription": "PAV file location code for the PAV file. Indicates which known location to load the file from.",
                "paramname": "iFileLocation"
            },
            {
                "paramdescription": "Bit mask for removing command buttons from the PA, bit flags as shown below:\n1 - Load View\n2 - Save View\n4 - Print\n8 - Copy to Clipboard\n16 - Copy to File\n32 - Add Pens\n64 - Remove Pens\n128 - Show Properties\n256 - Help",
                "paramname": "iButtonMask"
            },
            {
                "paramdescription": "Name of the PA object on the given Page where the PAV file will be loaded.",
                "paramname": "sObjName"
            }
        ],
        "returnType": "Zero (0) if the function is successfully run. otherwise an error code is returned.",
        "syntax": "ProcessAnalystLoadFile(sPAVFile, iFileLocation, iButtonMask, sObjName )"
    },
    "processanalystpopup": {
        "doc": "Displays a Process Analyst page (in a new page child window) at the current mouse position preloaded with the pre-defined Process Analyst View (PAV) file.",
        "example": "No example found",
        "name": "ProcessAnalystPopUp",
        "params": [
            {
                "paramdescription": "The name of the page that contains Process Analyst object(s). For example, pages based on the Process Analyst templates found in the Tab_Style_Include project.",
                "paramname": "sPage"
            },
            {
                "paramdescription": "Name of the PAV file",
                "paramname": "sPAVFile"
            },
            {
                "paramdescription": "PAV file location code for the PAV file, see PA doc LoadFromFile() for details.",
                "paramname": "iFileLocation"
            },
            {
                "paramdescription": "Bit mask for removing command buttons from the PA, bit flags as shown below:\n1 - Load View\n2 - Save View\n4 - Print\n8 - Copy to Clipboard\n16 - Copy to File\n32 - Add Pens\n64 - Remove Pens\n128 - Show Properties\n256 - Help",
                "paramname": "iButtonMask"
            },
            {
                "paramdescription": "Name of the PA object on the given Page where the PAV file will be loaded. If this parameter is not specified or empty string, it is defaulted to the object name used in the tab style templates, that is \"_templatePA1\".",
                "paramname": "sObjName"
            },
            {
                "paramdescription": "The mode of the window (see WinNewAt() for details).",
                "paramname": "iMode"
            }
        ],
        "returnType": "Window number if the window is successfully displayed. Otherwise -1 is returned.",
        "syntax": "ProcessAnalystPopup(sPage [, sPAVFile [, iFileLocation [, iButtonMask [, sObjName [, iMode ]]]]])"
    },
    "processanalystselect": {
        "doc": "Works like the existing Cicode Function TrnSelect(). It allows a set of pens to be selected before displaying the PA page. When PageProcessAnalystPens() is called after ProcessAnalystSelect(), the pens specified by both functions will be available in the final PA display. You can also repeat the call sequence of ProcessAnalystSelect() and ProcessAnalystSetPen() multiple times to set up multiple PA objects for the same page before displaying the page.",
        "example": "No example found",
        "name": "ProcessAnalystSelect",
        "params": [
            {
                "paramdescription": "The window number (returned from the WinNumber() function):\n-3 - for the current window\n-2 - For the next window displayed",
                "paramname": "iWindow"
            },
            {
                "paramdescription": "The name of the page that displays the PA.",
                "paramname": "sPage"
            },
            {
                "paramdescription": "The name of the PA object. If this is not specified, it is defaulted to \"_TemplatePA1\" which is the name used by the built-in templates.",
                "paramname": "sObjName"
            },
            {
                "paramdescription": "The name of the cluster that is associated with any trend tag for this PA. This is optional if you have one cluster or are resolving the trend via the current cluster context. The argument is enclosed in quotation marks \"\".",
                "paramname": "sClusterName"
            },
            {
                "paramdescription": "Bit mask for removing command buttons from the PA, bit flags as shown below:\n1 - Load View\n2 - Save View\n4 - Print\n8 - Copy to Clipboard\n16 - Copy to File\n32 - Add Pens\n64 - Remove Pens\n128 - Show Properties\n256 - Help",
                "paramname": "iButtonMask"
            },
            {
                "paramdescription": "Name of the PAV file",
                "paramname": "sPAVFile"
            },
            {
                "paramdescription": "PAV file location code for the PAV file, see PA doc LoadFromFile() for details.",
                "paramname": "iFileLocation"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "ProcessAnalystSelect((iWindow, sPage [, sObjName [, sClusterName [, iButtonMask [, sPAVFile [, iFileLocation]]]]]) )"
    },
    "processanalystsetpen": {
        "doc": "Works like the existing function TrnSetPen(). Allows a new pen to be added to a PA display. The pane defaults to the first pane of the PA if it is not specified.",
        "example": "No example found",
        "name": "ProcessAnalystSetPen",
        "params": [
            {
                "paramdescription": "Pen number. The allowed values are:\n<0 - new pen\n0 - the currently selected pen\nexisting pen number - change existing pen\n>existing pen number - new pen\nUp to 8 pens can be added to the PA using the Cicode function if ObjName is set to \"-2\".\nBe reminded that unlike trend objects, the pen numbers in Process Analyst are not fixed. They are dynamically reassigned when pens are added or deleted. When setting pens to the Process Analyst on the current display, pens are numbered within the scope of the pane they are in. On the other hand, when setting pens for the next display, pens are numbered in a flat scope regardless of pane number specified.",
                "paramname": "iPen"
            },
            {
                "paramdescription": "The trend tag name to be assigned to the pen.",
                "paramname": "sTag"
            },
            {
                "paramdescription": "The name of the PA object. If this is set to \"-2\", the pen is set to the next displayed PA page set up by ProcessAnalystSelect(). If the specified ObjName is valid, the changes will be applied to the currently displayed PA. Otherwise, the function will try to set the pen to the specified object on the currently displayed page. If this parameter is not specified or is an empty string, it will default to the object name used in the tab style templates, that is \"_templatePA1\".",
                "paramname": "sObjName"
            },
            {
                "paramdescription": "Optional number of the pane where the trend or variable tags are added. Please see the same parameter for function PageProcessAnalystPens() for details. Defaulted to 0, that is, the first pane.",
                "paramname": "iPane"
            },
            {
                "paramdescription": "Pen type for creation. The allowed values are:\n0 - Analog Trend (Default)\n1 - Digital Trend \n2 - Alarm\n0 (zero) if successful, otherwise an error code is returned.",
                "paramname": "iPenType"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "ProcessAnalystSetPen((iPen, sTag [, sObjName [, iPane [, iPenType]]]) )"
    },
    "processanalystwin": {
        "doc": "Displays a Process Analyst page (in a new window) preloaded with the pre-defined Process Analyst View (PAV) file.",
        "example": "No example found",
        "name": "ProcessAnalystWin",
        "params": [
            {
                "paramdescription": "The name of the page that contains Process Analyst object(s). For example, pages based on the Process Analyst templates found in the Tab_Style_Include project.",
                "paramname": "sPage"
            },
            {
                "paramdescription": "The X pixel coordinate",
                "paramname": "iX"
            },
            {
                "paramdescription": "The Y pixel coordinate",
                "paramname": "iY"
            },
            {
                "paramdescription": "The mode of the window (see WinNewAt() for details).",
                "paramname": "iMode"
            },
            {
                "paramdescription": "Name of the PAV file",
                "paramname": "sPAVFile"
            },
            {
                "paramdescription": "PAV file location code for the PAV file, see PA doc LoadFromFile() for details.",
                "paramname": "iFileLocation"
            },
            {
                "paramdescription": "Bit mask for removing command buttons from the PA, bit flags as shown below:\n1 - Load View\n2 - Save View\n4 - Print\n8 - Copy to Clipboard\n16 - Copy to File\n32 - Add Pens\n64 - Remove Pens\n128 - Show Properties\n256 - Help",
                "paramname": "iButtonMask"
            },
            {
                "paramdescription": "Name of the PA object on the given Page where the PAV file will be loaded. If this parameter is not specified or empty string, it is defaulted to the object name used in the tab style templates, that is \"_templatePA1\".",
                "paramname": "sObjName"
            }
        ],
        "returnType": "Window number if the window is successfully displayed. Otherwise -1 is returned.",
        "syntax": "ProcessAnalystWin(sPage, iX, iY, iMode [, sPAVFile [, iFileLocation [, iButtonMask [, sObjName ]]]])"
    },
    "processisclient": {
        "doc": "Determines if the currently executing process contains a Client component.",
        "example": "IF (ProcessIsClient()) THEN\n    SimulateLocalVariables();\nEND",
        "name": "ProcessIsClient",
        "params": [],
        "returnType": "TRUE (1) if the process contains a Client component, otherwise FALSE (0).",
        "syntax": "ProcessIsClient()"
    },
    "processisserver": {
        "doc": "Determines if the currently executing process contains a particular server component.",
        "example": "IF (ProcessIsServer(\"IOServer\", \"Cluster1\", \"IOServer3\")) THEN\n    SimulateDiskTags();\nEND",
        "name": "ProcessIsServer",
        "params": [
            {
                "paramdescription": "Case insensitive string specifying the type of server to check for. Supported values are \"IOServer\", \"Trend\", \"Alarm\" and \"Report\".",
                "paramname": "sServerType"
            },
            {
                "paramdescription": "Optional case insensitive string specifying the cluster name to combine with the server type specified in the first argument and the server name (if specified).",
                "paramname": "sClusterName"
            },
            {
                "paramdescription": "Optional case insensitive string specifying a server name to combine with the server type specified in the first argument and the cluster name (if specified).",
                "paramname": "sServerName"
            }
        ],
        "returnType": "TRUE (1) if the process contains the specified component, otherwise FALSE (0).",
        "syntax": "ProcessIsServer(sServerType [, sClusterName] [, sServerName])"
    },
    "processrestart": {
        "doc": "Restarts the current process in which Cicode is running.",
        "example": "ProcessRestart()",
        "name": "ProcessRestart",
        "params": [],
        "returnType": "0 (zero) if successful, otherwise the following error is returned:",
        "syntax": "INT error = ProcessRestart()"
    },
    "productinfo": {
        "doc": "Returns information about the Plant SCADA product.",
        "example": "No example found",
        "name": "ProductInfo",
        "params": [
            {
                "paramdescription": "Type of information required: \n0 - product name, default\n1 - product company\n2 - product major version\n3 - product minor version\n4 - product version string",
                "paramname": "iType"
            }
        ],
        "returnType": "The product information. An empty string will be returned if the type is invalid.",
        "syntax": "ProductInfo(iType)"
    },
    "projectinfo": {
        "doc": "Returns information about a particular project, which is identified by a project enumerated number.",
        "example": "INT hFile;",
        "name": "ProjectInfo",
        "params": [
            {
                "paramdescription": "Project number. This is a sequential number generated by the Compiler starting from 0,1,2,3,4,5.... to 1026, so the maximum include projects are limited to 1027.",
                "paramname": "iProject"
            },
            {
                "paramdescription": "Type of information to return:\n0 - Project name\n1 - Project description\n2 - Project major revision number\n3 - Project minor revision number\n4 - Project date\n5 - Project time",
                "paramname": "iType"
            }
        ],
        "returnType": "The specified project information. An empty string will be returned if the project number or type is invalid ",
        "syntax": "ProjectInfo(iProject, iType)"
    },
    "projectrestartget": {
        "doc": "Gets the path to the project to be run the next time Plant SCADA is restarted. (you need to have a project already set using either ProjectSet or ProjectRestartSet. Use this function with the Shutdown() function to shut down and then restart the project that is currently running.",
        "example": "No example found",
        "name": "ProjectRestartGet",
        "params": [],
        "returnType": "The path to the project to be run the next time Plant SCADA is restarted.",
        "syntax": "ProjectRestartGet()"
    },
    "projectrestartset": {
        "doc": "Sets the path to the project to be run the next time Plant SCADA is restarted.",
        "example": "No example found",
        "name": "ProjectRestartSet",
        "params": [
            {
                "paramdescription": " The path to the project. You need to use the full path, for example to specify the path to the project \"Demo\", use: \"C:\\Plant SCADA\\USER\\DEMO\".",
                "paramname": "sPath"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "ProjectRestartSet(sPath)"
    },
    "projectset": {
        "doc": "Sets either the name or the path of the project to be run next time Plant SCADA is restarted. The project path is written to the [CtEdit]Run parameter.",
        "example": "No example found",
        "name": "projectset",
        "params": [
            {
                "paramdescription": "The name of the project (for example \"DEMO\"), or the path to the project. If you specify the path to the project, you need to use the full path. If you do not specify a project, the current project will be used.",
                "paramname": "sProject"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "ProjectSet(sProject)"
    },
    "prompt": {
        "doc": "Displays a message in the prompt line (AN=2) on the operator's computer.",
        "example": "/* Display \"This is a prompt!\" at the prompt AN. */\nPrompt(\"This is a prompt!\");",
        "name": "Prompt",
        "params": [
            {
                "paramdescription": " The message to be displayed.",
                "paramname": "String"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "Prompt(String)"
    },
    "pulse": {
        "doc": "Pulses (jogs) a variable tag on, then off. The variable tag is switched ON (1) and two seconds later it is switched OFF (0). The exact period of the pulse is determined by the communication channel to the I/O device. If the communication channel is busy, the pulse time may be longer than two seconds. The code in the I/O device should not be dependant on a pulse time of exactly 2 seconds. Use the pulse as a trigger only.\nPulse(sTag)\nsTag: \n0 (zero) if successful, otherwise an error code is returned.",
        "example": "No example found",
        "name": "Pulse",
        "params": [
            {
                "paramdescription": " The digital tag to pulse.",
                "paramname": "sTag"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "Pulse(sTag)"
    },
    "qualitycreate": {
        "doc": "Creates a quality value based on the quality fields provided. When the value of a particular quality field is out of range, the value of its corresponding part in the returned quality remains at 0, and hardware error is generated.",
        "example": "QUALITY q1;\nq1 = QualityCreate(QUAL_BAD, QUAL_BAD_NON_SPECIFIC, QUAL_LIMITED_HIGH, QUAL_EXT_NOT_REPLICATED);",
        "name": "QualityCreate",
        "params": [
            {
                "paramdescription": "Specifies the general quality.",
                "paramname": "generalQuality"
            },
            {
                "paramdescription": "Specifies the quality substatus.",
                "paramname": "qualitySubstatus"
            },
            {
                "paramdescription": "TheQuality Limit.",
                "paramname": "qualityLimit"
            },
            {
                "paramdescription": "Specifies the extended quality substatus.",
                "paramname": "extendedSubstatus"
            },
            {
                "paramdescription": "Specifies the Tag Status Override Flag.",
                "paramname": "bOverride"
            },
            {
                "paramdescription": "Specifies the Tag Status Control Inhibit Flag.",
                "paramname": "bControlInhibit"
            },
            {
                "paramdescription": "Specifies the data source error code.\nFor further information on the quality arguments listed above, refer to the Tag Extensions documentation in the main help.",
                "paramname": "datasourceErrorCode"
            }
        ],
        "returnType": "The Quality value of the element.",
        "syntax": "QualityCreate(INT generalQuality [, INT qualitySubstatus [, INT qualityLimit [, INT extendedSubstatus [, INT bOverride [, bControlInhibit [, INT datasourceErrorCode ]]]]]] )"
    },
    "qualitygetpart": {
        "doc": "Extracts a requested part of the quality value from a variable tag's quality item.",
        "example": "INT qualityGeneral;\nqualityGeneral = QualityGetPart(Tag1.Field.Q, 0);",
        "name": "QualityGetPart",
        "params": [
            {
                "paramdescription": "Specifies the quality variable.",
                "paramname": "Quality"
            },
            {
                "paramdescription": "The part to extract:\n0 – The General Quality value\n1 – Quality Substatus value\n2 - The Quality Limit value \n3 - The Extended Quality Substatus value\n4 – The Tag Status Override flag \n5 – The Tag Status Control Inhibit flag\n 6 - The DataSource error code\n 7 – The OPC Quality (General + Substatus + Limit)",
                "paramname": "Part"
            }
        ],
        "returnType": "The value of the requested Quality part (see tables below), or -1 if error.",
        "syntax": "QualityGetPart(QUALITY Quality, INT Part)"
    },
    "qualityisbad": {
        "doc": "This function will return a value indicating whether the general part of quality is bad.",
        "example": "INT bad;\nbad = QualityIsBad(Tag1.Field.Q);",
        "name": "QualityIsBad",
        "params": [
            {
                "paramdescription": "Specifies the QUALITY variable.",
                "paramname": "quality"
            }
        ],
        "returnType": "0: the quality is not bad.\n",
        "syntax": "QualityIsBad(QUALITY quality)"
    },
    "qualityiscontrolinhibit": {
        "doc": "Returns a value indicating whether the tag is in Control Inhibit Mode.",
        "example": "INT controlInhibitEnabled;\ncontrolInhibitEnabled = QualityIsControlInhibit(Tag1.Field.Q);",
        "name": "QualityIsControlInhibit",
        "params": [
            {
                "paramdescription": "Specifies the QUALITY variable.",
                "paramname": "quality"
            }
        ],
        "returnType": "0: the tag is not in Control inhibit Mode.\n",
        "syntax": "QualityIsControlInhibit(QUALITY quality)"
    },
    "qualityisgood": {
        "doc": "This function will return a value indicating whether the general part of quality is good.",
        "example": "INT good;\ngood = QualityIsGood(Tag1.Field.Q);",
        "name": "QualityIsGood",
        "params": [
            {
                "paramdescription": "Specifies the QUALITY variable.",
                "paramname": "quality"
            }
        ],
        "returnType": "0: the quality is not good.\n",
        "syntax": "QualityIsGood(QUALITY quality)"
    },
    "qualityisoverride": {
        "doc": "Returns a value indicating whether the tag is in Override Mode.",
        "example": "INT overrideEnabled;\noverrideEnabled = QualityIsOverride(Tag1.Q);",
        "name": "QualityIsOverride",
        "params": [
            {
                "paramdescription": "Specifies the QUALITY variable.",
                "paramname": "quality"
            }
        ],
        "returnType": "0: the tag is not in Override Mode.\n",
        "syntax": "QualityIsOverrride(QUALITY quality)"
    },
    "qualityisuncertain": {
        "doc": "This function will return a value indicating whether the general part of quality is uncertain.",
        "example": "No example found",
        "name": "QualityIsUncertain",
        "params": [
            {
                "paramdescription": "Specifies the QUALITY variable.",
                "paramname": "quality"
            }
        ],
        "returnType": "0: the quality is not uncertain.\n",
        "syntax": "QualityIsUncertain(QUALITY quality)"
    },
    "qualitysetpart": {
        "doc": "Sets a Quality part’s value to the QUALITY variable. This function can only be used to manipulate the quality of Cicode variables. The quality item of a variable tag element (for example, 'Tag1.Field.Q') can only be used by QualityGetPart() as it is read only.",
        "example": "QUALITY q;\nINT qualityGeneral;\n// insert code here\nq = QualitySetPart(q, 0, qualityGeneral);",
        "name": "QualitySetPart",
        "params": [
            {
                "paramdescription": "Specifies the quality variable.",
                "paramname": "quality"
            },
            {
                "paramdescription": "The part to extract:\n0 – The General Quality value\n1 – Quality Substatus value\n2 - The Quality Limit value \n3 - The Extended Quality Substatus value\n4 – The Tag Status Override flag \n5 – The Tag Status Control Inhibit flag\n 6 - The DataSource error code\n 7 – The OPC Quality (General + Substatus + Limit)",
                "paramname": "part"
            },
            {
                "paramdescription": "The new value for the given part.",
                "paramname": "value"
            }
        ],
        "returnType": "The modified Quality value, or the original value if the given part is not applicable.",
        "syntax": "QualitySetPart(QUALITY quality, INT part, INT value)"
    },
    "qualitytostr": {
        "doc": "Returns a textual representation of the quality.",
        "example": "\tQUALITY q;;\n\tSTRING str;\n\tq = QualityCreate(QUAL_GOOD, 0, QUAL_LIMITED_NOT_LIMITED,\n\tQUAL_EXT_NON_SPECIFIC, 1, 1, 0);\n\tstr = QualityToStr(q, -1, 0);\n\t// The result is: Good [Override] [Control Inhibit]\n \n\tq = QualityCreate(QUAL_GOOD, QUAL_GOOD_LOCAL_OVERRIDE,\n\tQUAL_LIMITED_NOT_LIMITED, QUAL_EXT_NON_SPECIFIC);\n\tstr = QualityToStr(q, 1, 0);\n\t// The result is: Overriden\n \n\tq = QualityCreate(QUAL_GOOD, 0, QUAL_LIMITED_QL_LOW_LIMITED,\n\tQUAL_EXT_NON_SPECIFIC);\n\tstr = QualityToStr(q, 2, 0);\n\t// The result is: Below Low\n \n\tSetLanguage(\"FRENCH\");\n \n\tq = QualityCreate(QUAL_GOOD, 0, QUAL_LIMITED_NOT_LIMITED,\n\tQUAL_EXT_NON_SPECIFIC, 1, 1, 0);\n\tstr = QualityToStr(q, -1, 1);\n\t// The result is: Bon [Supplémenté] [Contrôle Inhibé]\n\t// Entries for ‘Bon’, ‘Supplémenté’ and ‘Contrôle Inhibé’\n\t// needs to have been provided in FRENCH.dbf\n \n\tSetLanguage(\"ENGLISH\");\n \n\tq = QualityCreate(QUAL_BAD, QUAL_BAD_CONFIGURATION_ERROR,\n\tQUAL_LIMITED_NOT_LIMITED, QUAL_EXT_NON_SPECIFIC);\n\tstr = QualityToStr(q, -1, 0);\n\t// The result is: Bad - Configuration Error\n \n\tSetLanguage(\"FRENCH\");\n \n\tq = QualityCreate(QUAL_BAD, QUAL_BAD_CONFIGURATION_ERROR,\n\tQUAL_LIMITED_NOT_LIMITED, QUAL_EXT_NON_SPECIFIC);\n\tstr = QualityToStr(q, -1, 1);\n\t// The result is: Mauvais - Erreur de Configuration\n \n\tSetLanguage(\"ENGLISH\");\n \n\tq = QualityCreate(QUAL_UNCR, QUAL_UNCR_NON_SPECIFIC,\n\tQUAL_LIMITED_NOT_LIMITED, QUAL_EXT_TAG_OUT_OF_RANGE);\n\tstr = QualityToStr(q, 0, 0);\n\t// The result is: Uncertain\n \n\tq = QualityCreate(QUAL_UNCR, QUAL_UNCR_NON_SPECIFIC,\n\tQUAL_LIMITED_NOT_LIMITED, QUAL_EXT_TAG_OUT_OF_RANGE);\n\tstr = QualityToStr(q, 3, 0);\n\t// The result is: Tag Address Out Of Range\n \n\tq = QualityCreate(QUAL_UNCR, QUAL_UNCR_SUBNORMAL,\n\tQUAL_LIMITED_NOT_LIMITED, QUAL_EXT_NON_SPECIFIC);\n\tstr = QualityToStr(q, 1, 0);\n\t// The result is: Subnormal\t\t\n\t\t\t\n\t\t\t",
        "name": "QualityToStr",
        "params": [
            {
                "paramdescription": "Specifies the QUALITY variable.",
                "paramname": "quality"
            },
            {
                "paramdescription": "Specifies the part of quality to obtain the textual representation.\n-2: Short representation in the format <General Quality> [– <Quality Substatus>]\n-1: Full representation in the format <General Quality> [Override] [Control Inhibit] – <Quality Substatus>\n0: <General Quality>\n1: <Quality Substatus>\n 2: <Quality Limit>\n3: <Extended Quality Substatus>\n 4: <Quality Override>\n5: <Control Inhibit>",
                "paramname": "part"
            },
            {
                "paramdescription": "The flag indicating if the returned text should be in native language or in Runtime localized language.",
                "paramname": "localized"
            }
        ],
        "returnType": "A textual representation of the quality, or an empty string if the part given is not applicable.",
        "syntax": "QualityToStr(QUALITY quality, INT part, INT localized)"
    },
    "queclose": {
        "doc": "Closes a queue opened with the QueOpen() function. All data is flushed from the queue.\nIf a Cicode task is waiting on the QueRead() function, it returns with a \"queue empty\" status. You should close all queues when they are no longer required, because they consume memory. At shutdown, Plant SCADA closes all open queues.",
        "example": "hQue=QueOpen(\"MyQue\",1);\n...\nQueClose(hQue);",
        "name": "QueClose",
        "params": [
            {
                "paramdescription": " The queue handle, returned from the QueOpen() function. The queue handle identifies the table where all data on the associated queue is stored.",
                "paramname": "hQue"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "QueClose(hQue)"
    },
    "quelength": {
        "doc": "Gets the current length of the queue.",
        "example": "Length=QueLength(hQue);",
        "name": "QueLength",
        "params": [
            {
                "paramdescription": "The queue handle, returned from the QueOpen() function. The queue handle identifies the table where all data on the associated queue is stored.",
                "paramname": "hQue"
            }
        ],
        "returnType": "The current length of the queue. If the queue is closed then 0 is returned.",
        "syntax": "QueLength(hQue)"
    },
    "queopen": {
        "doc": "Open a queue for reading and writing data elements. Use this function to create a new queue or open an existing queue. Use queues for sending data from one task to another or for other buffering operations.",
        "example": "! Create a queue.\nhQue=QueOpen(\"MyQue\",1);\n! Write data into the queue.\nQueWrite(hQue,1,\"Quetext\");\nQueWrite(hQue,1,\"Moretext\");\n! Read back data from the queue.\nQueRead(hQue,Type,Str,0);",
        "name": "QueOpen",
        "params": [
            {
                "paramdescription": " The name of the queue. You need to use the following syntax:",
                "paramname": "sName"
            },
            {
                "paramdescription": "Any following characters need to be either alpha characters (A-Z or a-z), digit characters (0 - 9), period characters (.), backslash characters (\\), or underscore characters (_).\nThe use of any other characters will result in the name being modified. ",
                "paramname": "Names need to begin with either an alpha character (A-Z or a-z) or the underscore character (_)."
            },
            {
                "paramdescription": " The mode of the queue open:\n0 - Open existing queue.\n1 - Create new queue.\n2 - Attempts to open an existing queue. If the queue does not exist, it will create it.\n4 - Create a queue that can have multiple blocked readers.",
                "paramname": "Mode"
            }
        ],
        "returnType": "The queue handle, or -1 if the queue cannot be opened. The queue handle identifies the table where all data on the associated queue is stored.",
        "syntax": "QueOpen(Name, Mode)"
    },
    "quepeek": {
        "doc": "Searches a queue for a queue element. You can search for the element by specifying a string, an integer, or both. You can remove the element from the queue by adding 8 to the Mode.",
        "example": "STRING Str;\nINT Type;\n! search for 'mystring' in queue, don't remove if found\nStr = \"mystring\";\nstatus=QuePeek(hQue,Type,Str,1);\nIF Status = 0 THEN\n    ! Now use found Type\n    ...\nEND",
        "name": "QuePeek",
        "params": [
            {
                "paramdescription": " The queue handle, returned from the QueOpen() function. The queue handle identifies the table where all data on the associated queue is stored.",
                "paramname": "hQue"
            },
            {
                "paramdescription": " The number to search for (if using the search mode for a matching number). If you are using a matching string mode, the number found is returned in Type. Must be a Long type variable. ",
                "paramname": "nType"
            },
            {
                "paramdescription": " The string to search for (if using the search mode for a matching string). If you are using a matching number mode, the string found is returned in Str. Must be a String type variable. ",
                "paramname": "Str"
            },
            {
                "paramdescription": " The mode of the search:\n1 - Search for a matching string.\n2 - Search for a matching number.\n4 - Search for a matching string and use a case-sensitive search.\n8 - If the element is found, remove it from the queue.\n16 Search the queue, in order, for the element at the offset specified by Type.\nUse mode 16 when you know the location of the element you want. For example if you set Type = 0, QuePeek will return the first element in the queue, type = 2, will return the 3rd element in the queue, etc. If you specify an offset which is greater than the length of the queue, the \"queue empty\" error (296) is returned.\nYou can extend the search by adding modes. For example, set Mode to 3 to search for a matching string and matching number, or set Mode to 11 to also remove the string and number from the queue.",
                "paramname": "Mode"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "QuePeek(hQue, Type, Str, Mode)"
    },
    "queread": {
        "doc": "Reads data from a queue, starting from the head of the queue. Data is returned in the same order as it was written onto the queue and is removed from the queue when read. If the Mode is 0 (non-blocking) and the queue is empty, the function returns with an error. If the Mode is 1 (blocking) the function does not return until another Cicode task writes data onto the queue.\nThis function is a blocking function. It will block the calling Cicode task until the operation is complete.",
        "example": "Status=QueRead(hQue,Type,Str,0);\nIF Status = 0 THEN\n\t! Now use Type and Str.\n\t...\nEND",
        "name": "QueRead",
        "params": [
            {
                "paramdescription": " The queue handle, returned from the QueOpen() function. The queue handle identifies the table where all data on the associated queue is stored.",
                "paramname": "hQue"
            },
            {
                "paramdescription": "The integer to read from the queue (written to the queue as Type by the QueWrite() function). Must be an Integer type variable.",
                "paramname": "nType"
            },
            {
                "paramdescription": "The string to read from the queue (written to the queue as Str by the QueWrite() function). Must be a String type variable.",
                "paramname": "Str"
            },
            {
                "paramdescription": " The mode of the read:\n0 - Non-blocking.\n1 - Wait for element.",
                "paramname": "Mode"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "QueRead(hQue, Type, Str, Mode)"
    },
    "quewrite": {
        "doc": "Writes an integer and string onto the end of a queue. The integer and string have no meaning to the queue system, they are just passed from QueWrite() to QueRead(). Queue data is written to the end of the queue. When the data is later read from the queue, it is returned on a first-in-first-out basis.\nThis function is a blocking function. It will block the calling Cicode task until the operation is complete.",
        "example": "QueWrite(hQue,2,\"Hello there\");\nQueWrite(hQue,4,\"Help\");",
        "name": "QueWrite",
        "params": [
            {
                "paramdescription": " The queue handle, returned from the QueOpen() function. The queue handle identifies the table where all data on the associated queue is stored.",
                "paramname": "hQue"
            },
            {
                "paramdescription": " The integer to put into the queue.",
                "paramname": "nType"
            },
            {
                "paramdescription": " The string to put into the queue.",
                "paramname": "Str"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "QueWrite(hQue, Type, Str)"
    },
    "radtodeg": {
        "doc": "Converts an angle from radians to degrees.",
        "example": "Variable=RadToDeg(Pi());\n! Sets Variable to 180.",
        "name": "RadToDeg",
        "params": [
            {
                "paramdescription": "Any angle (in degrees).",
                "paramname": "Angle"
            }
        ],
        "returnType": "The angle in degrees.",
        "syntax": "RadToDeg(Angle)"
    },
    "rand": {
        "doc": "Generates a random number between 0 and a specified maximum number less one.\nThe Rand function is zero-based, so the resultant number generated will range from zero to one less than the number provided in the Maximum argument.",
        "example": "Variable=Rand(101);\n! Sets Variable to a random number from 0 to 100.\n// To create a random number between 0 and 1 with 2 decimal places, \ndivide the above variable by 100, as shown here: //\nVariable = Variable/100;",
        "name": "Rand",
        "params": [
            {
                "paramdescription": "The maximum number. This number needs to be between 2 and 32767 (inclusive).",
                "paramname": "Maximum"
            }
        ],
        "returnType": "A random number of integer type.",
        "syntax": "Rand(Maximum)"
    },
    "realtostr": {
        "doc": "Converts a floating-point number into a string.",
        "example": "Variable=RealToStr(12.345,10,1);\n! Sets Variable to \"      12.3\" (10 characters long).",
        "name": "RealToStr",
        "params": [
            {
                "paramdescription": "The floating-point number to convert.",
                "paramname": "Number"
            },
            {
                "paramdescription": "The width of the string.",
                "paramname": "Width"
            },
            {
                "paramdescription": "The number of decimal places contained in the string.",
                "paramname": "Places"
            },
            {
                "paramdescription": "Optionally, the decimal separator contained in the string. Defaults to empty string.\n\".\" - period\n\",\" - comma\n\"\" - empty string\nIf an empty string or an invalid separator is passed as a parameter, the string will contain the decimal separator used in the current locale. ",
                "paramname": "Separator"
            }
        ],
        "returnType": "The floating-point number (as a string).",
        "syntax": "RealToStr(Number, Width, Places[, Separator])"
    },
    "repgetcluster": {
        "doc": "This function retrieves the name of the cluster a report is running on. This function should only be called from a report file.",
        "example": "No example found",
        "name": "RepGetCluster",
        "params": [],
        "returnType": "The name of the cluster the report in running on.",
        "syntax": "RepGetCluster()"
    },
    "repgetcontrol": {
        "doc": "Gets report control information on a report. This function is a blocking function. It will block the calling Cicode task until the operation is complete.",
        "example": "Next=RepGetControl(\"SHIFT\",1,\"ClusterXYZ\");\n! Sets Next to the time that the report is due to run.\n! Display a message at the prompt AN (AN2) if \n! the report is running.\nIF RepGetControl(\"SHIFT\",0,\"ClusterXYZ\")=3 THEN\n    Prompt(\"Shift report is running\");\nEND",
        "name": "RepGetControl",
        "params": [
            {
                "paramdescription": "The name of the report (can be prefixed by the name of the cluster that is ClusterName.ReportName).",
                "paramname": "ReportName"
            },
            {
                "paramdescription": "The type of report control information to get (send back in the return value):\n0 - State of the report - returns one of:\n0 -Idle\n1 - Waiting for PLC data for trigger\n2 - Waiting for PLC data\n3 - Running\n1 - Time of day that the report is due to run next.\n2 - The report period, in seconds, or week day, month or year, for example, if the report is weekly, this is the day of the week, 0 (Sunday) to 6 (Saturday).\n3 - Synchronisation time of day of the report, for example, 10:00:00 (In seconds from midnight).\n4 - Type of report schedule - returns one of:\n0 - Event triggered\n1 - Daily\n2 - Weekly\n3 - Monthly\n4 - Yearly\n5 - Report state - returns one of:\n0 - Enabled\n1 - Disabled",
                "paramname": "nType"
            },
            {
                "paramdescription": "Name of the cluster in which the report resides. This is optional if you have one cluster or are resolving the report server via the current cluster context. The argument is enclosed in quotation marks \"\".",
                "paramname": "sClusterName"
            }
        ],
        "returnType": "The control information, as an integer.",
        "syntax": "RepGetControl(ReportName, Type [, sClusterName])"
    },
    "report": {
        "doc": "Runs a report on the Report Server. This function only schedules the report for execution. The running of the report is controlled entirely by the Report Server.\nThis function will start the specified report on the Reports Server to which the Plant SCADA computer is communicating. If you are using the Reports Servers in Primary/Standby mode, the report can run on the Standby Server. If you call this function on the Standby Server then the report will definitely run on the Standby Server, even if the Primary Server is active.\nThis function is a blocking function. It will block the calling Cicode task until the operation is complete.",
        "example": "Report(\"SHIFT\",\"ClusterXYZ\");\n! Runs the report named \"SHIFT\".\nReport(\"DAY\",\"ClusterXYZ\");\n! Runs the report named \"DAY\".\n/* The \"SHIFT\" and \"DAY\" reports are started. The order in which \nthe reports are run cannot be determined. If you want the \"DAY\" \nreport to run after the \"SHIFT\" report, call Report(\"DAY\") at the \nend of the \"SHIFT\" report. */",
        "name": "Report",
        "params": [
            {
                "paramdescription": " The name of the report to run (can be prefixed by the name of the cluster that is ClusterName.ReportName).",
                "paramname": "ReportName"
            },
            {
                "paramdescription": "Name of the cluster in which the report resides. This is optional if you have one cluster or are resolving the report server via the current cluster context. The argument is enclosed in quotation marks \"\".",
                "paramname": "sClusterName"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "Report(ReportName [, sClusterName] )"
    },
    "repsetcontrol": {
        "doc": "Sets report control information to temporarily override the normal settings for a specified report. You can change the report schedule for a periodic report, and run one-time or event-triggered reports. These new settings are set on both the primary and standby report servers, but are not saved to the database. When you restart your system, Plant SCADA uses the existing settings, defined in the Reports database.\nYou might need to call this function several times. For example, to change an event-triggered report to run at 6 hourly intervals, you need to change the schedule (Type 4), synchronization time (Type 3), and period (Type 2). If you use incompatible values for these options, you can get unpredictable results. To change more than one option, disable the report, set the options, and then re-enable the report.\nThis function is a blocking function. It will block the calling Cicode task until the operation is complete.",
        "example": "RepSetControl(\"Shift\",1,TimeCurrent()+60,\"ClusterXYZ\");\nRepSetControl(\"Weekly\", 5, 1,\"ClusterXYZ\");        ! disable report\nRepSetControl(\"Weekly\", 4, 1,\"ClusterXYZ\");        ! change mode to daily\nRepSetControl(\"Weekly\", 3, 7 * 60 * 60,\"ClusterXYZ\"); ! sync at 7:00:00 am\nRepSetControl(\"Weekly\", 2, 8 * 60 * 60,\"ClusterXYZ\"); ! run every 8 hours\nRepSetControl(\"Weekly\", 5, 0,\"ClusterXYZ\");        ! enable report\nRepSetControl(\"Yearly\", 5, 1,\"ClusterXYZ\");        ! disable report\nRepSetControl(\"Yearly\", 4, 4,\"ClusterXYZ\");        ! change mode to yearly\nRepSetControl(\"Yearly\", 3, 7 * 60 * 60,\"ClusterXYZ\"); ! sync at 7:00:00 am\nRepSetControl(\"Yearly\", 2, 31 + 28 + 10,\"ClusterXYZ\"); ! run on March 10th\nRepSetControl(\"Yearly\", 5, 0,\"ClusterXYZ\");        ! enable report",
        "name": "RepSetControl",
        "params": [
            {
                "paramdescription": " The name of the report (can be prefixed by the name of thecluster that is ClusterName.ReportName).",
                "paramname": "ReportName"
            },
            {
                "paramdescription": " The type of report control information to set:\n1 - The time of day at which to run the next report in Cicode (date/time) variable type. Subsequent reports are run at the times calculated from the period (Type 2) and synchronisation time (Type 3). Use Type 1 to specify a one-time report. Set the time in Data in seconds from midnight (for example, specify 6 p.m. as TimeMidNight() + (18 * 60 * 60) ).\n2 - The report period. Set the new period in Data according to the report schedule (Type 4), in seconds from midnight, day of week (0 to 6, Sunday = 0), month (1 to 12), or year.\nFor a daily report schedule, set the report frequency in Data in seconds from midnight; for example, set Data to 6 * 60 * 60 for a 6 hourly shift report. If the report is weekly, set Data to the day of the week, for example, when Data = 2, the day is Tuesday.\n3 - Synchronisation time of day of the report. Set the time in Data in seconds from midnight, for example, to synchronize at 10a.m., set Data to 10 * 60 * 60.\n4 - Type of report schedule. Set Data to one of the following:\n0 - Event triggered\n1 - Daily\n2 - Weekly\n3 - Monthly\n4 - Yearly\n5 - Report state. Set Data to either:\n0 - Enabled\n1 - Disabled",
                "paramname": "nType"
            },
            {
                "paramdescription": " The new data value, dependent on the Type.",
                "paramname": "Data"
            },
            {
                "paramdescription": "Name of the cluster in which the report resides. This isoptional if you have one cluster or are resolving the reportserver via the current cluster context. The argument isenclosed in quotation marks \"\".",
                "paramname": "sClusterName"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "RepSetControl(ReportName, Type, Data [, sClusterName] )"
    },
    "reread": {
        "doc": "ReRead is deprecated in this version of Plant SCADA.\nTags are now subscribed at the start of a function and updated tag values are sent to the subscribing function. Tag subscriptions are made at the update rate of:\nYou will want to verify that the subscription update rate matches the requirements of your system.\nAfter removing ReRead from looping code you may need to extend the period of the Sleep function. This is to replace the pause ReRead created while it read all the tag values.",
        "example": "No example found",
        "name": "ReRead",
        "params": [
            {
                "paramdescription": "The mode of the read:\n0 - Read only if data is stale.\n1 - Read anyway.",
                "paramname": "Mode"
            }
        ],
        "returnType": "No value (void).",
        "syntax": "ReRead(Mode)"
    },
    "resetscreenprofile": {
        "doc": "Returns all top level windows back to their original screen starting position as defined by the screen profile in a multi-monitor setup.",
        "example": "ResetScreenProfile();",
        "name": "ResetScreenProfile",
        "params": [],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "ResetScreenProfile()"
    },
    "round": {
        "doc": "Rounds a number to a specified number of decimal places.",
        "example": "No example found",
        "name": "Round",
        "params": [
            {
                "paramdescription": "The floating-point number to round.",
                "paramname": "Number"
            },
            {
                "paramdescription": "The number of decimal places.",
                "paramname": "Places"
            }
        ],
        "returnType": "The number rounded to Places decimal places.",
        "syntax": "Round(Number, Places)"
    },
    "schdclose": {
        "doc": "The SchdClose function terminates a browsing session and cleans up the resources used by the session. ",
        "example": "No example found",
        "name": "SchdClose",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by theSchdOpen call",
                "paramname": "Session"
            }
        ],
        "returnType": "0 (zero) if the browsing session exists, otherwise an error code is returned.",
        "syntax": "INT SchdClose(LONG Session)"
    },
    "schdconfigclose": {
        "doc": "The SchdConfigClose function terminates a browsing session and cleans up the resources used by the session. ",
        "example": "No example found",
        "name": "SchdConfigClose",
        "params": [
            {
                "paramdescription": "",
                "paramname": "Session"
            },
            {
                "paramdescription": "",
                "paramname": "0 (zero) if the browsing session exists, otherwise an error code is returned."
            }
        ],
        "returnType": "0 (zero) if the browsing session exists, otherwise an error code is returned.",
        "syntax": "INT SchdConfigClose(LONG Session )"
    },
    "schdconfigfirst": {
        "doc": "The SchdConfigFirst function places the data browse cursor at the first record. \nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "SchdConfigFirst",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by theSchdConfigOpen call.",
                "paramname": "Session"
            }
        ],
        "returnType": "0 (zero) if the browsing session exists, otherwise an error code is returned.",
        "syntax": "INT SchdConfigFirst(LONG Session)"
    },
    "schdconfiggetfield": {
        "doc": "The SchdConfigGetField function returns the value of the particular field in a record to which the data browse cursor is currently referencing.  ",
        "example": "No example found",
        "name": "SchdConfigGetField",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by theSchdConfigOpen call.",
                "paramname": "Session"
            },
            {
                "paramdescription": "A field to retrieve. Refer to ScheduleConfigOpen for detailed list of fields.",
                "paramname": "field"
            }
        ],
        "returnType": "The value of the specified field as a string. An empty string may or may not be an indication that an error has been detected. The last error should be checked in this instance to determine if an error has actually occurred.",
        "syntax": "STRING SchdConfigGetField(LONG Session, STRING Field )"
    },
    "schdconfignext": {
        "doc": "The SchdConfigNext function places the data browse cursor at the next available record.  This function will return an error if called when the data cursor is at end of the records.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "SchdConfigNext",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by theSchdConfigOpen call.",
                "paramname": "Session"
            }
        ],
        "returnType": "0 (zero) if the browsing session exists, otherwise an error code is returned.",
        "syntax": "INT SchdConfigNext(LONG Session)"
    },
    "schdconfignumrecords": {
        "doc": "The SchdConfigNumRecords function returns the number of records that match the current filter criteria. This function uses iSession as an argument which is previously returned by the SchdConfigOpen function.",
        "example": "No example found",
        "name": "SchdConfigNumRecords",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by theSchdConfigOpen call",
                "paramname": "Session"
            }
        ],
        "returnType": "Returns number of records. 0 means no records were found.",
        "syntax": "LONG SchdConfigNumRecords(LONG Session)"
    },
    "schdconfigopen": {
        "doc": "The SchdConfigOpen function initiates a new session for browsing the schedules configured. It returns a handle for the browsing session which can be used for further browsing operations.",
        "example": "\t\t\ntsConfigtimeBrowseStartTime = TimestampCreate(2011, 11, 20, 0, 0, 0, 0);\niConfigtimeSession = SchdConfigOpen(tsConfigtimeBrowseStartTime, 86400, \"Id=1\",\n\"\", \"Cluster1\");\nIF iConfigtimeSession = -1 THEN\n   prompt(\"Could not open a schedule configtime browse session\");\nEND\t\t\t\t",
        "name": "SchdConfigOpen",
        "params": [
            {
                "paramdescription": "The start date of the schedules in UTC time to return during the browse.If not specified, today at midnight will be taken as start time. The types of this field is TIMESTAMP. Use StrToTimestamp or TimestampCreate cicode functions to create a TIMESTAMP type.",
                "paramname": "start"
            },
            {
                "paramdescription": "The duration of the browse in seconds. The default is 86400 seconds(24 hour)",
                "paramname": "Duration"
            },
            {
                "paramdescription": "A filter expression specifying the records to return during the browse. An empty string indicates that every record will be returned.\n All string fields can be filtered based on regular expressions. Using an operator other than = will cause strings to not match the filter criteria. The following regular expressions are supported *expr, expr*, and *expr*.",
                "paramname": "Filter"
            },
            {
                "paramdescription": "Specifies via a comma delimited string the columns to be returned during the browse. An empty string indicates that the server will return every available column. \nSupported fields are:\nID:\n The unique ID of the schedule within the schedule engine. ID value is the same for all recurring schedules. \nEQUIPMENT: \nThe equipment name\nSTATE: \nThe state of the schedule",
                "paramname": "Fields"
            },
            {
                "paramdescription": " The start time of the schedule.\nOCCURRENCESTART:\nThe start of this occurrence. For non-recurring entries will be the same as START.\nEND:\n The end time of the schedule.\nOCCURRENCEEND: \nThe end of this occurrence. For non-recurring entries will be the same as END.\nDESC: \nThe description of the schedule.\nMODIFIEDTIME:\n The time when the entry was modified last time.\nNote: Time values (START, OCCURRENCESTART, END, OCCURRENCEEND, MODIFIEDTIME) are TIMESTAMP type. Use TimestampToStr() cicode function to convert it to string.\nThe following fields are used when a schedule is recurrent. The value of FREQ filed -1 means the schedule is not recurrent:\nFREQ: \nThe type of the recurrence: 4 - daily, 5 - weekly, 6- monthly, 7 - yearly, 8 - special days. -1 means this schedule is non-recurring.\nINTERVAL:\n The interval of the recurrence. 1 - every 1 day/week/month etc., 2 - every second day/week/month etc. and so on.\nWEEKDAY:\n The first day of the week\nWEEKDAYMASK: \n The day of week mask. Defines day of week where recurrence happens.\nNone = 0,\nSunday = 1,\nMonday = 2,\nTuesday = 4,\nWednesday = 8,\nThursday = 16,\nFriday = 32,\nSaturday = 64,\nEveryday = 127,\nWeekdays = 62,\nWeekenddays = 65\nCombination of days can be achieved by addition. For example, Tuesdays and Wednesdays would be 12 (4 + 8).\nMAXREC:\n The maximum number recurrences (-1 means MAXREC is not specified. If MAXREC is -1 then the recurrence stops on the date specified by RECUNTIL field. If RECUNTIL is not specified the recurrence occurs forever).\nRECUNTIL: \nThe time until recurrence occurs. -1 means never stops (or finishes after MAXREC occurrences if is specified).\nDAYORD: Day ordinal. Applicable for monthly and yearly recurrence patterns. Using the values 1 to 4 you can set the schedule to run on the first, second, third, or fourth occurrence of the DAY in each month (monthly recurrences), or the specified MONTH (yearly recurrences). Use the value -1 for the last week of the month\nDAY: \nThe day of month\nMONTH: \n The month of the year\nSPECIALINC: \nDefined whether the special day is included in the pattern. 0 - none, 1 - all, 2 - selected.\nGROUPIDS\n A list of group’s ID included in the recurring pattern (used only when SPECIALINC is defined as 2 (\"selected\")).",
                "paramname": "START"
            },
            {
                "paramdescription": "An optional parameter that specifies via a comma delimited string the subset of the clusters to browse. An empty string indicates that the connected clusters will be browsed.\nReturns an integer handle to the browse session. Returns -1 when an error is detected.",
                "paramname": "sClusters"
            },
            {
                "paramdescription": "",
                "paramname": ""
            }
        ],
        "returnType": "Returns an integer handle to the browse session. Returns -1 when an error is detected.",
        "syntax": "LONG SchdConfigOpen([TIMESTAMP Start] [, LONG Duration] [, STRING Filter] [, STRING Fields] [, STRING Clusters] )"
    },
    "schdconfigprev": {
        "doc": "The SchdConfigPrev function places the data browse cursor at the previous record.  This function will return an error if called when the data cursor is at beginning of the records.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "SchdConfigPrev",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by theSchdConfigOpen call",
                "paramname": "Session"
            }
        ],
        "returnType": "0 (zero) if the browsing session exists, otherwise an error code is returned.",
        "syntax": "INT SchdConfigPrev(LONG Session)"
    },
    "schdfirst": {
        "doc": "The SchdFirst function places the data browse cursor at the first record. \nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "SchdFirst",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by theSchdOpen call.",
                "paramname": "Session"
            }
        ],
        "returnType": "0 (zero) if the browsing session exists, otherwise an error code is returned.",
        "syntax": "INT SchdFirst(LONG Session)"
    },
    "schdgetfield": {
        "doc": "The SchdGetField function returns the value of the particular field in a record to which the data browse cursor is currently referencing. ",
        "example": "No example found",
        "name": "SchdGetField",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by theSchdOpen call.",
                "paramname": "Session"
            },
            {
                "paramdescription": "Specifies via a comma delimited string the columns to be returned during the browse. An empty string indicates that the server will return every available column. See SchdOpen for supported fields.",
                "paramname": "Field"
            }
        ],
        "returnType": "The value of the specified field as a string. An empty string may or may not be an indication that an error has been detected. The last error should be checked in this instance to determine if an error has actually occurred.",
        "syntax": "STRING SchdGetField(LONG Session, STRING Field)"
    },
    "schdnext": {
        "doc": "The SchdNext function places the data browse cursor at the next available record. This function will return an error if called when the data cursor is at end of the records.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "SchdNext",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by the SchdOpen call.",
                "paramname": "Session"
            }
        ],
        "returnType": "0 (zero) if the browsing session exists, otherwise an error code is returned.",
        "syntax": "INT SchdNext(LONG Session)"
    },
    "schdnumrecords": {
        "doc": "The SchdNumRecords function returns the number of records that matchthe current filter criteria. ",
        "example": "No example found",
        "name": "SchdNumRecords",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by theSchdOpen call.",
                "paramname": "Session"
            }
        ],
        "returnType": "The number of records that have matched the filter criteria. A value of 0 denotes that no records have matched. A value of -1 denotes that the browse session is unable to provide a fixed number. This may be the case if the data being browsed changed during the browse session.",
        "syntax": "LONG SchdNumRecords(LONG Session)"
    },
    "schdopen": {
        "doc": "The SchdOpen function initiates a new session for browsing the runtime schedules. It returns a handle for the browsing session which can be used for further browsing operations.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "\ttsRuntimeBwseStartTime = TimestampCreate(2011, 11, 20, 0, 0, 0, 0);\n\tiRuntimeSession = SchdOpen(\"MyEquipment1\", tsRuntimeBrowseStartTime, 86400,\n\t\"state=ON\", \"\", \"Cluster1\");\n\tIF iRuntimeSession = -1 THEN\n\t\tprompt(\"Could not open a schedule runtime browse session\");\n\tEND\t\n\t\t",
        "name": "SchdOpen",
        "params": [
            {
                "paramdescription": "The name of the equipment to browse.",
                "paramname": "Equipment"
            },
            {
                "paramdescription": "The start date of the schedules. If not specified, today at midnight will be taken as the start time. The types of this field is TIMESTAMP. Use StrToTimestamp or TimestampCreate Cicode functions to create a TIMESTAMP type.",
                "paramname": "Start"
            },
            {
                "paramdescription": "The duration of the browse in seconds. The default is 86400 seconds(24 hour)",
                "paramname": "Duration"
            },
            {
                "paramdescription": "A filter expression specifying the records to return during the browse. An empty string indicates that every record will be returned.",
                "paramname": "Filter"
            },
            {
                "paramdescription": "Specifies via a comma delimited string the columns to be returned during the browse. An empty string indicates that the server will return every available column. Supported fields are:",
                "paramname": "Fields"
            },
            {
                "paramdescription": "STATE: The state to be set by the schedule",
                "paramname": "EQUIPMENT: The equipment name"
            },
            {
                "paramdescription": "END: The end time of the schedule. The time is returned as a Timestamp value. Use StrToTimestamp() to get a TIMESTAMP data value.\nINHERITED: Indicates if the schedule entry is inherited from a schedule defined in a parent equipment higher in the hierarchy.\nDESC: The description of the schedule.",
                "paramname": "START: The start time of the schedule. The time is returned as a Timestamp value. Use StrToTimestamp() to get a TIMESTAMP data value."
            },
            {
                "paramdescription": "An optional parameter that specifies via a comma delimited string the subset of the clusters to browse. An empty string indicates that the connected clusters will be browsed.",
                "paramname": "Clusters"
            }
        ],
        "returnType": "Returns an integer handle to the browse session. Returns -1 when an error is detected.",
        "syntax": "LONG SchdOpen(STRING Equipment[, TIMESTAMP Start] [,LONG Duration] [,STRING Filter] [,STRING Fields] [, STRING Clusters] )"
    },
    "schdprev": {
        "doc": "The SchdPrev function places the data browse cursor at the previous record.  This function will return an error if called when the data cursor is at beginning of the records.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "SchdPrev",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by theSchdOpen call.",
                "paramname": "Session"
            }
        ],
        "returnType": "0 (zero) if the browsing session exists, otherwise an error code is returned.",
        "syntax": "INT SchdPrev(LONG Session)"
    },
    "schdspecialadd": {
        "doc": "The SchdSpecialAdd adds a new Special Day Group to the scheduler engine.  \nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.\n",
        "example": "No example found",
        "name": "SchdSpecialAdd",
        "params": [
            {
                "paramdescription": "The name of the cluster",
                "paramname": "Cluster"
            },
            {
                "paramdescription": "",
                "paramname": "Name"
            },
            {
                "paramdescription": "",
                "paramname": "Name of the special day group"
            }
        ],
        "returnType": "Returns the Id of the Special Day Group which can be used for modifying and deleting this Special Day Group. Returns the ID for an existing Special Day group. This function returns -1 if, unsuccessful. Trap the error to get the error returned by this function. ",
        "syntax": "LONG SchdSpecialAdd(STRING Cluster, STRING Name)"
    },
    "schdspecialclose": {
        "doc": "The SchdSpecialClose function terminates a browsing session and cleans up the resources used by the session. This function uses iSession as the argument which is previously returned by the SchdSpecialOpen function.",
        "example": "No example found",
        "name": "SchdSpecialClose",
        "params": [
            {
                "paramdescription": "",
                "paramname": "Session"
            },
            {
                "paramdescription": "",
                "paramname": "0 (zero) if the browsing session exists, otherwise an error code is returned."
            },
            {
                "paramdescription": "",
                "paramname": ""
            }
        ],
        "returnType": "0 (zero) if the browsing session exists, otherwise an error code is returned.",
        "syntax": "INT SchdSpecialClose(LONG Session)"
    },
    "schdspecialdelete": {
        "doc": "The SchdSpecialDelete function deletes an existing special day group.",
        "example": "No example found",
        "name": "SchdSpecialDelete",
        "params": [
            {
                "paramdescription": "Name of the Cluster",
                "paramname": "Cluster"
            },
            {
                "paramdescription": "Special day group ID",
                "paramname": "ID"
            }
        ],
        "returnType": "Returns 0 if successful otherwise it returns an error.",
        "syntax": "LONG SchdSpecialDelete(STRING Cluster, LONG ID)"
    },
    "schdspecialfirst": {
        "doc": "The SchdSpecialFirst function places the data browse cursor at the first record. This function uses iSession as the argument which is previously returned by the SchdSpecialOpen function.           \nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "SchdSpecialFirst",
        "params": [
            {
                "paramdescription": "Current special day group browsing session obtained by SchdSpecialOpen",
                "paramname": "Session"
            }
        ],
        "returnType": "0 (zero) if the browsing session exists, otherwise an error code is returned.",
        "syntax": "INT SchdSpecialFirst(LONG Session)"
    },
    "schdspecialgetfield": {
        "doc": "The SchdSpecialGetField function returns the value of a particular field from the record currently referenced by the data browse cursor. This function uses iSession as an argument which is previously returned by the SchdSpecialOpen function and the field name of the value to be returned.       ",
        "example": "No example found",
        "name": "SchdSpecialGetField",
        "params": [
            {
                "paramdescription": " Current special day group browsing session obtained by SchdSpecialOpen",
                "paramname": "Session"
            },
            {
                "paramdescription": "Specifies via a comma delimited string the columns to be returned during the browse. An empty string indicates that the server will return every available column. Supported fields are:",
                "paramname": "Field"
            }
        ],
        "returnType": "The value of the specified field as a string. An empty string may or may not be an indication that an error has been detected. The last error should be checked in this instance to determine if an error has actually occurred.",
        "syntax": "STRING SchdSpecialItemGetField(LONG Session, STRING Field)"
    },
    "schdspecialitemadd": {
        "doc": "The SchdSpecialItemAdd function adds a new Special Day to the scheduler engine. It returns the ID of the Special Day which can be used for modifying and deleting the Special Day. \nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "\tTIMESTAMP tsDate = TimestampCreate(2012,1,2,0,0,0);\n\n\t// Add the new special day\n\tnCatID = SchdSpecialAdd(STRING Cluster, sCategory);\n\tIF (nCatID > -1) THEN\n\t\tnSchdID = SchdSpecialItemAdd(STRING Cluster, nCatID, sLabel, tsDate);\n\t\tIF (nSchdID > -1) THEN\n\t\t\t// Use the new schedule special day item\n\t\tEND\n\tEND ",
        "name": "SchdSpecialItemAdd",
        "params": [
            {
                "paramdescription": "",
                "paramname": "Cluster"
            },
            {
                "paramdescription": "",
                "paramname": "Name of the Cluster"
            },
            {
                "paramdescription": "Special day group ID",
                "paramname": "GroupID"
            },
            {
                "paramdescription": "",
                "paramname": "Name"
            },
            {
                "paramdescription": "",
                "paramname": "Name of special day"
            },
            {
                "paramdescription": "The special day as a timestamp. Use TimestampCreate or StrToTimestamp Cicode functions to get a timestamp data value.",
                "paramname": "Day"
            }
        ],
        "returnType": "Returns the ID for an existing special day or -1 if unsuccessful. Trap the error to get the error returned by this function.",
        "syntax": "LONG SchdSpecialItemAdd(STRING Cluster, LONG GroupID, STRING Name, TIMESTAMP Day)"
    },
    "schdspecialitemaddrange": {
        "doc": "The SchdSpecialItemAddRange function adds a range of special days in the specified special day group (category).\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "// Add the special day range for group id 1\n// 2018-05-06 : 2018-05-10 \n\nSchdSpecialItemAddRange(\"Cluster1\", 1,\nTimestampCreate(2018,5,6,0,0,0,0,0), TimestampCreate(2018,5,10,0,0,0,0,0);",
        "name": "SchdSpecialItemAddRange",
        "params": [
            {
                "paramdescription": "The name of the cluster.",
                "paramname": "Cluster"
            },
            {
                "paramdescription": "The ID of the special day group.",
                "paramname": "GroupID"
            },
            {
                "paramdescription": "The first day of the special day range as a timestamp. Use TimestampCreate or StrToTimestamp Cicode functions to get a timestamp data value. When creating a timestamp, please use midnight of the required day.",
                "paramname": "FirstDay"
            },
            {
                "paramdescription": "",
                "paramname": "LastDay"
            },
            {
                "paramdescription": "",
                "paramname": "Last day (inclusive) of the special day range as a timestamp. Use TimestampCreate or StrToTimestamp Cicode functions to get a timestamp data value. When creating a timestamp, please use midnight of the required day."
            }
        ],
        "returnType": "0 if successful, otherwise an error code is returned.",
        "syntax": "INT SchdSpecialItemAddRange(STRING Cluster, STRING GroupID, TIMESTAMP FirstDay, TIMESTAMP LastDay)"
    },
    "schdspecialitemclose": {
        "doc": "This function terminates a browsing session and cleans up the resources used by the session. This function uses iSession as the argument which is previously returned by the SchdSpecialItemOpen function. ",
        "example": "No example found",
        "name": "SchdSpecialItemClose",
        "params": [
            {
                "paramdescription": "Current schedule special item browsing session obtained by SchdSpecialItemOpen",
                "paramname": "Session"
            }
        ],
        "returnType": "0 (zero) if the browsing session exists, otherwise an error code is returned.",
        "syntax": "INT SchdSpecialItemClose(LONG Session)"
    },
    "schdspecialitemdelete": {
        "doc": "This function deletes an existing Special Day. \nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "SchdSpecialItemDelete",
        "params": [
            {
                "paramdescription": "Name of the cluster\nSpecial day ID",
                "paramname": "Cluster"
            }
        ],
        "returnType": "This function returns 0 if successful otherwise it returns an error.",
        "syntax": "LONG SchdSpecialItemDelete(STRING Cluster, LONG ID)"
    },
    "schdspecialitemdeleterange": {
        "doc": "The SchdSpecialItemDeleteRange function removes a range of special days in a specified special day group (category).\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "// Delete the following special day range for group id 1\n// 2018-05-06 : 2018-05-10 \n\nSchdSpecialItemDeleteRange(\"Cluster1\", 1,\nTimestampCreate(2018,5,6,0,0,0,0,0), TimestampCreate(2018,5,10,0,0,0,0,0);",
        "name": "SchdSpecialItemDeleteRange",
        "params": [
            {
                "paramdescription": "The name of the cluster.",
                "paramname": "Cluster"
            },
            {
                "paramdescription": "The ID of the special day group.",
                "paramname": "GroupID"
            },
            {
                "paramdescription": "The first day of the special day range as a timestamp. Use TimestampCreate or StrToTimestamp Cicode functions to get a timestamp data value. When creating a timestamp, please use midnight of the required day.",
                "paramname": "FirstDay"
            },
            {
                "paramdescription": "",
                "paramname": "LastDay"
            },
            {
                "paramdescription": "",
                "paramname": "Last day (inclusive) of the special day range as a timestamp. Use TimestampCreate or StrToTimestamp Cicode functions to get a timestamp data value. When creating a timestamp, please use midnight of the required day."
            }
        ],
        "returnType": "0 if successful, otherwise an error code is returned.",
        "syntax": "INT SchdSpecialItemDeleteRange(STRING Cluster, STRING GroupID, TIMESTAMP FirstDay, TIMESTAMP LastDay)"
    },
    "schdspecialitemfirst": {
        "doc": "The SchdSpecialItemFirst places the data browse cursor at the first record. This function uses iSession as the argument which is previously returned by the SchdSpecialItemOpen function.          \nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "SchdSpecialItemFirst",
        "params": [
            {
                "paramdescription": "Current schedule special item browsing session obtained by SchdSpecialItemOpen",
                "paramname": "Session"
            }
        ],
        "returnType": "0 (zero) if the browsing session exists, otherwise an error code is returned.",
        "syntax": "INT SchdSpecialItemFirst(LONG Session)"
    },
    "schdspecialitemgetfield": {
        "doc": "This function returns the value of the particular field in a record to which the data browse cursor is currently referencing. This function uses iSession as an argument which is previously returned by the SchdSpecialItemOpen function and the field name of the value  to be returned. ",
        "example": "No example found",
        "name": "SchdSpecialItemGetField",
        "params": [
            {
                "paramdescription": " Current special day group browsing session obtained by SchdSpecialItemOpen",
                "paramname": "Session"
            },
            {
                "paramdescription": "",
                "paramname": "Field"
            },
            {
                "paramdescription": "",
                "paramname": "The value of the specified field as a string. An empty string may or may not be an indication that an error has been detected. The last error should be checked in this instance to determine if an error has actually occurred."
            }
        ],
        "returnType": "The value of the specified field as a string. An empty string may or may not be an indication that an error has been detected. The last error should be checked in this instance to determine if an error has actually occurred.",
        "syntax": "STRING SchdSpecialItemGetField(LONG Session, STRING Field)"
    },
    "schdspecialitemmodify": {
        "doc": "This function modifies an existing Special Day.          \nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "SchdSpecialItemModify",
        "params": [
            {
                "paramdescription": "",
                "paramname": "Cluster"
            },
            {
                "paramdescription": "",
                "paramname": "ID"
            },
            {
                "paramdescription": "",
                "paramname": "Name"
            },
            {
                "paramdescription": "The special day as a timestamp. Use TimestampCreate or StrToTimestamp Cicode functions to get a timestamp data value.",
                "paramname": "Day"
            }
        ],
        "returnType": "This function returns 0 if successful otherwise it returns an error code.",
        "syntax": "LONG SchdSpecialItemModify(STRING Cluster, LONG ID, STRING Name, TIMESTAMP Day)"
    },
    "schdspecialitemmodifyrange": {
        "doc": "The SchdSpecialItemModifyRange function can be used to modify a range of special days in a specified special day group (category).\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "// Modify the existing special day range for group id 1\n// from 2018-05-06 : 2018-05-10 \n// to 2018-06-06 : 2018-06-10 \n\nSchdSpecialItemModifyRange(\"Cluster1\", 1, \"NewDays\", \nTimestampCreate(2018,5,6,0,0,0,0,0), TimestampCreate(2018,5,10,0,0,0,0,0), \nTimestampCreate(2018,6,6,0,0,0,0,0), TimestampCreate(2018,6,10,0,0,0,0,0));",
        "name": "SchdSpecialItemModifyRange",
        "params": [
            {
                "paramdescription": "The name of the cluster.",
                "paramname": "Cluster"
            },
            {
                "paramdescription": "The ID of the special day group.",
                "paramname": "GroupID"
            },
            {
                "paramdescription": "The first day of the special day range as a timestamp. Use TimestampCreate or StrToTimestamp Cicode functions to get a timestamp data value. When creating a timestamp, please use midnight of the required day.",
                "paramname": "FirstDay"
            },
            {
                "paramdescription": "",
                "paramname": "LastDay"
            },
            {
                "paramdescription": "",
                "paramname": "Last day (inclusive) of the special day range as a timestamp. Use TimestampCreate or StrToTimestamp Cicode functions to get a timestamp data value. When creating a timestamp, please use midnight of the required day."
            },
            {
                "paramdescription": "A new name for the special days.",
                "paramname": "NewName"
            },
            {
                "paramdescription": "A new first day for the special day range as a timestamp. Use TimestampCreate or StrToTimestamp Cicode functions to get a timestamp data value. When creating a timestamp, please use midnight of the required day.",
                "paramname": "NewFirstDay"
            },
            {
                "paramdescription": "A new last day (inclusive) of the special day range as a timestamp. Use TimestampCreate or StrToTimestamp Cicode functions to get a timestamp data value. When creating a timestamp, please use midnight of the required day.",
                "paramname": "NewLastDay"
            }
        ],
        "returnType": "0 if successful, otherwise an error code is returned.",
        "syntax": "INT SchdSpecialItemAddRange(STRING Cluster, STRING GroupID, TIMESTAMP FirstDay, TIMESTAMP LastDay, STRING NewName, TIMESTAMP NewFirstDay, TIMESTAMP NewLastDay)"
    },
    "schdspecialitemnext": {
        "doc": "This function places the data browse cursor at the next available record. This function uses iSession as the argument which is previously returned by the SchdSpecialItemOpen function. This function will return an EOF error code  if called when the data cursor is at end of the records. \nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "SchdSpecialItemNext",
        "params": [
            {
                "paramdescription": "Current special day group browsing session obtained by SchdSpecialItemOpen",
                "paramname": "Session"
            }
        ],
        "returnType": "0 (zero) if the browsing session exists, otherwise an error code is returned.",
        "syntax": "INT SchdSpecialItemNext(LONG Session)"
    },
    "schdspecialitemnumrecords": {
        "doc": "The SchdSpecialItemNumRecords function returns the number of records that match the current filter criteria. This function uses iSession as an argument which is previously returned by the SchdSpecialItemOpen function. ",
        "example": "No example found",
        "name": "SchdSpecialItemNumRecords",
        "params": [
            {
                "paramdescription": "Current special day group browsing session obtained by SchdSpecialItemOpen",
                "paramname": "Session"
            }
        ],
        "returnType": "The number of records that have matched the filter criteria. A value of 0 denotes that no records have matched. A value of -1 denotes that the browse session is unable to provide a fixed number. This may be the case if the data being browsed changed during the browse session.",
        "syntax": "LONG SchdSpecialItemNumRecords(LONG Session)"
    },
    "schdspecialitemopen": {
        "doc": "This function initiates a new session for browsing the special days. It returns a handle for the browsing session which can be used for further browsing operations. \nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "SchdSpecialItemOpen",
        "params": [
            {
                "paramdescription": "A filter expression specifying the records to return during the browse. An empty string indicates that all records will be returned.",
                "paramname": "Filter"
            },
            {
                "paramdescription": "Specifies via a comma delimited string the columns to be returned during the browse. An empty string indicates that the server will return every available column. See SchdSpecialItemGetField for the fields supported.",
                "paramname": "Fields"
            },
            {
                "paramdescription": "An optional parameter that specifies via a comma delimited string the subset of the clusters to browse. An empty string indicates that the connected clusters will be browsed.",
                "paramname": "Clusters"
            }
        ],
        "returnType": "Returns an integer handle to the browse session. Returns -1 when an error is detected.",
        "syntax": "LONG SchdSpecialItemOpen(STRING Filter, STRING Fields [, STRING Clusters])"
    },
    "schdspecialitemprev": {
        "doc": "This function places the data browse cursor at the previous record. This function uses iSession as the argument which is previously returned by the SchdSpecialItemOpen function. This function will return an error(EOF) if called when the data cursor is at beginning of the records. \nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "SchdSpecialItemPrev",
        "params": [
            {
                "paramdescription": "Current special day group browsing session obtained by SchdSpecialItemOpen",
                "paramname": "Session"
            }
        ],
        "returnType": "0 (zero) if the browsing session exists, otherwise an error code is returned.",
        "syntax": "INT SchdSpecialItemPrev(LONG Session)"
    },
    "schdspecialmodify": {
        "doc": "This function modifies an existing special day group. \nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "SchdSpecialModify",
        "params": [
            {
                "paramdescription": "The name of the cluster",
                "paramname": "Cluster"
            },
            {
                "paramdescription": "Existing ID for the current special day group.",
                "paramname": "ID"
            },
            {
                "paramdescription": "New name of the current special day group.",
                "paramname": "NewName"
            }
        ],
        "returnType": "This function returns 0 if successful otherwise it returns an error.",
        "syntax": "LONG SchdSpecialModify(STRING Cluster, LONG ID, STRING NewName)"
    },
    "schdspecialnext": {
        "doc": "This function places the data browse cursor at the next available record. This function uses iSession as the argument which is previously returned by the SchdSpecialOpen function. This function will return an EOF error code  if called when the data cursor is at end of the records. \nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "SchdSpecialNext",
        "params": [
            {
                "paramdescription": "Current special day group browsing session obtained by SchdSpecialOpen",
                "paramname": "Session"
            }
        ],
        "returnType": "0 (zero) if the browsing session exists, otherwise an error code is returned.",
        "syntax": "INT SchdSpecialNext(LONG Session)"
    },
    "schdspecialnumrecords": {
        "doc": "The SchdSpecialNumRecords function returns the number of records that match the current filter criteria. This function uses iSession as an argument which is previously returned by the SchdSpecialOpen function. ",
        "example": "No example found",
        "name": "SchdSpecialNumRecords",
        "params": [
            {
                "paramdescription": "Current special day group browsing session obtained by SchdSpecialOpen",
                "paramname": "Session"
            }
        ],
        "returnType": "The number of records that have matched the filter criteria. A value of 0 denotes that no records have matched. A value of -1 denotes that the browse session is unable to provide a fixed number. This may be the case if the data being browsed changed during the browse session.",
        "syntax": "LONG SchdSpecialNumRecords(LONG Session)"
    },
    "schdspecialopen": {
        "doc": "The SchdSpecialOpen function initiates a new session for browsing the special day groups. It returns a handle for the browsing session which can be used for further browsing operations. \nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "SchdSpecialOpen",
        "params": [
            {
                "paramdescription": "A filter expression specifying the records to return duringthe browse. An empty string indicates that every record will bereturned. Multiple filters can be specified and separated with ';'. Where a fieldname is not specified in the filter, it isassumed to be tagname. For example, the filter \"AAA\" isequivalent to \"name=AAA\".",
                "paramname": "Filter"
            },
            {
                "paramdescription": "Specifies via a comma delimited string the columns to be returned during the browse. An empty string indicates that the server will return every available column. Supported fields are:\nNAME: The name of the special day group.\nID: The unique ID of the special day group. Every special day group is assigned a unique ID.",
                "paramname": "Fields"
            },
            {
                "paramdescription": "An optional parameter that specifies via a comma delimited string the subset of the clusters to browse. An empty string indicates that the connected clusters will be browsed.",
                "paramname": "Clusters"
            }
        ],
        "returnType": "Returns an integer handle to the browse session. Returns -1 when an error is detected.",
        "syntax": "LONG SchdSpecialOpen(STRING Filter, STRING Fields[, STRING Clusters])"
    },
    "schdspecialprev": {
        "doc": "The SchdSpecialPrev places the data browse cursor at the previous record. This function uses iSession as the argument which is previously returned by the SchdSpecialOpen function. This function will return an error(EOF) if called when the data cursor is at beginning of the records.          \nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "SchdSpecialPrev",
        "params": [
            {
                "paramdescription": "Current special day group browsing session obtained by SchdSpecialOpen",
                "paramname": "Session"
            }
        ],
        "returnType": "0 (zero) if the browsing session exists, otherwise an error code is returned.",
        "syntax": "INT SchdSpecialPrev(LONG Session)"
    },
    "scheduleitemadd": {
        "doc": "The ScheduleItemAdd function adds a new schedule to the scheduler engine. It returns the Id of the schedule which can be used for modifying, setting recurrence and deleting this schedule.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "\t\t\n\t//The following example creates a schedule item using state MyState1 for\n\tMyEquipment1, that starts from 3am and ends at 4am on 20th of Nov 2011.\n \n\tTIMESTAMP tsStartTime;\n\tTIMESTAMP tsEndTime;\n\tINT iScheduleID;\n\ttsStartTime = TimestampCreate(2011, 11, 20, 3, 0, 0, 0);\n\ttsEndTime = TimestampCreate(2011, 11, 20, 4, 0, 0, 0);\n\tiScheduleID = ScheduleItemAdd(\"Cluster1\",\n\t\"MyEquipment1\",\"MyState1\",tsStartTime,tsEndTime,\"MyScheduleItem1\");\t\n\t\t",
        "name": "ScheduleItemAdd",
        "params": [
            {
                "paramdescription": "The name of the cluster",
                "paramname": "Cluster"
            },
            {
                "paramdescription": "The name of the equipment to browse.",
                "paramname": "Equipment"
            },
            {
                "paramdescription": "The state of the schedule",
                "paramname": "State"
            },
            {
                "paramdescription": "The start time of the schedule. The type of this parameter is TIMESTAMP. Use TimestampCreate or StrToTimestamp to get a TIMESTAMP value.",
                "paramname": "Start"
            },
            {
                "paramdescription": "The end time of the schedule. The type of this parameter is TIMESTAMP. Use TimestampCreate or StrToTimestamp to get a TIMESTAMP value.",
                "paramname": "End"
            },
            {
                "paramdescription": "The description of the schedule.",
                "paramname": "Desc"
            }
        ],
        "returnType": "The id of the schedule which can be used for modifying, setting recurrence and deleting this schedule. This function returns -1 if unsuccessful. Trap the error to get the error returned by this function.",
        "syntax": "LONG ScheduleItemAdd(STRING Cluster, STRING Equipment, STRING State, TIMESTAMP Start, TIMESTAMP End, STRING Desc)"
    },
    "scheduleitemdelete": {
        "doc": "The ScheduleItemDelete function deletes an existing schedule. \nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.\nLONG ScheduleItemDelete(STRING Cluster, LONG ID)\nCluster:\nID:\nReturns 0 if successful otherwise it returns an error.",
        "example": "No example found",
        "name": "ScheduleItemDelete",
        "params": [],
        "returnType": "Returns 0 if successful otherwise it returns an error.",
        "syntax": "The ScheduleItemDelete function deletes an existing schedule. "
    },
    "scheduleitemmodify": {
        "doc": "The ScheduleItemModify function modifies an existing schedule. \nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "ScheduleItemModify",
        "params": [
            {
                "paramdescription": "Name of cluster.",
                "paramname": "Cluster"
            },
            {
                "paramdescription": "The unique ID of the schedule within the schedule engine",
                "paramname": "ID"
            },
            {
                "paramdescription": "The state of the schedule",
                "paramname": "State"
            },
            {
                "paramdescription": "The start time of the schedule. The type of this parameter is TIMESTAMP. Use TimestampCreate or StrToTimestamp to get a TIMESTAMP value.",
                "paramname": "Start"
            },
            {
                "paramdescription": "The end time of the schedule. The type of this parameter is TIMESTAMP. Use TimestampCreate or StrToTimestamp to get a TIMESTAMP value.",
                "paramname": "End"
            },
            {
                "paramdescription": "",
                "paramname": "Desc"
            },
            {
                "paramdescription": "",
                "paramname": "The description of the schedule."
            }
        ],
        "returnType": "Returns 0 if successful otherwise it returns an error.",
        "syntax": "LONG ScheduleItemModify(STRING Cluster, LONG ID, STRING State, TIMESTAMP Start, TIMESTAMP End, STRING Desc)"
    },
    "scheduleitemsetrepeat": {
        "doc": "The ScheduleItemSetRepeat function adds recurrence information to an existing schedule to the scheduler engine. The same function is used if the schedule already has recurrence information that need to be changed. \nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "ScheduleItemSetRepeat",
        "params": [
            {
                "paramdescription": "Name of cluster",
                "paramname": "Cluster"
            },
            {
                "paramdescription": "",
                "paramname": "ID"
            },
            {
                "paramdescription": "",
                "paramname": "Freq"
            },
            {
                "paramdescription": "",
                "paramname": "Interval"
            },
            {
                "paramdescription": "",
                "paramname": "WeekDay"
            },
            {
                "paramdescription": "",
                "paramname": "WeekDayMask"
            },
            {
                "paramdescription": "",
                "paramname": "MaxRec"
            },
            {
                "paramdescription": "",
                "paramname": "RecUntil"
            },
            {
                "paramdescription": "",
                "paramname": "DayOrd"
            },
            {
                "paramdescription": "",
                "paramname": "Day"
            },
            {
                "paramdescription": "",
                "paramname": "Month"
            },
            {
                "paramdescription": "",
                "paramname": "SpecialInc"
            },
            {
                "paramdescription": " ",
                "paramname": "GroupIds "
            }
        ],
        "returnType": "Returns 0 if successful otherwise it returns an error.",
        "syntax": "LONG ScheduleItemSetRepeat(STRING Cluster, LONG ID, LONG Freq, LONG Interval, LONG Weekday, LONG WeekDayMask, LONG MaxRec, LONG RecUntil,LONG DayOrd, LONG Day, LONG Month,LONG SpecialInc, STRING GroupIds)"
    },
    "semclose": {
        "doc": "Closes a semaphore opened with SemOpen(). You should close all semaphores when they are no longer required, because they consume memory. If any Cicode tasks are waiting on this semaphore, the tasks are released with an error.",
        "example": "SemClose(hSem);",
        "name": "SemClose",
        "params": [
            {
                "paramdescription": " The semaphore handle, returned from the SemOpen() function. The semaphore handle identifies the table where all data on the associated semaphore is stored.",
                "paramname": "hSem"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "SemClose(hSem)"
    },
    "semopen": {
        "doc": "Opens a semaphore for access control. When the semaphore is opened, it is initially signalled. Use a semaphore for controlling access to a restricted device, for example, to stop another Cicode task accessing a device while it is in use. You might require semaphores for some Cicode operations, because they can access a device that is critical. (Cicode is a multi-tasking system.)",
        "example": "hSem=SemOpen(\"MySem\",1);",
        "name": "SemOpen",
        "params": [
            {
                "paramdescription": "The name of the semaphore. Follow the naming convention outlined in the topic Tag Name Syntax in the main help.",
                "paramname": "sName"
            },
            {
                "paramdescription": "The mode of the open:\n0 - Open existing semaphore.\n1 - Create new semaphore.\n2 - Attempts to open an existing semaphore. If the semaphore does not exist, it will create it.",
                "paramname": "Mode"
            }
        ],
        "returnType": "The semaphore handle, or -1 if the semaphore was not opened successfully. The semaphore handle identifies the table where all data on the associated semaphore is stored.",
        "syntax": "SemOpen(Name, Mode)"
    },
    "semsignal": {
        "doc": "Signals a semaphore. If several Cicode tasks are waiting on this semaphore, the first task is released. This function is a blocking function. It will block the calling Cicode task until the operation is complete.",
        "example": "SemSignal(hSem);",
        "name": "SemSignal",
        "params": [
            {
                "paramdescription": " The semaphore handle, returned from the SemOpen() function. The semaphore handle identifies the table where all data on the associated semaphore is stored.",
                "paramname": "hSem"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "SemSignal(hSem)"
    },
    "semwait": {
        "doc": "Waits on a semaphore to be signalled. This function is a blocking function. It will block the calling Cicode task until the operation is complete.",
        "example": "Status=SemWait(hSem,10);\nIF Status=0 THEN\n\t...\nELSE\n\tPrompt(\"Could not get semaphore\");\nEND",
        "name": "SemWait",
        "params": [
            {
                "paramdescription": " The semaphore handle, returned from the SemOpen() function. The semaphore handle identifies the table where all data on the associated semaphore is stored.",
                "paramname": "hSem"
            },
            {
                "paramdescription": "Semaphore time-out time:\n-1 - Wait until semaphore is clear (regardless of how long).\n0 - Do not wait - return immediately. (This timeout can be used to check the state.)\n> 0 - The number of seconds to wait if semaphore is not signalling, then return.",
                "paramname": "Timeout"
            }
        ],
        "returnType": "0 (zero) if the semaphore has been gained, otherwise an error code is returned.",
        "syntax": "SemWait(hSem, Timeout)"
    },
    "sendkeys": {
        "doc": "Sends a keystroke (or string of keystrokes) to a window as if they were typed on the keyboard. The window receives input focus and is brought to the foreground.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "SendKeys(\"Untitled - Notepad\", \"abc\");\n// Send the key sequence \"abc\" to the Notepad application",
        "name": "SendKeys",
        "params": [
            {
                "paramdescription": "The title (caption) of the destination window.",
                "paramname": "sTitle"
            },
            {
                "paramdescription": "The key (or keys) to send to sTitle.\nTo send a single keyboard character, use the character itself. For example, to send the letter a, set sKeys to a. To send more than one character, append each additional character to the string. For example, to send the letters a, b, and c, set sKeys to abc.\nThe plus (+), caret (^), and percent sign (%) have special meanings. To send one of these special characters, enclose the character with braces. For example, to send the plus sign, use {+}. To send a { character or a } character, use {{} and {}}, respectively.\nTo specify characters that are not displayed when you press a key (such as Enter or Tab) and other keys that represent actions rather than characters, use the codes shown below:\nTo specify keys combined with any combination of Shift, Ctrl, and Alt, precede the regular key code with one or more of these codes: KeyCode Shift + Ctrl ^ Alt %\nTo specify that Shift, Ctrl, and/or Alt are held down while several keys are pressed, enclose the keys in parentheses. For example, to hold down the Shift key while sending E then C, use +(EC). To hold down Shift while sending E, followed by C without the Shift key, use +EC. To specify repeating keys, use the form {key number}. For example, {left 42} means send the left arrow key 42 times. Be aware that you need to leave a space between the key and number.",
                "paramname": "sKeys"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "SendKeys(sTitle, sKeys)"
    },
    "serialkey": {
        "doc": "Redirects all serial characters from a port to the keyboard. If using a keyboard attached to a serial port, you should call this function at startup, so that Plant SCADA copies all characters (read from the port) to the keyboard. The Port needs to be defined in the Ports database.\nIf the port is not on an I/O server, you need to create a dummy I/O server record (for example, name the server DServer1). Complete the Boards and Ports records. Set the following parameters in the CITECT.INI file:\nThis method enables the port without making the computer an I/O server. (If the I/O server is enabled (and not required as an I/O server), extra overhead and memory are used.)\nThis function can only be called from an I/O server.",
        "example": "SerialKey(\"Port1\"); ! enable the serial keyboard",
        "name": "SerialKey",
        "params": [
            {
                "paramdescription": "The name of the port connected to the serial keyboard.",
                "paramname": "sPort"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "SerialKey(sPort)"
    },
    "serverbrowseclose": {
        "doc": "The ServerBrowseClose function terminates an active data browse session and cleans up resources associated with the session.",
        "example": "No example found",
        "name": "ServerBrowseClose",
        "params": [
            {
                "paramdescription": "Handle to a browse session previously opened by a ServerBrowseOpen call.",
                "paramname": "iSession"
            }
        ],
        "returnType": "0 (zero) if the server browse session exists, otherwise an error code is returned. ",
        "syntax": "ServerBrowseClose(iSession)"
    },
    "serverbrowsefirst": {
        "doc": "The ServerBrowseFirst function places the data browse cursor at the first record.",
        "example": "No example found",
        "name": "ServerBrowseFirst",
        "params": [
            {
                "paramdescription": "Handle to a browse session previously opened by a ServerBrowseOpen call.",
                "paramname": "iSession"
            }
        ],
        "returnType": "0 (zero) if the server browse session exists, otherwise an error code is returned. ",
        "syntax": "ServerBrowseFirst(iSession)"
    },
    "serverbrowsegetfield": {
        "doc": "The ServerBrowseGetField function retrieves the value of the specified field from the record the data browse cursor is currently referencing.",
        "example": "No example found",
        "name": "ServerBrowseGetField",
        "params": [
            {
                "paramdescription": "Handle to a browse session previously opened by a ServerBrowseOpen call.",
                "paramname": "iSession"
            },
            {
                "paramdescription": "The name of the field that references the value to be returned. Supported fields are:\nNAME, TYPE, COMMENT, CLUSTER, MODE, NETADDR, PORT.\nSee Browse Function Field Reference for information about fields.",
                "paramname": "sFieldName"
            }
        ],
        "returnType": "The value of the specified field as a string. An empty string may or may not be an indication that an error has been detected. The last error should be checked in this instance to determine if an error has actually occurred.",
        "syntax": "ServerBrowseGetField(iSession, sFieldName)"
    },
    "serverbrowsenext": {
        "doc": "The ServerBrowseNext function moves the data browse cursor forward one record. If you call this function after you have reached the end of the records, error 412 is returned (Databrowse session EOF).",
        "example": "No example found",
        "name": "ServerBrowseNext",
        "params": [
            {
                "paramdescription": "Handle to a browse session previously opened by a ServerBrowseOpen call.",
                "paramname": "iSession"
            }
        ],
        "returnType": "0 (zero) if the server browse session exists, otherwise an error code is returned. ",
        "syntax": "ServerBrowseNext(iSession)"
    },
    "serverbrowsenumrecords": {
        "doc": "The ServerBrowseNumRecords function returns the number of records that match the filter criteria.",
        "example": "No example found",
        "name": "ServerBrowseNumRecords",
        "params": [
            {
                "paramdescription": "Handle to a browse session previously opened by a ServerBrowseOpen call.",
                "paramname": "iSession"
            }
        ],
        "returnType": "The number of records that matched the filter criteria. A value of 0 denotes that no records matched. A value of -1 denotes that the browse session is unable to provide a fixed number. This could be the case if the data being browsed changed during the browse session.",
        "syntax": "ServerBrowseNumRecords(iSession)"
    },
    "serverbrowseopen": {
        "doc": "The ServerBrowseOpen function initiates a new browse session and returns a handle to the new session that can be used in subsequent data browse function calls.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "ServerBrowseOpen",
        "params": [
            {
                "paramdescription": "A semicolon delimited list of field name=field value pairs, specifying the records to return during the browse. An empty string indicates that all records will be returned. \nThe following regular expressions are supported: *expr, expr*, and *expr*. To specify an exclusion filtering condition, use the NOT keyword after the = operator. ",
                "paramname": "Filter"
            },
            {
                "paramdescription": "Specifies via a comma-delimited string the columns to be returned during the browse. An empty string indicates that the server will return available columns. Supported fields are:\nNAME, TYPE, COMMENT, CLUSTER, MODE, NETADDR, PORT.\nSee Browse Function Field Reference for information about fields.",
                "paramname": "Fields"
            },
            {
                "paramdescription": "An optional parameter that specifies via a comma delimited string the subset of clusters to browse. An empty string indicates that connected clusters will be browsed.",
                "paramname": "Clusters"
            }
        ],
        "returnType": "An integer handle to the browse session. Returns -1 on error.",
        "syntax": "ServerBrowseOpen(STRING Filter , STRING Fields , STRING Clusters)"
    },
    "serverbrowseprev": {
        "doc": "The ServerBrowsePrev function moves the data browse cursor back one record. If you call this function after you have reached the beginning of the records, error 412 is returned (Databrowse session EOF).",
        "example": "No example found",
        "name": "ServerBrowsePrev",
        "params": [
            {
                "paramdescription": "Handle to a browse session previously opened by a ServerBrowseOpen call.",
                "paramname": "iSession"
            }
        ],
        "returnType": "0 (zero) if the server browse session exists, otherwise an error code is returned. ",
        "syntax": "ServerBrowsePrev(iSession)"
    },
    "serverdumpkernel": {
        "doc": "Dumps Kernel data to the KERNEL.DAT file (written to the Logs folder)  either on a local server or on a remote server. The server is specified with the server and cluster parameters. Instead of creating a new file subsequent calls to this function will append Kernel data to the KERNEL.DAT file. This is a blocking function.",
        "example": "ServerDumpKernel(0x8000, \"\");\n!Dump the Kernel data",
        "name": "ServerDumpKernel",
        "params": [
            {
                "paramdescription": " The Kernel data to dump:\nYou can select any one of the above modes or may add them together to get more than one type of information. For example, to dump netstat and I/O device data in verbose mode, set iMode to 0x4014 (0x0004 + 0x0010 + 0x4000). Using 0x4000 on its own will dump no data, it needs to be combined with another mode.",
                "paramname": "iMode"
            },
            {
                "paramdescription": "The queue or table name (empty for all queues or tables).Only valid if iMode is 0x0020 and 0x0040.",
                "paramname": "sName"
            },
            {
                "paramdescription": "Specifies the name of the server, as defined in the project, on which kernel data will be dumped. ",
                "paramname": "sServer"
            },
            {
                "paramdescription": "Specifies the cluster of the server on which kernel data will be dumped. This parameter is optional in a single cluster environment.",
                "paramname": "sCluster"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "ServerDumpKernel(iMode, sName, sServer [, sCluster])"
    },
    "servergetproperty": {
        "doc": "This function returns information about a specified server and can be called from any client.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "ServerGetProperty(\"AlarmServer1\", \"ReloadStatus\", \"Cluster12\");",
        "name": "ServerGetProperty",
        "params": [
            {
                "paramdescription": "The name of the server to be queried in quotations marks \"\". Can be prefixed by the name of the host cluster, that is \"ClusterName.ServerName\".",
                "paramname": "sServer"
            },
            {
                "paramdescription": "The name of the requested property. Can be one of the following:",
                "paramname": "sProperty"
            },
            {
                "paramdescription": "The cluster of the server to be queried in quotation marks \"\". This parameter is optional. However, if the Server Name is not local or not specified in ClusterName.ServerName format an error code is returned.",
                "paramname": "sCluster"
            }
        ],
        "returnType": "The value of the server property requested.       ",
        "syntax": "STRING ServerGetProperty(STRING Server, STRING Property [, STRINGCluster])."
    },
    "serverinfo": {
        "doc": "Gets status information on clients and servers.",
        "example": "sSrvInfo=ServerInfo(\"Report\",0);\nIF sSrvInfo THEN\n    ! This is a primary report server.\nELSE\n    ! This is a stand-by report server.\nEND\n/* Get and store the names of clients attached to this server */\niCount = 0;\niClients = ServerInfo(\"Server\", 1);\nWHILE iCount < iClients DO\n    sName[iCount] = ServerInfo(IntToStr(iCount), 2);\n    iCount = iCount + 1;\nEND",
        "name": "ServerInfo",
        "params": [
            {
                "paramdescription": "The name of the client or server, either \"Client\", \"Server\",\"Alarm\", \"Trend\", or \"Report\".\nYou can also pass a number instead of the name (but it still needs to be enclosed in quotes). The number represents the target client. For example, if there are 12 clients, passing \"3\" will get information on the 3rd client.\nIf this server is an Alarm, Trend, Report, and I/O server then each client will be attached 4 times. So 12 clients would mean there are 3 Plant SCADA computers using this server - one of which is itself.",
                "paramname": "Name"
            },
            {
                "paramdescription": "The type of information required (depends on the Name youspecify):\n\"Alarm\", \"Trend\", or \"Report\" name:\n0 - Active flag (returns 1 if this is the active server, 0 if an inactive server).\n1 - Number of clients attached to this server.\n2 - If this client is attached to the primary or standby server for the specified server name. If Name is \"Alarm\" and if this client is attached to the primary alarm server, the return value is 0. If this client is attached to the standby, the return value is 1.\n3 - The status of the client connection to the specified server name. If Name is \"Report\" and the client is talking to a report server (either primary or standby), the return value is 1. If not, the return value is 0.\n4 - Alarm DB Status for the alarm server. Returns 1 if initializing, 2 if main, 3 if standby and 4 if invalid. \n\"Client\" name:\n0 - The computer name, as specified by [LAN]Node.\n1 - Not supported.\n2 - Not supported.\n3 - Not supported.\nFor modes 1,2 and 3, use ServerInfoEx instead.\n\"Server\" name:\n0 - Not supported.\n1 - The number of clients attached to this server. This is the total number of Alarm, Trend Report, and I/O server clients.\n\"<number>\":\n0 - The name of the server this client is talking to. For example, \"Alarm\", \"Trend\", \"Report\", or \"IOServer\".\n1 - The login name of the client. This may be an empty string if the client has not logged in.\n2 - The Plant SCADA computer name of the client computer.\n3 - The time the client logged in.\n4 - The number of messages received from this client.\n5 - The number of messages sent to this client.\n6 - If this client has a licence (1) from this server or not (0).\n7 - The type of the licence; full licence (0), View-only Client (1), or Control Client (2).\n8 - If the client is remote (1) or local (0).",
                "paramname": "Type"
            },
            {
                "paramdescription": "The name of the cluster that the server belongs to. This isonly relevant if:\nThe Name is \"alarm\", \"report\", or \"trend\"; AND\nThe type of information required, nType, is 2 or 3.\nStatus information specified by nnType.",
                "paramname": "ClusterName"
            }
        ],
        "returnType": "Status information specified by nnType.",
        "syntax": "STRING ServerInfo(STRING Name, INT Type [, STRING ClusterName] )"
    },
    "serverinfoex": {
        "doc": "Gets status information on clients and servers from a specified component in a multiprocess runtime environment.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.\nWhen this function is called, the system redirects the call to the process that contains the specified component. If the specified component is in the calling process, the call is not redirected. If the specified component is not one of the servers listed in the sComponent argument description (see below), of if the system cannot find the component from the connected local processes, a hardware alarm is raised.",
        "example": "sSrvInfo=ServerInfoEx(\"Report\",0, \"Report\");\nIF sSrvInfo THEN\n    ! This is a primary report server.\nELSE\n    ! This is a stand-by report server.\nEND\n/* Get and store the names of clients attached to the report server */\niCount = 1;\niClients = ServerInfoEx(\"Server\", 1, \"Report\");\nWHILE iCount <= iClients DO\n    sName[iCount] = ServerInfoEx(IntToStr(iCount), 2, \"Report\");\n    iCount = iCount + 1;\nEND",
        "name": "ServerInfoEx",
        "params": [
            {
                "paramdescription": "The name of the client or server, either \"Client\", \"Server\",\"Alarm\", \"Trend\", or \"Report\".\nYou can also pass a number instead of the name (but it still needs to be enclosed in quotes). The number represents the target client. For example, if there are 12 clients, passing \"3\" will get information on the 4th client.\nIf this server is an Alarm, Trend, Report, and I/O server then each client will be attached 4 times. So 12 clients would mean there are 3 Plant SCADA computers using this server - one of which is itself.",
                "paramname": "Name"
            },
            {
                "paramdescription": "The type of information required (depends on the Name youspecify): \n\"Alarm\", \"Trend\", or \"Report\" name:\n0 - Active flag (returns 1 if this is the active server, 0 if an inactive server).\n1 - Number of clients attached to this server.\n2 - If this client is attached to the primary or standby server for the specified server name. If Name is \"Alarm\" and if this client is attached to the primary alarm server, the return value is 0. If this client is attached to the standby, the return value is 1.\n3 - The status of the client connection to the specified server name. If Name is \"Report\" and the client is talking to a report server (either primary or standby), the return value is 1. If not, the return value is 0.\n4 - Alarm DB Status for the alarm server. Returns 1 if initializing, 2 if main, 3 if standby and 4 if invalid. \n\"Client\" name:\n0 - The computer name, as specified by [LAN]Node.\n1 - The primary server name, as specified in the server configuration forms in Project Editor.\n2 - The secondary server name, as specified , as specified in the server configuration forms in Project Editor.\n3 - The name of the INI file being used, for example, Citect.INI.\n\"Server\" name:\n0 - The server name, as specified in the server configuration forms in Project Editor.\n1 - The number of clients attached to this server. This is the total number of Alarm, Trend Report, and I/O server clients.\n\"<number>\":\n0 - The name of the server this client is talking to. For example, \"Alarm\", \"Trend\", \"Report\", or \"IOServer\".\n1 - The login name of the client. This may be an empty string if the client has not logged in.\n2 - The Plant SCADA computer name of the client computer.\n3 - The time the client logged in.\n4 - The number of messages received from this client.\n5 - The number of messages sent to this client.\n6 - If this client has a license from the server listed in ‘sComponent’ parameter (1) or not (0). If the server is running in multi-process mode, you will need to iterate through all the server processes on the computer using mode 6 to detect if a license is being issued from that computer.\n7 - The type of the licence; full licence (0), View-only Client (1), or Control Client (2). If the client has not obtained a license from the listed server component (i.e. ServerInfoEx mode 6 has returned 0), then this will not be defined and always return 0.\n8 - If the client is remote (1) or local (0). \"Remote\" means the client is not in the same process as the server. For example, the client could be in another process on the same computer as the server, or even on another computer. \"Local\" means the client is in the same process as the server.",
                "paramname": "Type"
            },
            {
                "paramdescription": "Specifies the component name from which to retrieve thestatus information:\n\" \"- An empty string causes the function to run on the calling process.\n\"Alarm\" - Redirects the function to the alarm server process.\n\"Trend\" - Redirects the function to the trend server process.\n\"Report\" - Redirects the function to the report server process.\n\"IOServer\" - Redirects the function to the I/O server process.",
                "paramname": "Component"
            },
            {
                "paramdescription": "The name of the cluster that the server belongs to. This isonly relevant if:\nThe Name is \"alarm\", \"report\", or \"trend\"; AND\nThe type of information required, nType, is 2 or 3.",
                "paramname": "ClusterName"
            },
            {
                "paramdescription": "Specifies the name of the the I/O Server. This parameter is only required if you are running more than one I/O server process from the same cluster on the same computer and need to instruct the system which process to redirect to. The argument is enclosed in quotation marks \"\".",
                "paramname": "ServerName"
            }
        ],
        "returnType": "Status information specified by nType.",
        "syntax": "STRING ServerInfoEx(STRING Name, INT Type, STRING Component [, STRING ClusterName] [, STRING ServerName]   )"
    },
    "serverisonline": {
        "doc": "The ServerIsOnline function checks if the given server can be contacted by the client for giving the online/offline status of the server.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "ServerIsOnline(\"AlarmServer1\", \"Cluster12\");",
        "name": "ServerIsOnline",
        "params": [
            {
                "paramdescription": "The name of the server to be queried in quotations marks \"\". ",
                "paramname": "ServerName"
            },
            {
                "paramdescription": "The cluster of the server to be queried in quotation marks \"\". An empty string indicates that the default cluster will be used.",
                "paramname": "Cluster"
            },
            {
                "paramdescription": "The mode of the server status check. \n A value of \"1\" results in a local check of the server status, checking if the current computer can connect to the server directly. In local mode, this function will return a value immediately, without blocking the Cicode. \n A value of \"0\" (default) indicates that a remote check of the server status is required to confirm if the server can be reached through its peer. In remote mode, this function will block the Cicode while waiting for a response to the query.",
                "paramname": "bLocal"
            }
        ],
        "returnType": "An integer value of online/offline status. Returns 1 for online, 0 for offline.",
        "syntax": "INT ServerIsOnline(STRING ServerName[, STRING Clusters][, INT bLocal])"
    },
    "serverreload": {
        "doc": "This function  can only be called for\t\tAlarm, Report and Trend Servers and reloads the server specified by cluster and server name. If the server is not found an error code is returned. ServerReload can be used in blocking or non-blocking modes using the bSync parameter. When used in non-blocking mode, the server status can be returned using the ServerGetProperty function. \nTo call this function successfully a valid user needs to be logged in as the client and you need to set the [LAN]AllowRemoteReload parameter in the Citect.ini file  to \"1\" on the computer where the receiving server is running.",
        "example": "ServerReload(\"AlarmServer1\", \"Cluster1\", 0);",
        "name": "ServerReload",
        "params": [
            {
                "paramdescription": "The name of the server to be reloaded in quotations marks \"\". Can be prefixed by the name of the host cluster, that is \"ClusterName.ServerName\".",
                "paramname": "sServer"
            },
            {
                "paramdescription": "The cluster of the server to be reloaded in quotation marks \"\". This parameter is optional. However, if the server name is not local or not specified in ClusterName.ServerName format, an error code is returned.",
                "paramname": "sCluster"
            },
            {
                "paramdescription": "Specifies whether the function operates in blocking or non-blocking mode. If bSync is set to 1, the function will not return until the server reload is complete. The reload is complete when all the records of all rdb files have been processed and updated. Blocking mode cannot be used from a foreground task (for example on graphic pages). When bSync is set to 0, the function operates in non-blocking mode. You can get the latest status of the reload using the ServerGetProperty function.Default value is 0.",
                "paramname": "bSync"
            }
        ],
        "returnType": "0 (zero) if the function was successful. Returns an error if unsuccessful.Outline of errors:",
        "syntax": "INT ServerReload(STIRNG Server [, STRING Cluster] [, INT Sync] )"
    },
    "serverrestart": {
        "doc": "Allows you to restart any specific alarm, report, trend or I/O server from any Cicode node in a system, without affecting other server processes running on the same machine. To call this function, a valid user needs to be logged in.\nFor this function to operate successfully, you need to make the following Citect.ini parameter settings:\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "ServerRestart(\"AlarmServer1\", \"Cluster1\");",
        "name": "ServerRestart",
        "params": [
            {
                "paramdescription": "The name of the server to restart ",
                "paramname": "sServerName"
            },
            {
                "paramdescription": "The cluster the server belongs to. This parameter is optional. If sCluster is not specified the current system cluster is used.",
                "paramname": "sCluster"
            }
        ],
        "returnType": "0 (zero) if  successful, otherwise one of the following error codes is returned:",
        "syntax": "INT error = ServerRestart (STRING sServerName, STRING sCluster = \"\")"
    },
    "serverrpc": {
        "doc": "Calls a remote procedure on the Plant SCADA server specified by the ServerName argument. You can call any of the built-in Cicode functions remotely, or your own functions. You pass the Name of the function as a string and pass the arguments for that function in Arg.\nYou can call the function in synchronous or asynchronous mode. In synchronous mode, ServerRPC() does not return until the function call has completed on the server and the result is returned. In asynchronous mode, ServerRPC() returns before the function is called, an empty string is returned as the result cannot be returned.\nThis means this function is a blocking function if iMode is set to zero (0). A logged on user is required for this function to be successful.\nServerRPC(sServerName, sName, sArg, iMode [, sClusterName])\nsServerName:\nsName:\nsArg:\niMode:\nsClusterName:\nTaskNew, TaskNewEx\n",
        "example": "No example found",
        "name": "ServerRPC",
        "params": [
            {
                "paramdescription": "Plant SCADA server name where the Cicode function needs to be executed. You can optionally specify this name in <ClusterName>.<ServerName> syntax.",
                "paramname": "sServerName"
            },
            {
                "paramdescription": "The name of the Cicode function to call remotely as string.",
                "paramname": "sName"
            },
            {
                "paramdescription": "The arguments to pass to the function, separated by commas (,).Enclose string arguments in quotes \"\" and use the string escape character (^) around strings enclosed within a string. If you forget to enclose the string in quotes, then the string is only the first tag found.",
                "paramname": "sArg"
            },
            {
                "paramdescription": "The mode of the call:\n0 - Blocking mode - synchronous\n1 - Non-blocking mode - asynchronous",
                "paramname": "iMode"
            },
            {
                "paramdescription": "The name of the cluster that the server resides in. This argument is optional, as in several situations it may not be required. In single cluster systems, it is not required, or if the current Cicode task already has the correct cluster context for the server you may omit this argument.",
                "paramname": "sClusterName"
            }
        ],
        "returnType": "The result of the remote function call (as a string). If the function is called in asynchronous mode the result of the remote function cannot be returned, so an empty string is returned.  If the function cannot work due to an error, empty string is also returned and the error can be obtained by calling the IsError function. If  current user has view-only access on client side, the function will return an error code.",
        "syntax": "ServerRPC(sServerName, sName, sArg, iMode [, sClusterName])"
    },
    "servicegetlist": {
        "doc": "Determines the service type(s), cluster name(s), and service name(s) of all services currently running in the component that called this function. It also determines if the client component is running.\nIf you call this function from a component that is running purely as a Control Client or View-only Client, the function will return \"Client\".\nIf you call this function from a single-process component that includes:\nThe function will return a string similar to:\n\"IOServer.ClustA.IOServ1,Trend.ClustB.Trend1,Alarm.ClustA.Alarm1,Report.ClustB.Report1,Client\"\nThe order of components in the string is not fixed so the exact string may vary from the above. You should parse the returned string or alternatively use ProcessIsClient or ProcessIsServer to find the information you need.",
        "example": "No example found",
        "name": "ServiceGetList",
        "params": [],
        "returnType": "String in the form:",
        "syntax": "ServiceGetList()"
    },
    "setarea": {
        "doc": "Sets the current viewable areas. You can pass a single area number, or a group of areas to set multiple areas. You can only set areas that are flagged for the current user.",
        "example": "/* Set current viewable area to Area 1. */\nSetArea(1);",
        "name": "SetArea",
        "params": [
            {
                "paramdescription": " The area to set (1 to 255).",
                "paramname": "Area"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "SetArea(Area)"
    },
    "setevent": {
        "doc": "Sets an event callback function by specifying a function handle. You can use this function with the GetEvent() function to restore an old event handler.",
        "example": "No example found",
        "name": "SetEvent",
        "params": [
            {
                "paramdescription": "The type of event:\n0 - The mouse has moved. When the mouse moves the callback function is called. The return value must be 0.\n1 - A key has been pressed. When the user presses a key, the callback function is called after Plant SCADA checks for hot keys. If the return value is 0, Plant SCADA checks for key sequences. If the return value is not 0, Plant SCADA assumes that you will process the key and does not check the key sequence. It is up to you to remove the key from the key command line.\nIf you are using a right mouse button click as an event, you should read about the ButtonOnlyLeftClick parameter.\n2 - Error event. This event is called if an error is detected in Cicode, so you can write a single error function to check for your errors. If the return value is 0, Plant SCADA continues to process the error and generates a hardware error - it may then halt the Cicode task. If the return value is not 0, Plant SCADA assumes that you will process the error, and continues the Cicode without generating a hardware error.\n3 - Page user communication error. A communication error has been detected in the data required for this page. If the return value is 0 (zero), Plant SCADA still animates the page. If the return value is not zero, it does not update the page.\n4 - Page user open. A new page is being opened. This event allows you to define a single function that is called when all pages are opened. The return value must be 0.\n5 - Page user close. The current page is being closed. This event allows you to define a single function that is called when all pages are closed. The return value must be 0.\n6 - Page user always. The page is active. This event allows you to define a single function that is called when all pages are active. The return value must be 0.\n7 - Page communication error. A communication error has been detected in the data required for this page. Reserved for use by Plant SCADA.\n8 - Page open. This event is called each time a page is opened. Reserved for use by Plant SCADA.\n9 - Page close. This event is called each time a page is closed. Reserved for use by Plant SCADA.\n10 - Page always. This event is called while a page is active. Reserved for use by Plant SCADA.\n11..17 - Undefined.\n18 - Report start. The report server is about to start a new report. This event is called on the report server. The return value must be 0.\n19 - Device history. A device history has just completed. The return value must be 0.\n20 - Login. A user has just logged in.\n21 - Logout. A user has just logged out.\n22 - Trend needs repainting. This event is called each time Plant SCADA re-animates a real-time trend or scrolls an historical trend. You should use this event to add additional animation to a trend, because Plant SCADA deletes all existing animation when a trend is re-drawn. (For example, if you want to display extra markers, you must use this event.)\n23 - Hardware error has been detected.\n24 - Keyboard cursor moved. This event is called each time the keyboard command cursor moves. The cursor can be moved by the cursor keys, the mouse, or the Cicode function KeySetCursor(). Note that you can find where the keyboard command cursor is located by calling the function KeyGetCursor().\n25 - Network shutdown. A Shutdown network command has been issued.\n26 - Runtime system shutdown and restart. (Required because of configuration changes.)\n27 - Event. An event has occurred.\n28 - Accumulator. An accumulator has logged a value.\n29 - Slider. A slider has been selected.\n30 - Slider. A slider has moved.\n31 - Slider. A slider has been released (that is stopped moving).\nWhile responding to slider events 29, 30, and 31, you can set any variables but you cannot call functions that cause immediate changes to animations on the page (for example, DspText() and DspSym()). Types 29, 30, & 31 relate only to V3.xx and V4.xx animations, and will be superseded in future releases.\n32 - Shutdown. Plant SCADA is being shutdown.\n33 - Reserved for Plant SCADA internal use.\n34 - 41 - Plant SCADA Confirmation Events. Reserved for Plant SCADA internal use. For the confirmation events, two sets of event type code are defined. The runtime calls the Plant SCADA event handler first, and conditionally proceed to the user's event handler depending on the return value of the Plant SCADA event handler. \n34 -Plant SCADA Event: Child Window Close Confirmation.\n35 - Plant SCADA Event: Main Window Close Confirmation.\n36 - Plant SCADA Event: Maximize Window Confirmation.\n37 - Plant SCADA Event: Minimize Window Confirmation.\n38 - Plant SCADA Event: Restore Window Confirmation.\n39 - Plant SCADA Event: Move Window Confirmation.\n40 - Plant SCADA Event: Size Window Confirmation.\n41 - Plant SCADA Event: Shutdown Confirmation Confirmation.\n42 to 49 - User Confirmation Events. These functions are called when a specific event (mainly from Window title bar) occur and before the runtime performs the intended action. This gives a chance for the user to decide what to do with the event. If the return value is 0, the event will be passed on to the default handler so the intended action will be performed. If the return value is not 0, the event will be ignored and no further action will be taken.\n42 - Child Window Close Confirmation, when the close button of the windows' title bar is clicked or an equivalent Windows' message is received.\n43 - Main Window Close Confirmation, when close button of the windows' title bar is clicked which will cause the process to shutdown.\n44 - Maximize Window Confirmation, when the maximize button of the windows' title bar is clicked or an equivalent Windows' message is received.\n45- Minimize Window Confirmation, when the minimize button of the windows' title bar is licked or an equivalent Windows' message is received.\n46 - Restore Window Confirmation, when the restore button of the windows' title bar is clicked or an equivalent Windows' message is received.\n47 - Move Window Confirmation, when the window is being dragged or an equivalent Windows' message is received.\n48 - Size Window Confirmation, when the windows is being resized or an equivalent Windows' message is received.\n49 - Shutdown Confirmation, when shutdown() function is called.\n50 - 127 - Reserved for future Plant SCADA use.\n128 - 256 - User-defined events. These events are for your own use.",
                "paramname": "Type"
            },
            {
                "paramdescription": "The function handle, as returned from the GetEvent()function.",
                "paramname": "hFn"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "SetEvent(nType, hFn)"
    },
    "setlogging": {
        "doc": "Adjusts logging parameters while online. The parameters you can modify include the following:",
        "example": "No example found",
        "name": "SetLogging",
        "params": [
            {
                "paramdescription": " The INI section name.",
                "paramname": "Section"
            },
            {
                "paramdescription": " The system parameter name.",
                "paramname": "sName"
            },
            {
                "paramdescription": " The value you would like to set the parameter to.",
                "paramname": "Value"
            },
            {
                "paramdescription": "Makes the value persistent across restarts by writing the value to the INI file.",
                "paramname": "Persist"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "SetLogging(Section, Name, Value, Persist)"
    },
    "shutdown": {
        "doc": "Terminates Plant SCADA's operation. Use this function to shut down the Plant SCADA system, otherwise buffered data could be lost. This function impacts the operation of the computer as a whole, it is not process-based. If a computer is the target for shutdown, all Plant SCADA processes on the computer will be shutdown.\nThe shutdown can affect only the computer that calls it, or all or part of a Plant SCADA network. If you are shutting down a network, specify the computers (Control Clients and servers) to be shut down in sDest, and the extent of the shutdown in Mode.\nYou can allow selected computers to override the shutdown with the [Shutdown]NetworkIgnore parameter. (You might set this parameter for key servers, for example, I/O servers.)\nUse the ShutdownForm() function to prompt the user for verification before shutting Plant SCADA down.",
        "example": "/* Shut down \nPlant SCADA\n on this computer. */\nShutdown();\n/* Shut down and restart \nPlant SCADA\n clients, but not this computer. */\nShutdown(\"All Clients\", ProjectRestartGet(), 6, \"ClusterXYZ\");",
        "name": "Shutdown",
        "params": [
            {
                "paramdescription": "The destination computer(s) on which Plant SCADA will be shut down, as a string:\n\"\" (blank string) - this computer only (default value).\n[\"Computer_Name\"] - a specified Plant SCADA computer. Use the name defined in the computer's CITECT.INI file. If this is not configured, you can use the Windows computer name. \n[\"Server_Name\"] - a specified Plant SCADA server computer. Shutdown will only work if the specified server is the only one configured on the computer. \n\"All Clients\" - All Plant SCADA client computers on the network.\n\"All Servers\" - All Plant SCADA server computers on the network.\n\"Everybody\" - All Plant SCADA computers on the network.",
                "paramname": "sDest"
            },
            {
                "paramdescription": "The full path of the project to run on restart as a string. The path is written to the configuration files and is used when the system restarts. The default value is \"\", which means that no changes are made to the configuration and the current project is restarted.",
                "paramname": "sProject"
            },
            {
                "paramdescription": "The type of shutdown:\n1 - Shutdown Plant SCADA only - Default value.\n2 - Shutdown and restart Plant SCADA (without logging off Windows).\n3 - Shutdown and restart Plant SCADA and log off Windows (an auto login to the Operating System and Plant SCADA needs to be configured to run on start up or log in).\n4 - Shutdown Plant SCADA and re-boot the computer.\n5 - Shutdown Plant SCADA only.\n6 - Shutdown and restart Plant SCADA on remote computers, but not this computer.\n7 - Shutdown Plant SCADA and shutdown the computer. If the computer supports power off feature the power will be turned off.",
                "paramname": "Mode"
            },
            {
                "paramdescription": " The name of the cluster to which the machine(s) named in Dest belong. This is not required if:\nthe function is called with Dest empty (the default); OR\nthe client is connected to only one cluster containing an Alarm Server.",
                "paramname": "sClusterName"
            },
            {
                "paramdescription": "Flag for initiating a user-specified shutdown event prior to shutting down. Refer to OnEvent() type code for the value of shutdown event.\n0 - no event\n1 - raise event. The user defined shutdown event handler will be called before the shutdown occurs - Default value\n0 (zero) if successful, otherwise an error code is returned.",
                "paramname": "CallEvent"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "Shutdown( [sDest] [, sProject] [, Mode] [, sClusterName] [, CallEvent])"
    },
    "shutdownform": {
        "doc": "Displays a dialog box to verify that the user really wants to shut down the Plant SCADA system. If the user selects [Yes], Plant SCADA is shut down.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "ShutdownForm",
        "params": [],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "ShutdownForm()"
    },
    "shutdownmode": {
        "doc": "Gets the mode of the last Shutdown function call. The mode is useful to identify the type of Shutdown that was performed.",
        "example": "nMode = ShutdownMode()\nIf nMode = 4 Then\n    Prompt (\"\nPlant SCADA\n closed down and computer was rebooted\")\nEND",
        "name": "ShutdownMode",
        "params": [],
        "returnType": "The shutdown mode set when shutdown was called.",
        "syntax": "ShutdownMode()"
    },
    "sign": {
        "doc": "Gets the sign of a number.",
        "example": "Variable=Sign(100);\n! Sets Variable to 1.\nVariable=Sign(-300);\n! Sets Variable to -1.\nVariable=Sign(0);\n! Sets Variable to 0.",
        "name": "Sign",
        "params": [
            {
                "paramdescription": " Any number.",
                "paramname": "Number"
            }
        ],
        "returnType": "The sign of Number.",
        "syntax": "Sign(Number)"
    },
    "sin": {
        "doc": "Calculates the trigonometric sine of an angle.",
        "example": "Variable=Sin(0.7854);\n! Sets Variable to 0.7071...",
        "name": "Sin",
        "params": [
            {
                "paramdescription": " Any angle (in radians).",
                "paramname": "Angle"
            }
        ],
        "returnType": "The sine of Angle.",
        "syntax": "Sin(Angle)"
    },
    "sleep": {
        "doc": "Suspends the current Cicode task for a specified number of seconds. After the time delay, the Cicode task wakes and continues execution. If the sleep time is 0, the Cicode task is pre-empted for 1 time slice only.\nThis function does not affect any other Cicode tasks - only the task calling Sleep() is suspended. If you have Cicode that runs continuously in a loop, you should call the Sleep() function somewhere within the loop, to pause the loop and allow other tasks to run.\nThis function is a blocking function. It will block the calling Cicode task until the operation is complete.",
        "example": "! Display \"Hello\" 10 times at 60 second intervals.\nWHILE I < 10 DO\n\tSleep(60);\n\tPrompt(\"Hello\");\n\tI = I + 1;\nEND\n! Sleep a while in polling loops\nWHILE < waiting for event or time> DO\n\t! do what ever here\n\t...\n\tSleep(10);\t! sleep a while to give other tasks a go.\n\t! the longer the sleep the better for other tasks.\nEND",
        "name": "Sleep",
        "params": [
            {
                "paramdescription": " The number of seconds. Set to 0 to pre-empt the task for one time-slice.",
                "paramname": "Seconds"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "Sleep(Seconds)"
    },
    "sleepms": {
        "doc": "Suspends the current Cicode task for a specified number of milliseconds. After the time delay, the Cicode task wakes and continues execution. This function is similar to the Sleep function but with greater resolution.\nAlthough a value of 0 milliseconds is accepted, it is not recommended. Try to use at least a value of 1.\nThis function does not affect any other Cicode tasks; only the task calling SleepMS() is suspended. If you have Cicode that runs continuously in a loop, you should call the SleepMS() or Sleep() function somewhere within the loop, to pause the loop and allow other tasks to run.\nThis function is a blocking function. It will block the calling Cicode task until the operation is complete.",
        "example": "! Increment a memory variable by ten, 120 times over one minute \n(twice a second).\nI = 0;\nWHILE I < 180 DO\n\tSleepMS(500);\n\tiRamp = iRamp + 10;\n\tI = I + 1;\nEND\n! sleep a while in polling loops\nWHILE < waiting for event or time> DO\n\t! do what ever here\n\t...\n\tSleepMS(200);\t! sleep a while to give other tasks a go.\n\t! the longer the sleep the better for other tasks.\nEND",
        "name": "SleepMS",
        "params": [
            {
                "paramdescription": "The number of milliseconds (1000 milliseconds per second). Set to 0 to pre-empt the task for one time-slice. Be careful not to use a value that is too small. Setting the value to 0 would generally have no desirable effect.",
                "paramname": "Milliseconds"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "SleepMS(Milliseconds)"
    },
    "soearchive": {
        "doc": "Use this function to archive event journals. To use this function you need to log in with a user assigned to a role that has full privileges (privilege 1..8).\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "SOEArchive",
        "params": [
            {
                "paramdescription": "The path set for SOEArchive (for example, \"C:\\temp\\SOEArchive\").\nIf a path is not entered, the default archive path for the alarm server configuration will be used.",
                "paramname": "Path: (optional)"
            },
            {
                "paramdescription": "Optional cluster on which to perform mounting operation. If not specified, the operation will be performed on all clusters.",
                "paramname": "sClusterName"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "INT SOEArchive(STRING Path[, STRING ClusterName])"
    },
    "soedismount": {
        "doc": "Use this function to dismount archive volume. To use this function you will need to log in with a role (e.g.Engineer) who has full privilege (privilege 1..8).\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "SOEDismount",
        "params": [
            {
                "paramdescription": "Optional cluster on which to perform mounting operation. If not specified, the operation will be performed on all clusters.",
                "paramname": "sClusterName"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "INT SOEDisMount([, STRING ClusterName])"
    },
    "soeeventadd": {
        "doc": "Use this function to insert an event into the Event Journal.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "SOEEventAdd",
        "params": [
            {
                "paramdescription": "The time of the inserted event.",
                "paramname": "TimeStamp"
            },
            {
                "paramdescription": "The message for the event.",
                "paramname": "Message"
            },
            {
                "paramdescription": "Alarm tag associated with the event. This can be Cluster.Tag or Tag if running on a single cluster system. If not specified the event is classed as a ‘User’ event.",
                "paramname": "Tag"
            },
            {
                "paramdescription": "Specify if running on a multi-cluster system and Tag has been specified. If Tag has not been specified and the Cluster is blank, the User event will be broadcast to all of the clusters to which the client is currently connected.",
                "paramname": "Cluster"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "INT SOEEventAdd(TIMESTAMP TimeStamp, STRING Message[,STRING Tag, STRING Cluster])"
    },
    "soemount": {
        "doc": "Use this function to mount an archive volume. Archived data from the volume can be displayed on the Alarm Summary and Sequence of events page. To use this function you will need to log in with a role (e.g.Engineer) who has full privilege (privilege 1..8).\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "SOEMount",
        "params": [
            {
                "paramdescription": "Optional cluster on which to perform mounting operation. If not specified, the operation will be performed on all clusters.",
                "paramname": "sClusterName"
            },
            {
                "paramdescription": "",
                "paramname": "0 (zero) if successful, otherwise an error code is returned."
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "INT SOEMount(STRING sPath [, STRING ClusterName])"
    },
    "spcalarms": {
        "doc": "Returns the status of the specified SPC alarm. This function is used to configure SPC alarms, by defining alarms with this trigger in Advanced Alarms.\nThis function can only be used if the Alarm Server is on the current machine. When the Alarm Server is not in the calling process, this function will become blocking and cannot be called from a foreground task. In this case, the return value will be undefined and a Cicode hardware alarm will be raised.",
        "example": "No example found",
        "name": "SPCAlarms",
        "params": [
            {
                "paramdescription": "The SPC Tag name as defined in SPC Tags.",
                "paramname": "sSPCTag"
            },
            {
                "paramdescription": "The description of the alarm type. The following types are valid:",
                "paramname": "AlarmType"
            }
        ],
        "returnType": "Alarm status, ON (1) or OFF (0).",
        "syntax": "SPCAlarms(sSPCTag, AlarmType)"
    },
    "spcclientinfo": {
        "doc": "Returns SPC data for the given SPC tag. The information retrieved through this function is from the cache maintained by the client. This function will give a faster response than the related functions which access the SPC (trend) server.\nThis function can only be called while the SPC tag is being displayed on an SPC page.",
        "example": "/* This function will check the capability of a particular SPC tag.*/\nREAL\nFUNCTION\nCheckCapability(STRING sTAG)\n    REAL rReturn;\n    rReturn = SPCClientInfo(sTag, 8);\n    !rReturn holds the inherent capability value\n    IF rReturn > 1.0 THEN\n        Message(sTag + \"Assessment\",\"The process is Capable.\",64);\n    ELSE\n        Message(sTag + \"Assessment\",\"The process is not Capable.\",64);\n    END\n    Return rReturn;\nEND",
        "name": "SPCClientInfo",
        "params": [
            {
                "paramdescription": "The SPC Tag name as defined in SPC Tags.",
                "paramname": "sSPCTag"
            },
            {
                "paramdescription": "The information to be returned:\n1 - Subgroup Size\n2 - No. of Subgroups\n3 - Process Mean (x double bar)\n4 - Process Range\n5 - Process Standard Deviation\n6 - Lower Specification Limit (LSL)\n7 - Upper Specification Limit (USL)\n8 - Cp - Process Capability Actual\n9 - Cpk - Process Capability Potential\n10 - Process Skewness\n11 - Process kurtosis",
                "paramname": "iType"
            }
        ],
        "returnType": "The requested data specified by iType. It is of type REAL.",
        "syntax": "SPCClientInfo(sSPCTag, iType)"
    },
    "spcgethistogramtable": {
        "doc": "Returns an array containing the frequencies of particular ranges for the given SPC tag. The histogram structure is implied in the order of the table as follows - the first array element is the data less than -3 sigma. The second value is the data between -3 sigma and -3 sigma plus the bar width etc. The last value is the data greater than +3 sigma.\nThis function can only be called while the SPC tag is being displayed on an SPC page.",
        "example": "/* This function will get the maximum frequency present in the\nhistogram of a particular SPC tag.*/\nREAL iFrequency[7];\n! This variable needs to be global to the file so is declared outside\nof the function\nINT\nFUNCTION\nGetMaxFreq(STRING sTAG)\n    INT        iError;\n    INT        iMax = -1;\n    iError = SPCGetHistogramTable(sTag, 7, iFrequency);\n    !The elements of iFrequency now hold the histogram table frequencies.\n    IF iError = 0 THEN\n        ! Get maximum\n        iMax = TableMath(iFrequency,7,1,0);\n    END\n    Return iMax;\nEND",
        "name": "SPCGetHistogramTable",
        "params": [
            {
                "paramdescription": "The SPC Tag name as defined in SPC Tags.",
                "paramname": "sSPCTag"
            },
            {
                "paramdescription": "The number of bars in the table. The valid range is restricted to values from 7 to 100. This also indicates the size of the array to be returned.",
                "paramname": "iNoBars"
            },
            {
                "paramdescription": "The Cicode array that will store the histogram data. The number of elements in the array needs to be equal to (or greater than) iNoBars. Must be a Real type global array variable. ",
                "paramname": "TableVariable"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error number is returned. The histogram table is written to TableVariable.",
        "syntax": "SPCGetHistogramTable(sSPCTag, iNoBars, TableVariable)"
    },
    "spcgetsubgrouptable": {
        "doc": "Returns an array containing the specified subgroup's elements with the mean, range and standard deviation. The data will be in the following order:\nElement0, Element1, ... , Element(n-1), Mean, Range, StdDev\nwhere n is the subgroup size.\nThis function can only be called while the SPC tag is being displayed on an SPC page.",
        "example": "/* This function will get the minimum value present in the sample\ndata of a particular SPC tag.*/\nREAL rSubgroup[8];        ! 5 samples + mean + range + stddev.\n! This variable needs to be global to the file, so is declared outside\nof the function\nREAL\nFUNCTION\nGetMinSample(STRING sTAG)\n    INT        iError;\n    REAL        iMin = 0;\n    iError = SPCGetSubgroupTable(sTag, 7, rSubgroup);\n    !The elements of rSubgroup now hold the group samples, mean, range and stddev.\n    IF iError = 0 THEN\n        ! Get minimum. Be aware that the range of data is 5\n        iMin = TableMath(rSubgroup,5,0,0);\n    END\n    Return iMin;\nEND",
        "name": "SPCGetSubgroupTable",
        "params": [
            {
                "paramdescription": "The SPC Tag name as defined in SPC Tags.",
                "paramname": "sSPCTag"
            },
            {
                "paramdescription": "The number of the subgroup being displayed whose data is to be retrieved. Zero ('0') represents the latest subgroup.",
                "paramname": "iSubgroup"
            },
            {
                "paramdescription": "The first element of the Cicode array that will store thesample data. . The number of elements in the array needs to beequal to (or greater than) the subgroup size + 3. Must be a Real type global arrayvariable.",
                "paramname": "TableVariable"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error number is returned. The subgroup's data is written to TableVariable.",
        "syntax": "SPCGetSubgroupTable(sSPCTag, iSubgroup, TableVariable)"
    },
    "spcplot": {
        "doc": "This function is designed to work only on an SPCXRSChart page. It prints a single page showing three separate trends of the SPC Mean, Range, and Standard Deviation. The Mean needs to be at nAN, the Range at AN + 1, and the Standard Deviation at AN + 2. You can specify a title and a comment for the plot, and whether it is printed in color or in black and white.",
        "example": "/* This function will print the Mean trend (currently displayed at \nanimation point 40), the Range trend (currently at animation point \n41), and the Standard Deviation trend (currently at animation \npoint 42). The result is a one page, black and white combination \nof all three trends, printed to LPT1. */\nSPCPlot(\"LPT1:\",40, \"\nPlant SCADA\n SPC Chart\",\"Gradually \nincreasing trend\",0);",
        "name": "SPCPlot",
        "params": [
            {
                "paramdescription": " The name of the printer port to which the plot will be printed. This name needs to be enclosed within quotation marks. For example LPT1:, to print to the local printer, or \\\\Pserver\\canon1 using UNC to print to a network printer.",
                "paramname": "sPort"
            },
            {
                "paramdescription": " The animation point at which the Mean chart is currently situated. The Range and Standard Deviation charts need to be on the next two consecutive animation numbers. For example, if the Mean chart is at animation point 40, the Range chart needs to be at animation point 41, and the Standard Deviation chart needs to be at animation point 42.",
                "paramname": "nAN"
            },
            {
                "paramdescription": " The title of the trend plot.",
                "paramname": "sTitle"
            },
            {
                "paramdescription": " The comment that is to display beneath the title of the trend plot. You do not have to enter a comment.",
                "paramname": "sComment"
            },
            {
                "paramdescription": " The color mode of the printer.\n0 - Black and White (default)\n1 - Color",
                "paramname": "nMode"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "SPCPlot(sPort, nAN [, sTitle] [, sComment] [, nMode] )"
    },
    "spcprocessxrsget": {
        "doc": "Gets the process mean, range, and standard deviation overrides for the specified SPC tag. The values that are returned are the values that are currently being used by the SPC (trend) server, not necessarily the values specified in the SPC Tag definition.\nThis function is a blocking function. It will block the calling Cicode task until the operation is complete.\nThis function can only be called while the SPC tag is being displayed on an SPC page.",
        "example": "/* This function will set a new override value for Mean, without\noverwriting the values already in place for Standard Deviation and\nRange */\nREAL rOldMean;\nREAL rRange;\nREAL rStdDev;\n! These variables need to be global to the file, so are declared\noutside of the function\nINT\nFUNCTION\nTank1SPCNewMean(REAL rNewMean)\n    INT iError;\n    iError = SPCProcessXRSGet(\"TANK_1_TEMP\", rOldMean, rRange, rStdDev);\n    ! If no error, rOldMean, rRange and rStdDev now hold the current values of XRS. \n    IF iError = 0 THEN\n        iError = SPCProcessXRSSet(\"TANK_1_TEMP\", rNewMean, rRange, rStdDev);\n    END\n    Return iError;\nEND",
        "name": "SPCProcessXRSGet",
        "params": [
            {
                "paramdescription": "The SPC Tag name as defined in SPC Tags.",
                "paramname": "sSPCTag"
            },
            {
                "paramdescription": "The Cicode variable that stores the process mean (X doublebar). A constant is not allowed. Must be a Real type global variable.",
                "paramname": "XVariable"
            },
            {
                "paramdescription": "The Cicode variable that stores the range (R). A constant is not allowed. Must be a Real type global variable.",
                "paramname": "RVariable"
            },
            {
                "paramdescription": "The Cicode variable that stores the standard deviation (S).A constant is not allowed. Must be a Real type global variable.",
                "paramname": "SVariable"
            },
            {
                "paramdescription": "Specifies the name of the cluster of the SPC tag.",
                "paramname": "sClusterName"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error number is returned. The process mean is written to XVariable, the process range to RVariable, and the standard deviation to SVariable.",
        "syntax": "SPCProcessXRSGet(sSPCTag, XVariable, RVariable, SVariable [, sClusterName] )"
    },
    "spcprocessxrsset": {
        "doc": "Sets the process mean, range and standard deviation overrides for the specified SPC tag. The values entered here will override Plant SCADA's automatic calculations, and the overrides specified in the SPC Tags definition.\nThis function is a blocking function. It will block the calling Cicode task until the operation is complete.\nThis function can only be called while the SPC tag is being displayed on an SPC page.",
        "example": "No example found",
        "name": "SPCProcessXRSSet",
        "params": [
            {
                "paramdescription": "The SPC Tag name as defined in SPC Tags.",
                "paramname": "sSPCTag"
            },
            {
                "paramdescription": "The new value of process mean (x double bar) to set.",
                "paramname": "rMean"
            },
            {
                "paramdescription": "The new value of process range to set.",
                "paramname": "rRange"
            },
            {
                "paramdescription": "The new value of process standard deviation to set.",
                "paramname": "rStdDev"
            },
            {
                "paramdescription": "Specifies the name of the cluster of the SPC tag.",
                "paramname": "sClusterName"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error number is returned.",
        "syntax": "SPCProcessXRSSet(sSPCTag, rMean, rRange, rStdDev [, sClusterName] )"
    },
    "spcsetlimit": {
        "doc": "Sets the upper or lower control limits of X-bar, range, or standard deviation charts. Using this function will only set the controller limits on the Client display which will not affect the SPC Alarms. To set the server control limits, use the SPCProcessXRSSet function.",
        "example": "SPCSetLimit(40,1,250,1);\n! Sets X-bar upper control limit to 250 at AN40.",
        "name": "SPCSetLimit",
        "params": [
            {
                "paramdescription": "The AN where the SPC chart is located.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The SPC type:\n1 - X-bar upper control limit\n2 - X-bar lower control limit\n3 - Range upper control limit\n4 - Range lower control limit\n5 - Standard deviation upper control limit\n6 - Standard deviation lower control limit\n7 - X-bar centre line\n8 - Range centre line\n9 - Standard deviation centre line",
                "paramname": "nType"
            },
            {
                "paramdescription": " The value for the control limit.",
                "paramname": "Value"
            },
            {
                "paramdescription": " Automatic calculation or manual setting of control limits:\n0 - Automatic\n1 - Manual",
                "paramname": "Setting"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "SPCSetLimit(nAN, Type, Value, Setting)"
    },
    "spcspeclimitget": {
        "doc": "Gets the process Upper and Lower Specification Limits (USL and LSL) for the specified SPC tag. The values that are returned are the values that are currently being used by the SPC (trend) server, not necessarily the values specified in the SPC Tag definition.\nThis function is a blocking function. It will block the calling Cicode task until the operation is complete.",
        "example": "/* This function will increase the current USL and LSL of the \nspecified Tag by 10 percent.*/\nREAL rLSL;\nREAL rUSL;\n! These variables need to be global to the file, so are declared \noutside of the function\nINT\nFUNCTION\nExpSLbyPercent(STRING sTAG)\n    REAL        rIncPercent = 1.1;\n    REAL        rDecPercent = 0.9;\n    INT        iError;\n    iError = SPCSpecLimitGet(sTag, rLSL, rUSL);\n    ! If no error, rLSL and rUSL now hold the current values of \n      LSL and USL for sTAG\n    rLSL = rLSL * rDecPercent;\n    rUSL = rUSL * rIncPercent;\n    IF iError = 0 THEN\n        iError = SPCSpecLimitSet(sTAG, rLSL, rUSL);\n    END\n    Return iError;\nEND\n! The function would be called as follows;",
        "name": "SPCSpecLimitGet",
        "params": [
            {
                "paramdescription": " The SPC Tag name as defined in SPC Tags.",
                "paramname": "sSPCTag"
            },
            {
                "paramdescription": " The Cicode variable that stores the Lower Specification Limit (LSL). Do not specify a constant in this field. Must be a Real type global variable.",
                "paramname": "LSLVariable"
            },
            {
                "paramdescription": " The Cicode variable that stores the Upper Specification Limit (USL). Do not specify a constant in this field. Must be a Real type global variable.",
                "paramname": "USLVariable"
            },
            {
                "paramdescription": "Specifies the name of the cluster of the SPC tag.",
                "paramname": "sClusterName"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error number is returned. The LSL is written to LSLVariable, while the USL is written to USLVariable.",
        "syntax": "SPCSpecLimitGet(sSPCTag, LSLVariable, USLVariable [, sClusterName] )"
    },
    "spcspeclimitset": {
        "doc": "Sets the process Upper and Lower Specification Limits (USL and LSL) for the specified SPC tag. The values entered here will override those specified in the SPC Tags definition.\nThis function is a blocking function. It will block the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "SPCSpecLimitSet",
        "params": [
            {
                "paramdescription": " The SPC Tag name as defined in SPC Tags.",
                "paramname": "sSPCTag"
            },
            {
                "paramdescription": " The new value of Lower Specification Limit (LSL) to set.",
                "paramname": "rLSL"
            },
            {
                "paramdescription": " The new value of Upper Specification Limit (USL) to set.",
                "paramname": "rUSL"
            },
            {
                "paramdescription": "Specifies the name of the cluster of the SPC tag.",
                "paramname": "sClusterName"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error number is returned.",
        "syntax": "SPCSpecLimitSet(sSPCTag, rLSL, rUSL [, sClusterName] )"
    },
    "spcsubgroupsizeget": {
        "doc": "Gets the subgroup size for the specified SPC tag. The value that is returned is the value that is currently being used by the SPC (trend) server, not necessarily the value specified in the SPC Tag definition.\nThis function is a blocking function. It will block the calling Cicode task until the operation is complete.\nThis function can only be called while the SPC tag is being displayed on an SPC page.",
        "example": "No example found",
        "name": "SPCSubgroupSizeGet",
        "params": [
            {
                "paramdescription": " The SPC Tag name as defined in SPC Tags.",
                "paramname": "sSPCTag"
            },
            {
                "paramdescription": " The Cicode variable that stores the subgroup size. Thisvariable needs to be defined as a global of type INT. A constant is not allowed. Must be a Long type variable.",
                "paramname": "SizeVariable"
            },
            {
                "paramdescription": "Specifies the name of the cluster of the SPC tag.",
                "paramname": "sClusterName"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error number is returned. The subgroup size is written to SizeVariable.",
        "syntax": "SPCSubgroupSizeGet(sSPCTag, SizeVariable [, sClusterName] )"
    },
    "spcsubgroupsizeset": {
        "doc": "Sets a new subgroup size for the specified SPC tag. The new subgroup size becomes the new size as long as the SPC (trend) server is running. The subgroup size is updated first in the SPC server, which then informs the clients to update. This will force re-calculation of SPC values (UCL and LCL) across the span of any displayed charts.\nThis function is a blocking function. It will block the calling Cicode task until the operation is complete.\nThis function can only be called while the SPC tag is being displayed on an SPC page.",
        "example": "/* This function increments the subgroup size for FEED_RATE_1 by\nthe specified amount. */\nINT iSize;\n! This variable needs to be global to the file, so is declared outside\nof the function\nINT\nFUNCTION\nIncSubgroupSize(INT iIncrement)\n    INT iError;\n    iError = SPCSubgroupSizeGet(\"FEED_RATE_1\", iSize);\n    ! If no error, iSize now contains the current subgroup size of FEED_RATE_1 \n    iSize = iSize + iIncrement;\n    IF iError = 0 and (isize > 1) THEN\n        iError = SPCSubgroupSizeSet(\"FEED_RATE_1\", iSize    );\n    END\n    Return iError;\nEND",
        "name": "SPCSubgroupSizeSet",
        "params": [
            {
                "paramdescription": " The SPC Tag name as defined in SPC Tags.",
                "paramname": "sSPCTag"
            },
            {
                "paramdescription": " The new size of the subgroup to set.",
                "paramname": "iSize"
            },
            {
                "paramdescription": "Specifies the name of the cluster of the SPC tag.",
                "paramname": "sClusterName"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error number is returned.",
        "syntax": "SPCSubgroupSizeSet(sSPCTag, iSize [, sClusterName] )"
    },
    "sqlappend": {
        "doc": "Appends a query string to the SQL buffer. Cicode cannot send an SQL query that is longer than 255 characters. If you have an SQL query that is longer than the 255 character limit, you can split the query into smaller strings, and use this function to append the query in the SQL buffer.\nThis function can be called in the foreground or background.\nQueries which are built on the basis of user data, for example inputed by users via graphics pages or forms, may be prone to SQL Injection attacks. In such case, try to limit the risk by using CiCode functions from parameterized queries group and refer to a professional advice in this matter. \nBuilding queries from pieces (SQLSet, SQLAppend) or adding parameters to either queries or connections (SQLParam functions) requires a few calls to respective CiCode functions. If a few functions try to manipulate the same connection in the same time some conflicts and unintended operations may occur. It is a typical multithreading problem. \nTo avoid this, instead of manipulating connections, consider using locally created and locally disposed queries. For example:",
        "example": "No example found",
        "name": "SQLAppend",
        "params": [
            {
                "paramdescription": "The handle either to the DB connection object (returned from either SQLCreate() or SQLConnect() function) or to the query handle (returned from SQLQueryCreate()). When it is the connection handle, the operation is performed on the default query in that DB connection object. When it is the query handle, the operation is performed on that query through the DB object which is associated to it.",
                "paramname": "hGeneral"
            },
            {
                "paramdescription": "The query string to append to the SQL buffer.",
                "paramname": "String"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error number is returned. (For details of the 307 error code, call the SQLErrMsg function).",
        "syntax": "SQLAppend(hGeneral, String)"
    },
    "sqlbegintran": {
        "doc": "Starts a database transaction. When you make a transaction, your changes are not written to the database until you call the SQLCommit() function. Alternatively, you can use the SQLRollBack() function to discard all changes made during the transaction.\nAfter you begin a transaction, you need to call either SQLCommit() to save the changes or SQLRollBack() to discard the changes. You need to use one of these functions to complete the transaction and release all database locks.\nA single database connection can only handle one transaction at a time. After you call SQLBeginTran(), you need to complete that transaction before you can call SQLBeginTran() again.\nIf you disconnect from a database while a transaction is active (not completed), the transaction is automatically \"rolled back\" any changes you made to the database in that transaction are discarded.\nYou do not need to begin a transaction to modify a database. Any changes you make to a database before you call the SQLBeginTran() are automatically committed, and no database locks are held.\nThe SQLBeginTran() function is not supported by all databases. If the function is not performing as you expect, check that both your database and/or DB provider support transactions. Refer to the documentation for your database for more information on transactions.\nThis function is a blocking function and should not be called from a foreground task. ",
        "example": "/* Increase each employee's salary and superannuation by a\nspecified amount. If any errors occur, the changes are aborted */\nINT\nFUNCTION\nPayIncrease(STRING sIncrease)\n    INT hSQL;\n    INT Count1;\n    INT Count2;\n    hSQL = SQLConnect(\"DRV=QEDBF\");\n    SQLBeginTran(hSQL);\n    SQLExec(hSQL, \"UPDATE C:\\DATA\\EMPLOYEE SET Salary = Salary + \" +sIncrease);\n    Count1 = SQLNumChange(hSQL);\n    SQLExec(hSQL, \"UPDATE C:\\DATA\\EMPLOYEE SET Super = Super + \" +sIncrease);\n    Count2 = SQLNumChange(hSQL);\n    IF Count1 = Count2 THEN\n        SQLCommit(hSQL);\n    ELSE\n        SQLRollBack(hSQL);\n    END\n    SQLEnd(hSQL);\n    SQLDisconnect(hSQL);\nEND",
        "name": "SQLBeginTran",
        "params": [
            {
                "paramdescription": "The handle to the DB connection object, returned from either SQLCreate() or SQLConnect() function. The handle identifies the DB connection object where details of the associated SQL connection are stored.",
                "paramname": "hSQL"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error number is returned. (For details of the 307 error code, call the SQLErrMsg function).",
        "syntax": "SQLBeginTran(hSQL)"
    },
    "sqlcall": {
        "doc": "Executes an SQL query on a database. The function returns the number of rows affected by the executed query. With this function, you can execute any SQL query or command supported by the SQL database. If it returns some data (as for SELECT query), the data is ignored. \nThis function is a blocking function and should not be called from a foreground task. \nQueries which are built on the basis of user data, for example inputed by users via graphics pages or forms, may be prone to SQL Injection attacks. In such case, try to limit the risk by using CiCode functions from parameterized queries group and refer to a professional advice in this matter. ",
        "example": "No example found",
        "name": "SQLCall",
        "params": [
            {
                "paramdescription": "The handle either to the DB connection object (returned from either SQLCreate() or SQLConnect() function) or to the query handle (returned from SQLQueryCreate()). When it is the connection handle and sSelect is an empty string, the operation is performed on the first query in that DB connection object. When it is the query handle, the operation is performed on that query through the DB object which is associated to it.",
                "paramname": "hGeneral"
            },
            {
                "paramdescription": "The SQL query to be sent to the SQL database.",
                "paramname": "sSelect"
            }
        ],
        "returnType": "The number of affected records or -1 if an error is detected. (For details call the SQLErrMsg() function). The presence of error code can be tested by calling the IsError() CiCode function.",
        "syntax": "SQLCall(hGeneral, sSelect)"
    },
    "sqlcancel": {
        "doc": "This function cancels both the current operation on the given connection and all other pending operations on the given connection. The cancellation means that the current operation on the SCADA side is immediately finished. The cancelled operation returns error code 299 and its state on the database side should be considered as undefined, that is, it is not known that it either succeeded, partially succeeded, or was unsuccessful. \nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete. It can be called in the foreground or background.",
        "example": "No example found",
        "name": "SQLCancel",
        "params": [
            {
                "paramdescription": "The handle to the connection.",
                "paramname": "hConnection"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned. (For details of the 307 error code, call the SQLErrMsg() function).",
        "syntax": "SQLCancel(hConnection)"
    },
    "sqlclose": {
        "doc": "Closes a SQL connection between the DB connection object specified by the function's parameter and a database. The DB connection object is not deleted from the memory until calling SQLDispose function.\nThis function is a blocking function and should not be called from a foreground task.",
        "example": "No example found",
        "name": "SQLClose",
        "params": [
            {
                "paramdescription": "The handle to the DB connection object, returned from the SQLCreate() function. The handle identifies the DB connection object where details of the associated SQL connection are stored. ",
                "paramname": "hSQL"
            }
        ],
        "returnType": "0 if success, otherwise an error code (For details call the SQLErrMsg() function).",
        "syntax": "SQLClose(hSQL)"
    },
    "sqlcommit": {
        "doc": "Commits (to the database) all changes made within a transaction. If you call the SQLBeginTrans() function to begin a transaction, you need to call the SQLCommit() function to save the changes you make to the database during that transaction (with the Insert, Delete, and Update SQL commands).\nThe SQLCommit() and SQLRollBack() functions both complete a transaction and release all database locks. But while the SQLCommit() function saves all changes made during the transaction, the SQLRollBack() function discards these changes. Unless you call the SQLCommit() function before you disconnect the database, the transaction is automatically rolled back any changes you made to the database in that transaction are discarded.\nThe SQLCommit() function could affect different databases in different ways. If the function is not performing as you expect, check that your database is able to service transactions. Refer to the documentation for your database for information on committing transactions.\nThis function is a blocking function and should not be called from a foreground task.",
        "example": "No example found",
        "name": "SQLCommit",
        "params": [
            {
                "paramdescription": "The handle to the DB connection object, returned from either SQLCreate() or SQLConnect() function.The handle identifies the DB connection object where details of the associated SQL connection are stored.",
                "paramname": "hSQL"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error number is returned. (For details of the 307 error code, call the SQLErrMsg() function).",
        "syntax": "SQLCommit(hSQL)"
    },
    "sqlconnect": {
        "doc": "Creates an internal database connection object and tries to connect it to a database specified by the connection string. Returns a handle to the database connection object for use by the other database functions. \nYou only require one database connection object for each database system to be accessed (for example, Oracle, dBASE, Excel, etc.).\nIt is recommended not to use an SQL database for storage of real-time data (such as alarms), because SQL databases do not provide real-time performance when accessing database data. Only use an SQL database where data transfer is not a priority (for example, recipes or reports). If you try to use SQL to store real time data, Plant SCADA's performance could be greatly decreased.\nEach database connection object created by SQLConnect should be released by calling SQLDisconnect with handle to the object. The releasing operation should be performed even when the SQL connection to database is no longer active; for example automatically dropped by a remote database or manually closed by SQLClose. Memory leaks can occur if the handles are not properly released.\nThis function is a blocking function and should not be called from a foreground task.",
        "example": "/* Make a connection to an SQL server and select the name fieldfrom each record in the employee database. */\nFUNCTION\nListNames()\n    INT hSQL;\n    STRING sName;\n    INT Status;\n    hSQL = SQLConnect(\"DSN=MyDatabase;UID=billw;SRVR=CI1\");\n    IF hSQL <> -1 THEN\n        Status = SQLExec(hSQL, \"SELECT NAME FROM EMPLOYEE\");\n        IF Status = 0 THEN\n            WHILE SQLNext(hSQL) = 0 DO\n                sName = SQLGetField(hSQL, \"NAME\");\n                .. \n            END\n            SQLEnd(hSQL);\n        ELSE\n            Message(\"Information\", SQLErrMsg(), 48);\n        END\n        SQLDisconnect(hSQL);\n    ELSE\n        Message(\"Information\", SQLErrMsg(), 48);\n    END\nEND",
        "name": "SQLConnect",
        "params": [
            {
                "paramdescription": " The connection string, in the format:\n<attribute>=<value>[;<attribute>=<value>. . .]\nAcceptable attributes and their values vary accordingly to the provider and/or the database system, so please refer to your database documentation. For example, connecting to a SQL Server via ODBC usually requires giving the computer name and the database name which can be done by defining \"Server\" and \"Database\" attributes. The same connection via OleDB requires defining the computer as \"Data Source\" and the database as \"Initial Catalog\".\nProviding username and password as a plain text in the connection string may lead to a security breach on the database side. Please consider using other forms of authentication instead of username/password login, for example Windows Authentication. If this is not possible, try to limit the database account rights and not use the same username and password for other vital parts of the system such as for SCADA.\nSome simple examples are shown below:\nODBC provider\nOleDB provider\nSQLClient Provider\nThe handle to the database connection object if the connection is successful, otherwise -1 is returned. (For details call the SQLErrMsg() function). The handle identifies the database connection object where details of the associated SQL connection to a DB are stored.",
                "paramname": "sConnect"
            }
        ],
        "returnType": "The handle to the database connection object if the connection is successful, otherwise -1 is returned. (For details call the SQLErrMsg() function). The handle identifies the database connection object where details of the associated SQL connection to a DB are stored.",
        "syntax": "SQLConnect(sConnect)"
    },
    "sqlcreate": {
        "doc": "Creates an internal DB connection object and returns a handle to the object for use by the other DB functions. The object is in disconnected state and can be connected to a database by executing the SQLOpen function.\nYou only require one DB connection object for each database system to be accessed (for example, Oracle, dBASE, Excel, etc.).\nEach DB connection object created by SQLCreate should be released by calling SQLDispose with the handle to the object. The releasing operation should be performed even when the SQL connection to DB is no longer active; for example, automatically dropped by a remote DB. Memory leaks can occur if the handles are not properly released.\nThis function can be called in the foreground or background.",
        "example": "//* Make a connection to an SQL server and select the name field\nfrom each record in the employee database. */\nFUNCTION\nListNames()\n    INT hSQL;\n    STRING sName;\n    INT Status;\n    INT hRec;\n    INT nColumns;\n    INT nRows;\n    INT i;\n    hSQL = SQLCreate(\"DSN=MyDatabase;UID=billw;SRVR=CI1\");\n    IF hSQL <> -1 THEN\n      Status = SQLOpen(hSQL);\n      IF Status = 0 THEN\n        hRec = SQLGetRecordset(hSQL, \"SELECT NAME FROM EMPLOYEE\");\n        IF hRec <> -1 THEN\n          nRows = SQLRowCount(hRec);\n          FOR i=0 TO nRows - 1 DO\n            sName = SQLGetField(hRec, \"NAME\", i);\n              .. \n          END\n          SQLEnd(hRec);\n        ELSE\n            Message(\"Information\", SQLErrMsg(), 48);\n        END\n        SQLClose(hSQL);\n      ELSE\n        Message(\"Information\", SQLErrMsg(), 48);\n      END\n      SQLDispose(hSQL);\n    END\nEND",
        "name": "SQLCreate",
        "params": [
            {
                "paramdescription": " The connection string, in the format:\n<attribute>=<value>[;<attribute>=<value>. . .]\nAcceptable attributes and their values vary accordingly to the provider and/or the database system, so please refer to your database documentation. For example, connecting to a SQL Server via ODBC usually requires giving the computer name and the database name which can be done by defining \"Server\" and \"Database\" attributes. The same connection via OleDB requires defining the computer as \"Data Source\" and the database as \"Initial Catalog\".\nProviding username and password as a plain text in the connection string may lead to a security breach on the database side. Please consider use of other forms of authentication instead of username/password login as for example Windows Authentication. If not possible, try to limit the database account rights and not use the same username and password as for other vital part of the system as for example for SCADA.\n Some simple examples are shown below:\nODBC provider\nOleDB provider\nSQLClient Provider\nThe handle to the DB connection object if the connection is successful, otherwise -1 is returned. (For details call the SQLErrMsg() function). The handle identifies the DB connection object where details of the associated SQL connection to a DB are stored.",
                "paramname": "sConnect"
            }
        ],
        "returnType": "The handle to the DB connection object if the connection is successful, otherwise -1 is returned. (For details call the SQLErrMsg() function). The handle identifies the DB connection object where details of the associated SQL connection to a DB are stored.",
        "syntax": "SQLCreate(sConnect)"
    },
    "sqldisconnect": {
        "doc": "Closes the SQL connection to a database and disposes the DB connection object specified by the function parameter.\nThis function is a blocking function and should not be called from a foreground task.",
        "example": "No example found",
        "name": "SQLDisconnect",
        "params": [
            {
                "paramdescription": "The handle to the DB connection object, returned from the SQLConnect() function. The handle identifies the DB connection object where details of the associated SQL connection are stored.",
                "paramname": "hSQL"
            }
        ],
        "returnType": "0 if success, otherwise an error code (For details call the SQLErrMsg() function).",
        "syntax": "SQLDisconnect(hSQL)"
    },
    "sqldispose": {
        "doc": "Disposes the DB connection object specified by its parameter. If there is an active SQL connection to a database, the SQL connection has to be closed before disposal.\nThis function can be called in the foreground or background.",
        "example": "No example found",
        "name": "SQLDispose",
        "params": [
            {
                "paramdescription": "The handle to the DB connection object, returned from either the SQLCreate() or SQLConnect() function. The handle identifies the DB connection object where details of the associated SQL connection are stored. ",
                "paramname": "hSQL"
            }
        ],
        "returnType": "0 - if success, otherwise an error code (For details call the SQLErrMsg() function).",
        "syntax": "SQLDispose(hSQL)"
    },
    "sqlend": {
        "doc": "The function can be called  with:            The connection handle, in which case the function releases resources allocated for the default recordset for this connection. Generally, SCADA does the operation automatically each time when a new query is executed through SQLExec on the connection, but the operation can be also triggered manually. However, using the SQLEnd() function aids efficiency and creates good programming standards. SQLEnd() releases the memory that was allocated when the last query was executed via SQLExec.The recordset handle, in which case the function then removes the disconnected recordset associated with the handle from the system. This operation has to be done each time when the recordset is no longer necessary. Not removing recordsets from the system can result in consuming all available memory and halting SCADA and other applications on a computer.\nThis function is a blocking function and should not be called from a foreground task.",
        "example": "No example found",
        "name": "SQLEnd",
        "params": [
            {
                "paramdescription": "The handle either to:\nthe DB connection object, returned from either SQLCreate() or SQLConnect() function. The handle identifies the DB connection object where details of the associated SQL connection are stored",
                "paramname": "hGeneral"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned. (For details of the 307 error code, call the SQLErrMsg() function).",
        "syntax": "SQLEnd(hGeneral)"
    },
    "sqlerrmsg": {
        "doc": "Returns an error message from either a particular data object or entire data system. If a 307 error code occurs when one of the SQL functions is called, an SQL error message is generated. Call this function to get that error message.\nThis function can be called in the foreground or background.",
        "example": "No example found",
        "name": "SQLErrMsg",
        "params": [
            {
                "paramdescription": "The handle to any data object either to the database connection object, recordset or query. The default value is -1 and then the function returns the error message for entire SQL system.",
                "paramname": "hGeneral"
            }
        ],
        "returnType": "The error message (as a string).",
        "syntax": "SQLErrMsg(hGeneral)"
    },
    "sqlexec": {
        "doc": "Executes an SQL query on a database. With this function, you can execute any SQL query or command supported by the SQL database.\nData obtained by this function is stored in the default recordset. The default recordset is always a connected recordset. Connected recordsets fetch only small portion of data when the query is executed, but later they have to fetch further portions when recordset functions are used. This kind of recordset needs open connections to DB, but they need little memory.\nThe SQLNext() function needs to be called after the SQLExec() function before you can access data in the first record.\nOnly one query can be active at a time, so there is no need to end one query before you execute another query; each time you call SQLExec(), the previous query (through a previous SQLExec() call) is automatically ended. It means that each query executed from SQLExec cleans the default recordset. \nQueries are queued for execution and a result from one query overwrites the result from preceding one. Similarly, Plant SCADA automatically ends the latest query when it disconnects the database, even if you have not called SQLEnd(). However, the SQLEnd() function aids efficiency; SQLEnd() releases the memory that was allocated when the latest query was executed.\nThis function is a blocking function and should not be called from a foreground task.\nQueries which are built on the basis of user data, for example inputed by users via graphics pages or forms, may be prone to SQL Injection attacks. In such case, try to limit the risk by using CiCode functions from parameterized queries group and refer to a professional advice in this matter. \nSQLExec(hGeneral, sSelect)\nhGeneral:\nsSelect:\n0 (zero) if successful, otherwise an error number is returned. (For details of the 307 error code, call the SQLErrMsg() function).",
        "example": "SQLExec(hSQL, sSQL);\nTo add a record to a table:\nsSQL = \"INSERT INTO PEOPLE (SURNAME, FIRSTNAME, OCCUPATION, DEPARTMENT)\n             VALUES('ALLEN','MATTHEW','PROGRAMMER','SCADA')\";\nsSQL = \"DELETE FROM (PEOPLE, PHONE) WHERE SURNAME='MARTIAN'\";\nSQLBeginTran(hSQL);\nSQLExec(hSQL,sSQL);\nIF (Message(\"Alert\", \"Do you really want to DELETE MARTIAN\", 33) = 0) THEN\n    SQLCommit(hSQL);\nELSE\n    SQLRollback(hSQL);\nEND",
        "name": "SQLExec",
        "params": [
            {
                "paramdescription": "The handle either to the DB connection object (returned from either SQLCreate() or SQLConnect() function) or to the query handle (returned from SQLQueryCreate()). When it is the connection handle and sSelect is an empty string, the operation is performed on the first query in that DB connection object. When it is the query handle, the operation is performed on that query through the DB object which is associated to it.",
                "paramname": "hGeneral"
            },
            {
                "paramdescription": "The SQL query to be sent to the SQL database.",
                "paramname": "sSelect"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error number is returned. (For details of the 307 error code, call the SQLErrMsg() function).",
        "syntax": "SQLExec(hGeneral, sSelect)"
    },
    "sqlfieldinfo": {
        "doc": "Gets information about the fields or columns selected by a SQL query. The function returns the name and width of the specified field. If you call the function within a loop, you can return the names and sizes of all the fields in the database.\nWhen the hGeneral is the connection handle, the function returns information about the default recordset. When the hGeneral is the recordset handle, the function returns information about the recordset itself.\nKeywords such as \"DATE\", \"TIME\", and \"DESC\" cannot be used as field names by some database systems. To use fields with these names, you need to append underscores to the names (for example, \"TIME_\", \"DATE_\", \"DESC_\").\nThis function can be called in the foreground or background.\nSome combinations of database drivers and databases can return no name for certain classes of fields/columns, for example for aggregation queries such as \"select SUM\". In those cases such fields can be either explicitly named in the query itself, or accessed via a unified name in the format of \"Field{ColumnNumber}\" where {ColumnNumber} is the number of the requested field/column in the recordset.",
        "example": "! Lists all fields in the Employee database\nFUNCTION\nListFields()\n    INT hSQL;\n    STRING sField;\n    INT Count;\n    INT Width;\n    INT Index;\n    SQLTraceOn(\"C:\\DATA\\TRACE.LOG\");\n    hSQL = SQLConnect(\"DRV=QEDBF\");\n    SQLExec(hSQL, \"SELECT * FROM C:\\DATA\\EMPLOYEE\");\n    Count = SQLNoFields(hSQL);\n    Index = 0;\n    WHILE Index < Count DO\n        SQLFieldInfo(hSQL,Index,sField,Width);\n        ..\n    END\n    SQLEnd(hSQL);\n    SQLDisconnect(hSQL);\n    SQLTraceOff();\nEND",
        "name": "SQLFieldInfo",
        "params": [
            {
                "paramdescription": "The handle either to:",
                "paramname": "hGeneral"
            },
            {
                "paramdescription": " The field (or column) handle, indicating the position of thefield in the database.",
                "paramname": "hField"
            },
            {
                "paramdescription": "Output Parameter: A string in which the function stores the field name. The argument is returned by the function. Must be a String type variable.",
                "paramname": "sName"
            },
            {
                "paramdescription": "Output Parameter: An integer in which the function stores the maximum number of characters in the field. The argument is returned by the function. Must be an Integer type variable.",
                "paramname": "Width"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error number is returned. (For details of the 307 error code, call the SQLErrMsg function).",
        "syntax": "SQLFieldInfo(hGeneral, hField, sName, Width)"
    },
    "sqlgetfield": {
        "doc": "Gets field or column data from a database field. To get to a specific record in the recordset, use either the SQLNext() or SQLPrev() functions or, in case of disconnected recordsets, the nRowIndex argument.\nWhen the hGeneral is the connection handle, the function returns information from the default recordset. When the hGeneral is the recordset handle, the function returns information from the recordset itself.\nKeywords such as \"DATE\", \"TIME\", and \"DESC\" cannot be used as field names by some database systems. To use fields with these names, you need to append underscores to the names (for example, \"TIME_\", \"DATE_\", \"DESC_\").\nThis function can be called in the foreground or background.\nSome combinations of database drivers and databases can return no name for certain classes of fields/columns, for example for aggregation queries such as \"select SUM\". In those cases such fields can be either explicitly named in the query itself, or accessed via a unified name in the format of \"Field{ColumnNumber}\" where {ColumnNumber} is the number of the requested field/column in the recordset.",
        "example": "No example found",
        "name": "SQLGetField",
        "params": [
            {
                "paramdescription": "The handle either to:",
                "paramname": "hGeneral"
            },
            {
                "paramdescription": "The name of the field or column.",
                "paramname": "sField"
            },
            {
                "paramdescription": "If hGeneral is a connection handle and nRowindex is not equal -1, then the function returns an empty string. ",
                "paramname": "nRowIndex"
            }
        ],
        "returnType": "The field or column data (as a string).",
        "syntax": "SQLGetField(hGeneral, sField, nRowIndex)"
    },
    "sqlgetrecordset": {
        "doc": "Executes an SQL query on a database and returns a handle to any resulting disconnected recordset. All recordsets created in this way should be closed by the SQLEnd() function. If unsuccessful, the function returns an invalid handle and an error code is returned (can be tested by IsError()). In case of no data returned, the function returns an invalid handle and no error. With this function, you can execute any SQL query or command supported by the SQL database, but it is designed mainly to work with queries returning data like for example SELECT. Queries which don't return database data, like INSERT or UPDATE, should be executed via SQLCall. \nRecordsets produced by this function are disconnected. The disconnected recordsets fetch the data from the DB when the query is executed and thus they don't need an open connection when recordset functions are used. This kind of recordset improves speed of access to data after executing the query, but may consume significant amounts of memory.\nCreating disconnected recordsets without releasing them may lead to utilizing all available memory, which can result in degraded performance.\nThis function is a blocking function and should not be called from a foreground task.\nQueries which are built on the basis of user data, for example inputed by users via graphics pages or forms, may be prone to SQL Injection attacks. In such case, try to limit the risk by using CiCode functions from parameterized queries group and refer to a professional advice in this matter. ",
        "example": "No example found",
        "name": "SQLGetRecordset",
        "params": [
            {
                "paramdescription": "The handle either to the DB connection object (returned from either SQLCreate() or SQLConnect() function) or to the query handle (returned from SQLQueryCreate()). When it is the connection handle and sSelect is an empty string, the operation is performed on the first query in that DB connection object. When it is the query handle, the operation is performed on that query through the DB object which is associated to it.",
                "paramname": "hGeneral"
            },
            {
                "paramdescription": "The SQL query to be sent to the SQL database.",
                "paramname": "sSelect"
            }
        ],
        "returnType": "The handle to a recordset holding the result of the query. If unsuccessful an invalid handle and an error code are returned (for details call the SQLErrMsg() function). If no data is returned, an invalid handle and no error message are returned. The presence of an error can be tested by calling the IsError() CiCode function",
        "syntax": "SQLGetRecordset(hGeneral, sSelect)"
    },
    "sqlgetscalar": {
        "doc": "Executes an SQL query on a database. The value from the first column of the first row is returned. With this function, you can execute any SQL query or command supported by the SQL database. If it doesn’t return any data (like INSERT or UPDATE), a respective error code is set which can be tested by calling IsError()). \nThis function is a blocking function and should not be called from a foreground task.\nQueries which are built on the basis of user data, for example inputed by users via graphics pages or forms, may be prone to SQL Injection attacks. In such case, try to limit the risk by using CiCode functions from parameterized queries group and refer to a professional advice in this matter. ",
        "example": "No example found",
        "name": "SQLGetScalar",
        "params": [
            {
                "paramdescription": "The handle either to the DB connection object (returned from either SQLCreate() or SQLConnect() function) or to the query handle (returned from SQLQueryCreate()). When it is the connection handle and sSelect is an empty string, the operation is performed on the first query in that DB connection object. When it is the query handle, the operation is performed on that query through the DB object which is associated to it.",
                "paramname": "hGeneral"
            },
            {
                "paramdescription": "The SQL query to be sent to the SQL database.",
                "paramname": "sSelect"
            },
            {
                "paramdescription": "Output Parameter: Indicated whether the returned variable is NULL. The argument is returned by the function.",
                "paramname": "isNull"
            }
        ],
        "returnType": "String representing a value from the first column and the first row of the result of executing the SQL query. If the value is NULL, the string is empty and isNull parameter is set to TRUE. If there are no records in the result, the string is empty and the error code is set to 294. For details of the 307 error code, call the SQLErrMsg() function. The presence of error code can be tested by calling the IsError() CiCode function.",
        "syntax": "SQLGetScalar(hGeneral, sSelect, isNull)"
    },
    "sqlinfo": {
        "doc": "Gets information about a database connection, recordset or query properties.\nThis function can be called in the foreground or background.",
        "example": "SQLInfo(1,2);",
        "name": "SQLInfo",
        "params": [
            {
                "paramdescription": "The handle either to:",
                "paramname": "hGeneral"
            },
            {
                "paramdescription": "The type of information to get:\n0 - The connection string\n1 - The current SQL query for connection handles and query handles or the source SQL query for recordset handles\n2 - The current database filename (only works with SQL device)\n3 - No longer supported.\n4 - No longer supported. Now returns an empty string and sets the SQL error to 'Invalid Type'.\n5 - The DB connection object's state: Closed (The connection is closed), Open (The connection is open), Connecting (The connection object is connecting to the data source. For future release), Executing (The connection object is executing a command. For future release), Fetching (The connection object is retrieving data. For future release), Broken (The connection to the data source is broken. This can occur only after the connection has been opened. A connection in this state may be closed and then re-opened. For future release). An empty string means either error occurred or the handle is invalid\n6 - The handle to the connection if used on either recordset or query handle. Note: There is no guarantee that the objects behind the connection handles still exist in the system.\n7 - Checks whether a new transaction can be opened. The function perform a check how many transaction levels have been already opened and returns TRUE if a new one can be opened, otherwise FALSE. The function doesn't check ability of the external DB to open transactions. The functions returns FALSE for recordset handles.",
                "paramname": "nType"
            }
        ],
        "returnType": "The information (as a string).",
        "syntax": "SQLInfo(hGeneral, Type)"
    },
    "sqlisnullfield": {
        "doc": "Checks presence of null value in field from a recordset. To get to a specific record in the recordset, use either the SQLNext()/SQLPrev() functions or the nRowIndex argument.\nWhen the hGeneral is the connection handle, the function returns information from the default recordset. When the hGeneral is the recordset handle, the function returns information from the recordset itself.\nThis function can be called in the foreground or background.",
        "example": "No example found",
        "name": "SQLIsNullField",
        "params": [
            {
                "paramdescription": "The handle either to:",
                "paramname": "hGeneral"
            },
            {
                "paramdescription": "The name of the field or column.",
                "paramname": "sField"
            },
            {
                "paramdescription": "The number of the row which data is requested. The first row has index 0. -1 means that an internal pointer is used instead. The pointer can be moved forward and backward by executing SQLNext() or SQLPrev() functions.",
                "paramname": "nRowIndex"
            }
        ],
        "returnType": "TRUE if the value is NULL, FALSE otherwise.",
        "syntax": "SQLIsNullField(hGeneral, sField, nRowIndex=-1)"
    },
    "sqlnext": {
        "doc": "Gets the next database record from an SQL query. Use the  SQLExec()/SQLGetRecordset()  function to select a number of records or rows from the SQL database, and then use the SQLNext() function to step through each record separately.\nWhen the hGeneral is the connection handle, the function moves in the default recordset. When the hGeneral is the recordset handle, the function moves in the recordset itself.\nThis function can be called in the foreground or background.",
        "example": "No example found",
        "name": "SQLNext",
        "params": [
            {
                "paramdescription": "The handle either to:\n0 (zero) if successful, otherwise an error number is returned. (For details of the 307 error code, call the SQLErrMsg function).",
                "paramname": "hGeneral"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error number is returned. (For details of the 307 error code, call the SQLErrMsg function).",
        "syntax": "SQLNext(hGeneral)"
    },
    "sqlnofields": {
        "doc": "When the hGeneral is the connection handle, the function returns the number of fields or columns that were returned by the last SQL statement. When the hGeneral is the recordset handle, the function returns the number of fields or columns in the recordset itself.\nThis function can be called in the foreground or background.",
        "example": "No example found",
        "name": "SQLNoFields",
        "params": [
            {
                "paramdescription": "The handle either to:\nThe number of fields. A value of 0 is returned if no fields were returned or if an error has been detected. (For details of an error code, call the SQLErrMsg function).",
                "paramname": "hGeneral"
            }
        ],
        "returnType": "The number of fields. A value of 0 is returned if no fields were returned or if an error has been detected. (For details of an error code, call the SQLErrMsg function).",
        "syntax": "SQLNoFields(hGeneral)"
    },
    "sqlnumchange": {
        "doc": "Gets the number of records that were modified in the last SQL Insert, Update, or Delete statement.\nThis function can be called in the foreground or background.",
        "example": "No example found",
        "name": "SQLNumChange",
        "params": [
            {
                "paramdescription": "The handle to the DB connection object, returned from either SQLCreate() or SQLConnect() function. The handle identifies the DB connection object where details of the associated SQL connection are stored.",
                "paramname": "hSQL"
            }
        ],
        "returnType": "The number of records that were modified. A value of 0 is returned if no fields were returned or if an error has occurred. (For details of an error code, call the SQLErrMsg function).",
        "syntax": "SQLNumChange(hSQL)"
    },
    "sqlnumfields": {
        "doc": "When hGeneral is the connection handle, the function returns the number of fields or columns that were returned by the last SQL statement. When hGeneral is the recordset handle, the function returns the number of fields or columns in the recordset itself.\nThis function can be called in the foreground or background.",
        "example": "No example found",
        "name": "SQLNumFields",
        "params": [
            {
                "paramdescription": "The handle either to:\nThe number of fields. A value of 0 is returned if no fields were returned or if an error has been detected. (For details of an error code, call the SQLErrMsg function).",
                "paramname": "hGeneral"
            }
        ],
        "returnType": "The number of fields. A value of 0 is returned if no fields were returned or if an error has been detected. (For details of an error code, call the SQLErrMsg function).",
        "syntax": "SQLNumFields(hGeneral)"
    },
    "sqlopen": {
        "doc": "Opens an SQL connection between the DB connection object specified by the function's parameter and the database defined by the connection string given before as the parameter to either SQLCreate or SQLConnect function. \nThis function is a blocking function and should not be called from a foreground task.",
        "example": "No example found",
        "name": "SQLOpen",
        "params": [
            {
                "paramdescription": "The handle to the DB connection object, returned from either the SQLCreate() or SQLConnect() function. The handle identifies the DB connection object where details of the associated SQL connection are stored. ",
                "paramname": "hSQL"
            }
        ],
        "returnType": "0 if success, otherwise an error code (For details call the SQLErrMsg() function)",
        "syntax": "SQLOpen(hSQL)"
    },
    "sqlparamsclearall": {
        "doc": "Remove all parameters associated with a particular connection object.\nEach database provider (Odbc, OleDb, SQL Server) uses parameterized queries in a different way. It is recommended that you look at documentation and examples included with your database.\nThis function is a blocking function and should not be called from a foreground task.\nBuilding queries from pieces (SQLSet, SQLAppend) or adding parameters to either queries or connections (SQLParam functions) requires a few calls to respective CiCode functions. If a few functions try to manipulate the same connection in the same time some conflicts and unintended operations may occur. It is a typical multithreading problem. \nTo avoid this, instead of manipulating connections, consider using locally created and locally disposed queries. For example:",
        "example": "No example found",
        "name": "SQLParamsClearAll",
        "params": [
            {
                "paramdescription": "The handle to the DB connection object, returned from either SQLCreate() or SQLConnect() function. The handle identifies the DB connection object where details of the associated SQL connection are stored.",
                "paramname": "hSQL"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error number is returned. (For details of the 307 error code, call the SQLErrMsg function).",
        "syntax": "SQLParamsClearAll(hSQL)"
    },
    "sqlparamssetasint": {
        "doc": "Adds or replace a parameterized query parameter and its value in the specified connection. The value of the parameter is given as integer.\nEach database provider (Odbc, OleDb, SQL Server) uses parameterized queries in a different way. It is recommended that you look at documentation and examples included with your database.\nBuilding queries from pieces (SQLSet, SQLAppend) or adding parameters to either queries or connections (SQLParam functions) requires a few calls to respective CiCode functions. If a few functions try to manipulate the same connection in the same time some conflicts and unintended operations may occur. It is a typical multithreading problem. \nTo avoid this, instead of manipulating connections, consider using locally created and locally disposed queries. For example:\nThis function is a blocking function and should not be called from a foreground task.",
        "example": "INT nError = 0;\nSTRING sValue0 = \"\";\nSTRING sValue1 = \"\";\nINT nIsNull = 0;\nINT hQueryDelete = SQLQueryCreate(hSQL);\nSQLSet(hQueryDelete, \"delete from PEOPLE where SURNAME=? and FIRSTNAME=?\");\nSQLParamsClearAll(hSQL);\n//the name of the parameter does not matter\nSQLParamsSetAsString(hSQL, \"sName\", \"CASE\");\nSQLParamsSetAsString(hSQL, \"fName\", \"CARRIE\");\nSQLCall(hQueryDelete, \"\");\nSQLParamsClearAll(hSQL);\nSQLParamsSetAsString(hSQL, \"sName\", \"JACKSON\");\nSQLParamsSetAsString(hSQL, \"fName\", \"DAVID\");\nSQLParamsSetAsInt(hSQL, \"nAge\", 28);\nSQLParamsSetAsReal(hSQL, \"nHeight\", 1.85);\nSQLCall(hSQL, \"insert into PEOPLE (SURNAME, FIRSTNAME, AGE, HEIGHT) values (?,?,?,?)\");\nSQLParamsClearAll(hSQL);\nSQLParamsSetAsString(hSQL, \"fName\", \"DAVID\");\nSQLParamsSetAsString(hSQL, \"sName\", \"JACKSON\");\nsValue0 = SQLGetScalar(hSQL, \"select AGE from PEOPLE where FIRSTNAME=? and SURNAME=?\", nIsNull);\nsValue1 = SQLGetScalar(hSQL, \"select HEIGHT from PEOPLE where FIRSTNAME=? And SURNAME=?\", nIsNull);\nINT nError = 0;\nSTRING sValue0 = \"\";\nSTRING sValue1 = \"\";\nINT nIsNull = 0;\nINT hQueryDelete = SQLQueryCreate(hSQL);\nSQLSet(hQueryDelete, \"delete from PEOPLE where SURNAME=@sName and FIRSTNAME=@fName\");\nSQLParamsClearAll(hSQL);\nSQLParamsSetAsString(hSQL, \"sName\", \"CASE\");\nSQLParamsSetAsString(hSQL, \"fName\", \"CARRIE\");\nSQLCall(hQueryDelete, \"\");\nSQLParamsClearAll(hSQL);\nSQLParamsSetAsString(hSQL, \"sName\", \"JACKSON\");\nSQLParamsSetAsString(hSQL, \"fName\", \"DAVID\");\nSQLParamsSetAsInt(hSQL, \"nAge\", 28);\nSQLParamsSetAsReal(hSQL, \"nHeight\", 1.85);\nSQLCall(hSQL, \"insert into PEOPLE (SURNAME, FIRSTNAME, AGE, HEIGHT) values (@sName, @fName, @nAge, @nHeight)\");\nSQLParamsClearAll(hSQL);\nSQLParamsSetAsString(hSQL, \"fName\", \"DAVID\");\nSQLParamsSetAsString(hSQL, \"sName\", \"JACKSON\");\nsValue0 = SQLGetScalar(hSQL, \"select AGE from PEOPLE where FIRSTNAME=@fName and SURNAME=@sName\", nIsNull);\nsValue1 = SQLGetScalar(hSQL, \"select HEIGHT from PEOPLE where FIRSTNAME=@fName And SURNAME=@sName\", nIsNull);\nINT nError = 0;\nSTRING sValue0 = \"\";\nSTRING sValue1 = \"\";\nINT nIsNull = 0;\nINT hQueryDelete = SQLQueryCreate(hSQL);\nSQLSet(hQueryDelete, \"delete from PEOPLE where SURNAME=@sName and FIRSTNAME=@fName\");\nSQLParamsSetAsString(hSQL, \"sName\", \"CASE\");\nSQLParamsSetAsString(hSQL, \"fName\", \"CARRIE\");\nSQLCall(hQueryDelete, \"\");\n//Order does not matter\nSQLParamsSetAsInt(hSQL, \"nAge\", 28);\nSQLParamsSetAsReal(hSQL, \"nHeight\", 1.85);\n//If a parameter has been defined already, setting the value again //will replace the old value.\nSQLParamsSetAsString(hSQL, \"sName\", \"JACKSON\");\nSQLParamsSetAsString(hSQL, \"fName\", \"DAVID\");\nSQLCall(hSQL, \"insert into PEOPLE (SURNAME, FIRSTNAME, AGE, HEIGHT) values (@sName, @fName, @nAge, @nHeight)\");\nsValue0 = SQLGetScalar(hSQL, \"select AGE from PEOPLE where FIRSTNAME=@fName and SURNAME=@sName\", nIsNull);\nsValue1 = SQLGetScalar(hSQL, \"select HEIGHT from PEOPLE where FIRSTNAME=@fName And SURNAME=@sName\", nIsNull);",
        "name": "SQLParamsSetAsInt",
        "params": [
            {
                "paramdescription": "The handle to the DB connection object, returned from either SQLCreate() or SQLConnect() function. The handle identifies the DB connection object where details of the associated SQL connection are stored.",
                "paramname": "hSQL"
            },
            {
                "paramdescription": "The name of the parameter to add or change.",
                "paramname": "ParamName"
            },
            {
                "paramdescription": "The value of the parameter as an integer.",
                "paramname": "ParamValue"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error number is returned. (For details of the 307 error code, call the SQLErrMsg function).",
        "syntax": "SQLParamsSetAsInt(hSQL, ParamName, ParamValue)"
    },
    "sqlparamssetasreal": {
        "doc": "Adds or replaces a parameterized query's parameter and its value in the specified connection. The value of the parameter is given as a real.\nEach database provider (Odbc, OleDb, SQL Server) uses parameterized queries in a different way. It is recommended that you look at documentation and examples included with your database.\nThis function is a blocking function and should not be called from a foreground task.\nBuilding queries from pieces (SQLSet, SQLAppend) or adding parameters to either queries or connections (SQLParam functions) requires a few calls to respective CiCode functions. If a few functions try to manipulate the same connection in the same time some conflicts and unintended operations may occur. It is a typical multithreading problem. \nTo avoid this, instead of manipulating connections, consider using locally created and locally disposed queries. For example:",
        "example": "No example found",
        "name": "SQLParamsSetAsReal",
        "params": [
            {
                "paramdescription": "The handle to the DB connection object, returned from either SQLCreate() or SQLConnect() function. The handle identifies the DB connection object where details of the associated SQL connection are stored.",
                "paramname": "hSQL"
            },
            {
                "paramdescription": "The name of the parameter to add or change.",
                "paramname": "ParamName"
            },
            {
                "paramdescription": "The value of the parameter as a real.",
                "paramname": "ParamValue"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error number is returned. (For details of the 307 error code, call the SQLErrMsg function).",
        "syntax": "SQLParamsSetAsReal(hSQL, ParamName, ParamValue)"
    },
    "sqlparamssetasstring": {
        "doc": "Adds or replaces a parameterized query's parameter and its value in the specified connection. The value of the parameter is given as a string.\nEach database provider (Odbc, OleDb, SQL Server) uses parameterized queries in a different way. It is recommended that you look at documentation and examples included with your database.\nBuilding queries from pieces (SQLSet, SQLAppend) or adding parameters to either queries or connections (SQLParam functions) requires a few calls to respective CiCode functions. If a few functions try to manipulate the same connection in the same time some conflicts and unintended operations may occur. It is a typical multithreading problem. \nTo avoid this, instead of manipulating connections, consider using locally created and locally disposed queries. For example:\nThis function is a blocking function and should not be called from a foreground task.",
        "example": "int function SAFE_SQL_CICODE_MULTITHREAD_USE()\n  //locally created query\n  int hStmt = SQLQueryCreate(hConnection);\n  //Set the query\n  SQLSet(hStmt, \"select * from TAB where NAME=@Name\");\n  //Add parameters to the query\n  SQLParamsSetAsString(hStmt, \"Name\", \"Aaa\");\n  //Execute the query\n  SQLGetRecordset(hStmt, \"\");\n  //the locally created query is disposed\n  SQLQueryDispose(hStmt);\nEnd ",
        "name": "SQLParamsSetAsString",
        "params": [
            {
                "paramdescription": "The handle to the DB connection object, returned from either SQLCreate() or SQLConnect() function. The handle identifies the DB connection object where details of the associated SQL connection are stored.",
                "paramname": "hSQL"
            },
            {
                "paramdescription": "The name of the parameter to add or change.",
                "paramname": "ParamName"
            },
            {
                "paramdescription": "The value of the parameter as a string.",
                "paramname": "ParamValue"
            },
            {
                "paramdescription": "The index specifying the type of the string:\n0 - Allowing ADO engine to use the default string type of the protocol. For SQLClient, OleDB and ODBC, the default string type is NVarChar (A variable-length stream of Unicode characters ranging between 1 and 4,000 characters);\n1 - Forcing the string type to be NVarChar;\n2 - Forcing the string type to be NChar (A fixed-length stream of Unicode characters ranging between 1 and 4,000 characters);\n3 - Forcing the string type to be VarChar (A variable-length stream of non-Unicode characters ranging between 1 and 8,000 characters. VarChar is used when the database column is varchar(max));\n4 - Forcing the string type to be Char (A fixed-length stream of non-Unicode characters ranging between 1 and 8,000 characters).\nThe default value of nStrType is 0.",
                "paramname": "nStrType"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error number is returned. (For details of the 307 error code, call the SQLErrMsg function).",
        "syntax": "SQLParamsSetAsString(hSQL, ParamName, ParamValue, nStrType)"
    },
    "sqlprev": {
        "doc": "Gets the previous database record from an SQL query. The function works only with disconnected recordsets. Use the SQLGetRecordset() function to select a number of records or rows from the SQL database, and then use the SQLNext()/SQLPrev() function to step through each record separately.\nThis function can be called in the foreground (only for disconnected recordsets) or background.",
        "example": "No example found",
        "name": "SQLPrev",
        "params": [
            {
                "paramdescription": "The handle to the disconnected recordset.",
                "paramname": "hGeneral"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error number is returned. (For details of the 307 error code, call the SQLErrMsg function).",
        "syntax": "SQLPrev(hGeneral)"
    },
    "sqlquerycreate": {
        "doc": "The function creates a new query and returns its handle. The query is empty and has to be set by using SQLSet() and/or SQLAppend() functions. The query handle can be used with the statement functions as SQLExec() or SQLGetRecordset(). \nQueries allocated by SQLQueryCreate should be disposed by SQLQueryDispose when no longer necessary. Each DB connection object has one default query which is created and disposed automatically. The default query need not be disposed by the function SQLQueryDispose. \nThis function can be called in the foreground or background.",
        "example": "No example found",
        "name": "SQLQueryCreate",
        "params": [
            {
                "paramdescription": "The handle to the DB connection object, returned from either SQLCreate() or SQLConnect() function. The handle identifies the DB connection object where details of the associated SQL connection are stored.",
                "paramname": "hSQL"
            }
        ],
        "returnType": "The handle to the query if successful, otherwise the invalid handle.",
        "syntax": "SQLQueryCreate(hSQL)"
    },
    "sqlquerydispose": {
        "doc": "The function disposes the query which handle is given as the argument.\nQueries allocated by SQLQueryCreate should be disposed by SQLQueryDispose when no longer necessary. Each DB connection object has one default query which is created and disposed automatically. The default query need not be disposed by the function SQLQueryDispose. \nThis function can be called in the foreground or background.",
        "example": "No example found",
        "name": "SQLQueryDispose",
        "params": [
            {
                "paramdescription": "The handle to the query, returned from SQLQueryCreate() function. ",
                "paramname": "hQuery"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned. (For details of the 307 error code, call the SQLErrMsg() function).",
        "syntax": "SQLQueryDispose(hQuery)"
    },
    "sqlrollback": {
        "doc": "Rolls back (discards) all changes made to the database within the current transaction. If you call the SQLBeginTrans() function to begin a transaction, you are not committed to changes to the database made by the Insert, Delete, and Update commands until you call the SQLCommit() function. You can discard these changes by calling the SQLRollBack() function.\nYou can only call the SQLRollBack() function if you have called SQLBeginTran() to begin a transaction. You do not need to begin a transaction to modify a database, but any changes you make to a database outside of a transaction are automatically committed.\nThe SQLRollBack() function could affect different databases in different ways. If the function is not performing as you expect, check that your database is able to service transactions. Refer to the documentation for your database for more information on rolling back transactions.\nThis function is a blocking function and should not be called from a foreground task.",
        "example": "No example found",
        "name": "SQLRollBack",
        "params": [
            {
                "paramdescription": "The handle to the DB connection object, returned from either SQLCreate() or SQLConnect() function. The handle identifies the DB connection object where details of the associated SQL connection are stored.",
                "paramname": "hSQL"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error number is returned. (For details of the 307 error code, call the SQLErrMsg function).",
        "syntax": "SQLRollBack(hSQL)"
    },
    "sqlrowcount": {
        "doc": "Gets the number of rows in the recordset.\nThis function can be called in the foreground or background.",
        "example": "No example found",
        "name": "SQLRowCount",
        "params": [
            {
                "paramdescription": "The handle either to:\nThe number of rows in the given recordset for disconnected recordsets. For the connected recordset, the function returns always -1.",
                "paramname": "hGeneral"
            }
        ],
        "returnType": "The number of rows in the given recordset for disconnected recordsets. For the connected recordset, the function returns always -1.",
        "syntax": "SQLRowCount(hGeneral)"
    },
    "sqlset": {
        "doc": "Sets a query string in the SQL buffer. Cicode cannot send an SQL query that is longer than 255 characters. If you have an SQL query that is longer than the 255 character limit, you can split the query into smaller strings, and use this function and the SQLAppend() function to append the query in the SQL buffer.\nThis function can be called in the foreground or background.\nQueries which are built on the basis of user data, for example inputed by users via graphics pages or forms, may be prone to SQL Injection attacks. In such case, try to limit the risk by using CiCode functions from parameterized queries group and refer to a professional advice in this matter. \nBuilding queries from pieces (SQLSet, SQLAppend) or adding parameters to either queries or connections (SQLParam functions) requires a few calls to respective CiCode functions. If a few functions try to manipulate the same connection in the same time some conflicts and unintended operations may occur. It is a typical multithreading problem. \nTo avoid this, instead of manipulating connections, consider using locally created and locally disposed queries. For example:",
        "example": "int function SAFE_SQL_CICODE_MULTITHREAD_USE()\n  //locally created query\n  int hStmt = SQLQueryCreate(hConnection);\n  //Set the query\n  SQLSet(hStmt, \"select * from TAB where NAME=@Name\");\n  //Add parameters to the query\n  SQLParamsSetAsString(hStmt, \"Name\", \"Aaa\");\n  //Execute the query\n  SQLGetRecordset(hStmt, \"\");\n  //the locally created query is disposed\n  SQLQueryDispose(hStmt);\nEnd \nhSQL = SQLConnect(\"DSN=QEDBF\");\nnError = SQLBeginTran(hSQL);\nnError = SQLSet(hSQL, \"SELECT *\");\nnError = SQLAppend(hSQL, \" FROM EMP\");\nnError = SQLAppend(hSQL, \" ORDER BY last_name\");\nhRec = SQLGetRecordset(hSQL, \"\");",
        "name": "SQLSet",
        "params": [
            {
                "paramdescription": "The handle either to the DB connection object (returned from either SQLCreate() or SQLConnect() function) or to the query handle (returned from SQLQueryCreate()). When it is the connection handle, the operation is performed on the first query in that DB connection object. When it is the query handle, the operation is performed on that query through the DB object which is associated to it.",
                "paramname": "hGeneral"
            },
            {
                "paramdescription": "The query string to set in the SQL buffer. The string needs to contain the first part of an SQL query.",
                "paramname": "sString"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error number is returned. (For details of the 307 error code, call the SQLErrMsg() function).",
        "syntax": "SQLSet(hGeneral, sString)"
    },
    "sqltraceoff": {
        "doc": "Turns off the debug trace. Use this function to stop tracing function calls that are made to the database. The trace can be turned off globally for all connections or for a specific one.\nThis function can be called in the foreground or background.",
        "example": "No example found",
        "name": "SQLTraceOff",
        "params": [
            {
                "paramdescription": "The handle to the DB connection object: INVALID HANDLE - The trace is deactivated for all DB connections (default), otherwise - The trace is deactivated for this specific DB connection object.",
                "paramname": "hSQL"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error number is returned. (For details of the 307 error code, call the SQLErrMsg function).",
        "syntax": "SQLTraceOff(hSQL)"
    },
    "sqltraceon": {
        "doc": "Turns on a debug trace. Use this function to begin tracing function calls that are made to the database. The information is written to TraceLog.dat file (the strFileName argument is currently ignored). The trace can be turned on globally for all connections or for a specific connection.\nThis function can be called in the foreground or background.",
        "example": "No example found",
        "name": "SQLTraceOn",
        "params": [
            {
                "paramdescription": "The output file name for the debug trace. Currently ignored.",
                "paramname": "sFileName"
            },
            {
                "paramdescription": "The handle to the DB connection object: INVALID HANDLE - The trace is activated for all DB connections (default), otherwise - The trace is activated for this specific DB connection object.",
                "paramname": "hSQL"
            },
            {
                "paramdescription": "Defines the level of details written to the trace file. The following values are allowed:\n0 - as per 1, but without values (default).",
                "paramname": "nTraceLevel"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error number is returned. (For details of the 307 error code, call the SQLErrMsg function).",
        "syntax": "SQLTraceOn(sFileName, hSQL, nTraceLevel)"
    },
    "sqrt": {
        "doc": "Gets the square root of a number.",
        "example": "Variable=Sqrt(4);\n! Sets Variable to 2.",
        "name": "Sqrt",
        "params": [
            {
                "paramdescription": "Any positive number.",
                "paramname": "Number"
            }
        ],
        "returnType": "The square root of Number.",
        "syntax": "Sqrt(Number)"
    },
    "strcalcwidth": {
        "doc": "Retrieves the pixel width of a string using a particular font.",
        "example": "No example found",
        "name": "StrCalcWidth",
        "params": [
            {
                "paramdescription": "The text to determine the pixel width of",
                "paramname": "sText"
            },
            {
                "paramdescription": "The font number used to calculate the pixel width of the text. (To use the default font, set to -1).",
                "paramname": "iFont"
            }
        ],
        "returnType": "The pixel width of a string using the particular font.",
        "syntax": "StrCalcWidth(sText, iFont)"
    },
    "strclean": {
        "doc": "Removes control characters from a string. Any character that is not a displayable ASCII character is removed from the string.",
        "example": "Variable=StrClean(\"*****Text*****\");\n/* Sets Variable to \"Text\" (the \"*\" character in this example\nrepresents an unprintable character). */",
        "name": "StrClean",
        "params": [
            {
                "paramdescription": "The source string.",
                "paramname": "String"
            }
        ],
        "returnType": "The string with all control characters removed.",
        "syntax": "StrClean(String)"
    },
    "strendswith": {
        "doc": "Verifies whether the given string ends with a specific string.",
        "example": "No example found",
        "name": "StrEndsWith",
        "params": [
            {
                "paramdescription": "The source string to check.",
                "paramname": "sSource"
            },
            {
                "paramdescription": "The string to search for in the source string.",
                "paramname": "sSearchTerm"
            }
        ],
        "returnType": "Returns TRUE if sSource ends with sSearchTerm, otherwise returns FALSE.",
        "syntax": "StrEndsWith(STRING sSource, STRING sSearchTerm)"
    },
    "strfill": {
        "doc": "Fills a string with a number of occurrences of another string.",
        "example": "Variable=StrFill(\"abc\",10);\n! Sets Variable to \"abcabcabca\".\nVariable=StrFill(\"x\",10);\n! Sets Variable to \"xxxxxxxxxx\".",
        "name": "StrFill",
        "params": [
            {
                "paramdescription": "The string to be repeated.",
                "paramname": "String"
            },
            {
                "paramdescription": "The length of the string.",
                "paramname": "Length"
            }
        ],
        "returnType": "The filled string.",
        "syntax": "StrFill(String, Length)"
    },
    "strformat": {
        "doc": "Converts a variable into a formatted string. This function is the equivalent of the Cicode \" :#### \" operator.",
        "example": "Variable=StrFormat(10.345,5,2,\"%\");\n! Sets Variable to \"10.35%\".",
        "name": "StrFormat",
        "params": [
            {
                "paramdescription": " The variable to format into a string.",
                "paramname": "Variable"
            },
            {
                "paramdescription": "The width of the variable after it has been converted to stringformat.",
                "paramname": "Width"
            },
            {
                "paramdescription": "The number of decimal places in the converted string.",
                "paramname": "DecPlaces"
            },
            {
                "paramdescription": "The engineering units of the variable.",
                "paramname": "EngUnits"
            }
        ],
        "returnType": "The variable (as a formatted string).",
        "syntax": "StrFormat(Variable, Width, DecPlaces, EngUnits)"
    },
    "strgetchar": {
        "doc": "Gets a single character from a string or buffer. Use this function to read a string, character by character.",
        "example": "FOR i = 0 To length DO\n    char = StrGetChar(str, i);\n    ! Get char from string\nEND",
        "name": "StrGetChar",
        "params": [
            {
                "paramdescription": "The source string. Must be a String type variable.",
                "paramname": "String"
            },
            {
                "paramdescription": "The offset in the string, commencing at 0.",
                "paramname": "iOffset"
            }
        ],
        "returnType": "The character at the offset in the string.",
        "syntax": "StrGetChar(String, iOffset)"
    },
    "strleft": {
        "doc": "Gets the left-most characters from a string.",
        "example": "Variable=StrLeft(\"ABCDEF\",2);\n! Sets Variable to \"AB\".",
        "name": "StrLeft",
        "params": [
            {
                "paramdescription": "The source string.",
                "paramname": "String"
            },
            {
                "paramdescription": "The number of characters to get from the source string.",
                "paramname": "N"
            }
        ],
        "returnType": "A string containing the left-most N characters of String. ",
        "syntax": "StrLeft(String, N)"
    },
    "strlength": {
        "doc": "Gets the length of a string.",
        "example": "Variable=StrLength(\"ABCDEF\");\n! Sets Variable to 6.",
        "name": "StrLength",
        "params": [
            {
                "paramdescription": "The source string.",
                "paramname": "String"
            }
        ],
        "returnType": "The length of the string (as an integer).",
        "syntax": "StrLength(String)"
    },
    "strlistcontainsitem": {
        "doc": "Checks whether the  string passed is an item contained in a delimited list of strings. String comparison is case insensitive. Leading and trailing spaces are removed before comparing.",
        "example": "No example found",
        "name": "StrListContainsItem",
        "params": [
            {
                "paramdescription": "Item that you wish to search for.",
                "paramname": "sItem"
            },
            {
                "paramdescription": "List to search within.",
                "paramname": "sList"
            },
            {
                "paramdescription": "The string to use as a delimiter. If this is not specified, a comma (,) is used.",
                "paramname": "sDelim"
            }
        ],
        "returnType": "Returns TRUE if the item is found in the list, otherwise returns FALSE",
        "syntax": "StrListContainsItem(STRING sItem, STRING sList, STRING sDelim)"
    },
    "strlower": {
        "doc": "Converts a string to lowercase.",
        "example": "Variable=StrLower(\"ABCDEF\");\n! Sets Variable to \"abcdef\".\nVariable=StrLower(\"AbCdEf\");\n! Sets Variable to \"abcdef\".",
        "name": "StrLower",
        "params": [
            {
                "paramdescription": "The source string.",
                "paramname": "String"
            }
        ],
        "returnType": "The string (as lowercase).",
        "syntax": "StrLower(String)"
    },
    "strmid": {
        "doc": "Gets characters from the middle of a string.",
        "example": "Variable=StrMid(\"ABCDEF\",1,3);\n! Sets Variable to \"BCD\".\nVariable=StrMid(\"ABCDEF\",4,1);\n! Sets Variable to \"E\".",
        "name": "StrMid",
        "params": [
            {
                "paramdescription": "The source string.",
                "paramname": "String"
            },
            {
                "paramdescription": "The offset in the string, commencing at 0.",
                "paramname": "Offset"
            },
            {
                "paramdescription": "The number of characters to get, commencing at the offset.",
                "paramname": "Characters"
            }
        ],
        "returnType": "A string containing the number of characters from the offset.",
        "syntax": "StrMid(String, Offset, Characters)"
    },
    "strpad": {
        "doc": "Pads a string with a number of occurrences of another string. Padding can be added to the left or to the right of a string. If the string is already longer than the required string length, the string is truncated.",
        "example": "Variable=StrPad(\"Test\",\" \",10);\n! Sets Variable to \"Test      \".\nVariable=StrPad(\"Test\",\"abc\",-14);\n! Sets Variable to \"abcabcabcaTest\".",
        "name": "StrPad",
        "params": [
            {
                "paramdescription": "The source string.",
                "paramname": "String"
            },
            {
                "paramdescription": "The padding string.",
                "paramname": "PadString"
            },
            {
                "paramdescription": "The length of the string. If a positive length is specified,padding will be added to the right of the string. If a negativelength is specified, padding will be added to the left of thestring.",
                "paramname": "Length"
            }
        ],
        "returnType": "A padded string.",
        "syntax": "StrPad(String, PadString, Length)"
    },
    "strreplace": {
        "doc": "Replaces a substring in a string with replacement substring.",
        "example": "// Replaces argument “abc” with 12. Use the sTerminators for higher precision",
        "name": "StrReplace",
        "params": [
            {
                "paramdescription": "The source string.",
                "paramname": "sString"
            },
            {
                "paramdescription": "The substring to search for.",
                "paramname": "sFindSubstring"
            },
            {
                "paramdescription": "The replacement substring. If this is not specified, it defaults to an empty string, that is, the matched substring will be removed from the original string.",
                "paramname": "sReplaceSubstring"
            },
            {
                "paramdescription": "Optional set of characters to terminate the substring. If this is not specified, it defaults to an empty string. When it is specified, the substring is only considered a match if it is enclosed by one of the characters specified by this argument.",
                "paramname": "sTerminators"
            }
        ],
        "returnType": "The replaced string.",
        "syntax": "StrReplace(sString, sFindSubstring [, sReplaceSubstring [, sTerminators]])"
    },
    "strright": {
        "doc": "Gets the rightmost characters from a string.",
        "example": "Variable=StrRight(\"ABCDEF\",2);\n! Sets Variable to \"EF\".",
        "name": "StrRight",
        "params": [
            {
                "paramdescription": "The source string.",
                "paramname": "String"
            },
            {
                "paramdescription": "The number of characters to get from the source string.",
                "paramname": "N"
            }
        ],
        "returnType": "A string containing the rightmost N characters of String. ",
        "syntax": "StrRight(String, N)"
    },
    "strsearch": {
        "doc": "Searches for a string within a string, commencing at a specified offset. The result of the search is the index in the source string, where the first character of the sub-string is found. Index 0 is the first character in the string, index 1 is the second, and so on.",
        "example": "Variable=StrSearch(1,\"ABCDEF\",\"CD\");\n! Sets Variable to 2.\nVariable=StrSearch(4,\"ABCDEF\",\"CD\");\n! Sets Variable to -1.\nVariable=StrSearch(5,\"ABCDEF\",\"F\");\n! Sets Variable to 5.",
        "name": "StrSearch",
        "params": [
            {
                "paramdescription": "The offset in the string, commencing at 0.",
                "paramname": "Offset"
            },
            {
                "paramdescription": "The source string.",
                "paramname": "String"
            },
            {
                "paramdescription": "The substring to search for.",
                "paramname": "Substring"
            }
        ],
        "returnType": "The index in the search string, or -1 if the sub-string does not exist in the string.",
        "syntax": "StrSearch(Offset, String, Substring)"
    },
    "strsetchar": {
        "doc": "Sets a single character into a string or buffer. Use this function to build up a string, character by character, and terminate the string with the end-of-string character 0 (zero). (If you use a string without a terminator in a function that expects a string, or in a Cicode expression, you could get invalid results.) To use the string to build up a buffer, you do not need the terminating 0 (zero).",
        "example": "! Set chars in buffer, Buf is NOT a valid string\n! and cannot be used where a normal string would be used.\nFOR i = 0 To length DO\n    StrSetChar(Buf, i, 30 + i);\nEND\nStrSetChar(sStr, 0, 13);        ! put CR into string\nStrSetChar(sStr, 1, 0);        ! terminate so may be used as a normal string",
        "name": "StrSetChar",
        "params": [
            {
                "paramdescription": "The destination string. Must be a String type variable.",
                "paramname": "sText"
            },
            {
                "paramdescription": "The offset in the string, commencing at 0.",
                "paramname": "iOffset"
            },
            {
                "paramdescription": "The ASCII character to set into the string.",
                "paramname": "Char"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "StrSetChar(sText, iOffset, Char)"
    },
    "strsplit": {
        "doc": "Splits a string into sub-strings based on the specified delimiter. Sub-strings are stored in a new array and a handle to this array is returned. The returned array contains the exact number of split strings. You can use the ArrayCount function to determine the number of strings into which the source was split. \n Consecutive delimiters are treated as a single delimiter. By default, leading and trailing white space is trimmed from sub-strings.",
        "example": "No example found",
        "name": "StrSplit",
        "params": [
            {
                "paramdescription": "The source string to split.",
                "paramname": "sSource"
            },
            {
                "paramdescription": "The string to use as a delimiter. If not specified, a comma (,) is used.",
                "paramname": "sDelim"
            },
            {
                "paramdescription": "Optional flag to disable the trimming of white space from sub-strings. Trimming will occur by default.",
                "paramname": "bNoTrim"
            }
        ],
        "returnType": "Returns a handle to the array containing all sub-strings.",
        "syntax": "StrSplit(STRING sSource, STRING sDelim, INT bNoTrim)"
    },
    "strtobool": {
        "doc": "Converts a string value to a Boolean value.",
        "example": "No example found",
        "name": "StrToBool",
        "params": [
            {
                "paramdescription": "Boolean value as a string. Allowable values are: TRUE, FALSE or any numeric value.",
                "paramname": "sVal"
            }
        ],
        "returnType": "Boolean value of 0 or 1.",
        "syntax": "StrToBool(sVal)"
    },
    "strtochar": {
        "doc": "Gets the ASCII code of the first character in a string.",
        "example": "Variable=StrToChar(\"ABC\");\n! Sets Variable to 65 (ASCII \"A\").",
        "name": "StrToChar",
        "params": [
            {
                "paramdescription": "The source string.",
                "paramname": "String"
            }
        ],
        "returnType": "The ASCII code of the first character in String. ",
        "syntax": "StrToChar(String)"
    },
    "strtodate": {
        "doc": "Converts a \"date\" string into a time/date variable. This variable is the same as returned from the TimeCurrent() function. To set the order of the day, month, and year, and the delimiter, use the Windows Control panel.\nTime/date functions can only be used with dates from 1980 to 2035. You should check that the date you are using is valid with the following Cicode:",
        "example": "! Australian format (dd/mm/yy) is set in the Windows Control panel.\nDateVariable=DateAdd(StrToDate(\"3/11/95\"),86400);\nNewDate= TimeToStr(DateVariable, 2);\n! Adds 24 hours to 3/11/95 and sets NewDate to \"4/11/95\".",
        "name": "StrToDate",
        "params": [
            {
                "paramdescription": "The source string.",
                "paramname": "String"
            }
        ],
        "returnType": "A time/date variable, or 274 if the time/date is out of range.",
        "syntax": "StrToDate(String)"
    },
    "strtofmt": {
        "doc": "Converts a string into field data for a format template. This function is useful for splitting a string into separate strings. After the string is converted, you can call the FmtGetField() function to extract the individual data from the template fields.",
        "example": "StrToFmt(hFmt,\"CV101 Raw Coal Conveyor\");\nName=FmtGetField(hFmt,\"Name\");\n! Sets Name to \"CV101\".",
        "name": "StrToFmt",
        "params": [
            {
                "paramdescription": "The format template handle, returned from the FmtOpen()function. The handle identifies the table where all data on theassociated format template is stored.",
                "paramname": "hFmt"
            },
            {
                "paramdescription": "The source string.",
                "paramname": "String"
            }
        ],
        "returnType": "The string (formatted as template field data).",
        "syntax": "StrToFmt(hFmt, String)"
    },
    "strtogrp": {
        "doc": "Converts a string into a group and places it into a group number. Any existing values in the group are cleared before the new values are inserted. The group string is a series of numbers separated by \" , \" to list individual values or \" .. \" to specify a range of values.",
        "example": "hGrp=GrpOpen(\"MyGrp\",1);\n! Set group to 1 ... 10 and 20, 30 and 40.\nStrToGrp(hGrp,\"1..10,20,30,40\");",
        "name": "StrToGrp",
        "params": [
            {
                "paramdescription": "The group handle, returned from the GrpOpen() function.The group handle identifies the table where all data on theassociated group is stored.",
                "paramname": "hGrp"
            },
            {
                "paramdescription": "The string to convert.",
                "paramname": "Str"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "StrToGrp(hGrp, Str)"
    },
    "strtohex": {
        "doc": "Converts a hexadecimal string into an integer. This function will search the string for the first non-blank character, and then start converting until it finds the end of the string or a non-hexadecimal numeric character. If the first non-blank character is not one of the following hexadecimal characters, the return value is 0 (zero):",
        "example": "Variable=StrToHex(\"123\");\n! Sets Variable to hex 123, decimal 291\nVariable=StrToHex(\"F2\");\n! Sets Variable to hex F2, decimal 242\nVariable=StrToHex(\"G45\");\n! Sets Variable to 0.\nVariable=StrToHex(\"-FG\");\n! Sets Variable to hex, -F decimal -15.",
        "name": "StrToHex",
        "params": [
            {
                "paramdescription": "The string to convert.",
                "paramname": "String"
            }
        ],
        "returnType": "An integer (converted from String).",
        "syntax": "StrToHex(String)"
    },
    "strtoint": {
        "doc": "Converts a string into an integer. This function will search the string for the first non-blank character, and then start converting until it finds the end of the string or a non-numeric character. If the first non-blank character is not a numeric character (0-9), a space, a \" + \" or a \" - \" sign, the return value is 0 (zero).",
        "example": "Variable=StrToInt(\"45\");\n! Sets Variable to 45.\nVariable=StrToInt(\"45.23\");\n! Sets Variable to 45.\nVariable=StrToInt(\"A45\");\n! Sets Variable to 0.",
        "name": "StrToInt",
        "params": [
            {
                "paramdescription": "The string to convert.",
                "paramname": "String"
            }
        ],
        "returnType": "An integer (converted from String).",
        "syntax": "StrToInt(String)"
    },
    "strtolines": {
        "doc": "Converts a string into separate lines that contain no more than the number of characters specified in the MaxChars argument.\nThe function splits the string by inserting newline characters into the text string, thus dividing it into separate lines. The string will be split at a whitespace character if possible, and that whitespace will be replaced by the newline character. If no whitespace characters are available then the insertion will be made at the maximum number of characters from the previous line break.",
        "example": "BrokenString=StrToLines(\"Was that a real Stegosaur?\", 5, nLines);\n!The function returns the value 6 in nLines, and Broken String now contains:\nWas \nthat \na\nreal \nStego\nsaur?\nBrokenString=StrToLines(\"It breaks the string by inserting newline characters into\n the text.\", 16, nLines);\n!The function returns the value 6 in nLines, and Broken String now contains:\nIt breaks the\nstring by\ninserting\nnewline\ncharacters into\nthe text.",
        "name": "StrToLines",
        "params": [
            {
                "paramdescription": "The string to convert.",
                "paramname": "String"
            },
            {
                "paramdescription": "The maximum number of characters permitted in each newline produced by the StrToLines() function.",
                "paramname": "MaxChars"
            },
            {
                "paramdescription": "Output Parameter: Returns the number of lines produced by the StrToLines() functionfrom the input string. This should be a Cicode INT type variable.",
                "paramname": "nLines"
            }
        ],
        "returnType": "A string containing the input string with new line characters inserted into it.",
        "syntax": "StrToLines(String,MaxChars, nLines)"
    },
    "strtolocaltext": {
        "doc": "Converts a native string into the local version of that string. (The string needs to be contained within quotation marks, as shown in the example below.) The local version is taken from the current language database(as specified using the [Language]LocalLanguage parameter).\nStrToLocalText(sText)\nsText: \nThe local version of the text if it was found, otherwise the native text or \"#MESS\" is returned, depending on the setting of the [Language]DisplayError parameter.",
        "example": "StrToLocalText(\"@(Motor Overload)\");\n! Returns the Local translation of Motor Overload.",
        "name": "StrToLocalText",
        "params": [
            {
                "paramdescription": "The string for which you would like the local translationreturned. This string needs to be enclosed in quotation marks.For example:\n\"@(Motor Overload)\"",
                "paramname": "sText"
            }
        ],
        "returnType": "The local version of the text if it was found, otherwise the native text or \"#MESS\" is returned, depending on the setting of the [Language]DisplayError parameter.",
        "syntax": "StrToLocalText(sText)"
    },
    "strtoperiod": {
        "doc": "Converts a string into a time period. You would normally use this function to convert operator input, for example, to set a trend period.\nA valid period string is in the format HH:MM:SS, MM:SS or SS, where HH is the hours, MM is the minutes and SS is the seconds. The colon character (':') represents the time delimiter for these fields, which will be the current system time delimiter as set in the Windows Control Panel.\nIf minutes are specified, seconds need to be in the range 0-59. If hours are specified, minutes need to be in the range 0-59.",
        "example": "Variable=StrToPeriod(\"200\");\n! Sets Variable to 200 (seconds).\nVariable=StrToPeriod(\"200:40\");\n! Sets Variable to 12040 (12000 + 40 seconds).\nVariable=StrToPeriod(\"48:00:40\");\n! Sets Variable to 172840 (172800 + 40 seconds).",
        "name": "StrToPeriod",
        "params": [
            {
                "paramdescription": "The string to convert.",
                "paramname": "String"
            }
        ],
        "returnType": "A period (converted from String), or -1 if no conversion can be performed.",
        "syntax": "StrToPeriod(String)"
    },
    "strtoreal": {
        "doc": "Converts a string into a floating-point number. This function will search the string for the first non-blank character, and then start converting until it finds the end of the string or a non-numeric character. If the first non-blank character is not a numeric character (0-9), a space, a decimal point, a \" + \" or a \" - \" sign, the return value is 0 (zero).",
        "example": "Variable=StrToReal(\"45\");\n! Sets Variable to 45.\nVariable=StrToReal(\"45.23\");\n! Sets Variable to 45.23\nVariable=StrToReal(\"A45\");\n! Sets Variable to 0.",
        "name": "StrToReal",
        "params": [
            {
                "paramdescription": "The string to convert.",
                "paramname": "String"
            }
        ],
        "returnType": "A floating-point number (converted from String).",
        "syntax": "StrToReal(String)"
    },
    "strtotime": {
        "doc": "Converts a \"time\" string into a time/date variable. The value returned is the number of seconds from midnight. You can add this value to the date to get the current time value. To set the time delimiter, use the Windows Control Panel.\nA valid time string is in the format HH:MM:SS or HH:MM:SS tt, where HH is the hour in the range 0-23, MM is the minute in the range 0-59, SS is the second in the range 0-59 and tt is the time extension; for example,, am or pm. The colon character ':' represents the time delimiter for these fields, which will be the current system time delimiter as set in the Windows control panel.\nTimes may also be passed in the for HH or HH:MM. In other words, you may omit the right-hand fields if they are 0.",
        "example": "Variable=StrToTime(\"11:43:00\");\n! Sets Variable to (11*3600+43*60+0) seconds.\nVariable=StrToTime(\"9:02\");\n! Sets Variable to (9*3600+2*60) seconds.\nVariable=StrToTime(\"2\");\n! Sets Variable to (2*3600) seconds.",
        "name": "StrToTime",
        "params": [
            {
                "paramdescription": "The string to convert.",
                "paramname": "String"
            }
        ],
        "returnType": "A time/date variable, or -1 if no conversion can be performed.",
        "syntax": "StrToTime(String)"
    },
    "strtotimestamp": {
        "doc": "This function  converts timestamp in a STRING format into a TIMESTAMP format. This function can be used in browsing functions to convert timestamp fields returned as a string.        ",
        "example": "No example found",
        "name": "StrToTimestamp",
        "params": [
            {
                "paramdescription": "The date and time as a STRING or TIMESTAMP",
                "paramname": "String"
            },
            {
                "paramdescription": "The format of the string. Should be 15. Other types reserved for future use.",
                "paramname": "Format"
            },
            {
                "paramdescription": "If 1, the date is considered to be in UTC. Otherwise, local time is used. This field is only applicable for format STRING formats (i.e. format is not equal 15).",
                "paramname": "UTC"
            }
        ],
        "returnType": "This function returns a date in TIMESTAMP format if successful, otherwise returns TIMESTAMP of January 1, 1601, 00:00:00 (UTC). If the function is unsuccessful you can call the IsError() function to get the actual error code.",
        "syntax": "TIMESTAMP StrToTimestamp(STRING String [, INT Format [, INT UTC]])"
    },
    "strtovalue": {
        "doc": "Converts a string into a floating-point number. This function is similar to the StrToReal() function except that the function halts if it is passed an invalid string. The function will search the string for the first non-blank character, and then start converting until it finds the end of the string or a non-numeric character. If the first non-blank character is not a numeric character (0-9), a space, a decimal point, a \" +\" or a \" - \" sign, the function will halt.\nUse this function to check keyboard input from the operator by setting control points (for example, it minimizes the likelihood of a setpoint being set to 0 if the operator presses ENTER or enters invalid data by mistake).",
        "example": "No example found",
        "name": "StrToValue",
        "params": [
            {
                "paramdescription": "The string to convert.",
                "paramname": "String"
            }
        ],
        "returnType": "A floating-point number (converted from String).",
        "syntax": "StrToValue(String)"
    },
    "strtrim": {
        "doc": "Removes leading and trailing spaces from a string. Internal spaces are not removed from the string.",
        "example": "Variable=StrTrim(\"     Test String     \");\n! Sets Variable to \"Test String\".",
        "name": "StrTrim",
        "params": [
            {
                "paramdescription": "The source string.",
                "paramname": "String"
            }
        ],
        "returnType": "String with leading and trailing spaces removed.",
        "syntax": "StrTrim(String)"
    },
    "strtruncfont": {
        "doc": "Returns the truncated string using a particular font (specified by name) or the specified number of characters.",
        "example": "No example found",
        "name": "StrTruncFont",
        "params": [
            {
                "paramdescription": "The text to truncate",
                "paramname": "sText"
            },
            {
                "paramdescription": "The name of the font that is used to display the text. The Font Name needs to be defined in the Fonts database. If the font is not found, the default font is used.",
                "paramname": "sFont"
            },
            {
                "paramdescription": "Length of the Text to display, either in characters or pixels depending on iLengthMode (default -1, no truncation)",
                "paramname": "iLength"
            },
            {
                "paramdescription": " The length mode of the text string:\n0 - Length as pixels truncated (default)\n1 - Length as pixels truncated with ellipsis\n2 - Length interpreted as characters.",
                "paramname": "iLengthMode"
            }
        ],
        "returnType": "A truncated string or the original one.",
        "syntax": "StrTruncFont(sText, sFont [, iLength] [, iLengthMode])"
    },
    "strtruncfonthnd": {
        "doc": "Returns the truncated string using a particular font (specified by font number) or the specified number of characters.",
        "example": "No example found",
        "name": "StrTruncFontHnd",
        "params": [
            {
                "paramdescription": "The text to truncate",
                "paramname": "sText"
            },
            {
                "paramdescription": "The font handle used to calculate the pixel width of the text. (To use the default font, set to -1).",
                "paramname": "hFont"
            },
            {
                "paramdescription": "Length of the Text to display, either in characters or pixels depending on iLengthMode (default -1, no truncation)",
                "paramname": "iLength"
            },
            {
                "paramdescription": " The length mode of the text string:\n0 - Length as pixels truncated (default)\n1 - Length as pixels truncated with ellipsis\n2 - Length interpreted as characters.",
                "paramname": "iLengthMode"
            }
        ],
        "returnType": "A truncated string or the original one.",
        "syntax": "StrTruncFontHnd(sText, hFont [, iLength] [, iLengthMode])"
    },
    "strtruncfonttooltip": {
        "doc": "Returns a truncated string with ellipsis, and sets an AN with a tooltip containing the complete string if a truncation occurs.",
        "example": "No example found",
        "name": "StrTruncFontTooltip",
        "params": [
            {
                "paramdescription": "The AN for which the tooltip needs to be set.",
                "paramname": "nANForTooltip"
            },
            {
                "paramdescription": "The text to truncate.",
                "paramname": "sText"
            },
            {
                "paramdescription": "The name of the font that is used to display the text. The font name needs to be defined in the Fonts database. If the font is not found, the default font is used.",
                "paramname": "sFont"
            },
            {
                "paramdescription": "Number of pixels that the text can display before truncation occurs.",
                "paramname": "nPixels"
            }
        ],
        "returnType": "Returns the truncated string.",
        "syntax": "StrTruncFontTooltip(INT nANForTooltip, STRING sText, STRING sFont, INT nPixels)"
    },
    "strupper": {
        "doc": "Converts a string to uppercase.",
        "example": "Variable=StrUpper(\"abcdef\");\n! Sets Variable to \"ABCDEF\".\nVariable=StrUpper(\"AbCdEf\");\n! Sets Variable to \"ABCDEF\".",
        "name": "StrUpper",
        "params": [
            {
                "paramdescription": "The source string.",
                "paramname": "String"
            }
        ],
        "returnType": "The string (as uppercase).",
        "syntax": "StrUpper(String)"
    },
    "strword": {
        "doc": "Gets the first word from a string. The word is removed from the string to allow the function to be repeated. Word separators can be a space, newline, carriage return, or tab character.",
        "example": "Str=\"THIS IS A STRING\";\nVariable=StrWord(Str);\n! Sets Variable to \"THIS\".\nVariable=StrWord(Str);\n! Sets Variable to \"IS\".\nVariable=StrWord(Str);\n! Sets Variable to \"A\".\nVariable=StrWord(Str);\n! Sets Variable to \"STRING\".",
        "name": "StrWord",
        "params": [
            {
                "paramdescription": "The source string.",
                "paramname": "String"
            }
        ],
        "returnType": "A string containing the first word from String .",
        "syntax": "StrWord(String)"
    },
    "subscriptionaddcallback": {
        "doc": "Adds a function callback to a tag subscription. When the value change for a subscribed tag is detected, a callback function can be called. This implements change based Cicode and avoids continuously polling a tag value to monitor changes.\nMultiple callbacks are possible to the same subscription.\nTo remove a callback from a subscription use the SubscriptionRemoveCallback function.",
        "example": "No example found",
        "name": "SubscriptionAddCallback",
        "params": [
            {
                "paramdescription": "Integer handle of the subscription to add a callback to.",
                "paramname": "iHandle"
            },
            {
                "paramdescription": "String stating the name of a function to call when the value is updated. The function should have the structure:\nWhere subsHandle is the subscription that raised the event.",
                "paramname": "sCallback"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "SubscriptionAddCallback(iHandle, sCallback)"
    },
    "subscriptiongetattribute": {
        "doc": "Reads the specified attribute value of a subscribed tag. Similar to TagRead.\nSubscriptionGetAttribute(iHandle, sAttribute [, iOffset] )\niHandle\nsAttribute\niOffset\nString representation of the cached value for a subscribed tag. On error, an  empty string and an error is set.",
        "example": "No example found",
        "name": "SubscriptionGetAttribute",
        "params": [
            {
                "paramdescription": "Integer handle of the subscription to read from.",
                "paramname": "iHandle"
            },
            {
                "paramdescription": "Attribute of the tag to read. Supported Attributes are:\nClusterName - Returns the resultant cluster context of the subscription. Forexample, for the tag subscribed as \"cluster1.tagname\", the return value is\"cluster1\".There are several possible outcomes where no cluster isspecified in the subscription: If the tag is a local tag, an empty string will bereturned. If the tag is a variable tag and the system only contains onecluster, this cluster will be returned. If the tag is a variable tag and thereis a default cluster being run in the Cicode, the default cluster will bereturned.If none of these options are true, an empty string will be returned. \nFullName - Return the full subscription name. For example, for the tag subscribed as \"cluster1.tagname\", return value is \"cluster1.tagname\". If the tag was subscribed without a cluster the return value will be the tagname.\nTagName - Return the tagname for the subscription. For example, for the tag subscribed as \"cluster1.tagname\", return value is \"tagname\".\nValue - The current value of the tag.\nValueQuality - An indication of the current quality of the tag as an integer number.\nValueTimestamp - The time when the tag last changed. It is returned as an integer value compatible with a time/data variable.\nValueTimestampMS - The millisecond part of the time when the tag last changed.",
                "paramname": "sAttribute"
            },
            {
                "paramdescription": "Optional integer expressing the zero based index of an arrayattribute. This is only valid for the Value attribute. Defaultvalue is 0.",
                "paramname": "iOffset"
            }
        ],
        "returnType": "String representation of the cached value for a subscribed tag. On error, an  empty string and an error is set.",
        "syntax": "SubscriptionGetAttribute(iHandle, sAttribute [, iOffset] )"
    },
    "subscriptiongetinfo": {
        "doc": "Reads the specified text information about a subscribed tag.",
        "example": "STRING TagName = SubscriptionGetInfo(hSub, \"TagName\");",
        "name": "SubscriptionGetInfo",
        "params": [
            {
                "paramdescription": "Integer handle of the subscription to read from.",
                "paramname": "iHandle"
            },
            {
                "paramdescription": "Attribute of the tag to read. Supported Attributes are:\nClusterName - Return the cluster context of the subscription. For example, for the tag subscribed as \"cluster1.tagname\", return value is \"cluster1\". If the tag was subscribed without a cluster the return value will be an empty string.\nFullName - Return the full subscription name. For example, for the tag subscribed as \"cluster1.tagname.field\", return value is \"cluster1.tagname.field\". If the tag was subscribed without a cluster, the return value will be the tag name and/or element name. If the tag was subscribed without an element, the return value will be thetag name and/or cluster name.\nTagName - Return the tagname for the subscription. For example, for the tag subscribed as \"cluster1.tagname\", return value is \"tagname\".\nElementName - Retrieve the element name of the subscription.\nString representation of the requested information for a subscribed tag. On error, returns an empty string and an error is set.",
                "paramname": "sAttribute"
            }
        ],
        "returnType": "String representation of the requested information for a subscribed tag. On error, returns an empty string and an error is set.",
        "syntax": "SubscriptionGetInfo(iHandle, sAttribute      )"
    },
    "subscriptiongetquality": {
        "doc": "Reads quality of a subscribed tag.",
        "example": "QUALITY  theQuality = SubscriptionGetQuality(hSub);",
        "name": "SubscriptionGetQuality",
        "params": [
            {
                "paramdescription": "Integer handle of the subscription to read from.",
                "paramname": "iHandle"
            }
        ],
        "returnType": "The quality for a subscribed tag. On error, QUAL_BAD.",
        "syntax": "SubscriptionGetQuality(iHandle    )"
    },
    "subscriptiongettag": {
        "doc": "Reads a value, quality and timestamps of a subscribed tag.",
        "example": "INT Value = SubscriptionGetTag(hSub);",
        "name": "SubscriptionGetTag",
        "params": [
            {
                "paramdescription": "Integer handle of the subscription to read from.",
                "paramname": "iHandle"
            },
            {
                "paramdescription": "Optional integer expressing the zero based index of an array attribute. This is only valid for the Value attribute. Default value is 0.",
                "paramname": "sOffset"
            }
        ],
        "returnType": "Returns a value, quality and timestamps of a subscribed tag. The type of the returned value depends on a type of the subscribed tag. The quality and timestamps of the subscribed tag are read and passed with the returned value.",
        "syntax": "SubscriptionGetTag(iHandle, sOffset      )"
    },
    "subscriptiongettimestamp": {
        "doc": "Reads the specified timestamp of a subscribed tag.",
        "example": "TIMESTAMP theTime = SubscriptionGetTimestamp(hSub, \"ValueTimestamp\");",
        "name": "SubscriptionGetTimestamp",
        "params": [
            {
                "paramdescription": "Integer handle of the subscription to read from.",
                "paramname": "iHandle"
            },
            {
                "paramdescription": "Attribute of the tag to read. Supported Attributes are:\nTimestamp - The timestamp when the tag last changed. It is default value used when this argument is not specified.\nQualityTimestamp - The timestamp when quality of the tag last changed.\nValueTimestamp - The timestamp when value of the tag last changed.\nThe requested timestamp for a subscribed tag. On error, 0 (INVALID TIMESTAMP).",
                "paramname": "sAttribute"
            }
        ],
        "returnType": "The requested timestamp for a subscribed tag. On error, 0 (INVALID TIMESTAMP).",
        "syntax": "SubscriptionGetTimestamp(iHandle, sAttribute     )"
    },
    "subscriptiongetvalue": {
        "doc": "Reads a value of a subscribed tag.",
        "example": "INT Value = SubscriptionGetValue(hSub);",
        "name": "SubscriptionGetValue",
        "params": [
            {
                "paramdescription": "Integer handle of the subscription to read from.",
                "paramname": "iHandle"
            },
            {
                "paramdescription": "Optional integer expressing the zero based index of an array attribute. Default value is 0.",
                "paramname": "sOffset"
            }
        ],
        "returnType": "Returns a value of a subscribed tag. The type of the returned variable depends on a type of the subscribed tag. The quality and timestamps of the subscribed tag are not read i.e. quality of the returned value can be consider as GOOD and its timestamps as 0 (INVALID TIMESTAMP).",
        "syntax": "SubscriptionGetValue(iHandle, sOffset     )"
    },
    "subscriptionremovecallback": {
        "doc": "Removes a function callback from a tag subscription. The subscription handle and callback function needs to match those used when adding the callback.",
        "example": "No example found",
        "name": "SubscriptionRemoveCallback",
        "params": [
            {
                "paramdescription": "Integer handle of the subscription of the callback.",
                "paramname": "iHandle"
            },
            {
                "paramdescription": "String stating the name of the callback function.",
                "paramname": "sCallback"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "SubscriptionRemoveCallback(iHandle, sCallback)"
    },
    "switchconfig": {
        "doc": "Switches focus to a specific Plant SCADA configuration application. If the specified application is not running, it will be started.",
        "example": "! Switch to the Graphics Builder.\nSwitchConfig(1);",
        "name": "SwitchConfig",
        "params": [
            {
                "paramdescription": "The configuration application:\n1 - Graphics Builder (CTDRAW32.EXE)\n2 - Not in Use\n3 - Plant SCADA Studio (CITECTIDE.EXE)\n4 - Cicode Editor (CTCICODE.EXE)",
                "paramname": "nApp"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "SwitchConfig(nApp)"
    },
    "systime": {
        "doc": "Gets the Plant SCADA internal system millisecond counter. The counter is not based on time, but counts from 0 up to the maximum integer value and then back to 0.\nYou can use this function to time events down to the millisecond level, either by subtracting the current SysTime from the SysTime at the start of the event, or by using the SysTimeDelta() function (which will give the same result).\nThe SysTime() function does not return the time of day. Use the Time() or TimeCurrent() function to obtain the time of day.\nTime/date functions can only be used with dates between 1980 and 2035. You should check that the date you are using is valid with Cicode similar to the following:",
        "example": "Start=SysTime();\n! Gets the current time.\n...\nDelay=SysTime()-Start;\n! Sets Delay to the time difference, in milliseconds.",
        "name": "SysTime",
        "params": [],
        "returnType": "The Plant SCADA internal system millisecond counter (as an integer).",
        "syntax": "SysTime()"
    },
    "systimedelta": {
        "doc": "Calculates the time difference between a start time and the current time, and updates the start time to the current time. You can time continuous events in a single operation. See the SysTime() function for information on its use.\nTime/date functions can only be used with dates between 1980 and 2035. You should check that the date you are using is valid with Cicode similar to the following:",
        "example": "Start=SysTime();\n! Gets the current time.\n...\nDelay1=SysTimeDelta(Start);\n! Sets Delay1 to the time difference from Start.\n...\nDelay2=SysTimeDelta(Start);\n! Sets Delay2 to the time difference from the last SysTimeDelta() \ncall.",
        "name": "SysTimeDelta",
        "params": [
            {
                "paramdescription": "The start time returned from the SysTime() function. Must be a Long type variable.",
                "paramname": "Start"
            }
        ],
        "returnType": "The time difference from a start time and the current time.",
        "syntax": "SysTimeDelta(Start)"
    },
    "tablelookup": {
        "doc": "Searches for a value in a table, and returns the position (offset) of the value in the table. Be aware that the first item in a table is offset 0 (zero), the next item is offset 1, etc.\nTableLookup(Table, Size, Value)\nTable: \nSize: \nValue: \nThe offset to the table value, or -1 if the value does not exist.",
        "example": "REAL Levels[5]=10,15,50,100,200;\nVariable=TableLookup(Levels,5,50);\n! Sets Variable to 2.\nVariable=TableLookup(Levels,5,45);\n! Sets Variable to -1.",
        "name": "TableLookup",
        "params": [
            {
                "paramdescription": "The table to search. The table needs to be an array of real numbers. Must be a Real type variable.",
                "paramname": "Table"
            },
            {
                "paramdescription": "The maximum number of items in the table.",
                "paramname": "Size"
            },
            {
                "paramdescription": "The value to locate.",
                "paramname": "Value"
            }
        ],
        "returnType": "The offset to the table value, or -1 if the value does not exist.",
        "syntax": "TableLookup(Table, Size, Value)"
    },
    "tablemath": {
        "doc": "Performs mathematical operations on a table of real (floating-point) numbers. This function supports minimum, maximum, average, standard deviation, and total operations on a table of values. Use this function for operating on tables returned from the trend system with the TrnGetTable() function. You can set the Mode to either accept or ignore invalid or gated data returned from TrnGetTable().\nTableMath(Table, Size, Command [, Mode] )\nTable: \nSize: \nCommand: \nMode: \nReturns the value related to the requested mathematical operation performed on the table (Minimum, Maximum, Average, Standard deviation or Total).\\",
        "example": "REAL Array[5]=10,15,50,100,200;\nREAL Min,Avg;\n! Get the minimum value.\nMin=TableMath(Array, 5, 0, 0);     ! Sets Min to 10.\n! Get the average value.\nAvg=TableMath(Array, 5, 2, 0);     ! Sets Avg to 75.",
        "name": "TableMath",
        "params": [
            {
                "paramdescription": "Any table of floating-point numbers. Must be a Real type variable.",
                "paramname": "Table"
            },
            {
                "paramdescription": "The maximum number of items in the table.",
                "paramname": "Size"
            },
            {
                "paramdescription": "The mathematical operation to perform on the table:\n0 - Minimum\n1 - Maximum\n2 - Average\n3 - Standard deviation\n4 - Total",
                "paramname": "Command"
            },
            {
                "paramdescription": "The mode of the operation:\n0 - Operate on all data - default\n1 - Ignore invalid or gated data returned from the TrnGetTable() function",
                "paramname": "Mode"
            }
        ],
        "returnType": "Returns the value related to the requested mathematical operation performed on the table (Minimum, Maximum, Average, Standard deviation or Total).\\",
        "syntax": "TableMath(Table, Size, Command [, Mode] )"
    },
    "tableshift": {
        "doc": "Shifts table items in a table by a number of positions. You can shift the table left or right. Items shifted off the end of the table are lost. Items within a table that are not replaced by other items (that have moved) are set to 0.\nTableShift(Table, Size, Count)\nTable: \nSize: \nCount: \n0 (zero) if successful, otherwise an error code is returned.",
        "example": "REAL Levels[5]=10,15,50,100,200;\nTableShift(Levels,5,2);\n/* Shifts the table items by 2 positions to the left, that is\nLevels[0]=50\nLevels[1]=100\nLevels[2]=200\nLevels[3]=0\nLevels[4]=0 */",
        "name": "TableShift",
        "params": [
            {
                "paramdescription": "The table to shift, an array of real numbers. Must be a Real type variable.",
                "paramname": "Table"
            },
            {
                "paramdescription": "The maximum number of items in the table.",
                "paramname": "Size"
            },
            {
                "paramdescription": "The number of positions to shift the table items. A negative Count moves items to the right and a positive Count moves items to the left.",
                "paramname": "Count"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "TableShift(Table, Size, Count)"
    },
    "tagbrowseclose": {
        "doc": "The TagBrowseClose function terminates an active data browse session and cleans up resources associated with the session.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "TagBrowseClose",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by a TagBrowseOpen call.",
                "paramname": "Session"
            }
        ],
        "returnType": "0 if successful -1 if unsuccessful.",
        "syntax": "INT TagBrowseClose(LONG Session)"
    },
    "tagbrowsefirst": {
        "doc": "The TagBrowseFirst function places the data browse cursor at the first record.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "// first\ncount = 1;\nTBResult = TagBrowseFirst(TBHandle);\nErrLog(\"First: \" + IntToStr(TBResult) + \", Error = \" + IntToStr(IsError()));\nWHILE (TBResult <> -1) DO\nErrLog(\"Entry \" + IntToStr(count) + \": \" +\n\"Tag: \" + TagBrowseGetField(TBHandle , \"TAG\") + \", \" +\n\"Type: \" + TagBrowseGetField(TBHandle , \"TYPE\") + \", \" +\n\"Addr: \" + TagBrowseGetField(TBHandle , \"ADDR\") + \", \" +\n\"Error = \" + IntToStr(IsError()));\n             \nTBResult = TagBrowseNext(TBHandle);\nErrLog(\"Next: \" + IntToStr(TBResult) +\n\", Error = \" + IntToStr(IsError()));\ncount = count + 1;\nEND",
        "name": "TagBrowseFirst",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by a TagBrowseOpen call.",
                "paramname": "Session"
            }
        ],
        "returnType": "0 if successful -1 if unsuccessful.",
        "syntax": "INT TagBrowseFirst(LONG Session)"
    },
    "tagbrowsegetfield": {
        "doc": "The TagBrowseGetField function retrieves the value of the specified field from the record the data browse cursor is currently referencing.",
        "example": "No example found",
        "name": "TagBrowseGetField",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by a TagBrowseOpen call.",
                "paramname": "Session"
            },
            {
                "paramdescription": "The name of the field that references the value to be returned. Supported fields are:\nADDR, ARR_SIZE, CLUSTER, COMMENT, DEADBAND, ENG_FULL, ENG_UNITS, ENG_ZERO, EQUIPMENT, FORMAT, IODEV, PSI_TYPE, RAW_FULL, RAW_ZERO, SCALED_TYPE, TAG, ITEM, TYPE",
                "paramname": "Fieldname"
            },
            {
                "paramdescription": "",
                "paramname": "For details on these fields refer to the Browse Function Field Reference."
            }
        ],
        "returnType": "The value of the specified field as a string if successful. An empty string may or may not be an indication that an error has been detected. The last error should be checked in this instance to determine if an error has actually occurred. -1 if unsuccessful.",
        "syntax": "STRING TagBrowseGetField(LONG Session, STRING FieldName)"
    },
    "tagbrowsenext": {
        "doc": "The TagBrowseNext function moves the data browse cursor forward one record.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "// next without first\nTBResult = TagBrowseNext(TBHandle);\nErrLog(\"Next: \" + IntToStr(TBResult) + \", Error = \" + IntToStr(IsError()));\nEND\n\t\t",
        "name": "TagBrowseNext",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by a TagBrowseOpen call.",
                "paramname": "Session"
            }
        ],
        "returnType": "0 if successful -1 if unsuccessful.",
        "syntax": "INT TagBrowseNext(LONG Session)"
    },
    "tagbrowsenumrecords": {
        "doc": "The TagBrowseNumRecords function gets the number of records for a given browsing session. This function may not be accurate if the following occurs:\nThe count will be a consolidated sum of all browse records per I/O Device as returned by each I/O Server in response to opening a browse session. The count reconciliation is performed on the basis of the \"best device status\", that is records with the \"best status\" are picked and the others are discarded. \"Best device status\" is calculated as follows:",
        "example": "No example found",
        "name": "TagBrowseNumRecords",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by a TagBrowseOpen call.",
                "paramname": "Session"
            }
        ],
        "returnType": "Number of records (INT) if successful -1 if unsuccessful.",
        "syntax": "INT TagBrowseNumRecords(LONG Session)"
    },
    "tagbrowseopen": {
        "doc": "The TagBrowseOpen function initiates a new browse session and returns a handle to the new session that can be used in subsequent data browse function calls. Tag records are sorted on the server and, arrive at the client in the order specified by the sorting fields parameter, or default sorting order as described below under the Sort parameter.\nTag browsing provides a snapshot of tag configuration data. It is not intended to support  live data updates. \nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.\nLONG TagBrowseOpen(STRING Filter, STRING Fields, STRING Sort[, STRING Clusters])\nFilter:\nField:\nFor full details on these fields refer to the Browse Function Field Reference.\nThe fields LOG_UNIT and NET_UNIT available when using the Cicode functions TagInfo and TagInfoEx are also supported.\nSort:\nClusters:\t\nSession handle (LONG)  if successful, -1 if unsuccessful.",
        "example": "// open\nTBResult = TagBrowseOpen(\"ADDR=*2; TYPE<=2\", \"TAG,TYPE,ADDR\", \"ADDR:D\", \"\");\nErrLog(\"Open Session ID: \" + IntToStr(TBResult) +\n\", Error = \" + IntToStr(IsError()));\nTBHandle = TBResult;\nEND",
        "name": "TagBrowseOpen",
        "params": [
            {
                "paramdescription": " Semicolon delimited list of predefined field name filters specifying the records to return during the browsing session. If you do not specify a filter string then all tag records will be displayed.\nAll string fields can be filtered based on regular expressions. Using an operator other than = will cause strings to not match the filter criteria. The following regular expressions are supported *expr, expr*, and *expr*.\n If any of the filter names are invalid, opening a browsing session will not succeed and will return an invalid handle.",
                "paramname": "Filter"
            },
            {
                "paramdescription": " Comma separated list of record fields to be returned during the browsing session. An empty field string will return all possible fields.\nSupported fields are:",
                "paramname": "Field"
            }
        ],
        "returnType": "Session handle (LONG)  if successful, -1 if unsuccessful.",
        "syntax": "LONG TagBrowseOpen(STRING Filter, STRING Fields, STRING Sort[, STRING Clusters])"
    },
    "tagbrowseprev": {
        "doc": "The TagBrowsePrev function moves the data browse cursor back one record. If you call this function after you have reached the beginning of a browse, error code 412 is returned (Databrowse session EOF).\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "TagBrowsePrev",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by a TagBrowseOpen call.",
                "paramname": "Session"
            }
        ],
        "returnType": "0 if successful -1 if unsuccessful.",
        "syntax": "INT TagBrowsePrev(LONG Session)"
    },
    "tagdebug": {
        "doc": "Displays a dialog which allows you to select from a list of the configured variable tags in your system. Once you have selected a tag, you can either press the Read button to get the tag's current value; or change the value by entering a new one, and pressing the Write button. This function should only be used fordebugging or commissioning.\nTo read or change (write) the value of an element in an array variable, type it into the dialog's variable tag field as follows:\nTagDebug()",
        "example": "TagDebug(); /* Display debug form to allow user to debug */",
        "name": "TagDebug",
        "params": [],
        "returnType": "The name of the tag entered in the dialog.",
        "syntax": "TagDebug()"
    },
    "tagdebugform": {
        "doc": "The TagDebugForm Cicode function displays a dialog that allows you to select a variable tag and perform some basic read/write operations on it.  This function is useful for debugging or commissioning a project.\nWhen the TagDebug form appears, you can perform the following tasks:",
        "example": "No example found",
        "name": "TagDebugForm",
        "params": [],
        "returnType": "The name of the tag entered in the dialog.",
        "syntax": "TagDebugForm()"
    },
    "tageventformat": {
        "doc": "Returns a handle to the format of the data used by the TagEventQueue().",
        "example": "No example found",
        "name": "TagEventFormat",
        "params": [],
        "returnType": "The format handle.",
        "syntax": "TagEventFormat()"
    },
    "tageventqueue": {
        "doc": "Opens the tag update event queue. The I/O server writes events into this queue as they are processed. These events include tag updates from drivers that support time-stamped data. \nTo read events from this queue, use the QueRead() or QuePeek() functions. The data put into the queue contains the following fields:\nTo use this function, you need to enable the tag update event queue with the [IOServer]EnableEventQueue parameter. This parameter will tell the I/O Server to start placing events into the queue. The function TagEventFormat() returns a handle to the format of the data placed into the string field.\nEnabling this formatting feature can increase CPU loading and reduce performance of the I/O Server as every tag update event is formatted and placed in the queue. You should reconsider using this feature if a decrease in performance is noticeable.\nThe maximum length of each queue is controlled by the [Code]Queue parameter. You may need to adjust this parameter so as not to miss alarm events. When the queue is full, the I/O Server will discard events.",
        "example": "\tFUNCTION\n\tReadEvents()\n\t\tINT status;\n\t\tINT queue;\n\t\tINT format;\n\t\tINT eventId;\n\t\tSTRING event;\n\t\tINT sec;\n\t\tINT ms;\n\t\tTIMESTAMP time;\n \n\t\tqueue = TagEventQueue();\n\t\tformat = TagEventFormat();\n \n\t\tIF (queue <> -1 AND format <> -1) THEN\n\t\t\tWHILE (true) DO\n\t\t\tstatus = QueRead(queue, eventId, event, 1);\n\t\t\tIF status = 0 THEN\n\t\t\t   ErrLog(\"eventId: \" + IntToStr(eventId));\n\t\t\t   StrToFmt(format, event);\n\t\t\t   ErrLog(\"   driver: \" + FmtGetField(format, \"Driver\"));\n\t\t\t   ErrLog(\"   port: \" + FmtGetField(format, \"Port\"));\n\t\t\t   ErrLog(\"   unit: \" + FmtGetField(format, \"Unit\"));\n\t\t\t   ErrLog(\"   tag: \" + FmtGetField(format, \"Tag\"));\n\t\t\t   sec = FmtGetField(format, \"Seconds\");\n\t\t\t   ms = FmtGetField(format, \"Milliseconds\");\n\t\t\t   time = TimeIntToTimestamp(sec, ms, 1);\n\t\t\t   ErrLog(\"   time: \" + TimestampToStr(time,14));\n\t\t\t   ErrLog(\"   value: \" + FmtGetField(format, \"Value\"));\n\t\t\t   ErrLog(\"   quality: \" + FmtGetField(format, \"Quality\"));\n\t\t\tEND\n\t\t   END\n\t     END\n\t END\t\n\t\t\t",
        "name": "TagEventQueue",
        "params": [],
        "returnType": "The queue handle of the Tag Update Event queue.",
        "syntax": "TagEventQueue()"
    },
    "taggetproperty": {
        "doc": "This function reads a property of a variable tag from the data source. This function replaces TagInfo.",
        "example": "// Get the engineering full scale value for the variable \"PV131\"\nEngFullScale = TagGetProperty(\"PV131\", \"EngUnitsHigh\", 0);\n// Get the cached array size for the array variable \"PLC_Array\"\nArrayLength = TagGetProperty(\"PLC_Array\", \"ArraySize\", 1);",
        "name": "TagGetProperty",
        "params": [
            {
                "paramdescription": "The name of the tag or the equipment and item name of a variable tag (using equipment.item notation) from which to get information. The tag can be prefixed by the name of the cluster that is\"ClusterName.Tag\" or \"ClusterName.Equipment.Item\".",
                "paramname": "Name"
            },
            {
                "paramdescription": "The property to read. Property names are case sensitive.Supported properties are:\nAddress - Returns the configured address of the tag (as specifiedin the variable tags form). \nArraySize - Array size of the associated tag. Returns 1 for non-array types.",
                "paramname": "Property"
            },
            {
                "paramdescription": "DataBitWidth - Number of bits used to store the value\nDescription - Tag description\nEngUnitsHigh - Maximum scaled value\nEngUnitsLow - Minimum scaled value\nEquipment - Name of the equipment associated with the Tag.\nFormat - Format bit string. The format information is stored in the integer as follows:\nFormatDecPlaces - Number of decimal places for default format\nFormatWidth - Number of characters used in default format\nFullName - Full name of the tag in the form cluster.tagname.\nItem - Name of the equipment item associated with the Tag. If the tag is not resolved, returns an empty string.\nRangeHigh - Maximum unscaled value\nRangeLow - Minimum unscaled value\nTagName - Name of the tag specified.\nType - General type of tag. Allowed values are:\nUnits - Engineering Units for example, %, mm, Volts.\nCustom1 ... Custom8 - User-defined strings.",
                "paramname": "ClusterName - Name of the cluster the tag resides on."
            },
            {
                "paramdescription": "Optional parameter that specifies from where to retrieve the value for the property.\n-1 - The mode is determined by the INI parameter [Client]TagReadCachedMode.\n0 - The property value is retrieved direct from the server in blocking mode and an error code is returned if it is not on the server (or the server is unavailable).\n1 - The property value is retrieved from the cache and an error code is returned if the cache is not loaded yet.\n2 - The property value is retrieved from the local configuration and an error code is returned if it is not available (this is the traditional behaviour).\n3 - The property value is retrieved from the cache, if the cache is loaded, and from the local configuration, if the cache is not loaded yet.\nDefault value is -1.",
                "paramname": "CachedMode"
            },
            {
                "paramdescription": "Specifies the name of the cluster in which the Tag resides.The argument is enclosed in quotation marks.",
                "paramname": "ClusterName"
            }
        ],
        "returnType": "String representation of the property of the tag. If unsuccessful, an empty string and an error code is set.",
        "syntax": "STRING TagGetProperty(STRING Name, STRING Property [, INT CachedMode] [, STRING ClusterName] )"
    },
    "taggetscale": {
        "doc": "Gets the value of a tag at a specified scale from the datasource. The value is returned as a formatted string using the tags format specification and (optionally) the engineering units. Use this function to write generic Cicode that will work with any type of tag. This function replaces TagScaleStr.",
        "example": "// Display the zero, 50% and full scale of the tag CV_123_PV\nDspText(31,0,TagGetScale(\"CV_123_PV\", 0, 1));\nDspText(32,0,TagGetScale(\"CV_123_PV\", 50, 1));\nDspText(33,0,TagGetScale(\"CV_123_PV\", 100, 1));",
        "name": "TagGetScale",
        "params": [
            {
                "paramdescription": "The name of the tag, or the equipment and item name of a variable tag (using equipment.item notation). The tag can be prefixed bythe name of the cluster that is \"ClusterName.Tag\".",
                "paramname": "Name"
            },
            {
                "paramdescription": "The percentage of full scale of the returned value.",
                "paramname": "Percent"
            },
            {
                "paramdescription": "Flag to determine if the value is returned with engineeringunits:\n0 - Do not return the value with engineering units\n1 - Return the value with engineering units",
                "paramname": "EngUnits"
            },
            {
                "paramdescription": "Optional parameter that specifies from where to retrieve the value for the property. \n-1 - The mode is determined by the INI parameter [Client]TagReadCachedMode.\n0 - The property value is retrieved direct from the server in blocking mode and an error code is returned if it is not on the server (or the server is unavailable).\n1 - The property value is retrieved from the cache and an error code is returned if the cache is not loaded yet.\n2 - The property value is retrieved from the local configuration and an error code is returned if it is not available (this is the traditional behaviour).\n3 - The property value is retrieved from the cache, if the cache is loaded, and from the local configuration, if the cache is not loaded yet.\nDefault value is -1.",
                "paramname": "CachedMode"
            },
            {
                "paramdescription": "Specifies the name of the cluster in which the Tag resides.The argument is enclosed in quotation marks.",
                "paramname": "ClusterName"
            }
        ],
        "returnType": "The scale of the tag (as a string).",
        "syntax": "TagGetScale(STRING Name, INT Percent, INT EngUnits [, INT CachedMode] [, STRING ClusterName] )"
    },
    "taggetvalue": {
        "doc": "Reads the value, quality and timestamp of a tag based on the tag subscription. \nThis function sets up an asynchronous subscription that checks  at the specified polling period whether the value of a tag has changed. If the function fails to get a value from the tag initially, subsequent calls at periodic intervals retrieve the tag value. Unused subscriptions initiated by the function automatically expire at the end of the  timeout period. \nThis is a non-blocking function.",
        "example": "No example found",
        "name": "TagGetValue",
        "params": [
            {
                "paramdescription": "String representing the tag/tag element/ the equipment and item name (using equipment.item notation) associated with that tag, to subscribe to in the form of \"cluster_name.tag_name.element name\" or \"cluster_name.equipment. item.element_name\". If the element name (for example, 'Field') is not specified, it will be resolved at runtime as an unqualified tag reference. . If you need to access a specific tag element item to get timestamp and quality values, use the nItem parameter as well (for further information, refer to the Tag Extensions documentation in the main help).\nIf the TagName represents an array, the entire array is subscribed and will be reused. Note that square brackets for array indexing are unsupported. To retrieve values from individual elements of the array, use the nindex parameter.",
                "paramname": "TagName"
            },
            {
                "paramdescription": "Optional element number to access tag element values. For more information, refer to the Tag Extensions documentation in the main help.",
                "paramname": "Item"
            },
            {
                "paramdescription": "Optional index for an array variable. If not specified, it has a default value of 0. Since the TagName parameter does not support array indexing, use the Index parameter to access an element in an array. Note that the address of the first element in an array is 0 (zero).",
                "paramname": "Index"
            },
            {
                "paramdescription": "Optional integer representing the Datasource Poll time in milliseconds. Default is 250 milliseconds.",
                "paramname": "PollTime"
            },
            {
                "paramdescription": "Optional number to specify scaling mode of subscription.\n(Deadband, Lightweight, KeepAliveSeconds: Unchanged.)",
                "paramname": "ScaleMode"
            },
            {
                "paramdescription": "Optional real value specifying the percentage of the variable tag's engineering range by which a tag needs to change for an update to be sent through the system. Default is -1.0, indicating the deadband specified by the tag definition is to be used.",
                "paramname": "Deadband"
            },
            {
                "paramdescription": "This optional boolean argument indicates whether or not subscription updates use a \"lightweight\" version of the tag value that does not includea quality timestamp or a value timestamp. \nIf not used, this option is set to 1 which means lightweight tag values will be used by default. ",
                "paramname": "Lightweight"
            },
            {
                "paramdescription": "Optional length of time (in seconds) for which the subscription will remain in memory. The default is 30 seconds. If there are multiple requests to the same tag with different timeout values, only the first timeout value will be taken into account. ",
                "paramname": "KeepAliveSeconds"
            }
        ],
        "returnType": "Returns the value, quality and timestamp of a subscribed tag. The data type of the value returned depends on the type of the subscribed tag and also the tag extension. The quality and timestamp of the subscribed tag are read and passed with the value returned by the function. ",
        "syntax": "TagGetValue(STRING TagName  [, INT Item] [, INT Index] [, LONG PollTime] [, INT ScaleMode] [, REAL Deadband]  [, INT Lightweight] [, LONG KeepAliveSeconds])"
    },
    "taginfo": {
        "doc": "Gets information about a variable tag. This function allows you to develop generic Cicode and Super Genies.",
        "example": "/* Get the engineering full scale value for the variable \"PV131\" */\nEngFullScale = TagInfo(\"PV131\", 5);\n/* Get the engineering zero scale value for the array variable \"PLC_Array\" */\nEngZeroScale = TagInfo(\"PLC_Array\", 4);",
        "name": "TagInfo",
        "params": [
            {
                "paramdescription": "The name of the tag or the equipment and item reference of a variable tag (using equipment.item notation) from which to get information. The tag can be prefixed by the name of the cluster that is\"ClusterName.Tag\" or \"ClusterName.Equipment.Item\".\nTo get information on a particular element in an array, enter the array name here, followed by the number of the element as follows:\n\"PLC_Array[9]\"\nThe above example tells the function to get information on the tenth element in PLC_Array (remember, the address of the first element in an array is 0 (zero)).",
                "paramname": "Name"
            },
            {
                "paramdescription": "The type of information to get:\n0 - The Tag name from the variables table. This is the same as sName argument. (Returned to be compatible with the AssInfo() function). An empty string is returned if Type is 0.\n1 - Engineering units\n2 - Raw zero scale\n3 - Raw full scale\n4 - Engineering zero scale\n5 - Engineering full scale\n6 - Width of the format\n7 - Number of decimal places of format\n8 - The Tag format as a long integer. The format information is stored in the integer as follows:",
                "paramname": "Type"
            },
            {
                "paramdescription": "Bits 0-7 - format width\nBits 8-15 - number of decimal places\nBits 16 - zero-padded\nBit 17- left-justified \nBit 18 - display engineering units\nBit 20 - exponential (scientific) notation \n9 - Logical Unit Number - I/O device number (for internal use)\n10 - Raw Type - Protocol's raw data type number for this tag. Type numbers are:",
                "paramname": ""
            },
            {
                "paramdescription": "0 - Digital\n1 - Integer\n2 - Real\n3 - BCD\n4 - Long\n5 - Long BCD\n6 - Long Real\n7 - String\n8 - Byte\n10 - Unsigned integer\n11 - Bit Width - Tag's size in bits. For example, an INT is 16 bits\n12 - Unit Type - Protocol's unit type number for this tag\n13 - Unit Address - Tag's address after the protocol DBF's template is applied.\n14 - Unit Count - Array size. For example, if the tag's address is I1[50], the unit count is 50.\n15 - Record Number - Tag's record number in variable.DBF - 1. That is, the first tag has a record number of 0.\n16 - Comment - As defined in the variable tags list.\n17 - ClusterName of the tag. If the tag is not resolved, returns an empty string.\n18 - Full name (cluster.tagname) of the tag. If the tag is not resolved, returns an empty string.\n19 - Reserved for internal operation.\n20 - Configured Address of the tag. If the tag is not resolved, returns anempty string.\n21 - Network Number - I/O device number (as defined by the Number field of the I/O Devices dialog).\n22 - Name of the equipment associated with the Tag. If the tag is not resolved, returns an empty string.\nIf the tag is a local variable, mode 9 error code 348 is retrieved when cache mode is 0,1,2,3. Modes 12, 13, 14 and 15 will return an empty string (error 274 is trapped).\n23 - General Type.",
                "paramname": ""
            },
            {
                "paramdescription": "0 - Digital\n1 - Byte\n2 - Integer16\n3 - UInteger 16\n4 - Long\n5 - Real\n6 - String\n7 - ULong\n8 - Undefined\n24 - Reserved for internal use.\n25 - Name of the equipment item associated with the Tag. If the tag is not resolved, returns an empty string.\n26 - Custom 1 - a user-defined string.\n27 - Custom 2 - a user-defined string.\n28 - Custom 3 - a user-defined string.\n29 - Custom 4 - a user-defined string.\n30 - Custom 5 - a user-defined string.\n31 - Custom 6 - a user-defined string.\n32 - Custom 7 - a user-defined string.\n33 - Custom 8 - a user-defined string.",
                "paramname": ""
            },
            {
                "paramdescription": "Specifies the name of the cluster in which the Tag resides.The argument is enclosed in quotation marks.",
                "paramname": "ClusterName"
            },
            {
                "paramdescription": "Optional parameter that specifies from where to retrieve the value for the property.\n-1 - The mode is determined by the INI parameter [Client]TagReadCachedMode.\n0 - The property value is retrieved direct from the server in blocking mode and an error code is returned if it is not on the server (or the server is unavailable).\n1 - The property value is retrieved from the cache and an error code is returned if the cache is not loaded yet.\n2 - The property value is retrieved from the local configuration and an error code is returned if it is not available (this is the traditional behaviour).\n3 - The property value is retrieved from the cache, if the cache is loaded, and from the local configuration, if the cache is not loaded yet.\nDefault value is -1.\nThe value of the information as a string. ",
                "paramname": "CachedMode"
            }
        ],
        "returnType": "The value of the information as a string. ",
        "syntax": "STRING TagInfo(STRING Name, INT Type [, STRING ClusterName] [, INT CachedMode] )"
    },
    "taginfoex": {
        "doc": "This function replaces TagInfo and is identical in operation. It supports online changes. It is recommended therefore that instances of TagInfo in legacy code are migrated to either TagInfoEx or TagGetProperty. New Cicode should use TagGetProperty.\nGets information about a variable tag. This function allows you to develop generic Cicode and Super Genies. Execution can be blocking or non-blocking depending on the iCached argument.",
        "example": "/* Get the engineering full scale value for the variable \"PV131\".\nObtain the value from Cluster1 in blocking mode */\nEngFullScale = TagInfoEx(\"PV131\", 5, \"Cluster1\", 0);\n/* Get the engineering zero scale value for the array variable\n\"PLC_Array\" in non-blocking mode*/\nEngZeroScale = TagInfoEx(\"PLC_Array\", 4);",
        "name": "TagInfoEx",
        "params": [
            {
                "paramdescription": "The name of the tag or the equipment and item name of a variable tag (using equipment.item notation) from which to get information. Thename of the tag can be prefixed by the name of the cluster that is\"ClusterName.Tag\" or \"ClusterName.Equipment.Item\".\nTo get information on a particular element in an array, enter the array name here, followed by the number of the element as follows:\n\"PLC_Array[9]\"\nThe above example tells the function to get information on the tenth element in PLC_Array (remember, the address of the first element in an array is 0 (zero)).",
                "paramname": "Name"
            },
            {
                "paramdescription": "The type of information to get:\n0 - The Tag name from the variables table. This is the same as the Name argument. (Returned to be compatible with the AssInfo() function).\n1 - Engineering units\n2 - Raw zero scale\n3 - Raw full scale\n4 - Engineering zero scale\n5 - Engineering full scale\n6 - Width of the format\n7 - Number of decimal places of format\n8 - The Tag format as a long integer. The format information is stored in the integer as follows:\n9 - Logical Unit Number - I/O device number (for internal use)\n10 - General Type - Protocol's general data type number for this tag. Type numbers are:\n11 - Bit Width - Tag's size in bits. For example, an INT is 16 bits\n12 - Unit Type - Protocol's unit type number for this tag\n13 - Unit Address - Tag's address after the protocol DBF's template is applied.\n14 - Unit Count - Array size. For example, if the tag's address is I1[50], the unit count is 50.\n15 - Record Number - Tag's record number in variable.DBF - 1. That is, the first tag has a record number of 0.\n16 - Comment - As defined in the variable tags list.\n17 - ClusterName of the tag.\n18 - Full name (cluster.tagname) of the tag.\n19 - Reserved for internal operation.\n20 - Configured Address of the tag. If the tag is not resolved, returns anempty string.\n21 - Network Number - I/O device number (as defined by the Number field of the I/O Devices dialog).\n22 - Name of the equipment associated with the Tag. If the tag is not resolved, returns an empty string.\nIf the tag is a local variable, mode 9 error code 348 is retrieved when cache mode is 0,1,2,3. Modes 12, 13, 14 and 15 will return an empty string (error 274 is trapped).\n23 - Reserved for internal use.\n24 - Reserved for internal use.\n25 - Name of the equipment item associated with the Tag. If the tag is not resolved, returns an empty string.\n26 - Custom 1 - a user-defined string.\n27 - Custom 2 - a user-defined string.\n28 - Custom 3 - a user-defined string.\n29 - Custom 4 - a user-defined string.\n30 - Custom 5 - a user-defined string.\n31 - Custom 6 - a user-defined string.\n32 - Custom 7 - a user-defined string.\n33 - Custom 8 - a user-defined string.",
                "paramname": "Type"
            },
            {
                "paramdescription": "Specifies the name of the cluster in which the Tag resides.The argument is enclosed in quotation marks.",
                "paramname": "ClusterName"
            },
            {
                "paramdescription": "Optional parameter that specifies from where to retrieve the value for the property. \n-1 - The mode is determined by the INI parameter [Client]TagReadCachedMode.\n0 - The property value is retrieved direct from the server in blocking mode and an error code is returned if it is not on the server (or the server is unavailable).\n1 - The property value is retrieved from the cache and an error code is returned if the cache is not loaded yet.\n2 - The property value is retrieved from the local configuration and an error code is returned if it is not available (this is the traditional behavior).\n3 - The property value is retrieved from the cache, if the cache is loaded, and from the local configuration, if the cache is not loaded yet.\nDefault value is -1.\nThe value of the information as a string. If unsuccessful, an empty string is returned. The error code can be obtained by calling the IsError Cicode function.",
                "paramname": "CachedMode"
            }
        ],
        "returnType": "The value of the information as a string. If unsuccessful, an empty string is returned. The error code can be obtained by calling the IsError Cicode function.",
        "syntax": "STRING TagInfoEx(STRING Name, INT Type [, STRING ClusterName] [, INT CachedMode] )"
    },
    "tagramp": {
        "doc": "This function will increment a Tag by the amount defined by iPercentInc. It is often used for incrementing a tag while a button is held down.",
        "example": "No example found",
        "name": "TagRamp",
        "params": [
            {
                "paramdescription": "The variable tag name (or alarm property name), as a string. The name of the tag can be prefixed by the name of the cluster that is \"ClusterName.Tag\".\nTo read a particular element in an array, you can enter the array name here, followed by an index to the element as follows:\n\"PLC_Array[9] \"\nThe above example tells the function to read the 10th element in the array variable PLC_Array (remember, the address of the first element in an array is 0 (zero)).\nIf you enter an array offset using the nOffset argument, it will be added to the index value specified here. For example, TagRead(\"PLC_Array[9]\", 4) will read the 14th element in PLC_Array (because [9] means the 10th element, and an offset of 4 means 4 elements after the 10th = element 14).",
                "paramname": "Tag"
            },
            {
                "paramdescription": "The percentage by which you want to increase the value of the variable. A negative number will decrease the variable. The increment is calculated as a percentage of the full range.",
                "paramname": "PercentInc"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "TagRamp(STRING Tag, INT PercentInc)"
    },
    "tagrdbreload": {
        "doc": "Works in conjunction with the TagInfo function. Reloads the variable tag database so when TagInfo is called it picks up all online changes to the tag database.",
        "example": "No example found",
        "name": "TagRDBReload",
        "params": [],
        "returnType": "Returns 1 if the tag database was successfully reloaded, and 0 if the tag database fails to load.",
        "syntax": "TagRDBReload()"
    },
    "tagread": {
        "doc": "Reads a variable from an I/O device or a local variable. The variable tag needs to be defined in the Variable Tags database. Because the variable tag is specified as a string (not as a tag), you can ignore the data type of the variable.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.\nTagRead is useful when the variable tag name is a calculation, such as sAlarmExt+\".Paging\". For simple assignment of variables use the assignment operator. For example, MyString = MyCluster.MyAlarm.MyProperty. \nIf you try to read many variables at the same time, the TagRead() function may be slow. The offset index for array variables is checked against the size of the array.\nTagRead(STRING Tag [, INT nOffset [, STRING ClusterName]])\nTag: \nOffset: \nClusterName:\n \nThe function can return:",
        "example": "No example found",
        "name": "TagRead",
        "params": [
            {
                "paramdescription": "A string that can be one of the following:\nA tag name — for example, \"Fire1\"\nAn equipment item reference — for example, \"Motor1.Fire\"\nA tag property — for example, \"Fire1.v\"\nAn equipment item property — for example, \"Motor1.Fire.v\"\nAn alarm property — for example, \"AlarmFire1.On\"\nAn alarm equipment item property — for example, \"Motor1.AlarmFire.On\"\nCurrently only the \"v\" tag extension item is supported by TagRead. References to other extension items will generate an error message. If the element name is not specified, it will be resolved at runtime as an unqualified tag reference. \nThe name of the tag can be prefixed by the name of the cluster, for example, \"ClusterName.Tag\" or \"ClusterName.Equipment.Item\".\nIn the example below, assuming the following variable tag, equipment and item are defined in your project :\nTag: PLC_Array\nEquipment: PLC\nItem: Array\nAddress: 30000[10]\nYou can refer to the variable tag using the following syntax:\n\"PLC_Array\"\n\"PLC.Array\"\n To read a particular element in an array, you can enter the array name here, followed by an index to the element as follows:\n\"PLC_Array[9]\"\n\"PLC.Array[9]\"\nThe above example tells the function to read the 10th element in the array variable PLC_Array (remember, the address of the first element in an array is 0 (zero)).\nIf you enter an array offset using the nOffset argument, it will be added to the index value specified here. For example, TagRead(\"PLC_Array[9]\", 4) will read the 14th element in PLC_Array (because [9] means the 10th element, and an offset of 4 means 4 elements after the 10th = element 14). If you want to read the value of <Valid> element in the above example,\nTagRead(\"PLC_Array.Valid.V[9]\", 4)",
                "paramname": "Tag"
            },
            {
                "paramdescription": "The offset for an array variable. This argument is optional - ifnot specified, it has a default value of 0.\nIf you enter an array index as part of the sTag argument, it will be added to this offset value. For example, TagRead(\"PLC_Array[9]\", 4) will read the 14th element in PLC_Array (because [9] means the 10th element, and an offset of 4 means 4 elements after the 10th = element 14).",
                "paramname": "Offset"
            },
            {
                "paramdescription": "Specifies the name of the cluster in which the Tag resides.The argument is enclosed in quotation marks.",
                "paramname": "ClusterName"
            }
        ],
        "returnType": " ",
        "syntax": "TagRead(STRING Tag [, INT nOffset [, STRING ClusterName]])"
    },
    "tagreadex": {
        "doc": "Reads the value, quality or timestamp of a particular tag from the I/O device. The variable tag needs to be defined in the Variable Tags database. Because the variable tag is specified as a string (not as a tag), you can ignore the data type of the variable.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.\nTagReadEx should only be used when the variable tag name is a calculation such as sAlarmExt+\".Paging\". For simple assignment of variables use the assignment operator. For example, MyString = MyCluster.MyAlarm.MyProperty.\nIf you try to read many variables at the same time, the TagReadEx() function may be slow. The offset index for array variables is checked against the size of the array.\nTagReadEx(STRING Tag [, INT Offset [, STRING ClusterName]])\nTag: \nOffset: \nClusterName:\nThe function can return:",
        "example": "No example found",
        "name": "TagReadEx",
        "params": [
            {
                "paramdescription": "A string that can be one of the following:\nA tag name — for example, \"Fire1\"\nAn equipment item reference — for example, \"Motor1.Fire\"\nA tag property — for example, \"Fire1.v\"\nAn equipment item property — for example, \"Motor1.Fire.v\"\nAn alarm property — for example, \"AlarmFire1.On\"\nAn alarm equipment item property — for example, \"Motor1.AlarmFire.On\"\nCurrently only the \"v\" tag extension item is supported by TagRead. References to other extension items will generate an error message. If the element name is not specified, it will be resolved at runtime as an unqualified tag reference. \nThe name of the tag can be prefixed by the name of the cluster, for example, \"ClusterName.Tag\" or \"ClusterName.Equipment.Item\".\nIn the example below, assuming the following variable tag, equipment and item are defined in your project :\nTag: PLC_Array\nEquipment: PLC\nItem: Array\nAddress: 30000[10]\nYou can refer to the variable tag using the following syntax:\n\"PLC_Array\"\n\"PLC.Array\"\n To read a particular element in an array, you can enter the array name here, followed by an index to the element as follows:\n\"PLC_Array[9]\"\n\"PLC.Array[9]\"\nThe above example tells the function to read the 10th element in the array variable PLC_Array (remember, the address of the first element in an array is 0 (zero)).\nIf you enter an array offset using the nOffset argument, it will be added to the index value specified here. For example, TagRead(\"PLC_Array[9]\", 4) will read the 14th element in PLC_Array (because [9] means the 10th element, and an offset of 4 means 4 elements after the 10th = element 14). If you want to read the value of <Valid> element in the above example,\nTagReadEx(\"PLC_Array.Valid.V[9]\", 4)",
                "paramname": "Tag"
            },
            {
                "paramdescription": "The offset for an array variable. This argument is optional - ifnot specified, it has a default value of 0.\nIf you enter an array offset using the nOffset argument, it will be added to the index value specified here. For example, TagReadEx(\"PLC_Array[9]\", 4) will read the 14th element in PLC_Array (because [9] means the 10th element, and an offset of 4 means 4 elements after the 10th = element 14). ",
                "paramname": "Offset"
            },
            {
                "paramdescription": "Specifies the name of the cluster in which the Tag resides.The argument is enclosed in quotation marks.",
                "paramname": "ClusterName"
            }
        ],
        "returnType": "The function can return:",
        "syntax": "TagReadEx(STRING Tag [, INT Offset [, STRING ClusterName]])"
    },
    "tagresolve": {
        "doc": "This function can be used to increment a reference count on a tag to keep it resolved, making it readily available to a client.\nIf a tag is held in a resolved state, it will not be evicted from the client even if it is not being used. This means a client does not need to locate the tag's associated I/O server when a read or write is required. \nWhile this allows faster access to a tag, it should be only utilised for priority tags, as a large number of resolved tags will increase the amount of memory used. \nYou can use the function TagUnresolve todecrement the reference count.",
        "example": "No example found",
        "name": "TagResolve",
        "params": [
            {
                "paramdescription": "The name of the tag or the equipment and item name (using equipment.item notation) associated with that tag to resolve (in the format \"clusterName.tagName\" or \"clusterName.equipment.item\" if you need to specify a cluster).\nThe returned integer is a handle to the tag that has been resolved, or -1 if anerror occurred. \nThe specific error code is accessible by calling IsError().",
                "paramname": "TagName"
            }
        ],
        "returnType": "The returned integer is a handle to the tag that has been resolved, or -1 if an\nerror occurred. ",
        "syntax": "TagResolve(STRING TagName)"
    },
    "tagscalestr": {
        "doc": "Gets the value of a tag at a specified scale. The value is returned as a formatted string using the tags format specification and (optionally) the engineering units. Use this function to write generic Cicode that will work with any type of tag.",
        "example": "// Display the zero, 50% and full scale of the tag CV_123_PV\nDspText(31,0,TagScaleStr(\"CV_123_PV\", 0, 1));\nDspText(32,0,TagScaleStr(\"CV_123_PV\", 50, 1));\nDspText(33,0,TagScaleStr(\"CV_123_PV\", 100, 1));",
        "name": "TagScaleStr",
        "params": [
            {
                "paramdescription": "The name of the tag, or the equipment and item name of a variable tag (using equipment.item notation).",
                "paramname": "Tag"
            },
            {
                "paramdescription": "The percentage of full scale of the returned value.",
                "paramname": "Percent"
            },
            {
                "paramdescription": "Determines if the value is returned withengineering units:\n0 - Return the value without engineering units\n1 - Return the value with engineering units",
                "paramname": "EngUnits"
            },
            {
                "paramdescription": "Name of the cluster",
                "paramname": "ClusterName"
            },
            {
                "paramdescription": "Optional parameter that specifies from where to retrieve the value for the property. \n-1 - The mode is determined by the INI parameter [Client]TagReadCachedMode.\n0 - The property value is retrieved direct from the server in blocking mode and an error code is returned if it is not on the server (or the server is unavailable).\n1 - The property value is retrieved from the cache and an error code is returned if the cache is not loaded yet.\n2 - The property value is retrieved from the local configuration and an error code is returned if it is not available (this is the traditional behaviour).\n3 - The property value is retrieved from the cache, if the cache is loaded, and from the local configuration, if the cache is not loaded yet.\nDefault value is -1.",
                "paramname": "CachedMode"
            }
        ],
        "returnType": "The scale of the tag (as a string).",
        "syntax": "STRING TagScaleStr(STRING Tag, INT Percent , INT EngUnits [,STRING ClusterName] [,INT CachedMode] )"
    },
    "tagsetoverridebad": {
        "doc": "Sets a quality  Override element for a specified tag to Bad Non Specific.",
        "example": "TagSetOverrideBad(\"Tag1\");",
        "name": "TagSetOverrideBad",
        "params": [
            {
                "paramdescription": " The variable tag name or the equipment and item name (using equipment.item notation) associated with that tag as a string. The name of the tag can be prefixed by the name of the cluster that is \"ClusterName.Tag\" or \"ClusterName.Equipment.Item\".",
                "paramname": "Tag"
            },
            {
                "paramdescription": "An optional boolean argument that specifies whether the command is synchronous (blocking) or asynchronous (non- blocking). By default, this parameter is set to “True”, synchronous (blocking), and the function will wait until the write has completed and returned from the server before further code execution. If you specify this parameter the other parameters need to be explicitly specified.",
                "paramname": "Synch"
            },
            {
                "paramdescription": "Specifies the name of the cluster in which the Tag resides. The argument is enclosed in quotation marks.",
                "paramname": "ClusterName"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "TagSetOverrideBad(STRING Tag [,INT Synch [, STRING ClusterName]])"
    },
    "tagsetoverridegood": {
        "doc": "Sets a quality Override element for a specified tag to Good Non Specific.",
        "example": "TagSetOverrideGood(\"Tag1\");",
        "name": "TagSetOverrideGood",
        "params": [
            {
                "paramdescription": " The variable tag name or the equipment and item name (using <equipment>.<item> notation) associated with that tag as a string. The name of the tag can be prefixed by the name of the cluster that is \"ClusterName.Tag\" or \"ClusterName.Equipment.Item\".",
                "paramname": "Tag"
            },
            {
                "paramdescription": " An optional boolean argument that specifies whether the command is synchronous (blocking) or asynchronous (non- blocking). By default, this parameter is set to “True”, synchronous (blocking), and the function will wait until the write has completed and returned from the server before further code execution. If you specify this parameter the other parameters need to be explicitly specified.",
                "paramname": "Synch"
            },
            {
                "paramdescription": "Specifies the name of the cluster in which the Tag resides. The argument is enclosed in quotation marks.",
                "paramname": "ClusterName"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "TagSetOverrideGood (STRING Tag [,INT Synch [, STRING ClusterName]])"
    },
    "tagsetoverridequality": {
        "doc": "Sets a quality of Override element for a specified tag.",
        "example": "QUALITY q1 = QualityCreate(QUAL_UNCR);",
        "name": "TagSetOverrideQuality",
        "params": [
            {
                "paramdescription": " The variable tag name or the equipment and item name (using equipment.item notation) associated with that tag as a string. The name of the tag can be prefixed by the name of the cluster that is \"ClusterName.Tag\" or \"ClusterName.Equipment.Item\".",
                "paramname": "Tag"
            },
            {
                "paramdescription": " The new quality for the tag’s Override element.",
                "paramname": "qualityNew"
            },
            {
                "paramdescription": "An optional boolean argument that specifies whether the command is synchronous (blocking) or asynchronous (non- blocking). By default, this parameter is set to “True”, synchronous (blocking), and the function will wait until the write has completed and returned from the server before further code execution. If you specify this parameter the other parameters need to be explicitly specified.",
                "paramname": "Synch"
            },
            {
                "paramdescription": "Specifies the name of the cluster in which the Tag resides. The argument is enclosed in quotation marks.",
                "paramname": "ClusterName"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "TagSetOverrideQuality(STRING Tag, QUALITY qualityNew [,INT Synch [, STRING ClusterName]])"
    },
    "tagsetoverrideuncertain": {
        "doc": "Sets a quality Override element for a specified tag to Uncertain Non Specific.",
        "example": "TagSetOverrideUncertain(\"Tag1\");",
        "name": "TagSetOverrideUncertain",
        "params": [
            {
                "paramdescription": " The variable tag name or the equipment and item name (using equipment.item notation) associated with that tag as a string. The name of the tag can be prefixed by the name of the cluster that is \"ClusterName.Tag\" or \"ClusterName.Equipment.Item\".",
                "paramname": "Tag"
            },
            {
                "paramdescription": "An optional boolean argument that specifies whether the command is synchronous (blocking) or asynchronous (non- blocking). By default, this parameter is set to “True”, synchronous (blocking), and the function will wait until the write has completed and returned from the server before further code execution. If you specify this parameter the other parameters need to be explicitly specified.",
                "paramname": "Synch"
            },
            {
                "paramdescription": "Specifies the name of the cluster in which the Tag resides. The argument is enclosed in quotation marks.",
                "paramname": "ClusterName"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "TagSetOverrideUncertain(STRING Tag [,INT Synch [, STRING ClusterName]])"
    },
    "tagsubscribe": {
        "doc": "Subscribes a tag so that Cicode functions can be called when a tag's value changes. The subscription checks each poll period whether the tag has changed value and if it has, the specified callback function is called. This avoids continuously polling a tag value to monitor changes. To add a function callback to the subscription, use the optional parameter in this command or the SubscriptionAddCallback function.\nMultiple subscriptions are possible to the same tag. Each new subscription returns a new subscription handle. Multiple callbacks are possible to the same subscription.\nTo unsubscribe a tag use the TagUnsubscribe function.",
        "example": "...\nINT subsHandle = TagSubscribe(\"Conveyor1\", 100, \"Percent\", \n\"OnValueChanged\");\n... \n// Later on if no callback was registered initially, a new one can be added..\nSubscriptionAddCallBack(subsHandle, \"ValChanged2\");\n...\nFunction OnValueChanged(INT handle)\nSTRING   sTag;\n \n     sTag = SubscriptionGetAttribute(handle, \"FullName\");\t// If the name is needed \n     subsVal = SubscriptionGetAttribute(handle, \"Value\");\n     subsQual = SubscriptionGetAttribute(handle, \"ValueQuality\");\n...\nEND\n...\nFunction ValChanged2(INT handle)\nSTRING   sTag;\n \n     sTag = SubscriptionGetAttribute(handle, \"FullName\");\t// If the name is needed \n     subsVal = SubscriptionGetAttribute(handle, \"Value\");\n     subsTime = SubscriptionGetAttribute(handle, \"ValueTimestamp\");\n...\nEND\n...\n// Remove all callbacks and unsubscribe\nTagUnsubscribe(subsHandle);",
        "name": "TagSubscribe",
        "params": [
            {
                "paramdescription": "String representing the tag or tag element or the equipment and item name (using equipment.item notation) associated with that tag, to subscribe to in the form of \"cluster_name.tag_name.element name\" or \"cluster_name.equipment. item.element name\". If the element name is not specified, it will be resolved at runtime as an unqualified tag reference.",
                "paramname": "TagName"
            },
            {
                "paramdescription": "Optional integer representing the Datasource Poll time in milliseconds (default 250).",
                "paramname": "PollTime"
            },
            {
                "paramdescription": "Optional string stating the mode to subscribe. Supported modes are: Raw, Eng, Percent. Default is \"Eng\".",
                "paramname": "ScaleMode"
            },
            {
                "paramdescription": "Optional real value specifying the percentage of the variable tag's engineering range that a tag needs to change by for an update to be sent through the system. Default value is -1.0, indicating the deadband specified by the tag definition is to be used.",
                "paramname": "Deadband"
            },
            {
                "paramdescription": "Optional string stating the name of a function to call when the value is updated. If an empty string is specified, no handler is registered. Default value is \"\" (empty string). \nThe function should have the structure:\nFUNCTION evtHandler(INT subsHandle)...END\nWhere subsHandle is the subscription that raised the event.",
                "paramname": "Callback"
            },
            {
                "paramdescription": "This optional boolean argument indicates whether or not subscription updates use a \"lightweight\" version of the tag value that does not includea quality timestamp or a value timestamp. \nIf not used, this option is set to 1 which means lightweight tag values will be used by default. For a client to retrieve quality and value timestamps for a tag, you should explicitly specify that a full tagvalue is required by setting this option to 0.",
                "paramname": "Lightweight"
            },
            {
                "paramdescription": "This optional boolean argument allows you to specify if the subscription accepts duplicated values. Set this value to 1 to indicate that a duplicated update is not required for values that have already successfully written to the device. ",
                "paramname": "NoUpdateForDuplicateValues"
            }
        ],
        "returnType": "Integer representing the subscription handle that can be used to read values, hook to events or unsubscribe. If unsuccessful, -1 is returned and an error is set. Even though a subscription handle is returned immediately, it can't be used to get attributes until the subscription has been confirmed as this is an asynchronous Cicode function call. The typical Cicode error is 423 when a subscription handled is used too soon. We recommend the use of a callback function or the direct use of the tag extension, e.g. <tag>.VT",
        "syntax": "TagSubscribe(STRING TagName [, INT PollTime] [, STRING ScaleMode] [, REAL Deadband] [, STRING Callback]  [, INT Lightweight] [, INT NoUpdateForDuplicateValues])"
    },
    "tagunresolve": {
        "doc": "This function is used to decrement a reference count implemented on a tag by TagResolve. This will allow the tag to be evicted if the decrement causes its reference count to reach zero (0).",
        "example": "No example found",
        "name": "TagUnresolve",
        "params": [
            {
                "paramdescription": "The tag handle returned from a TagResolve() function call.",
                "paramname": "Handle"
            }
        ],
        "returnType": "The returned integer represents any error that occurs when the unresolve is attempted\n(0 for no error).",
        "syntax": "TagUnresolve(INT iHandle)"
    },
    "tagunsubscribe": {
        "doc": "Unsubscribes the tag subscription specified by the integer subscription handle that was returned from the TagSubscribe function. This function also removes any callbacks that are associated with the subscription.",
        "example": "No example found",
        "name": "TagUnsubscribe",
        "params": [
            {
                "paramdescription": "Integer handle of the subscription to unsubscribe.",
                "paramname": "Handle"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "TagUnsubscribe(INT Handle)"
    },
    "tagwrite": {
        "doc": "Writes to an I/O device variable by specifying the variable tag name or the variable tag name and the name of the requested element having read/write access. The variable tag needs to be defined in the Variable Tags database.\nThis function completes asynchronously to the caller. It will be unsuccessful if the tag does not exist or if a write request could not be sent. This function does not test whether the write succeeded. In cases where the write does not succeed, TagWrite does not return a driver error code. You can use the TagReadEx function to confirm the write operation took place.  \nTagWrite should only be used when the variable tag name is a calculation such as sAlarmExt+\".Paging\". For assignment of variables use the assignment operator. For example, MyCluster.MyAlarm.MyProperty = MyString.",
        "example": "TagWrite(\"PLC_VAR1\", 123);\nTagWrite(\"PLC_VAR1\", 123, 0, TRUE); ! Write to PLC variable \n! and block until write is successful.\nTagWrite(\"PLC_VAR_STR\", \"string data to write\");\nTagWrite(\"PLC_ARRAY\", 42, 3); ! Write to element 4 in array\nTagWrite(\"PLC_Array[9]\", 2); ! Write to element 12 in array\nTagWrite (\"Tag1\", \"123\");\nTagWrite(\"Tag1.Field\", \"123\");",
        "name": "TagWrite",
        "params": [
            {
                "paramdescription": "A string that can be one of the following:\nA tag name — for example, \"Fire1\"\nAn equipment item reference — for example, \"Motor1.Fire\"\nA tag property — for example, \"Fire1.v\"\nAn equipment item property — for example, \"Motor1.Fire.v\"\nAn alarm property — for example, \"AlarmFire1.On\"\nAn alarm equipment item property — for example, \"Motor1.AlarmFire.On\"\nIf the element name is not specified, the writing will be performed to the Field VQT element.\nThe name of the tag can be prefixed by the name of the cluster, for example, \"ClusterName.Tag\" or \"ClusterName.Equipment.Item\".",
                "paramname": "Tag"
            },
            {
                "paramdescription": "The value to be written to the I/O device variable. The valueis specified as a string, however if an integer or real is used the compiler will convert it to a string. The function converts the string intothe correct format, and then writes it to the variable.\nTo write to a particular element in an array, you can enter the array name here, followed by an index to the element as follows:\n\"PLC_Array[9] \"\nThe above example tells the function to write to the 10th element in the array variable PLC_Array (remember, the address of the first element in an array is 0 (zero)).\nIf you enter an array offset using the nOffset argument, it will be added to the index value. See example below.",
                "paramname": "Value"
            },
            {
                "paramdescription": "Optional offset for an array variable. Default is 0.",
                "paramname": "Offset"
            },
            {
                "paramdescription": "An optional boolean argument that specifies whether thecommand is synchronous (blocking) or asynchronous (non-blocking). If it is specified as synchronous (blocking) the function will wait until the write has completed and returned from the server before further code execution. This parameter is \"False\", or asynchronous, bydefault. If you specify this parameter the rest of the parameters need to be explicitly specified, including nOffset which should be set as 0 if the tag is not an array tag.",
                "paramname": "Synch"
            },
            {
                "paramdescription": "Specifies the name of the cluster in which the Tag resides.The argument is enclosed in quotation marks.",
                "paramname": "ClusterName"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "TagWrite(STRING Tag, STRING sValue [, INT Offset] [, INT Synch] [, STRING ClusterName])"
    },
    "tagwriteeventque": {
        "doc": "Opens the tag write event queue. The TagWriteEventQue is a queue of data containing details of tag value changes initiated by the process. To read events from the queue, use the QueRead() or QuePeek() functions. The queue contains timestamp, tagname and value data for each change event.\nThis queue is enabled by the corresponding INI parameter [General]TagWriteEventQue. Writes are logged to the queue for all tags whose IODevices have their Log Write parameter enabled.",
        "example": "FUNCTION\ncheckWrite()\n    STRING sTagAndValue = \"\";\n    INT nDateTime = 0;\n    INT hQue = TagWriteEventQue();\n    IF hQue = -1 THEN\n        RETURN;\n    END\n    WHILE 1 DO\n        QueRead(hQue, nDateTime, sTagAndValue, 1);\n        Message(\"Value written\", sTagAndValue, 64);\n    END\nEND",
        "name": "TagWriteEventQue",
        "params": [],
        "returnType": "The handle of the tag write event queue, or -1 if the queue cannot be opened.",
        "syntax": "TagWriteEventQue() "
    },
    "tagwriteintarray": {
        "doc": "This function writes an array of integers to a tag. You can write to all elements of an array tag, or write to a subset. Use the Offset parameter to write to the subset  (e.g. if you specify a Length of 5 and an Offset of 2, you will write to the 3rd, 4th, 5th, 6th and 7th elements in the tag array).\nThis function completes asynchronously to the caller. It will be unsuccessful if the tag does not exist or if a write request could not be sent. This function does not test whether the write succeeded. In cases where the write does not succeed, TagWriteIntArray does not return a driver error code. You can use the TagReadEx function to confirm the write operation took place.  \nTagWriteIntArray should only be used when the variable tag name is a calculation such as sAlarmExt+\".Paging\". For assignment of variables use the assignment operator. For example, MyCluster.MyAlarm.MyProperty = MyString.",
        "example": "\tGLOBAL INT ArrayOfInts[64];\n\n\tFUNCTION ArrayWriteAscendingInts()\n\t\tINT i = 0;\n\t\tFOR i = 0 TO 63 DO\n\t\tArrayOfInts[i] = i;\n\t\tEND\t\n\t\n\t\tTagWriteIntArray(\"ModnetIntArray\", 64, ArrayOfInts[0]);\n\tEND",
        "name": "TagWriteIntArray",
        "params": [
            {
                "paramdescription": "The string can refer to either: the variable tag name, the equipment and item name (using equipment.item notation) associated with that tag, the alarm name and the alarm property name, the tag name and the tag element name. If the element name is not specified, the writing will be performed to the Field VQT element.The name of the tag can be prefixed by the name of thecluster that is \"ClusterName.Tag\" or \"ClusterName.Equipment.Item\".",
                "paramname": "Tag"
            },
            {
                "paramdescription": "The number of elements written to the tag.",
                "paramname": "Length"
            },
            {
                "paramdescription": "The element you select in the array to be the first. The array contains the values you are writing to the variable tag. See example below. Must be a Long type variable.",
                "paramname": "Value"
            },
            {
                "paramdescription": "Optional offset inside the variable tag array where you start writing to. Default is 0.",
                "paramname": "Offset"
            },
            {
                "paramdescription": "An optional boolean argument that specifies whether thecommand is synchronous (blocking) or asynchronous (non-blocking). If it is specified as synchronous (blocking) the function will wait until the write has completed and returned from the server before further code execution. This parameter is \"False\", or asynchronous, bydefault. If you specify this parameter the rest of the parameters need to be explicitly specified, including nOffset which should be set as 0 if the tag is not an array tag.",
                "paramname": "Sync"
            },
            {
                "paramdescription": "Specifies the name of the cluster in which the Tag resides.The argument is enclosed in quotation marks.",
                "paramname": "ClusterName"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "TagWriteIntArray(STRING Tag, INT Length, VAR LONG Values, INT Offset, INT Sync, STRING ClusterName)"
    },
    "tagwriterealarray": {
        "doc": "This function writes an array of REAL values to a variable tag. You can write to all elements of an array tag, or write to a subset. Use the Offset parameter to write to the subset  (e.g. if you specify a Length of 5 and an Offset of 2, you will write to the 3rd, 4th, 5th, 6th and 7th elements in the tag array).\nThis function completes asynchronously to the caller. It will be unsuccessful if the tag does not exist or if a write request could not be sent. This function does not test whether the write succeeded. In cases where the write does not succeed, TagWriteRealArray does not return a driver error code. You can use the TagReadEx function to confirm the write operation took place.  ",
        "example": "No example found",
        "name": "TagWriteRealArray",
        "params": [
            {
                "paramdescription": "The string can refer to either: the variable tag name, the equipment and item name (using equipment.item notation) associated with that tag, the alarm name and the alarm property name, the tag name and the tag element name. If the element name is not specified, the writing will be performed to the Field VQT element.The name of the tag can be prefixed by the name of thecluster that is \"ClusterName.Tag\" or \"ClusterName.Equipment.Item\".",
                "paramname": "Tag"
            },
            {
                "paramdescription": "The number of elements written to the tag.",
                "paramname": "Length"
            },
            {
                "paramdescription": "The element you select in the array to be the first. The array contains the values you are writing to the variable tag. See example below.",
                "paramname": "Value"
            },
            {
                "paramdescription": "Optional offset inside the variable tag array where you start writing to. Default is 0.",
                "paramname": "Offset"
            },
            {
                "paramdescription": "An optional boolean argument that specifies whether thecommand is synchronous (blocking) or asynchronous (non-blocking). If it is specified as synchronous (blocking) the function will wait until the write has completed and returned from the server before further code execution. This parameter is \"False\", or asynchronous, bydefault. If you specify this parameter the rest of the parameters need to be explicitly specified, including nOffset which should be set as 0 if the tag is not an array tag.",
                "paramname": "Sync"
            },
            {
                "paramdescription": "Specifies the name of the cluster in which the Tag resides.The argument is enclosed in quotation marks.",
                "paramname": "ClusterName"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "TagWriteRealArray(STRING Tag, INT Length, VAR REAL Value [, INT Offset] [, INT Sync] [, STRING ClusterName])"
    },
    "tan": {
        "doc": "Calculates the trigonometric tangent of an angle.",
        "example": "Variable=Tan(1);\n! Sets Variable to 1.5574",
        "name": "Tan",
        "params": [
            {
                "paramdescription": "Any angle (in degrees).",
                "paramname": "Angle"
            }
        ],
        "returnType": "The tan of Angle.",
        "syntax": "Tan(Angle)"
    },
    "taskcall": {
        "doc": "Calls a Cicode function by specifying the function name and providing an arguments string.\nThe function will be executed in a new Cicode task with the same cluster context as the current task.  The current task will be blocked until the new task completes and a value can be returned.\nThis function cannot be called from page foreground animation code.  If this is attempted, a hardware alarm will be raised and IsError() will return 282 (Foreground Cicode cannot block).\nTaskCall allows the function to be called and the arguments to be provided tobe specified dynamically by the cicode logic. This may be useful in some caseswhere the function needed is not known until runtime.\nPlant SCADA requests the required I/O device data and waits for the data tobe returned before starting the function.",
        "example": "STRING result;\nresult = TaskCall(\"StrFill\", \"^\"abc^\",10\");\n// result will be set to \"abcabcabca\"",
        "name": "TaskCall",
        "params": [
            {
                "paramdescription": "The name of the function to call, as a string.",
                "paramname": "sName"
            },
            {
                "paramdescription": "The arguments to pass to the function, separated by commas (,). Enclose string arguments in quotes \"\" and use the string escape character (^) around strings enclosed within a string.",
                "paramname": "sArgs;"
            }
        ],
        "returnType": "The result of the function call (as a string). If a void function is called, an empty string is returned.  To see if an error occurred (such as an invalid function name or invalid arguments) call IsError()..",
        "syntax": "TaskCall(sName, sArgs)"
    },
    "taskcluster": {
        "doc": "Gets the name of the cluster context in which the current task is executing.",
        "example": "! Get the cluster context of the current task\nsCluster = TaskCluster();",
        "name": "TaskCluster",
        "params": [],
        "returnType": "The cluster name of the current context or an empty string if the task is executing without a cluster context.",
        "syntax": "TaskCluster()"
    },
    "taskgetsignal": {
        "doc": "Retrieves a value that indicates the signal that is currently set for a specific task. This function can be used to check the value of the current signal before using TaskSetSignal to apply a new signal.",
        "example": "No example found",
        "name": "TaskGetSignal",
        "params": [
            {
                "paramdescription": "The task's handle. To retreive this use the function TaskHnd().",
                "paramname": "Hnd"
            }
        ],
        "returnType": "The value of the current signal. (0 (zero) represents normal operation, 1 indicates the task is stopped).",
        "syntax": "TaskGetSignal(Hnd)"
    },
    "taskhnd": {
        "doc": "Gets the task handle of a specific task. You can then use the task handle with other task functions to control the task. If you do not specify a thread name, it will default to that of the current task.",
        "example": "! Get the task handle of the current task and then kill it.\nhTask=TaskHnd();\nTaskKill(hTask);\n! Get the task handle of MyTask and then kill it.\nhTask=TaskHnd(\"MyTask\");\nTaskKill(hTask);",
        "name": "TaskHnd",
        "params": [
            {
                "paramdescription": "The thread name of the task. The thread name is the name of the function that was passed to the TaskNew() function. For example, if. . .\nTaskNew(\"MyTask\",\"\",0);\nthen:\nhTask=TaskHnd(\"MyTask\");\nwill return the handle of this task.\nIf you do not specify a thread name, it will default to that of the current task.",
                "paramname": "sName"
            }
        ],
        "returnType": "The task handle, identifying the table where all data on the task is stored.",
        "syntax": "TaskHnd( [sName] )"
    },
    "taskkill": {
        "doc": "Kills a task. The Cicode task will be stopped and will not run again.",
        "example": "! Create a task, run it for 10 seconds and then kill it.\nhTask=TaskNew(\"MyFunc\",\"\",0);\nSleep(10);\nTaskKill(hTask);\nFUNCTION\nMyFunc()\n    INT Count;\n    WHILE 1 DO\n        Prompt(\"Hello \"+Count:###);\n        Count=Count+1;\n    END\nEND",
        "name": "TaskKill",
        "params": [
            {
                "paramdescription": "The task handle, returned from the TaskNew() or TaskHnd()function. The task handle identifies the table where all dataon the associated task is stored.",
                "paramname": "hTask"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "TaskKill(hTask)"
    },
    "tasknew": {
        "doc": "Creates a new Cicode task and returns the task handle. You pass the sName of the function (that creates the task) as a string, not as the function tag, and pass the arguments for that function in Arg. After the task is created, it runs in parallel to the calling task. The new task will run forever unless it returns from the function or is killed by another task.\n By default, Plant SCADA requests necessary I/O device data and waits forthe data to be returned before starting the task -  the task is provided with the correct data, but there will be a delay instarting the task.  If you add 16 to the Mode, Plant SCADA starts the task immediately, withoutwaiting for any data from the I/O devices -  any I/O device variable that you use will either contain 0 (zero) or the lastvalue read. \nYou can specify that if the task is already running, the function will exit without launching a new task and an error will display. This is useful when you want only a single instance of the function running at any point in time.\nIt is also possible to run the task within the context of a particular cluster in a multi cluster system by setting the ClusterName parameter. If a cluster is not specified, the task will use the cluster context of the caller, be it a page or Cicode task. Please be aware that the cluster context cannot be changed once the code is running.\nAny animation output for the new task is displayed in the window where it was created. If you want to send output to other windows, use the WinSelect() function.",
        "example": "! Create a task that displays a message for 10 seconds.\nhTask=TaskNew(\"MyFunc\",\"Data\",0);\n! Continue to run while task runs.\nFUNCTION\nMyFunc(STRING Msg)\n\tFOR I=0 TO 10 DO\n\t\tPrompt(Msg);\n\t\tSleep(1);\n\tEND\nEND\n...\n! Call a function which expects more complex argument\nhTask=TaskNew(\"ArgFunc\",\"^\"string one^\",^\"string two^\",1,2\",0);\nhTask=TaskNew(\"ArgFunc\",\"^\"\"+sOne+\"^\",^\"\"+sTwo+\"^\",\"+iOne:##+\",\"+\niTwo:##,0);\nFUNCTION\nArgFunc(STRING sOne, STRING sTwo, INT iOne, INT iTwo)\n\t...\nEND",
        "name": "TaskNew",
        "params": [
            {
                "paramdescription": "The name of the function to create the task, as a string.",
                "paramname": "sName"
            },
            {
                "paramdescription": "The set of arguments to be passed to the function. Individualarguments need to be separated by commas (,). Enclose stringarguments in quotes \"\" and use the string escape character (^)around strings enclosed within a string. If the string in quotes is not enclosed, then the string is only the first tag found.The entire set of arguments need to be enclosed in quotes (\"\").",
                "paramname": "sArg"
            },
            {
                "paramdescription": "The mode of the task:\n0 - Task runs forever.\n1 - Task runs until the current page is changed.\n2 - Task runs until the current window is freed.\n4 - This mode is deprecated and not active. Currently, by default, taskrequests I/O device data before starting.\n8 - If the task already exists, the function will exit without launching the new task.\n16- Task doesn't wait for necessary I/O device data and starts immediately.\nYou can select any one of modes 0, 1 or 2 and may add mode 4 and/or mode 8 and/or mode 16. For example, set Mode to 6 to request I/O device data before starting the task, and to run the task until the current window is freed.",
                "paramname": "Mode"
            },
            {
                "paramdescription": "The name of the cluster context to be applied to the newCicode task. This is optional if you have one cluster or areresolving the task via the current cluster context. Theargument is enclosed in quotation marks \"\". You may pass \"-\"as the ClusterName argument to run the requested Cicodetask without a cluster context.",
                "paramname": "sClusterName"
            }
        ],
        "returnType": "The task handle, or -1 if the task cannot be successfully created. The task handle identifies the table where data on the associated task is stored.",
        "syntax": "TaskNew(sName, sArg, Mode [, sClusterName] )"
    },
    "tasknewex": {
        "doc": "Creates a new Cicode task with an individual subscription rate and returns the task handle. You pass the sName of the function (that creates the task) as a string, not as the function tag, and pass the arguments for that function in Arg. After the task is created, it runs in parallel to the calling task. The new task will run forever with tags updated at the specified time interval unless it returns from the function or is killed by another task.\nBy default, Plant SCADA requests necessary I/O device data and waits forthe data to be returned before starting the task -  the task is provided with the correct data, but there will be a delay instarting the task.  If you add 16 to the Mode, Plant SCADA starts the task immediately, withoutwaiting for any data from the I/O devices -  any I/O device variable that you use will either contain 0 (zero) or the lastvalue read.  Use Mode 16 when the task has to start immediately.\nYou can specify that if the task is already running, the function will exit without launching the new task and an error will display. This is useful when you want only a single instance of the function running at any point in time.\nIt is also possible to run the task within the context of a particular cluster in a multi cluster system by setting the ClusterName parameter. If a cluster is not specified, the task will use the cluster context of the caller, be it a page or Cicode task. Please be aware that the cluster context cannot be changed once the code is running.\nAny animation output for the new task is displayed in the window where it was created. If you want to send output to other windows, use the WinSelect() function.",
        "example": "! Create a task that calls a function every half second.\nhTask=TaskNewEx(\"MyFunc\",\"Data\",0,500);",
        "name": "TaskNewEx",
        "params": [
            {
                "paramdescription": "The name of the function to create the task, as a string.",
                "paramname": "sName"
            },
            {
                "paramdescription": "The set of arguments to be passed to the function. Individualarguments need to be separated by commas (,). Enclose stringarguments in quotes \"\" and use the string escape character (^)around strings enclosed within a string. If you do not enclosethe string in quotes, then the string is only the first tag found.The entire set of arguments need to be enclosed in quotes (\"\").",
                "paramname": "sArg"
            },
            {
                "paramdescription": "The mode of the task:\n0 - Task runs forever.\n1 - Task runs until the current page is changed.\n2 - Task runs until the current window is freed.\n4 -This mode is deprecated and not active. Currently, by default, taskrequests all I/O device data before starting. \n8 - If the task already exists, the function will exit without launching the new task.\n16- Task doesn't wait for necessary I/O device data and startsimmediately.\nYou can select any one of modes 0, 1 or 2 and may add mode 4 and/or mode 8, and/or mode 16. For example, set Mode to 6 to request I/O device data before starting the task, and to run the task until the current window is freed.",
                "paramname": "Mode"
            },
            {
                "paramdescription": "The subscription rate for the task, between 0 and 60000milliseconds, which determines the frequency at which the I/O Server reads I/O device data in order to provide tags withup-to-date Cicode variables. A value of -1 may be passedwhich will use the current task's subscription rate or thedefault value as set by the existing parameter[CODE]TimeData which defaults to 250.",
                "paramname": "SubscriptionRate"
            },
            {
                "paramdescription": "The name of the cluster context to be applied to the newCicode task. This is optional if you have one cluster or areresolving the task via the current cluster context. Theargument is enclosed in quotation marks \"\". You may pass \"-\"as the ClusterName argument to run the requested Cicodetask without a cluster context.",
                "paramname": "sClusterName"
            }
        ],
        "returnType": "The task handle, or -1 if the task cannot be successfully created. The task handle identifies the table where data on the associated task is stored.",
        "syntax": "TaskNewEx(sName, sArg, Mode, SubscriptionRate [, sClusterName] )"
    },
    "taskresume": {
        "doc": "Resumes a task that was suspended by the TaskSuspend() function. After a task is resumed, it runs on the next time-slice.",
        "example": "TaskResume(hTask);",
        "name": "TaskResume",
        "params": [
            {
                "paramdescription": "The task handle, returned from the TaskNew() or TaskHnd() function. The task handle identifies the table where all data on the associated task is stored.",
                "paramname": "hTask"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "TaskResume(hTask)"
    },
    "tasksetsignal": {
        "doc": "Manually applies a signal to a specified task.",
        "example": "No example found",
        "name": "TaskSetSignal",
        "params": [
            {
                "paramdescription": "The task's handle. To retrieve this use the function TaskHnd().",
                "paramname": "Hnd"
            },
            {
                "paramdescription": "Allows you to signal a specified task. Set to 0 (zero) for normal operation, 1 to stop the task or any other number that represents a defined signal.",
                "paramname": "nSignal"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "TaskSetSignal(Hnd, nSignal)"
    },
    "tasksuspend": {
        "doc": "Suspends a task. The task will stop running and will start again only when TaskResume() is called.",
        "example": "TaskSuspend(hTask);\n...\nTaskResume(hTask);",
        "name": "TaskSuspend",
        "params": [
            {
                "paramdescription": "The task handle, returned from the TaskNew() or TaskHnd() function. The task handle identifies the table where all data on the associated task is stored.",
                "paramname": "hTask"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "TaskSuspend(hTask)"
    },
    "testrandomwave": {
        "doc": "Generates a random wave. The height of the wave is restricted by minimum and maximum values. You can offset the starting point of the wave, for example, to display multiple waves at the same AN. You can use this function to generate test input.",
        "example": "/* Specify a random wave of 60 seconds duration, with a minimum \nvalue of 0 units and a maximum value of 100 units, with no offset. \n*/\n\nTestRandomWave(60,0,100,0);",
        "name": "TestRandomWave",
        "params": [
            {
                "paramdescription": "The number of seconds required to generate one cycle of the wave. If no period is entered, the period has a default of 60.",
                "paramname": "Period"
            },
            {
                "paramdescription": "The lowest value of the wave. If no low value is entered, this value has a default of 0.",
                "paramname": "Low"
            },
            {
                "paramdescription": "The highest value of the wave. If no high value is entered, this value has a default of 100.",
                "paramname": "High"
            },
            {
                "paramdescription": "The offset in seconds, to generate the wave. If no offset is entered, the offset has a default of 0.",
                "paramname": "Offset"
            }
        ],
        "returnType": "The value of the random wave.",
        "syntax": "TestRandomWave( [Period] [, Low] [, High] [, Offset] )"
    },
    "testsawwave": {
        "doc": "Generates a saw wave. The height of the wave is restricted by minimum and maximum values. You can offset the starting point of the wave, for example, to display multiple waves at the same AN. You can use this function to generate test input.",
        "example": "/* Specifies a saw wave of 60 seconds duration, with a minimum \nvalue of 0 units and a maximum value of 100 units, with no offset. \n*/\n\nTestSawWave();",
        "name": "TestSawWave",
        "params": [
            {
                "paramdescription": "The number of seconds required to generate one cycle of the wave. If no period is entered, the period has a default of 60.",
                "paramname": "Period"
            },
            {
                "paramdescription": "The lowest value of the wave. If no low value is entered, this value has a default of 0.",
                "paramname": "Low"
            },
            {
                "paramdescription": "The highest value of the wave. If no high value is entered, this value has a default of 100.",
                "paramname": "High"
            },
            {
                "paramdescription": "The offset in seconds, to generate the wave. If no offset is entered, the offset has a default of 0.",
                "paramname": "Offset"
            }
        ],
        "returnType": "The value of the saw wave.",
        "syntax": "TestSawWave( [Period] [, Low] [, High] [, Offset] )"
    },
    "testsinwave": {
        "doc": "Generates a sine wave. The height of the wave is restricted by minimum and maximum values. You can offset the starting point of the wave, for example, to display multiple waves at the same AN. You can use this function to generate test input.",
        "example": "/* Specifies a sine wave of 30 seconds duration, with a minimum \nvalue of 0 units and a maximum value of 100 units, with no offset. \n*/\n\nTestSinWave(30);",
        "name": "TestSinWave",
        "params": [
            {
                "paramdescription": "The number of seconds required to generate one cycle of the wave. If no period is entered, the period has a default of 60.",
                "paramname": "Period"
            },
            {
                "paramdescription": "The lowest value of the wave. If no low value is entered, this value has a default of 0.",
                "paramname": "Low"
            },
            {
                "paramdescription": "The highest value of the wave. If no high value is entered, this value has a default of 100.",
                "paramname": "High"
            },
            {
                "paramdescription": "The offset in seconds, to generate the wave. If no offset is entered, the offset has a default of 0.",
                "paramname": "Offset"
            }
        ],
        "returnType": "The value of the sine wave.",
        "syntax": "TestSinWave( [Period] [, Low] [, High] [, Offset] )"
    },
    "testsquarewave": {
        "doc": "Generates a square wave. The height of the wave is restricted by minimum and maximum values. You can offset the starting point of the wave, for example, to display multiple waves at the same AN. You can use this function to generate test input.",
        "example": "/* Specifies a square wave of 30 seconds duration, with a minimum \nvalue of -1000 units and a maximum value of 1000 units, with an \noffset of 10 seconds. */\n\nTestSquareWave(30,-1000,1000,10);",
        "name": "TestSquareWave",
        "params": [
            {
                "paramdescription": "The number of seconds required to generate one cycle of the wave. If no period is entered, the period has a default of 60.",
                "paramname": "Period"
            },
            {
                "paramdescription": "The lowest value of the wave. If no low value is entered, this value has a default of 0.",
                "paramname": "Low"
            },
            {
                "paramdescription": "The highest value of the wave. If no high value is entered, this value has a default of 100.",
                "paramname": "High"
            },
            {
                "paramdescription": "The offset in seconds, to generate the wave. If no offset is entered, the offset has a default of 0.",
                "paramname": "Offset"
            }
        ],
        "returnType": "The value of the square wave.",
        "syntax": "TestSquareWave( [Period] [, Low] [, High] [, Offset] )"
    },
    "testtriangwave": {
        "doc": "Generates a triangular wave. The height of the wave is restricted by minimum and maximum values. You can offset the starting point of the wave, for example, to display multiple waves at the same AN. You can use this function to generate test input.",
        "example": "/* Specifies a triangular wave of 60 seconds duration, with a \nminimum value of 0 units and a maximum value of 100 units, with no \noffset. */\n\nTestTriangWave();",
        "name": "TestTriangWave",
        "params": [
            {
                "paramdescription": "The number of seconds required to generate one cycle of the wave. If no period is entered, the period has a default of 60.",
                "paramname": "Period"
            },
            {
                "paramdescription": "The lowest value of the wave. If no low value is entered, this value has a default of 0.",
                "paramname": "Low"
            },
            {
                "paramdescription": "The highest value of the wave. If no high value is entered, this value has a default of 100.",
                "paramname": "High"
            },
            {
                "paramdescription": "The offset in seconds, to generate the wave. If no offset is entered, the offset has a default of 0.",
                "paramname": "Offset"
            }
        ],
        "returnType": "The value of the triangular wave.",
        "syntax": "TestTriangWave( [Period] [, Low] [, High] [, Offset] )"
    },
    "time_ciref": {
        "doc": "Gets the current time in string format.\nTime/date functions can only be used with dates from 1980 to 2035. You should check that the date you are using is valid with Cicode similar to the following:",
        "example": "No example found",
        "name": "Time_CIREF",
        "params": [
            {
                "paramdescription": "The format of the time:\n0 - Short time format, hh:mm AM/PM\n1 - Long time format., hh:mm:ss AM/PM\nIf omitted, the default Format is 0.",
                "paramname": "Format"
            }
        ],
        "returnType": "The current time (as a string).",
        "syntax": "Time( [Format] )"
    },
    "timecurrent": {
        "doc": "Gets the current system time/date in time/date variable format. Please be aware that Plant SCADA stores time as the number of seconds since 01/01/1970. You can convert this value into usable date and time variables by using the various Date and Time functions.\nTime/date functions can only be used with dates between 1980 and 2035. You should check that the date you are using is valid with Cicode similar to the following:",
        "example": "! If the current system time is 11:43:10 a.m.;\nTimeVariable=TimeToStr(TimeCurrent(),0);\n! Sets TimeVariable to \"11:43\".",
        "name": "TimeCurrent",
        "params": [],
        "returnType": "A time/date variable.",
        "syntax": "TimeCurrent()"
    },
    "timehour": {
        "doc": "Gets the hour value from a time/date variable.\nTime/date functions can only be used with dates from 1980 to 2035. You should check that the date you are using is valid with Cicode similar to the following:",
        "example": "! If the current system time is 11:43:10 a.m.;\nHoursVariable=TimeHour(TimeCurrent());\n! Sets HoursVariable to 11.",
        "name": "TimeHour",
        "params": [
            {
                "paramdescription": "The time/date variable.",
                "paramname": "Time"
            }
        ],
        "returnType": "The hour (as an integer).",
        "syntax": "TimeHour(Time)"
    },
    "timeinfo": {
        "doc": "Returns the time format currently used on the Plant SCADA Server.",
        "example": "! If the current system time is 15:43:10.;\nClockType=TimeInfo(1);\n! Sets ClockType to \"1\".",
        "name": "TimeInfo",
        "params": [
            {
                "paramdescription": "Determines the contents of the string returned by the TimeInfo() function. Valid values and resulting strings are:\n1- The current time hour format:\n\"0\" - 12 hour\n\"1\" - 24 hour\n2- The current time delimiter.\n3- The current morning time extension.\n4- The current evening time extension.",
                "paramname": "nInfo"
            }
        ],
        "returnType": "Depending on the nInfo argument passed to the function, a string containing:",
        "syntax": "TimeInfo(nInfo)"
    },
    "timeinttotimestamp": {
        "doc": "Converts a time INTEGER which is represented as a number of seconds since 01/01/1970 to a TIMESTAMP.",
        "example": "\tINT TimeInt = TimeCurrent();",
        "name": "TimeIntToTimestamp",
        "params": [
            {
                "paramdescription": "The number of seconds since 01/01/1970.",
                "paramname": "TimeInt"
            },
            {
                "paramdescription": "The number of milliseconds since last second (optional).",
                "paramname": "Millesecond"
            },
            {
                "paramdescription": "Coordinated Universal Time (optional):\n0 – The given time INTEGER is a local date/time.\n1 – The given time INTEGER is a UTC date/time (default).",
                "paramname": "UTC"
            }
        ],
        "returnType": "A TIMESTAMP variable or INVALID_TIMESTAMP if invalid.",
        "syntax": "TimeIntToTimestamp(INT TimeInt [, INT Millisecond [, INT UTC]])"
    },
    "timemidnight": {
        "doc": "Returns the number of seconds between midnight on January 1, 1970, and the midnight immediately prior to the specified time/date. This function is useful for performing calculations with the time and date.\nTime/date functions can only be used with dates from 1980 to 2035. You should check that the date you are using is valid with Cicode similar to the following:",
        "example": "timeNow = TimeCurrent();\n! get the time variable at 7am today\ntime7am = TimeMidNight(timeNow) + 7*60*60;\nIF timeNow > time7am AND timeNow < time7am + 10 THEN\n    Beep();\n    Prompt(\"Wake Up!\");\nEND",
        "name": "TimeMidNight",
        "params": [
            {
                "paramdescription": "The time/date variable.",
                "paramname": "Time"
            }
        ],
        "returnType": "A time/date variable.",
        "syntax": "TimeMidNight(Time)"
    },
    "timemin": {
        "doc": "Gets the minutes value from a time/date variable.\nTime/date functions can only be used with dates from 1980 to 2035. You should check that the date you are using is valid with Cicode similar to the following:",
        "example": "! If the current system time is 11:43:10 a.m.\nMinutesVariable=TimeMin(TimeCurrent());\n! Sets MinutesVariable to 43.",
        "name": "TimeMin",
        "params": [
            {
                "paramdescription": "The time/date variable.",
                "paramname": "Time"
            }
        ],
        "returnType": "The minute (as an integer).",
        "syntax": "TimeMin(Time)"
    },
    "timesec": {
        "doc": "Gets the seconds value from a time/date variable.\nTime/date functions can only be used with dates from 1980 to 2035. You should check that the date you are using is valid with Cicode similar to the following:",
        "example": "! If the current system time is 11:43:10 a.m.;\nSecondsVariable=TimeSec(TimeCurrent());\n! Sets SecondsVariable to 10.",
        "name": "TimeSec",
        "params": [
            {
                "paramdescription": "The time/date variable.",
                "paramname": "Time"
            }
        ],
        "returnType": "The second (as an integer).",
        "syntax": "TimeSec(Time)"
    },
    "timeset": {
        "doc": "Sets the new system time. You can set the time only on the computer which thisfunction is called.\nTime/date functions can only be used with dates from 1980 to 2035.\nIf you call TimeSet without the required privileges tochange the system time you will receive a hardware alarm indicating this.",
        "example": "! set the time to 11:43 on June 23 1993\ntime = StrToTime(\"11:43:00\") + StrToDate(\"23/6/93\");\nTimeSet(time);.",
        "name": "TimeSet",
        "params": [
            {
                "paramdescription": "The time/date variable to which the new time is set. Sets the time on thiscomputer only.",
                "paramname": "Time"
            }
        ],
        "returnType": "The error status of the set",
        "syntax": "TimeSet(Time)"
    },
    "timestampadd": {
        "doc": "Adds an offset to a TIMESTAMP variable.",
        "example": "TIMESTAMP t1 = TimestampAdd(Tag1.T, 100); // 100 seconds",
        "name": "TimestampAdd",
        "params": [
            {
                "paramdescription": "The timestamp to which Offset will be added",
                "paramname": "Timestamp"
            },
            {
                "paramdescription": "The offset to add, expressed in units of the part parameter",
                "paramname": "Offset"
            },
            {
                "paramdescription": "Indicates which part to add:\n0 – Offset is in years.\n1 – Offset is in months.\n2 – Offset is in days.\n3 - Offset is in hours.\n4 - Offset is in minutes.\n5 - Offset is in seconds (default)\n6 - Offset is in milliseconds",
                "paramname": "Part"
            }
        ],
        "returnType": "The TIMESTAMP variable, or INVALID_TIMESTAMP if invalid.",
        "syntax": "TimestampAdd(TIMESTAMP Timestamp, INT Offset [, INT Part])"
    },
    "timestampcreate": {
        "doc": "Returns a TIMESTAMP variable created from the parts.\nTimestamp: \nThe timestamp from which the part will be extracted.",
        "example": "TIMESTAMP timestamp = TimestampCreate(2009, 6, 29, 11, 2, 10, 468);",
        "name": "TimestampCreate",
        "params": [
            {
                "paramdescription": "The year part.",
                "paramname": "Year"
            },
            {
                "paramdescription": "The month part.",
                "paramname": "Month"
            },
            {
                "paramdescription": "The day part.",
                "paramname": "Day"
            },
            {
                "paramdescription": "The hour part.",
                "paramname": "Hour"
            },
            {
                "paramdescription": "The minute part.",
                "paramname": "Minute"
            },
            {
                "paramdescription": "The second part.",
                "paramname": "Second"
            },
            {
                "paramdescription": "The millisecond part.",
                "paramname": "Millisecond"
            },
            {
                "paramdescription": "Coordinated Universal Time (optional):\n0 – The given time INTEGER is a local date/time.\n1 – The given time INTEGER is a UTC date/time (default).",
                "paramname": "UTC"
            }
        ],
        "returnType": "The composed TIMESTAMP variable, or INVALID_TIMESTAMP if invalid",
        "syntax": "TimestampCreate(INT Year, INT Month, INT  Day, INT  Hour, INT  Minute, INT  Second, INT  Millisecond [, INT bUtc])"
    },
    "timestampcurrent": {
        "doc": "Return the current system date and time as a TIMESTAMP variable.",
        "example": "TIMESTAMP t1 = TimestampCurrent();",
        "name": "TimestampCurrent",
        "params": [],
        "returnType": "A TIMESTAMP variable containing the current system date and time.",
        "syntax": "TimestampCurrent()"
    },
    "timestampdifference": {
        "doc": "Returns the difference between two TIMESTAMP variables as a number of milliseconds.",
        "example": "TIMESTAMP t1 = TimestampCreate(2008, 11, 28, 09, 01, 30);",
        "name": "TimestampDifference",
        "params": [
            {
                "paramdescription": "The TIMESTAMP variable 1.",
                "paramname": "Timestamp 1"
            },
            {
                "paramdescription": "The TIMESTAMP variable 2.",
                "paramname": "Timestamp 2"
            },
            {
                "paramdescription": "The type of time units being used for the result:\n 0 – Result is in years.\n 1 – Result is in months. \n2 – Result is in days. \n3 - Result is in hours\n 4 - Result is in minutes. \n5 - Result is in seconds (default).\n6 - Result is in milliseconds.",
                "paramname": "Part"
            },
            {
                "paramdescription": "Defines how to pass results which values are greater than their time units (see example below).\n 0 – Non-cumulative \n1 – Cumulative mode (default).",
                "paramname": "bCumulative"
            }
        ],
        "returnType": "The time period between Timestamp1 and Timestamp2. The value is equal or greater than zero. If error, returns 0 with an error code.",
        "syntax": "TimestampDifference(TIMESTAMP Timestamp1, TIMESTAMP Timestamp2 [, INT Part[, INT bCumulative]])"
    },
    "timestampformat": {
        "doc": "Format a TIMESTAMP variable into a string.",
        "example": "TIMESTAMP t1 = TimestampCreate(2009,07,11,09,27,34,123);",
        "name": "TimestampFormat",
        "params": [
            {
                "paramdescription": "The timestamp variable.",
                "paramname": "Timestamp"
            },
            {
                "paramdescription": "The format of the string is the same as .NET Framework DateTime format. Specifically be reminded that the format is case sensitive. For example 'MM' is the zero padded month number, whereas 'mm' is the zero padded current minute within the hour. Therefore no Year, Day or Seconds will be displayed if they are specified in uppercase as: YYYY, DD, SS. The correct display will only occur when they are specified in lowercase as: yyyy, dd, ss.\nA short list of formats are included below extracted from the\"Custom Date and Time Format Strings\" in the Microsoft .NET Framework Developer's Guide from the MSDN Library. It is recommended that you confirm its currency by consulting the source information periodically.\nUse the following single-character format strings by themselves to choose predefined standard date and time formats:\nd Short date pattern. Ex. \"6/15/2009\"\nD Long date pattern. Ex. \"Monday, June 15, 2009\"\nf Full date/time pattern (short time). Ex. \"Monday, June 15, 2009 1:45 PM\"\nF Full date/time pattern (long time). Ex. \"Monday, June 15, 2009 1:45:30 PM\"\ng General date/time pattern (short time). Ex. \"6/15/2009 1:45 PM\"\nG General date/time pattern (long time). Ex. \"6/15/2009 1:45:30 PM\"\nM or m Month/day pattern. \"June 15\"\nO or o Round-trip date/time pattern. Ex. \"2009-06-15T13:45:30.0900000\"\nR or r RFC1123 pattern. Ex. \"Mon, 15 Jun 2009 20:45:30 GMT\"\ns Sortable date/time pattern. Ex. \"2009-06-15T13:45:30\"\nt Short time pattern. Ex. \"1:45 PM\"\nT Long time pattern. Ex. \"1:45:30 PM\"\nu Universal sortable date/time pattern. Ex. \"2009-06-15 20:45:30Z\"\nU Universal full date/time pattern. Ex. \"Monday, June 15, 2009 8:45:30 PM\"\nY or y Year month pattern. Ex. \"June, 2009\"\nFor all the examples above, the input time/date is assumed to be 6/15/2009 1:45:30 PM with Windows set to the en-US locale. Many of the formats will change according to the current Windows locale.\nYou may combine the following format specifiers to make up custom format specifications:\nd The day of the month, from 1 through 31.\ndd The day of the month, from 01 through 31.\nddd The abbreviated name of the day of the week.\ndddd The full name of the day of the week.\nf Fraction of a second. Returns one decimal place for each 'f', up to 'fffffff'\nF Fraction of a second, if non-zero. Returns one decimal place for each 'f', up to 'fffffff'\ng, gg The period or era.\nh The hour, using a 12-hour clock from 1 to 12.\nhh The hour, using a 12-hour clock from 01 to 12.\nH The hour, using a 24-hour clock from 0 to 23.\nHH The hour, using a 24-hour clock from 00 to 23.\nK Time zone information.\nm The minute, from 0 through 59.\nmm The minute, from 00 through 59.\nM The month, from 1 through 12.\nMM The month, from 01 through 12.\nMMM The abbreviated name of the month.\nMMMM The full name of the month.\ns The second, from 0 through 59.\nss The second, from 00 through 59.\nt The first character of the AM/PM designator.\ntt The AM/PM designator.\ny The year, from 0 to 99.\nyy The year, from 00 to 99.\nyyy The year, with a minimum of three digits.\nyyyy The year as a four-digit number.\nyyyyy The year as a five-digit number.\nz Hours offset from UTC, with no leading zeros.\nzz Hours offset from UTC, with a leading zero for a single-digit value.\nzzz Hours and minutes offset from UTC.\n: The time separator.\n/ The date separator.\n\"string\" or 'string' Literal string delimiter.\n% Defines the following character as a custom format specifier.\n\\ The escape character.\nAny other character The character is copied to the result string unchanged.",
                "paramname": "Format"
            },
            {
                "paramdescription": "Coordinated Universal Time (optional):\n0 - Returns the time as a local date/time (default).\n1 - Returns the time as a UTC date/time.",
                "paramname": "UTC"
            }
        ],
        "returnType": "A string containing the converted time/date, or an empty string if invalid.",
        "syntax": "TimestampFormat(TIMESTAMP Timestamp, STRING Format [, INT UTC])"
    },
    "timestampgetpart": {
        "doc": "Returns one part (year, month, day, etc) of the TIMESTAMP variable.",
        "example": "TIMESTAMP t1;\n\t// insert code here\nINT year = TimestampGetPart(t1, 0);\nINT second = TimestampGetPart(t1, 5);",
        "name": "TimestampGetPart",
        "params": [
            {
                "paramdescription": "The timestamp from which the part will be extracted.",
                "paramname": "Timestamp"
            },
            {
                "paramdescription": "Indicates which part to extract:\n0 – The year part \n1 – The month part.\n2 – The day part.\n3 – The hour part.\n4 – The minute part.\n5 – The second part.\n6 – The millisecond part.\n7 - The number of milliseconds since midnight last occurred.",
                "paramname": "Part"
            },
            {
                "paramdescription": "Coordinated Universal Time (optional):\n0 – The given time INTEGER is a local date/time.(default).\n1 – The given time INTEGER is a UTC date/time.",
                "paramname": "UTC"
            }
        ],
        "returnType": "The required part of the TIMESTAMP variable.",
        "syntax": "TimestampGetPart(TIMESTAMP Timestamp, INT Part [, INT bUtc])"
    },
    "timestampsub": {
        "doc": "Subtracts an offset from a TIMESTAMP variable.",
        "example": "TIMESTAMP t1 = TimestampSub(Tag1.T, 1, 0); // 1 year;",
        "name": "TimestampSub",
        "params": [
            {
                "paramdescription": "The timestamp to which Offset will be subtracted",
                "paramname": "Timestamp"
            },
            {
                "paramdescription": "The offset to subtract, expressed in units of the part parameter",
                "paramname": "Offset"
            },
            {
                "paramdescription": "Indicates which part to subtract:\n0 – Offset is in years.\n1 – Offset is in months.\n2 – Offset is in days.\n3 - Offset is in hours.\n4 - Offset is in minutes.\n5 - Offset is in seconds (default)\n6 - Offset is in milliseconds",
                "paramname": "Part"
            }
        ],
        "returnType": "The TIMESTAMP variable, or INVALID_TIMESTAMP if invalid.",
        "syntax": "TimestampSub(TIMESTAMP Timestamp, INT Offset [, INT Part])"
    },
    "timestamptostr": {
        "doc": "Converts a TIMESTAMP variable into a string.",
        "example": "TIMESTAMP t1 = TimestampCreate(2009,07,11,09,27,34,123);\nSTRING sTimestamp = TimestampToStr(t1, 0, 0);\n// sTimestamp equals '9:27 AM'",
        "name": "TimestampToStr",
        "params": [
            {
                "paramdescription": "Specifies the TIMESTAMP variable.",
                "paramname": "Timestamp"
            },
            {
                "paramdescription": "The format number determines which of date/time patterns are used for formatting returned string. Date/time patterns are defined in regional settings on a particular computer and can vary depend on national or individual preferences. The possible format numbers together with examples based on en-US regional settings are listed below:\n0 – Short time format, hh:mm.\n1 – Long time format, hh:mm:ss.\n2 – Short date format, dd/MM/yyyy.\n3 – Long date format, dddd, dd MMMM yyyy.\n4 – Short date & short time format, dd/MM/yyyy hh:mm.\n5 – Short date & long time format, dd/MM/yyyy hh:mm:ss.\n6 – Long date & short time format, dddd, dd MMMM yyyy hh:mm.\n7 – Long date & long time format, dddd, dd MMMM yyyy hh:mm:ss.\n8 – Month day format, dd MMMM.\n9 – Year month format, MMMM yyyy.\n10 – RFC1123 format, ddd, dd MMM yyyy hh:mm:ss GMT\n11 – Sortable date time format, yyyy-MM-ddThh:mm:ss\n12 – Short universal format, yyyy-MM-dd hh:mm:ssZ\n13 – Long universal format, dddd, dd MMMM yyyy hh:mm:ss\n14 – Long Time & millisecond, hh:mm:ss.fff\n15 - Date and time as a 64-bit value specified by the number of 100-nanosecond intervals since January 1, 1601 .",
                "paramname": "Format"
            },
            {
                "paramdescription": "0 - Display the string as a local date/time (default).\n1 - Display the string as a UTC date/time.",
                "paramname": "UTC (optional - short for Universal Time Coordinate)"
            }
        ],
        "returnType": "A string containing the converted time/date or period variable, or an empty string if invalid.",
        "syntax": "TimestampToStr(Timestamp, INT Format [, INT UTC])"
    },
    "timestamptotimeint": {
        "doc": "Converts a TIMESTAMP variable into a time INTEGER which is represented as a number of seconds since 01/01/1970.",
        "example": "TIMESTAMP t1 = TimestampCreate(2009,07,11,09,27,34,123);",
        "name": "TimestampToTimeInt",
        "params": [
            {
                "paramdescription": "The timestamp variable.",
                "paramname": "Timestamp"
            },
            {
                "paramdescription": "Coordinated Universal Time (optional):\n0 – Returns the time as a local date/time.\n1 – Returns the time as a UTC date/time (default)",
                "paramname": "UTC"
            }
        ],
        "returnType": "Time as a number of seconds since 01/01/1970 in UTC or local time depending on the last input parameter,-1 if invalid.",
        "syntax": "TimestampToTimeInt(TIMESTAMP Timestamp [, INT UTC])"
    },
    "timetooledate": {
        "doc": "Converts a Plant SCADA time/date value to an OLE DATE value (this should be stored in a REAL).",
        "example": "Real = TimeToOLEDate(TimeCurrent(), 1);\n! Sets Real to the local date/time value",
        "name": "TimeToOLEDate",
        "params": [
            {
                "paramdescription": "",
                "paramname": "Time"
            },
            {
                "paramdescription": "",
                "paramname": "Time/date variable."
            },
            {
                "paramdescription": "0 - The return value is output as UTC time.\n1 - The return value is output as Local time.",
                "paramname": "Local"
            }
        ],
        "returnType": "Returns an OLE date value.",
        "syntax": "TimeToOLEDate(Time, Local)"
    },
    "timetostr": {
        "doc": "Converts a time/date variable into a string. Use this function for calculating time differences or run times, and so on. Set Format to 6 to convert time periods that are in milliseconds, such as the times that are returned from the SysTime() and SysTimeDelta() functions.\nTime/date functions can only be used with dates from 1980 to 2035. You should check that the date you are using is valid with Cicode similar to the following:",
        "example": "! If the current system time is 11:50:00 a.m.\nString=TimeToStr(TimeCurrent(),0);\n! Sets String to \"11:50 AM\".\nString=TimeToStr(125 + TimeCurrent(),5);\n! Sets String to \"11:52:05\" (the current time + 2 minutes and 5 \nseconds).",
        "name": "TimeToStr",
        "params": [
            {
                "paramdescription": "The time/date variable.",
                "paramname": "Time"
            },
            {
                "paramdescription": "",
                "paramname": "Format"
            },
            {
                "paramdescription": "0 - Short time format, hh:mm AM/PM.\n1 - Long time format, hh:mm:ss AM/PM.\n2 - Short date format, based on the system locale setting. For example, dd/mm/yy for English (Australia); mm/dd/yy for English (United States); or dd.mm.yy for German (Germany).\n3 - Long date format, day month year.\n4 - Time and date, weekday month day year hh:mm:ss AM/PM.\n5 - Long time period, hh:mm:ss. Time needs to be in seconds.\n6 - Millisecond time period, hh:mm:ss.xxx (\"xxx\" represents milliseconds). Time needs to be in milliseconds.\n7 - Short time period, hh:mm. Time needs to be in seconds.\n8 - Long time period, \"xxxxx Days hh Hours mm min ss sec\". Time needs to be in seconds.\n9 - Extended date format, based on the system locale setting. For example, dd/mm/yyyy for English (Australia); mm/dd/yyyy for English (United States); or dd.mm.yyyy for German (Germany).\n10 - Local TimeDate format, yyyy-mm-dd hh:mm:ss\n11 - Time of Day, hh:mm:ss tt format with no date",
                "paramname": "Format of the string"
            },
            {
                "paramdescription": "Coordinated Universal Time (optional)\n0 - Display the string as a local date/time (default).\n1 - Display the string as a UTC date/time (valid for formats 0-4 and 9).",
                "paramname": "UTC"
            }
        ],
        "returnType": "A string containing the converted time/date or period variable, or an empty string if invalid.",
        "syntax": "TimeToStr(Time, Format [, UTC] )"
    },
    "timeutcoffset": {
        "doc": "Determines the local time bias from UTC that was in force at a specified time. For example, US Pacific Standard Time is -8 hrs from UTC, so -28800 would be returned (-8 hours x 60 minutes x 60 seconds). However, if the specified time occurred during daylight saving, the returned value would be -7 hours (or -25200 seconds).",
        "example": "No example found",
        "name": "TimeUTCOffset",
        "params": [
            {
                "paramdescription": "The time/date variable.",
                "paramname": "Time"
            }
        ],
        "returnType": "The local time bias in seconds.",
        "syntax": "TimeUTCOffset(Time)"
    },
    "toggle": {
        "doc": "Toggles a digital tag on or off. If the variable tag is ON (1), this function will turn it OFF. If the variable tag is OFF (0), this function will turn it ON.",
        "example": "Toggle(MyCluster.Alarm_1.Paging);",
        "name": "Toggle",
        "params": [
            {
                "paramdescription": "The digital tag to toggle.",
                "paramname": "sTag"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "Toggle(sTag)"
    },
    "tracemsg": {
        "doc": "Displays a message in the Kernel and Debugger debug windows.",
        "example": "TraceMsg(\"Error Found\");\n// Displays \"Error Found\" in the debug window",
        "name": "TraceMsg",
        "params": [
            {
                "paramdescription": "The message to display.",
                "paramname": "String"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "TraceMsg(String)"
    },
    "trenddspcursorcomment": {
        "doc": "Displays the Trend Comment for the currently selected pen on the displayed trend graph.",
        "example": "No example found",
        "name": "TrendDspCursorComment",
        "params": [
            {
                "paramdescription": "The AN of the trend.",
                "paramname": "nAN"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "TrendDspCursorComment(nAN)"
    },
    "trenddspcursorscale": {
        "doc": "Displays a scale value for the current pen in the current pen font.",
        "example": "No example found",
        "name": "TrendDspCursorScale",
        "params": [
            {
                "paramdescription": "The AN of the trend.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The percentage of full scale to display for the current pen, asan integer.",
                "paramname": "Percent"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "TrendDspCursorScale(nAN, Percent)"
    },
    "trenddspcursortag": {
        "doc": "Displays the trend tag name of the current pen in the pen font.",
        "example": "No example found",
        "name": "TrendDspCursorTag",
        "params": [
            {
                "paramdescription": "The AN of the trend.",
                "paramname": "AN"
            },
            {
                "paramdescription": "An optional argument used to specify whether the trend tagname is displayed with a cluster prefix. Set:\n0 display tag without cluster prefix (default)\n1 display tag with cluster prefix.\n0 (zero) if successful, otherwise an error code is returned.",
                "paramname": "Mode"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "TrendDspCursorTag(AN [, Mode] )"
    },
    "trenddspcursortime": {
        "doc": "Displays the cursor time of the current pen in the current pen font.",
        "example": "No example found",
        "name": "TrendDspCursorTime",
        "params": [
            {
                "paramdescription": "The AN number of the trend.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "",
                "paramname": "Format"
            },
            {
                "paramdescription": "0 - Short time format, hh:mm AM/PM.\n1 - Long time format, hh:mm:ss AM/PM.\n2 - Short date format, dd/mm/yy.\n3 - Long date format, day month year.\n4 - Time and date, weekday month day year hh:mm:ss AM/PM.\n5 - Long time period, hh:mm:ss. Time needs to be in seconds.\n6 - Millisecond time period, hh:mm:ss:xxx (\"xxx\" represents milliseconds). Time needs to be in milliseconds.\n7 - Short time period, hh:mm. Time needs to be in seconds.\n8 - Long time period, days:hh:mm:sec. Time needs to be in seconds.\n9 - Extended date format, dd/mm/yyyy.\n0 (zero) if successful, otherwise an error code is returned.",
                "paramname": "Format of the string"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "TrendDspCursorTime(nAN, Format)"
    },
    "trenddspcursorvalue": {
        "doc": "Display the cursor value of the current pen in the current pen font.",
        "example": "No example found",
        "name": "TrendDspCursorValue",
        "params": [
            {
                "paramdescription": "The AN of the trend.",
                "paramname": "AN"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "TrendDspCursorValue(nAN)"
    },
    "trendgetan": {
        "doc": "Gets the AN number of the trend beneath the current mouse position.",
        "example": "No example found",
        "name": "TrendGetAn",
        "params": [],
        "returnType": "The AN of the trend, or 0 (zero) if the mouse is not positioned over a valid trend.",
        "syntax": "TrendGetAn()"
    },
    "trendpopup": {
        "doc": "Displays a pop-up trend with the specified trend pens. You need to create the trend page with the graphic builder and set the pen names to blank.",
        "example": "No example found",
        "name": "TrendPopUp",
        "params": [
            {
                "paramdescription": "The name of the trend page (drawn with the GraphicsBuilder).",
                "paramname": "sPage"
            },
            {
                "paramdescription": "The First trend tag to display on the page.",
                "paramname": "sTag1"
            },
            {
                "paramdescription": "The trend tags to display on the page.",
                "paramname": "sTag2..sTag8"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "TrendPopUp(sPage, sTag1 [, sTag2..sTag8] )"
    },
    "trendrun": {
        "doc": "Initializes the cursor and rubber-band features on a trend page. This function is included as a Cicode Object on all new trend pages. Only use this function when configuring a trend template that requires this functionality.",
        "example": "No example found",
        "name": "TrendRun",
        "params": [
            {
                "paramdescription": "The type of the page:\n0 - Normal trend page template\n1 - Compare trend page template",
                "paramname": "iPageType"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "TrendRun(iPageType)"
    },
    "trendsetdate": {
        "doc": "Sets the end date for all pens on a trend. Samples taken after this date will not be displayed. You can enter the date in the Value argument, or leave the Value blank - a form is then displayed in run time for the operator to enter an end date.",
        "example": "No example found",
        "name": "TrendSetDate",
        "params": [
            {
                "paramdescription": "The AN of the trend.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The new date, as a string. Samples taken after date will not be displayed. This argument is optional.",
                "paramname": "Value"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "TrendSetDate(nAN, Value)"
    },
    "trendsetscale": {
        "doc": "Sets the scale of the current pen or of all pens on a trend. You can enter a scale in the Value argument, or leave the Value blank. A form is then displayed in run time for the operator to enter a value for the scale.",
        "example": "No example found",
        "name": "TrendSetScale",
        "params": [
            {
                "paramdescription": "The AN of the trend.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The scale to be set:\n0 - Zero scale\n100 - Full scale",
                "paramname": "Percent"
            },
            {
                "paramdescription": "An optional value for the scale, as a string.",
                "paramname": "Value"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "TrendSetScale(nAN, Percent [, Value] )"
    },
    "trendsetspan": {
        "doc": "Sets the span time of the trend. The span time is the time period covered in the trend window. You can enter a span time in the Value argument, or leave the Value blank - a form is then displayed in run time for the operator to enter a value for the span time.",
        "example": "No example found",
        "name": "TrendSetSpan",
        "params": [
            {
                "paramdescription": "The AN of the trend.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "An optional value for the span time, as a string.",
                "paramname": "Value"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "TrendSetSpan(AN [, Value] )"
    },
    "trendsettime": {
        "doc": "Sets the end time for all the pens on a trend. Samples taken after this time will not be displayed. You can enter an end time in the Value argument, or leave the Value blank - a form is then displayed in run time for the operator to enter a value for the end time.",
        "example": "No example found",
        "name": "TrendSetTime",
        "params": [
            {
                "paramdescription": "The AN of the trend.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "An optional value for the end time, as a string. Samples taken after this time will not be displayed.",
                "paramname": "Value"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "TrendSetTime(AN [, Value] )"
    },
    "trendsettimebase": {
        "doc": "Sets a new sampling period for a trend. You can enter a sampling period in the Value argument, or leave the Value blank. A form is then displayed in run time for the operator to enter a value for the sampling period.",
        "example": "No example found",
        "name": "TrendSetTimebase",
        "params": [
            {
                "paramdescription": "The AN of the trend.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "An optional value for the sampling period, as a string.",
                "paramname": "Value"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "TrendSetTimebase(AN [, Value] )"
    },
    "trendwin": {
        "doc": "Displays a trend page (in a new window) with the specified trend pens. You need to create the trend page with the graphic builder and set the pen names to blank. You then display that page by calling this function and pass the required trend tags. The function will create a new window with the specified window mode.",
        "example": "No example found",
        "name": "TrendWin",
        "params": [
            {
                "paramdescription": "The name of the trend page (drawn with the GraphicsBuilder).",
                "paramname": "sPage"
            },
            {
                "paramdescription": "The x pixel coordinate of the top left corner of the window.",
                "paramname": "X"
            },
            {
                "paramdescription": "The y pixel coordinate of the top left corner of the window.",
                "paramname": "Y"
            },
            {
                "paramdescription": "The mode of the window:\n0 - Normal page.\n1 - Page child window. The window is closed when a new page is displayed, for example, when the PageDisplay() or PageGoto() function is called. The parent is the current active window.\n2 - Window child window. The window is closed automatically when the parent window is freed with the WinFree() function. The parent is the current active window.\n4 - No re-size. The window is displayed with thin borders and no maximize/minimize icons. The window cannot be re-sized.\n8 - No icons. The window is displayed with thin borders and no maximize/minimize or system menu icons. The window cannot be re-sized.\n16 - No caption. The window is displayed with thin borders, no caption, and no maximize/minimize or system menu icons. The window cannot be re-sized.\n32 - Echo enabled. When enabled, keyboard echo, prompts, and error messages are displayed on the parent window. This mode should only be used with child windows (for example, Mode 1 and 2).\n64 - Always on top.\n128 - Open a unique window. This mode helps prevent this window from being opened more then once.\n256 - Display the entire window. This mode commands that no parts of the window will appear off the screen\n512 - Open a unique Super Genie. This mode helps prevent a Super Genie from being opened more than once (at the same time). However, the same Super Genie with different associations can be opened.\n1024 - Disables dynamic resizing of new window, overriding the setting of the [Page]DynamicSizing parameter.\nYou can select multiple modes by adding modes together (for example, set Mode to 9 to open a page child window without maximize, minimize, or system menu icons).",
                "paramname": "Mode"
            },
            {
                "paramdescription": "The firs trend tag to display on the page.",
                "paramname": "sTag1"
            },
            {
                "paramdescription": "The trend tags to display on the page.",
                "paramname": "sTag2..sTag8"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "TrendWin(sPage, X, Y, Mode, sTag1 [, sTag2..sTag8] )"
    },
    "trendzoom": {
        "doc": "\"Zooms\" a specified trend in either one or both axes. Set the zoom values (TimeZoom and/or ScaleZoom) to greater than one to \"zoom in\" or to less than one to \"zoom out\".\nIf you specify a destination AN, you can zoom one trend (at SourceAn) onto another (at DestAn), in the same way as on the standard zoom trend page.",
        "example": "TrendZoom(30, 2.0, 2.0);\n/* Zoom in by a factor of 2 on both the time and scale axes. */\nTrendZoom(30, 0.5, 0.5);\n/* Zoom out by a factor of 2 on both the time and scale axes. */",
        "name": "TrendZoom",
        "params": [
            {
                "paramdescription": "The AN on which the source trend is located.",
                "paramname": "SourceAN"
            },
            {
                "paramdescription": "The scale by which the Time axis will be changed (as a real number).",
                "paramname": "TimeZoom"
            },
            {
                "paramdescription": "The scale by which the Scale axis will be changed (as a real number).",
                "paramname": "ScaleZoom"
            },
            {
                "paramdescription": "The AN on which the destination or target trend is located. If you do not enter a DestAn, it is set to the same AN as SourceAn.",
                "paramname": "DestAn"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "TrendZoom(SourceAN, TimeZoom, ScaleZoom [, DestAn] )"
    },
    "trnaddhistory": {
        "doc": "Adds an old (backed up) trend history file to the trend system so that its data can be used. When you back-up a trend file, change its extension so that it indicates the age of the file's trend data (for example, the month and year).\nAn archived trend file does not need to reside in the same directory as existing active trends. Plant SCADA retrieves the trend name from the header of the specified file and adds its data to the trend history. Please be aware that only a reference to the archived file, and not the file itself, is kept in the trend history. Therefore, care needs to be taken if using this function to access archived files residing on removable storage media. When you remove the media, the archived data is no longer available for display.\nThis function can only be used if the Trend Server is on the current machine. When the Trend Server is not in the calling process, this function will become blocking and cannot be called from a foreground task. In this case, the return value will be undefined and a Cicode hardware alarm will be raised.",
        "example": "TrnAddHistory(\"C:\\\nPlant SCADA\nx\\DATA\\TR1.MAY91\");\n! Adds the file TR1.MAY91 to the trend system.",
        "name": "TrnAddHistory",
        "params": [
            {
                "paramdescription": "The file name and directory path of an old history file. The old file does not need to reside in the same directory as existing active trends to be restored.",
                "paramname": "FileName"
            },
            {
                "paramdescription": "Specifies the name of the cluster in which the Trend Server resides. This is optional if you have one cluster or are resolving the trend server via the current cluster context. The argument is enclosed in quotation marks \"\".",
                "paramname": "sClusterName"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "TrnAddHistory(FileName [, sClusterName] )"
    },
    "trnbrowseclose": {
        "doc": "The TrnBrowseClose function terminates an active data browse session and cleans up all resources associated with the session.\nThis function is a non-blocking function. It does not block the calling Cicode task.\nTrnBrowseClose(iSession)\niSession \n0 (zero) if the trend browse session exists, otherwise an error code is returned.",
        "example": "No example found",
        "name": "TrnBrowseClose",
        "params": [],
        "returnType": "0 (zero) if the trend browse session exists, otherwise an error code is returned.",
        "syntax": "The TrnBrowseClose function terminates an active data browse session and cleans up all resources associated with the session."
    },
    "trnbrowsefirst": {
        "doc": "The TrnBrowseFirst function places the data browse cursor at the first record.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "TrnBrowseFirst",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by a TrnBrowseOpen call.",
                "paramname": "iSession"
            }
        ],
        "returnType": "0 (zero) if the trend browse session exists, otherwise an error code is returned.",
        "syntax": "TrnBrowseFirst(iSession)"
    },
    "trnbrowsegetfield": {
        "doc": "The TrnBrowseGetField function retrieves the value of the specified field from the record the data browse cursor is currently referencing.\nThis function is a non-blocking function. It does not block the calling Cicode task.",
        "example": "STRING fieldValue = \"\";\nSTRING fieldName = \"TYPE\";\nINT errorCode = 0;\n...\nfieldValue = TrnBrowseGetField(iSession, sFieldName);\nIF fieldValue <> \"\" THEN\n    // Successful case\nELSE\n    // Function did not succeed\nEND\n...",
        "name": "TrnBrowseGetField",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by aTrnBrowseOpen call.",
                "paramname": "Session"
            },
            {
                "paramdescription": "The name of the field that references the value to be returned.Supported fields are:\nACQERROR, AREA, EQUIPMENT, EXPRESSION, FILENAME, FILES, ITEM, LSL, PRIV, RANGE, SDEVIATION, SPCFLAG, STORMETHOD, SUBGRPSIZE, TIME, TRIGGER, USL, XDOUBLEBAR.\nSee Browse Function Field Reference for information about fields.",
                "paramname": "FieldName"
            }
        ],
        "returnType": "The value of the specified field as a string. An empty string may or may not be an indication that an error has been detected. This should be checked in this instance to determine if an error has actually occurred.",
        "syntax": "STRING TrnBrowseGetField(INT Session, STRING FieldName)"
    },
    "trnbrowsenext": {
        "doc": "The TrnBrowseNext function moves the data browse cursor forward one record. If you call this function after you have reached the end of the records, error412 is returned (Databrowse session EOF).\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "TrnBrowseNext",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by a TrnBrowseOpen call.",
                "paramname": "iSession"
            }
        ],
        "returnType": "0 (zero) if the trend browse session exists, otherwise an error code is returned.",
        "syntax": "TrnBrowseNext(iSession)"
    },
    "trnbrowsenumrecords": {
        "doc": "The TrnBrowseNumRecords function returns the number of records that match the filter criteria.\nThis function is a non-blocking function. It does not block the calling Cicode task.",
        "example": "INT numRecords = 0;\n...\nnumRecords = TrnBrowseNumRecords(iSession);\nIF numRecords <> 0 THEN\n    // Have records\nELSE\n    // No records\nEND\n...",
        "name": "TrnBrowseNumRecords",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by a TrnBrowseOpen call.",
                "paramname": "iSession"
            }
        ],
        "returnType": "The number of records that have matched the filter criteria. A value of 0 denotes that no records have matched. A value of -1 denotes that the browse session is unable to provide a fixed number. This may be the case if the data being browsed changed during the browse session.",
        "syntax": "TrnBrowseNumRecords(iSession)"
    },
    "trnbrowseopen": {
        "doc": "The TrnBrowseOpen function initiates a new browse session and returns a handle to the new session that can be used in subsequent data browse function calls.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "INT iSession;\n...\niSession = TrnBrowseOpen(\"NAME=ABC*\", \"NAME,TYPE\",\n\"ClusterA,ClusterB\");\nIF iSession <> -1 THEN\n    // Successful case\nELSE\n    // Function did not succeed\nEND\n...",
        "name": "TrnBrowseOpen",
        "params": [
            {
                "paramdescription": "A filter expression specifying the records to return duringthe browse. An empty string indicates that all records will bereturned. Where a fieldname is not specified in the filter, it isassumed to be tagname. For example, the filter \"AAA\" isequivalent to \"name=AAA\".\nThe following regular expressions are supported: *expr, expr*, and *expr*. To specify an exclusion filtering condition, use the NOT keyword after the = operator. ",
                "paramname": "Filter"
            },
            {
                "paramdescription": "Specifies via a comma delimited string the columns to bereturned during the browse. An empty string indicates thatthe server will return all available columns. Supported fieldsare:\nACQERROR, AREA, CLUSTER, COMMENT, DEADBAND, ENG_FULL, ENG_UNITS, ENG_ZERO, EQUIPMENT, EXPRESSION, FILENAME, FILES, LSL, NAME, PRIV, RANGE, RAW_FULL, RAW_ZERO, SAMPLEPER, SDEVIATION, SPCFLAG, STORMETHOD, SUBGRPSIZE, TAG, TIME, TRIGGER, TYPE, USL, XDOUBLEBAR.\nSee Browse Function Field Reference for information about fields.",
                "paramname": "Fields"
            },
            {
                "paramdescription": "An optional parameter that specifies via a comma delimitedstring the subset of the clusters to browse. An empty stringindicates that the connected clusters will be browsed.",
                "paramname": "Clusters"
            }
        ],
        "returnType": "Returns an integer handle to the browse session. Returns -1 if unsuccessful.",
        "syntax": "INT TrnBrowseOpen( STRING Filter, STRING Fields [, STRING Clusters] )"
    },
    "trnbrowseprev": {
        "doc": "The TrnBrowsePrev function moves the data browse cursor back one record.  If you call this function after you have reached the beginning of the records, error 412 is returned (Databrowse session EOF).\nThis function is a non-blocking function. It does not block the calling Cicode task.",
        "example": "No example found",
        "name": "TrnBrowsePrev",
        "params": [
            {
                "paramdescription": "The handle to a browse session previously returned by a TrnBrowseOpen call.",
                "paramname": "iSession"
            }
        ],
        "returnType": "0 (zero) if the trend browse session exists, otherwise an error code is returned.",
        "syntax": "TrnBrowsePrev(iSession)"
    },
    "trnclientinfo": {
        "doc": "Gets information about the trend that is being displayed at the AN point.",
        "example": "INT nError;\nINT nSamples;\nINT nTime;\n!Gets the number of samples configured for the current pen of the \ntrend displayed at AN 30.\nnSamples = TrnClientInfo(30, 0, 1, \"\", nError);\nIF nError = 0 THEN\n    nTime = nSamples * 50;\nELSE\n    nTime = 0;\nEND",
        "name": "TrnClientInfo",
        "params": [
            {
                "paramdescription": "The AN point number at which the trend is displayed.",
                "paramname": "hAN"
            },
            {
                "paramdescription": "The trend pen number:\n0 - The pen currently in focus\n1...8 - Pen1. . .Pen8",
                "paramname": "Pen"
            },
            {
                "paramdescription": "The type of information you would like returned.\n1 - The number of samples configured for the trend. If you select Type 1, the Data argument is ignored.",
                "paramname": "nType"
            },
            {
                "paramdescription": "For future enhancements; is currently ignored.",
                "paramname": "Data"
            },
            {
                "paramdescription": "Output Parameter: If the function is successful, the error is set to 0 (zero). If unsuccessful, an error value is set, and a hardware alarm is triggered. Must be a Long type variable.",
                "paramname": "Error"
            }
        ],
        "returnType": "The requested information (as a string) if successful, otherwise a hardware alarm is generated.",
        "syntax": "TrnClientInfo(nAN, Pen, Type, Data, Error)"
    },
    "trncompareplot": {
        "doc": "Prints two trends, one overlaid on the other. Each trend can have up to four tags configured on it. The significance of this type of plot is that the two trends show different times and display periods. It is possible to compare a trend tag or tags over different time slots. Each trend line is drawn with a different pen style and marker as appropriate. The trend plot includes a comment and a legend, and you can specify the vertical high and low scales.\nFor more advanced trend plotting, you can use the low-level plot functions.",
        "example": "/* Prints two black and white trends (one overlaid on the other) \nto LPT1, comparing the trend lines of one trend tag (Feed_Flow) at \ndifferent times. The first trend line has a starting time of \n12 noon, on 11/12/96, and the second has a starting time of 9am, on \n11/10/96. Both contain 200 sample points, and have a period of 2 \nseconds. Both trend lines will be on a vertical scale of 10-100. \n*/\nINT Time;\nINT RefTime;\nTime = StrToDate(\"11/12/96\") + StrToTime(\"12:00:00\");\nRefTime = StrToDate(\"11/10/96\") + StrToTime(\"09:00:00\");\nTrnComparePlot(\"LPT1:\",\"Citect Flow Comparison Plot\",\"Comparison \nwith Reference\",0, \n0,200,Time,2,RefTime,2,\"Feed_Flow\",\"\",\"\",\"\",\"Feed_Flow\",\"\",\"\",\"\",\n10,100,0,0,0,0,0,0,10,100);",
        "name": "TrnComparePlot",
        "params": [
            {
                "paramdescription": "The name of the printer port to which the plot will be printed. This name needs to be enclosed within quotation marks. For example LPT1:, to print to the local printer, or \\\\Pserver\\canon1 using UNC to print to a network printer.",
                "paramname": "sPort"
            },
            {
                "paramdescription": "The title of the trend plot.",
                "paramname": "sTitle"
            },
            {
                "paramdescription": "The comment that is to display beneath the title of the trend plot. You do not have to enter a comment.",
                "paramname": "sComment"
            },
            {
                "paramdescription": "Sets the display mode. A value of 0 causes the default display mode to be used. Otherwise, the display mode of the specified AN is set.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The color mode of the printer.",
                "paramname": "iMode"
            },
            {
                "paramdescription": "The number of data points on the plot.",
                "paramname": "nSamples"
            },
            {
                "paramdescription": "The end point in time (the most recent point) for the first trend.",
                "paramname": "iTime1"
            },
            {
                "paramdescription": "The period (in seconds) of the first trend. This can differ from the actual trend period. If you do not enter a period, it defaults to the sample period of Tag1.",
                "paramname": "rPeriod1"
            },
            {
                "paramdescription": "The end point in time (the most recent point) for the second trend.",
                "paramname": "iTime2"
            },
            {
                "paramdescription": "The period (in seconds) of the second trend. This can differ from the actual trend period. If you do not enter a period, it defaults to the sample period of Tag5.",
                "paramname": "rPeriod2"
            },
            {
                "paramdescription": "The trend tags for the plot. Tags 1 to 4 needs to be for the first trend, and tags 5 to 8 needs to be for the second.",
                "paramname": "Tag1. . .Tag8"
            },
            {
                "paramdescription": "The minimum and maximum on the vertical scale for the trend line of each of the tags (Tag1. . . Tag8)",
                "paramname": "rLoScale1, HiScale1,....LoScale8, HiScale8"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "TrnComparePlot(sPort, sTitle, sComment, AN, iMode, nSamples, iTime1, rPeriod1, iTime2, rPeriod2, Tag1......Tag8, rLoScale1, rHiScale1,......rLoScale8, rHiScale8)"
    },
    "trndelete": {
        "doc": "Deletes a trend that is displayed on a current page. This trend may have been created by the TrnNew() function or by a trend object.",
        "example": "TrnDelete(20);\n! Deletes the trend at AN20.",
        "name": "TrnDelete",
        "params": [
            {
                "paramdescription": "The AN where the trend is located.",
                "paramname": "nAN"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "TrnDelete(nAN)"
    },
    "trndelhistory": {
        "doc": "Removes a trend history file that has been added to the trend system by the TrnAddHistory() function. This function does not delete the file completely, it only disconnects it from the historical trend system.\nThis function can only be used if the Trend Server is on the current machine. When the Trend Server is not in the calling process, this function will become blocking and cannot be called from a foreground task. In this case, the return value will be undefined and a Cicode hardware alarm will be raised.",
        "example": "TrnDelHistory(\"C:\\\nPlant SCADA\n\\DATA\\TR1_91.MAY\");\n! Disconnects the file from the trend system.",
        "name": "TrnDelHistory",
        "params": [
            {
                "paramdescription": "The trend history file to disconnect from the historical trend system.",
                "paramname": "FileName"
            },
            {
                "paramdescription": "Specifies the name of the cluster in which the Trend Server resides. This is optional if you have one cluster or are resolving the trend server via the current cluster context. The argument is enclosed in quotation marks \"\".",
                "paramname": "sClusterName"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "TrnDelHistory(FileName [, sClusterName] )"
    },
    "trnecho": {
        "doc": "Enables and disables the echo of the trend display. Use this function when you need to make many changes to a trend display, so that the display updates only once. You should first disable the trend echo, do all the trend changes, and then enable the echo to show the changes.",
        "example": "! Disable echo of trend display at AN40\nTrnEcho(40,0);\n! Change the scales on pens 1 and 2\nTrnSetScale(40,1,0,-1000);\nTrnSetScale(40,1,100,-1000);\nTrnSetScale(40,2,0,-1000);\nTrnSetScale(40,2,100,-1000);\n! Enable echo to show changes to the display\nTrnEcho(40,1);",
        "name": "TrnEcho",
        "params": [
            {
                "paramdescription": "The animation number of the trend.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The mode of the echo:\n0 - Disable echo of the trend display.\n1 - Enable echo of the trend display, to show changes.",
                "paramname": "nMode"
            }
        ],
        "returnType": "The current echo mode, otherwise 0 (zero) is returned, and an error code is set. You can call the IsError() function to get the actual error code.",
        "syntax": "TrnEcho(nAN, nMode)"
    },
    "trneventgettable": {
        "doc": "Stores event trend data in an event table and the associated time stamp in a time table, for a specified trend tag. Data is stored at the specified Period, working backwards from the starting point specified by EventNo. If Period differs from the trend period configured in the Trend Tags database, the values to be stored are calculated from the trend data. Values are either averaged or interpolated.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "TrnEventGetTable",
        "params": [
            {
                "paramdescription": "The trend tag enclosed in quotation marks \"\" (can be prefixed by the name of the cluster that is ClusterName.Tag).",
                "paramname": "Tag"
            },
            {
                "paramdescription": "The starting event number for entries in the trend table.",
                "paramname": "EventNo"
            },
            {
                "paramdescription": "The time difference between tabulated trend values (in seconds). For example, if you set this period to 30 seconds, Plant SCADA will get the last trend value (sampled at the end of the trend section), then get the trend value that was sampled 30 seconds before that, and so on until it reaches the start time of the trend section.\nIf this period is different to the trend's sampling period, the trend values will be averaged or interpolated. Set to 0 (zero) to default to the actual trend period.",
                "paramname": "Period"
            },
            {
                "paramdescription": "The number of trend values to store in the trend table, from 1 to the maximum number of items in the table.",
                "paramname": "Length"
            },
            {
                "paramdescription": "The Cicode array in which the trend data is stored. You can enter the name of an array here (see the example). Must be a Real type variable.",
                "paramname": "Table"
            },
            {
                "paramdescription": "The table of integer values in which the time stamp is stored. Must be a Long type variable.",
                "paramname": "TimeTable"
            },
            {
                "paramdescription": "The Display Mode parameters allow you to enter a single integer to specify the display options for a trend (for a maximum of eight trends).\nTo calculate the integer that you should enter for a particular trend, select the options you want from the list below, adding their associated numbers together. The resulting integer is the DisplayMode parameter for that trend.\nInvalid/Gated trend options:\n0 - Convert invalid/gated trend samples to zero.\n1 - Leave invalid/gated trend samples as they are.\nOrdering trend sample options:\n0 - Order returned trend samples from oldest to newest.\n2 - Order returned trend samples from newest to oldest.\nCondense method options:\n0 - Set the condense method to use the mean of the samples.\n4 - Set the condense method to use the minimum of the samples.\n8 - Set the condense method to use the maximum of the samples.\nStretch method options:\n0 - Set the stretch method to step.\n128 - Set the stretch method to use a ratio.\n256 - Set the stretch method to use raw samples.\nGap Fill Constant option:\nn - the number of missed samples that the user wants to gap fill) x 4096.\nThe options listed in each group are mutually exclusive. The default value for each Display Mode is 258 (0 + 2 + 256).",
                "paramname": "Mode"
            },
            {
                "paramdescription": "The name of the cluster in which the trend tag resides. This is optional if you have one cluster or are resolving the trend via the current cluster context. The argument is enclosed in quotation marks \"\".",
                "paramname": "sClusterName"
            }
        ],
        "returnType": "The actual number of samples read. The return value is 0 if an error is detected. You can call the IsError() function to get the actual error code. If EventNo is 0 (zero) then the EventNo will be set to the current event number.",
        "syntax": "TrnEventGetTable(Tag, EventNo, Period, Length, Table, TimeTable, Mode [, sClusterName] )"
    },
    "trneventgettablems": {
        "doc": "Stores event trend data and time data (including milliseconds) for a specified trend tag. The event trend data is stored in an event table, and the time stamp in time tables. Data is stored at the specified Period, working backwards from the starting point specified by EventNo. If Period differs from the trend period configured in the Trend Tags database, the values to be stored are calculated from the trend data. Values are either averaged or interpolated.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "No example found",
        "name": "TrnEventGetTableMS",
        "params": [
            {
                "paramdescription": "The trend tag enclosed in quotation marks \"\" (can be prefixed by the name of the cluster that is ClusterName.Tag).",
                "paramname": "Tag"
            },
            {
                "paramdescription": "The starting event number for entries in the trend table.",
                "paramname": "EventNo"
            },
            {
                "paramdescription": "The time difference between tabulated trend values (in seconds). For example, if you set this period to 30 seconds, Plant SCADA will get the last trend value (sampled at the end of the trend section), then get the trend value that was sampled 30 seconds before that, and so on until it reaches the start time of the trend section.\nIf this period is different to the trend's sampling period, the trend values will be averaged or interpolated. Set to 0 (zero) to default to the actual trend period.",
                "paramname": "Period"
            },
            {
                "paramdescription": "The number of trend values to store in the trend table, from 1 to the maximum number of items in the table.",
                "paramname": "Length"
            },
            {
                "paramdescription": "The Cicode array in which the trend data is stored. You can enter the name of an array here (see the example). Must be a Real type variable.",
                "paramname": "Table"
            },
            {
                "paramdescription": "The table of integer values in which the time stamp is stored. Must be a Long type variable.",
                "paramname": "TimeTable"
            },
            {
                "paramdescription": "The Display Mode parameters allow you to enter a single integer to specify the display options for a trend (for a maximum of eight trends).\nTo calculate the integer that you should enter for a particular trend, select the options you wish to use from those listed below, adding their associated numbers together. The resulting integer is the DisplayMode parameter for that trend.\nInvalid/Gated trend options:\n0 - Convert invalid/gated trend samples to zero.\n1 - Leave invalid/gated trend samples as they are.\nOrdering trend sample options:\n0 - Order returned trend samples from oldest to newest.\n2 - Order returned trend samples from newest to oldest.\nCondense method options:\n0 - Set the condense method to use the mean of the samples.\n4 - Set the condense method to use the minimum of the samples.\n8 - Set the condense method to use the maximum of the samples.\nStretch method options:\n0 - Set the stretch method to step.\n128 - Set the stretch method to use a ratio.\n256 - Set the stretch method to use raw samples.\nGap Fill Constant option:\nn - the number of missed samples that the user wants to gap fill) x 4096.\nNote: Options listed in each group are mutually exclusive. The default value for each Display Mode is 258 (0 + 2 + 256).",
                "paramname": "Mode"
            },
            {
                "paramdescription": "The table of integer values in which the millisecond component of the time stamp is stored. Must be a Long type variable.",
                "paramname": "MSTimeTable"
            },
            {
                "paramdescription": "The name of the cluster in which the trend tag resides. This is optional if you have one cluster or are resolving the trend via the current cluster context. The argument is enclosed in quotation marks \"\".",
                "paramname": "sClusterName"
            }
        ],
        "returnType": "The actual number of samples read. The return value is 0 if an error is detected. You can call the IsError() function to get the actual error code.",
        "syntax": "TrnEventGetTableMS(Tag, EventNo, Period, Length, Table, TimeTable, Mode, MSTimeTable [, sClusterName] )"
    },
    "trneventsettable": {
        "doc": "Sets event trend data and time data for a specified trend tag. The event trend data is set in an event table, and the time stamp in time tables. Data is set at the period specified, working backwards from the starting point specified by EventNo.\nIf the period of setting data differs from the trend period (defined in the Trend Tags database), the values to be set are calculated from the trend data, either averaged or interpolated. The user needs to have the correct privilege (as specified in the Trend Tags form), otherwise the data is not written.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "REAL TrendTable1[100];\nINT TimeTable[100];\n/* Defines an array of a maximum of 100 entries. Assume that \nTrendTable1 has been storing data from a source. */\nTrnEventSetTable(\"OP1\",nEventNo, 1,10,TrendTable1[0], \nTimeTable[0], \"ClusterXYZ\");\n/* A set of 10 trend data values are set for the OP1 trend tag. */",
        "name": "TrnEventSetTable",
        "params": [
            {
                "paramdescription": "The trend tag enclosed in quotation marks \"\" (can be prefixed by the name of the cluster that is ClusterName.Tag).",
                "paramname": "Tag"
            },
            {
                "paramdescription": "",
                "paramname": "EventNo"
            },
            {
                "paramdescription": "When adding new events to a trend, set EventNo to 0.\nWhen overwriting existing values, set EventNo to the last event number to be overwritten. For example, if overwriting events 100 to 110, set EventNo to 110. ",
                "paramname": "Event Number"
            },
            {
                "paramdescription": "This will be the interval (in seconds) between trend values when they are set (that is, it will be the perceived sampling period for the trend). This period can differ from the actual trend period. Set to 0 (zero) to default to the actual trend period.",
                "paramname": "Period"
            },
            {
                "paramdescription": "The number of trend values in the trend table.",
                "paramname": "Length"
            },
            {
                "paramdescription": "The table of floating-point values in which the trend data is stored. You can enter the name of an array here (see the example). Must be a Real type variable.",
                "paramname": "Table"
            },
            {
                "paramdescription": "The table of integer values in which the time stamp is stored. If you would like events to stay in correct time-stamp order, sort the values in this table in ascending order. When EventNo is non-zero the values in this table may be zero. This will result in the values of the requested events being overwritten but the time-stamps staying the same. Must be a Long type variable.",
                "paramname": "TimeTable"
            },
            {
                "paramdescription": "The name of the cluster in which the trend tag resides. This is optional if you have one cluster or are resolving the trend via the current cluster context. The argument is enclosed in quotation marks \"\".",
                "paramname": "sClusterName"
            }
        ],
        "returnType": "The actual number of samples written. The return value is 0 if an error is detected. You can call the IsError() function to get the actual error code.",
        "syntax": "TrnEventSetTable(Tag, EventNo, Period, Length, Table, TimeTable [, sClusterName] )"
    },
    "trneventsettablems": {
        "doc": "Sets event trend data and time data (including milliseconds) for a specified trend tag. The event trend data is set in an event table, and the time stamp in time tables. Data is set at the period specified, working backwards from the starting point specified by EventNo.\nIf the period of setting data differs from the trend period (defined in the Trend Tags database), the values to be set are calculated from the trend data, either averaged or interpolated. The user needs to have the correct privilege (as specified in the Trend Tags form), otherwise the data is not written.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "// Arrays for trend data\nREAL garSingleValue[1];\nINT ganSingleTime[1];\nINT ganSingleMS[1];\n// Push the data in the trend system\nINT\nFUNCTION LogTrend(STRING sTagName, REAL rValue, INT nDateTime, INT \nnMS)\n    INT nSamplesWritten;\n    garSingleValue[0] = rValue;\n    ganSingleTime[0] = nDateTime;\n    ganSingleMS[0] = nMS;\n    nSamplesWritten    = TrnEventSetTableMS\n(sTagname, 0, 0, 1, garSingleValue[0], ganSingleTime[0], ganSingleMS[0], \"ClusterXYZ\");\n    RETURN nSamplesWritten;\nEND",
        "name": "TrnEventSetTableMS",
        "params": [
            {
                "paramdescription": "The trend tag enclosed in quotation marks \"\" (can be prefixed by the name of the cluster that is ClusterName.Tag).",
                "paramname": "Tag"
            },
            {
                "paramdescription": "",
                "paramname": "EventNo"
            },
            {
                "paramdescription": "When adding new events to a trend, set EventNo to 0.\nWhen overwriting existing values, set EventNo to the last event number to be overwritten. For example, if overwriting events 100 to 110, set EventNo to 110. ",
                "paramname": "Event Number"
            },
            {
                "paramdescription": "This will be the interval (in seconds) between trend values when they are set (that is it will be the perceived sampling period for the trend). This period can differ from the actual trend period. Set to 0 (zero) to default to the actual trend period.",
                "paramname": "Period"
            },
            {
                "paramdescription": "Number of trend values in the trend table.",
                "paramname": "Length"
            },
            {
                "paramdescription": "",
                "paramname": "Table"
            },
            {
                "paramdescription": "",
                "paramname": "Table of floating-point values in which the trend data is \nstored. You can enter the name of an array here (see \nexample). Must be  a Real type variable."
            },
            {
                "paramdescription": "",
                "paramname": "TimeTable"
            },
            {
                "paramdescription": "",
                "paramname": "Table of integer values in which the time stamp is stored. If you would like events to stay in correct time-stamp order, sort the values in this table in ascending order. When \nEventNo is non-zero the values in this table may be zero. This \nwill result in the values of the requested events being \noverwritten but the timestamps staying the same. Must be a Long type variable."
            },
            {
                "paramdescription": "The table of integer values in which the millisecond component of the time stamp is stored. Must be a Long type variable.",
                "paramname": "MSTimeTable"
            },
            {
                "paramdescription": "The name of the cluster in which the trend tag resides. This is optional if you have one cluster or are resolving the trend via the current cluster context. The argument is enclosed in quotation marks \"\".",
                "paramname": "sClusterName"
            }
        ],
        "returnType": "The actual number of samples written. The return value is 0 if an error is detected. You can call the IsError() function to get the actual error code.",
        "syntax": "TrnEventSetTableMS(Tag, EventNo, Period, Length, Table, TimeTable, MSTimeTable [, sClusterName] )"
    },
    "trnexportclip": {
        "doc": "Exports trend data to the Windows Clipboard. The data is set at the specified Time and Period, and listed from earliest to latest. Any gated or invalid data is written as 0.0.\nData is stored as a grid, with each row time-stamped. The first column/field is the date, followed by the time, followed by the tags 1 to 8.\nYou can use the ClipMode argument to make the output more useful. For example, to paste the data into Excel, use ClipMode 2 for CSV format. If you use ClipMode 1 or 3, the default paste menu option causes data to be pasted into the user's spreadsheet as text. If you use ClipMode 3, use the Paste Special option to paste the required format. Please be aware that not all packages support multiple clipboard formats in this way.",
        "example": "TrnExportClip(TimeCurrent(), 2, 60 * 60/2, 2, 3, \"Feed\",\n\"Weight\");\n/* Export the last hour of data from the trend tags Feed and Weight\nto the clipboard in both Text and CSV formats. Be aware that the 60 *\n60/2 is a decomposed way or writing 1800, which is the number of 2\nsecond samples in 1 hour. */",
        "name": "TrnExportClip",
        "params": [
            {
                "paramdescription": "The starting time for the data being exported.",
                "paramname": "Time"
            },
            {
                "paramdescription": "The period (in seconds) of the entries being exported. (Thisperiod can differ from the actual trend period.)",
                "paramname": "Period"
            },
            {
                "paramdescription": "The length of the data table, that is The number of rows ofsamples to be exported. for example if you put the length as12, and you declare two tags to be exported, you get a gridwith 12 rows of samples. Each row has values for each of thetwo tags making a total of 24 samples.",
                "paramname": "Length"
            },
            {
                "paramdescription": "The format mode to be used:\nPeriodic trends\nEvent trends",
                "paramname": "Mode"
            },
            {
                "paramdescription": "The format for the data being exported.\nYou can add these modes for a combination of formats.",
                "paramname": "ClipMode"
            },
            {
                "paramdescription": "The trend tag names for the data being exported.",
                "paramname": "sTag1 ... sTag8"
            },
            {
                "paramdescription": "The Display Mode parameters allow you to enter a single integer to specify the display options for a trend (for a maximum of eight trends).\nTo calculate the integer that you should enter for a particular trend, select the options you wish to use from those listed below, adding their associated numbers together. The resulting integer is the DisplayMode parameter for that trend.\nBy default, this argument is set to 3 (see the details for options 1 and 2 below).\nInvalid/Gated trend options:\nInvalid and gated samples that are not converted to zero will appear in the destination file as the string \"na\" (for invalid) or \"gated\".\nOrdering trend sample options:\nCondense method options:\nStretch method options:\nGap Fill Constant option:\nDisplay as Periodic options:",
                "paramname": "iDisplayMode1 ... iDisplayMode8"
            },
            {
                "paramdescription": "",
                "paramname": "0 (zero) if successful, otherwise an error code is returned."
            },
            {
                "paramdescription": "",
                "paramname": "ClipSetMode, TrnExportCSV"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "TrnExportClip(Time, Period, Length, Mode, ClipMode, sTag1 ... sTag8, iDisplayMode1 ... iDisplayMode 8)"
    },
    "trnexportcsv": {
        "doc": "Exports trend data to a file in CSV (Comma Separated Variable) format. The data is set at the specified Time and Period, and listed from earliest to latest. Any gated or invalid data is written as 0.0.\nData is stored as a grid, with each row time-stamped. The first column/field is the date, followed by the time, followed by the tags 1 to 8.\nYou can view the CSV file with a text editor, and import the file directly into other packages such as Excel for data analysis and presentation.\nIf you're using this function to export trends by using event numbers, you need to specify a valid event number in the Time argument, rather than a time.",
        "example": "TrnExportCSV(\"c:\\TrnData.CSV\", TimeCurrent(), 2, 60 * 60/2, 2,\n\"Feed\", \"Weight\");\n/* Export the last hour of data from the trend tags Feed and\nWeight.\nThe 60 * 60/2 is a decomposed way or writing 1800, which is the\nnumber of 2 second samples in 1 hour. */",
        "name": "TrnExportCSV",
        "params": [
            {
                "paramdescription": "The name of the destination path and file.",
                "paramname": "Filename"
            },
            {
                "paramdescription": "The starting time for the data being exported.",
                "paramname": "Time"
            },
            {
                "paramdescription": "The period (in seconds) of the entries being exported. (Thisperiod can differ from the actual trend period.)",
                "paramname": "Period"
            },
            {
                "paramdescription": "The length of the data table, that is, The number of rows ofsamples to be exported. for example if you put the length as12, and you declare two tags to be exported, you get a gridwith 12 rows of samples. Each row has values for each of thetwo tags making a total of 24 samples.",
                "paramname": "Length"
            },
            {
                "paramdescription": "The format mode to be used:\nPeriodic trends\nEvent trends",
                "paramname": "Mode"
            },
            {
                "paramdescription": "The trend tag names for the data being exported.",
                "paramname": "sTag1 ... sTag8"
            },
            {
                "paramdescription": "The Display Mode parameters allow you to enter a single integer to specify the display options for a trend (for a maximum of eight trends). \nTo calculate the integer that you should enter for a particular trend, select the options you wish to use from those listed below, adding their associated numbers together. The resulting integer is the DisplayMode parameter for that trend. By default, this argument is set to 3 (see the details for options 1 and 2 below).\nInvalid/Gated trend options:\nInvalid and gated samples that are not converted to zero will appear in the destination file as the string \"na\" (for invalid) or \"gated\".\nOrdering trend sample options:\nCondense method options:\nStretch method options:\nGap Fill Constant option:\nOptions listed in each group are mutually exclusive.",
                "paramname": "iDisplayMode1 ... iDisplayMode8"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "TrnExportCSV(Filename, Time, Period, Length, Mode, sTag1 ... sTag8, iDisplayMode1 ... iDisplayMode 8)"
    },
    "trnexportdbf": {
        "doc": "Exports trend data to a file in dBASE III format. The data is set at the specified Time and Period, and listed from earliest to latest. Any gated or invalid data is written as 0.0.\nData is stored as a grid, with each row time-stamped. The first column/field is the date, followed by the time, followed by the tags 1 to 8.\nYou can import the DBF file directly into other packages such as Excel, for data analysis and presentation.",
        "example": "TrnExportDBF(\"c:\\TrnData.DBF\", TimeCurrent(), 2, 60 * 60/2, 2,\n\"Feed\", \"Weight\");\n/* Export the last hour of data from the trend tags Feed and\nWeight. Be aware that the 60 * 60/2 is a decomposed way or writing\n1800, which is the number of 2 second samples in 1 hour. */",
        "name": "TrnExportDBF",
        "params": [
            {
                "paramdescription": "The name of the destination path and file.",
                "paramname": "Filename"
            },
            {
                "paramdescription": "The starting time for the data being exported.",
                "paramname": "Time"
            },
            {
                "paramdescription": "The period (in seconds) of the entries being exported. (Thisperiod can differ from the actual trend period.)",
                "paramname": "Period"
            },
            {
                "paramdescription": "The length of the data table, that is The number of rows ofsamples to be exported. for example if you put the length as12, and you declare two tags to be exported, you get a gridwith 12 rows of samples. Each row has values for each of thetwo tags making a total of 24 samples.",
                "paramname": "Length"
            },
            {
                "paramdescription": "The format mode to be used:\nPeriodic trends\nEvent trends",
                "paramname": "Mode"
            },
            {
                "paramdescription": "The trend tag names for the data being exported. Tag nameslonger than 10 characters will be truncated, as the standardDBF field format is 10 characters.",
                "paramname": "sTag1 ... sTag8"
            },
            {
                "paramdescription": "The Display Mode parameters allow you to enter a single integer to specify the display options for a trend (for a maximum of eight trends). \nTo calculate the integer that you should enter for a particular trend, select the options you wish to use from those listed below, adding their associated numbers together. The resulting integer is the DisplayMode parameter for that trend. By default, this argument is set to 3 (see the details for options 1 and 2 below).\nInvalid/Gated trend options:\nInvalid and gated samples that are not converted to zero will appear in the destination file as the string \"na\" (for invalid) or \"gated\".\nOrdering trend sample options:\nCondense method options:\nStretch method options:\nGap Fill Constant option:\nOptions listed in each group are mutually exclusive.",
                "paramname": "iDisplayMode1 ... iDisplayMode8"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "TrnExportDBF(Filename, Time, Period, Length, Mode, sTag1 ... sTag8, iDisplayMode1 ... iDisplayMode 8)"
    },
    "trnexportdde": {
        "doc": "Exports trend data via DDE. The data is set at the specified Time and Period, and listed from earliest to latest. Any gated or invalid data is written as 0.0. Data is stored as a grid, with each row time-stamped. The first column/field is the date, followed by the time, followed by the tags 1 to 8.\nYou can use the DDEMode argument to make the output more useful. For example; to paste the data into Excel, use DDEMode 2 for CSV format. If you use DDEMode 1, data will be put into the user's spreadsheet as text.",
        "example": "TrnExportDDE(\"Excel\", \"data.xls\", \"R1C1:R61C4\", TimeCurrent(), 1,\n60, 2, 2, \"Feed\", \"Weight\");\n/* Export the last 60 seconds of data from the trend tags Feed and\nWeight into Excel at R1C1:R61C4 in CSV formats */",
        "name": "TrnExportDDE",
        "params": [
            {
                "paramdescription": "The application name to export the data.",
                "paramname": "sApplication"
            },
            {
                "paramdescription": "The document in the application to export the data.",
                "paramname": "sDocument"
            },
            {
                "paramdescription": "The topic in the application to export the data. Be aware you mayhave to use a special topic format to make the data exportcorrectly. See your application documentation for details; Forexample with Excel you need to specify the matrix of rows andcolumns as \"R1C1:R8C50\" depending on the size of the data.",
                "paramname": "sTopic"
            },
            {
                "paramdescription": "The name of the destination path and file.",
                "paramname": "Filename"
            },
            {
                "paramdescription": "The starting time for the data being exported.",
                "paramname": "Time"
            },
            {
                "paramdescription": "The period (in seconds) of the entries being exported. (Thisperiod can differ from the actual trend period.)",
                "paramname": "Period"
            },
            {
                "paramdescription": "The length of the data table, that is The number of rows ofsamples to be exported. for example if you put the length as12, and you declare two tags to be exported, you get a gridwith 12 rows of samples. Each row has values for each of thetwo tags making a total of 24 samples.",
                "paramname": "Length"
            },
            {
                "paramdescription": "The format mode to be used:\nPeriodic trends\nEvent trends",
                "paramname": "Mode"
            },
            {
                "paramdescription": "The format for the data being exported. CSV format allowsthe application to separate the data into each individualelement, however not every application will support thismode. See you applications documentation for details.",
                "paramname": "DDEMode"
            },
            {
                "paramdescription": "The trend tag names for the data being exported. Tag nameslonger than 10 characters will be truncated, as the standardDBF field format is 10 characters.",
                "paramname": "sTag1 ... sTag8"
            },
            {
                "paramdescription": "The Display Mode parameters allow you to enter a single integer to specify the display options for a trend (for a maximum of eight trends). \nTo calculate the integer that you should enter for a particular trend, select the options you wish to use from those listed below, adding their associated numbers together. The resulting integer is the DisplayMode parameter for that trend.\nBy default, this argument is set to 3 (see the details for options 1 and 2 below).\nInvalid/Gated trend options:\nInvalid and gated samples that are not converted to zero will appear in the destination file as the string \"na\" (for invalid) or \"gated\".\nOrdering trend sample options:\nCondense method options:\nStretch method options:\nGap Fill Constant option:\nOptions listed in each group are mutually exclusive.",
                "paramname": "iDisplayMode1 ... iDisplayMode8"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "TrnExportDDE(sApplication, sDocument, sTopic, Time, Period, Length, Mode, DDEMode, sTag1 ... sTag8, iDisplayMode1 ... iDisplayMode 8)"
    },
    "trnflush": {
        "doc": "Writes acquired trend data to disk without waiting for the trend buffer to be filled. Plant SCADA normally buffers the trend data in memory and only writes to disk when required, to give optimum performance. Because this function reduces the performance of the Trends Server, use it only when necessary.",
        "example": "TrnFlush(\"Trend1\", \"ClusterXYZ\");\n! Forces the Trend1 data to be written to disk.",
        "name": "TrnFlush",
        "params": [
            {
                "paramdescription": "The name of the logging tag (can be prefixed by the name of the cluster that is ClusterName.Tag). Set to \" * \" to flush all trend data.",
                "paramname": "sName"
            },
            {
                "paramdescription": "The name of the cluster in which the trend tag resides. This is optional if you have one cluster or are resolving the trend via the current cluster context. The argument is enclosed in quotation marks \"\".",
                "paramname": "sClusterName"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "TrnFlush(Name [, sClusterName] )"
    },
    "trngetbufevent": {
        "doc": "Gets the event number of a trend at an offset for a specified pen. This function only operates on an event-based trend.",
        "example": "! For the trend at AN20\nDspText(31,0,TrnGetBufEvent(20,0,10));\n/* Displays the trend event at offset 10 for the pen currently in \nfocus. The event will display at AN31. */",
        "name": "TrnGetBufEvent",
        "params": [
            {
                "paramdescription": "The AN where the trend is located.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The trend pen number:\n0 - The pen currently in focus\n1...8 - Pen1. . .Pen8",
                "paramname": "Pen"
            },
            {
                "paramdescription": "The trend buffer offset, in samples. The number of samples can range from 0 to the maximum number of samples that can display on the trend - 1.",
                "paramname": "Offset"
            }
        ],
        "returnType": "The event number. If Offset is not within boundaries, 0 (zero) is returned. If AN or Pen is invalid, 0 (zero) is returned and an error code is set.",
        "syntax": "TrnGetBufEvent(nAN, Pen, Offset)"
    },
    "trngetbuftime": {
        "doc": "Gets the time and date of a trend at an offset for a specified pen. The Offset should be a value between 0 (zero) and the number of samples displayed on the trend.",
        "example": "! For the trend at AN20\nINT time;\ntime = TrnGetBufTime(20,0,10);\nIF time <> 0 THEN\n    DspText(31,0,TimeToStr(time,2));\nEND\n/* Displays the trend date at offset 10 for the pen currently in \nfocus. The time will display at AN31. */",
        "name": "TrnGetBufTime",
        "params": [
            {
                "paramdescription": "The AN where the trend is located.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The trend pen number:\n0 - The pen currently in focus\n1...8 - Pen1. . .Pen8",
                "paramname": "Pen"
            },
            {
                "paramdescription": "The trend buffer offset, in samples. The number of samples can range from 0 to the maximum number of samples that can display on the trend - 1.",
                "paramname": "Offset"
            }
        ],
        "returnType": "A time/date variable. If Offset is not within boundaries, 0 (zero) is returned. If nAN or Pen is invalid, 0(zero) is returned and an error code is set.",
        "syntax": "TrnGetBufTime(nAN, Pen, Offset)"
    },
    "trngetbufvalue": {
        "doc": "Gets the value of a trend at an offset for a specified pen. The offset should be a value between -1 and the number of samples displayed on the trend.",
        "example": "! For the trend at AN20\nDspText(31,0,TrnGetBufValue(20,0,10):###.#);\n/* Displays the trend value at offset 10 for the pen currently in \nfocus. */",
        "name": "TrnGetBufValue",
        "params": [
            {
                "paramdescription": "The AN where the trend is located.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The trend pen number:\n0 - The pen currently in focus\n1...8 - Pen1. . .Pen8",
                "paramname": "Pen"
            },
            {
                "paramdescription": "The trend buffer offset, in samples. The number of samples can range from -1 to the maximum number of samples that can display on the trend minus 1.\n-1 means get the last valid value in the display (provided it is less than 1.5 sample periods old).\nIf there is no invalid or gated sample within the last 1.5 sample periods, it is assumed that a sample has been missed and an invalid trend value is returned. See the TrnIsValidValue function.",
                "paramname": "Offset"
            }
        ],
        "returnType": "The trend value. If the actual value is gated or invalid, the standard invalid or gated values are returned (no error is set). You can check this return value using TrnIsValidValue().",
        "syntax": "TrnGetBufValue(nAN, Pen, Offset)"
    },
    "trngetcluster": {
        "doc": "Gets the cluster name of a trend graph on a page.",
        "example": "No example found",
        "name": "TrnGetCluster",
        "params": [
            {
                "paramdescription": "The AN of the chosen trend graph.",
                "paramname": "nAN"
            }
        ],
        "returnType": "The name of the cluster the trend graph is associated with.",
        "syntax": "TrnGetCluster(nAN)"
    },
    "trngetcursorevent": {
        "doc": "Gets the event number of a trend, at the trend cursor position for a specified pen. This function only operates on an event-based trend.",
        "example": "! For the trend at AN20\nDspText(31,0,TrnGetCursorEvent(20,0));\n/* Displays the trend event at the cursor for the pen currently in \nfocus. The event will display at AN31. */",
        "name": "TrnGetCursorEvent",
        "params": [
            {
                "paramdescription": "The AN where the trend is located.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The trend pen number:\n0 - The pen currently in focus\n1...8 - Pen1. . .Pen8",
                "paramname": "Pen"
            }
        ],
        "returnType": "The event number, or 0 (zero) if the trend cursor is disabled.",
        "syntax": "TrnGetCursorEvent(nAN, Pen)"
    },
    "trngetcursormstime": {
        "doc": "Gets the time (in milliseconds from the previous midnight) at a trend cursor for a specified pen.",
        "example": "! For the trend at AN20\nSTRING timeStr;\nSTRING msecStr;\ntimeStr = TimeToString(TrnGetCursorTime(20,1),2) + \" \";\nmsecStr = TimeToString(TrnGetCursorMSTime(20,1),6);\nDspText(31,0,timeStr + msecStr);\n! Returns \"23/02/01 10:53:22.717\"",
        "name": "TrnGetCursorMSTime",
        "params": [
            {
                "paramdescription": "The AN where the trend is located.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The trend pen number:\n0 - The pen currently in focus\n1...8 - Pen1. . .Pen8",
                "paramname": "Pen"
            }
        ],
        "returnType": "The number of milliseconds since the previous midnight. If the trend cursor is disabled, 0 (zero) is returned. If nAN or Pen is invalid, 0 (zero) is returned and an error code is set.",
        "syntax": "TrnGetCursorMSTime(nAN, Pen)"
    },
    "trngetcursorpos": {
        "doc": "Gets the offset of a trend cursor from its origin, in samples.",
        "example": "! For the trend at AN20\n! If the trend cursor is disabled\nOffset=TrnGetCursorPos(20);\n! Sets Offset to -1.\n! If the trend cursor is 50 samples from the origin\nOffset=TrnGetCursorPos(20);\n! Sets Offset to 50.",
        "name": "TrnGetCursorPos",
        "params": [
            {
                "paramdescription": "The AN where the trend is located.",
                "paramname": "nAN"
            }
        ],
        "returnType": "The offset of a trend cursor from its origin, in samples, or -1 if the trend cursor is disabled.",
        "syntax": "TrnGetCursorPos(nAN)"
    },
    "trngetcursortime": {
        "doc": "Gets the time and date at a trend cursor for a specified pen.",
        "example": "! For the trend at AN20\nINT time;\ntime = TrnGetCursorTime(20,1);\nDspText(31,0,TimeToStr(time,2));\n! Displays the trend cursor date for Pen1.\nDspText(32,0,TimeToStr(time,1));\n! Displays the trend cursor time for Pen1.",
        "name": "TrnGetCursorTime",
        "params": [
            {
                "paramdescription": "The AN where the trend is located.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The trend pen number:\n0 - The pen currently in focus\n1...8 - Pen1. . .Pen8",
                "paramname": "Pen"
            }
        ],
        "returnType": "A time/date variable. If the trend cursor is disabled, 0 (zero) is returned. If nAN or Pen is invalid, 0 (zero) is returned and an error code is set.",
        "syntax": "TrnGetCursorTime(nAN, Pen)"
    },
    "trngetcursorvalue": {
        "doc": "Gets the value at a trend cursor for a specified pen.",
        "example": "! For the trend at AN20\nDspText(31,0,TrnGetCursorValue(20,0));\n! Displays the value at the trend cursor for the focus pen.",
        "name": "TrnGetCursorValue",
        "params": [
            {
                "paramdescription": "The AN where the trend is located.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The trend pen number:\n0 - The pen currently in focus\n1...8 - Pen1. . .Pen8",
                "paramname": "Pen"
            }
        ],
        "returnType": "The trend value. If the actual value is gated or invalid, the standard invalid or gated values are returned (no error is set). You can check this return value using TrnIsValidValue().",
        "syntax": "TrnGetCursorValue(nAN, Pen)"
    },
    "trngetcursorvaluestr": {
        "doc": "Gets the value at a trend cursor for a specified pen. The value is returned as a formatted string using the pen's format specification and (optionally) the engineering units.",
        "example": "! For the trend at AN20\nDspText(31,0,TrnGetCursorValueStr(20,0,1));\n/* Displays the value at the trend cursor for the focus pen. The \nvalue will display as a formatted string (including the \nengineering units).*/",
        "name": "TrnGetCursorValueStr",
        "params": [
            {
                "paramdescription": "The AN where the trend is located.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The trend pen number:\n0 - The pen currently in focus\n1...8 - Pen1. . .Pen8",
                "paramname": "Pen"
            },
            {
                "paramdescription": "Engineering units mode:\n0 - Do not include the engineering units at the end of the formatted string.\n1 - Include the engineering units at the end of the formatted string.",
                "paramname": "EngUnits"
            }
        ],
        "returnType": "The trend value (as a string). If trend data is invalid, or an argument passed to the function is invalid \"<na>\" is returned. If the actual value is gated (not triggered) \"<gated>\" is returned. If the trend cursor is disabled, an empty string is returned.",
        "syntax": "TrnGetCursorValueStr(nAN, Pen, EngUnits)"
    },
    "trngetdefscale": {
        "doc": "Gets the default engineering zero and full scales of a trend tag.\nThis function is a blocking function. It will block the calling Cicode task until the operation is complete.",
        "example": "REAL LoScale;\nREAL HiScale;\nTrnGetDefScale(\"PV1\",LoScale,HiScale,\"ClusterXYZ\");\n/* Returns engineering zero and full scales of the trend tag \n\"PV1\". */",
        "name": "TrnGetDefScale",
        "params": [
            {
                "paramdescription": "The trend tag enclosed in quotation marks \"\" (can be prefixed by the name of the cluster that is \"ClusterName.Tag\").",
                "paramname": "Tag"
            },
            {
                "paramdescription": "The engineering zero scale. Must be a Real type variable.",
                "paramname": "LoScale"
            },
            {
                "paramdescription": "The engineering full scale. Must be a Real type variable.",
                "paramname": "HiScale"
            },
            {
                "paramdescription": "The name of the cluster in which the trend tag resides. This is optional if you have one cluster or are resolving the trend via the current cluster context. The argument is enclosed in quotation marks \"\".",
                "paramname": "sClusterName"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "TrnGetDefScale(Tag, LoScale, HiScale [, sClusterName] )"
    },
    "trngetdisplaymode": {
        "doc": "Returns the display mode of the selected trend pen. The display mode is set using TrnSetDisplayMode.",
        "example": "int DisplayMode = TrnGetDisplayMode (10, 7)\n/* Returns The Display Mode of pen 7 for the trend at AN 10.*/",
        "name": "TrnGetDisplayMode",
        "params": [
            {
                "paramdescription": "The AN of the chosen trend.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The trend pen number:\n0 - The pen currently in focus.\n1...8 - Pen1. . .Pen8.",
                "paramname": "PenNumber"
            }
        ],
        "returnType": "An integer representing the trend's display mode:",
        "syntax": "TrnGetDisplayMode(nAN, PenNumber)"
    },
    "trngetevent": {
        "doc": "Gets the event number of the trend at a percentage along the trend, using the current event as the base point. This function only operates on an event-based trend. The first recorded event (the start event) would be event number 1 and the highest number would be the latest event. The event number is stored in a LONG and would eventually wrap around if you have enough events.",
        "example": "/* Display the start event for the current pen of the trend at \nAN20. */\nDspText(31,0,TrnGetEvent(20,0,0));",
        "name": "TrnGetEvent",
        "params": [
            {
                "paramdescription": "The AN of the chosen trend.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The trend pen number:\n0 - The pen currently in focus\n1...8 - Pen1. . .Pen8",
                "paramname": "Pen"
            },
            {
                "paramdescription": "The percentage of the trend from the starting event, from 0 (the start event) to 100 (the end event).",
                "paramname": "Percent"
            }
        ],
        "returnType": "The event number.",
        "syntax": "TrnGetEvent(nAN, Pen, Percent)"
    },
    "trngetformat": {
        "doc": "Gets the format of a trend tag being plotted by a specified pen.",
        "example": "/* If the trend tag being plotted by Pen1 of the trend at AN20 has \na format of \"###.#\" */\nTrnGetFormat(20,1,Width,DecPlaces);\n! Sets Width to 5 and DecPlaces to 1.",
        "name": "TrnGetFormat",
        "params": [
            {
                "paramdescription": "The AN of the chosen trend.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The trend pen number:\n0 - The pen currently in focus\n1...8 - Pen1. . .Pen8",
                "paramname": "Pen"
            },
            {
                "paramdescription": "Variable denoting the width of the format.",
                "paramname": "Width"
            },
            {
                "paramdescription": "Variable denoting the number of decimal places in the format.",
                "paramname": "DecPlaces"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "TrnGetFormat(nAN, Pen, Width, DecPlaces)"
    },
    "trngetgatedvalue": {
        "doc": "Returns the internally stored value for <GATED>. If the internally stored value changes in the future, you will not need to modify your Cicode, as this function will  return the correct value.",
        "example": "REAL MyTrendValue;\nIF MyTrendValue = TrnGetGatedValue() THEN \n\tPrompt (\"This value is <GATED>\") \nELSE\n\tIF MyTrendValue = TrnGetInvalidValue() THEN \n\t\tPrompt(\"This value is <TRN_NO_VALUES>\") \n\tELSE \n\t\tPrompt(\"Trend value is = \" + RealToStr(MyTrendValue, 10, 1));\n\tEND\nEND",
        "name": "TrnGetGatedValue",
        "params": [],
        "returnType": "The internally stored value for <GATED>.",
        "syntax": "TrnGetGatedValue()"
    },
    "trngetinvalidvalue": {
        "doc": "Returns the internally stored value for <INVALID>. If the internally stored value changes in the future, you will not need to modify your Cicode, as this function will return the correct value.",
        "example": "REAL newArray[100];\nREAL oldArray[90];\nINT trigger;\nINT\nFUNCTION\nDoubleArray()\n\tINT i;\n\tFOR i = 0 TO 99 DO\n\t\tIF TrnIsValidValue(oldArray[i]) = 1 OR trigger = 0 THEN\n\t\t\tnewArray[i] = TrnGetGatedValue();\n\t\tELSE\n\t\t\tIF i >= 90 OR TrnIsValidValue(oldArray[i]) = 2 THEN\n\t\t\t\tnewArray[i] = TrnGetInvalidValue();\n\t\t\tELSE\n\t\t\t\tnewArray[i] = oldArray[i] * 2;\n\t\t\tEND\n\t\tEND\n\tEND\n\tRETURN i;\nEND",
        "name": "TrnGetInvalidValue",
        "params": [],
        "returnType": "The internally stored value for <INVALID>.",
        "syntax": "TrnGetInvalidValue()"
    },
    "trngetmode": {
        "doc": "Gets the mode (real-time or historical trending) of the trend pen.",
        "example": "! For the trend at AN20\nINT Mode;\nMode=TrnGetMode(20,0);\n! Gets the current mode of the pen in focus.\nIF Mode=0 THEN\n    DspText(31,0,\"Real Time Trending\");\nELSE\n    DspText(31,0,\"Historical Trending\");\nEND",
        "name": "TrnGetMode",
        "params": [
            {
                "paramdescription": "The AN of the chosen trend.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The trend pen number:\n0 - The pen currently in focus\n1...8 - Pen1. . .Pen8",
                "paramname": "Pen"
            }
        ],
        "returnType": "The current mode, 0 for real-time or 1 for historical.",
        "syntax": "TrnGetMode(nAN, Pen)"
    },
    "trngetmstime": {
        "doc": "Gets the time (in milliseconds from the previous midnight) of the trend (plotted by a specified pen) at a percentage along the trend, using the time and date of the right-most sample displayed. The time associated with the right-most sample displayed is known as the end time. The start time is the time of the left-most sample displayed. Percent 0 (zero) will correspond to the end time, and Percent 100 will correspond to the start time\nTrnGetMSTime(nAN, Pen, Percent)\nnAN:  \nPen: \nPercent: \nThe number of milliseconds since the previous midnight. Zero (0) is returned if an error is detected.",
        "example": "! For Pen 1 at AN20\nSTRING timeStr;\nSTRING msecStr;\ntimeStr = TimeToString(TrnGetTime(20,1,100),2) + \" \";\nmsecStr = TimeToString(TrnGetMSTime(20,1,100),6);\nDspText(31,0,timeStr + msecStr);",
        "name": "TrnGetMSTime",
        "params": [
            {
                "paramdescription": "The AN of the chosen trend.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The trend pen number:\n0 - The pen currently in focus\n1...8 - Pen1. . .Pen8",
                "paramname": "Pen"
            },
            {
                "paramdescription": "The percentage of the trend from the time and date of the right-most sample displayed (end time), from 0 to 100.",
                "paramname": "Percent"
            }
        ],
        "returnType": "The number of milliseconds since the previous midnight. Zero (0) is returned if an error is detected.",
        "syntax": "TrnGetMSTime(nAN, Pen, Percent)"
    },
    "trngetpen": {
        "doc": "Gets the trend tag being plotted by a specified pen.",
        "example": "! For the trend at AN20\nDspText(31,0,TrnGetPen(20,0,1));\n! Displays the trend tag with cluster prefix of the focus pen.",
        "name": "TrnGetPen",
        "params": [
            {
                "paramdescription": "The AN of the chosen trend.",
                "paramname": "nAN"
            },
            {
                "paramdescription": "The trend pen number:\n0 - The pen currently in focus\n1...8 - Pen1. . .Pen8",
                "paramname": "Pen"
            },
            {
                "paramdescription": "An optional argument used to specify whether the trend tag name is returned with a cluster prefix. Set:\n0 return tag without cluster prefix (default)\n1 return tag with cluster prefix.\nThe trend tag (as a string) being plotted by Pen. If nAN or Pen is invalid, an empty string is returned, and an error code is set. You can call the IsError() function to get the actual error code.",
                "paramname": "Mode"
            }
        ],
        "returnType": "The trend tag (as a string) being plotted by Pen. If nAN or Pen is invalid, an empty string is returned, and an error code is set. You can call the IsError() function to get the actual error code.",
        "syntax": "TrnGetPen(nAN, Pen [, Mode] )"
    },
    "trngetpencomment": {
        "doc": "Retrieves the comment of a pen.",
        "example": "No example found",
        "name": "TrnGetPenComment",
        "params": [
            {
                "paramdescription": "The AN of the chosen trend.",
                "paramname": "AN"
            },
            {
                "paramdescription": "The trend pen number:\n0 - The pen currently in focus\n1...8 - Pen1. . .Pen8",
                "paramname": "Pen"
            }
        ],
        "returnType": "The comment of the pen as a string.",
        "syntax": "TrnGetPenComment(nAN, Pen)"
    },
    "trngetpenfocus": {
        "doc": "Gets the number of the pen currently in focus.",
        "example": "! For the trend at AN20\nDspText(31,0,TrnGetPenFocus(20));\n! Displays the pen currently in focus.",
        "name": "TrnGetPenFocus",
        "params": [
            {
                "paramdescription": "The AN of the chosen trend.",
                "paramname": "AN"
            }
        ],
        "returnType": "The pen currently in focus (between 1 and 8). If nAN is invalid, -1 is returned and an error code is set.",
        "syntax": "TrnGetPenFocus(nAN)"
    },
    "trngetpenno": {
        "doc": "Gets the pen number of a pen name. The pens on a trend are either defined in the Page Trends database or set by the TrnSetPen() function.",
        "example": "/* Assume that 8 trend fonts, Pen1TrendFont ... Pen8TrendFont are \ndefined in the Fonts database. The following code will display the \ntrend tag using the matching font for that pen. */\n! For the trend at AN20\nSTRING sFont;\nINT iPen;\niPen = TrnGetPenNo(20,\"PV1\");\nIF 0 < iPen AND iPen < 9 THEN\n    sFont = \"Pen\" + IntToStr(iPen) + \"TrendFont\";\n    DspStr(31,sFont,\"PV1\");\nEND    ",
        "name": "TrnGetPenNo",
        "params": [
            {
                "paramdescription": "The AN of the chosen trend.",
                "paramname": "AN"
            },
            {
                "paramdescription": "The trend tag.",
                "paramname": "Tag"
            }
        ],
        "returnType": "The pen number, or 0 (zero) if an error is detected.",
        "syntax": "TrnGetPenNo(nAN, Tag)"
    },
    "trngetperiod": {
        "doc": "Gets the current display period of a trend. (To obtain the sampling period, use the TrnInfo function.)",
        "example": "/* For the trend at AN20, get and display the current display \nperiod. */\n! If the period is 10 seconds\nINT Period;\nSTRING Str;\nPeriod=TrnGetPeriod(20);\nStr=TimeToStr(Period,5);\nDspStr(31,\"\",Str);",
        "name": "TrnGetPeriod",
        "params": [
            {
                "paramdescription": "The AN of the chosen trend.",
                "paramname": "AN"
            }
        ],
        "returnType": "The current display period of a trend (in seconds), or 0 (zero) if an error code is detected.",
        "syntax": "TrnGetPeriod(nAN)"
    },
    "trngetscale": {
        "doc": "Gets the display scale of the trend tag being plotted by a specified pen.",
        "example": "! For the trend at AN20\nDspText(31,0,TrnGetScale(20,0,0));\n! Displays the zero scale of the focus pen.\nDspText(32,0,TrnGetScale(20,0,50));\n! Displays the 50% scale of the focus pen.\nDspText(33,0,TrnGetScale(20,0,100));\n! Displays the full scale of the focus pen.",
        "name": "TrnGetScale",
        "params": [
            {
                "paramdescription": "The AN of the chosen trend.",
                "paramname": "AN"
            },
            {
                "paramdescription": "The trend pen number:\n0 - The pen currently in focus\n1...8 - Pen1. . .Pen8",
                "paramname": "Pen"
            },
            {
                "paramdescription": "The percentage of the full scale, from 0 to 100.",
                "paramname": "Percent"
            }
        ],
        "returnType": "The scale of the trend tag being plotted by Pen. If nAN or Pen is invalid, 0 (zero) is returned and an error code is set.",
        "syntax": "TrnGetScale(nAN, Pen, Percent)"
    },
    "trngetscalestr": {
        "doc": "Gets the scale of the trend tag being plotted by a specified pen. The value is returned as a formatted string using the pen's format specification and (optionally) the engineering units.",
        "example": "! For the trend at AN20\nDspText(31,0,TrnGetScaleStr(20,0,0,1));\n/* Displays the zero scale of the focus pen. The scale displays as \na formatted string (including the engineering units). */\nDspText(32,0,TrnGetScaleStr(20,2,50,1));\n/* Displays the 50% scale of Pen2. The scale displays as a \nformatted string (including the engineering units). */\nDspText(33,0,TrnGetScaleStr(20,0,100,0));\n/* Displays the full scale of the trend tag being plotted by the \nfocus pen. The scale displays as a formatted string (excluding the \nengineering units). */",
        "name": "TrnGetScaleStr",
        "params": [
            {
                "paramdescription": "The AN of the chosen trend.",
                "paramname": "AN"
            },
            {
                "paramdescription": "The trend pen number:\n0 - The pen currently in focus\n1...8 - Pen1. . .Pen8",
                "paramname": "Pen"
            },
            {
                "paramdescription": "The percentage of the full scale, from 0 to 100.",
                "paramname": "Percent"
            },
            {
                "paramdescription": "Engineering units mode:\n0 - Do not include the engineering units at the end of the formatted string.\n1 - Include the engineering units at the end of the formatted string.",
                "paramname": "EngUnits"
            }
        ],
        "returnType": "The scale of the trend tag being plotted by Pen (as a string). If nAN or Pen is invalid, <na> is returned and an error code is set.",
        "syntax": "TrnGetScaleStr(nAN, Pen, Percent, EngUnits)"
    },
    "trngetspan": {
        "doc": "Gets the span time of a trend (if the span was set by the TrnSetSpan() function). The span time is the total time displayed in the trend window.",
        "example": "// Use a keyboard command or button to set a span of 2 hours.\nTrnSetSpan(40,StrToTime(\"2:00:00\");\n// Then use TrnGetSpan function to display the span\nTime = TrnGetSpan(40)\nDspText(31,0,TimeToStr(Time,5));",
        "name": "TrnGetSpan",
        "params": [
            {
                "paramdescription": "The AN of the chosen trend.",
                "paramname": "AN"
            }
        ],
        "returnType": "The span time, in seconds. 0(zero) is returned if the AN is invalid or if the span was not set by the TrnSetSpan() function.",
        "syntax": "TrnGetSpan(nAN)"
    },
    "trngettable": {
        "doc": "This function allows you to tabulate values from a specific section of trend. The values in the table (possibly an array variable) are arranged by time.\nIf the period (Period) is different to the trend's sampling period (configured in the Trend Tags database), the returned values are determined by DisplayMode.\nThis function is a blocking function. It will block the calling Cicode task until the operation is complete.",
        "example": "REAL TrendTable1[100];\n/* Defines an array of a maximum of 100 entries in which the trend \ndata is stored. */\nTrnGetTable(\"OP1\",StrToDate(\"17/07/20\")\t\n+StrToTime(\"09:00\"),2,10,TrendTable1[0],0,0,\"ClusterXYZ\");\n/* Stores the values of trend tag \"OP1\" in Table TrendTable1. Data \nis stored at the following times:\n17/07/20 09:00:00 TrendTable1[0]\n08:59:58 TrendTable1[1]\n08:59:56 TrendTable1[2]\n...\n17/07/20 08:59:42 TrendTable1[9] */\nAverage=TableMath(TrendTable1[0],100,2);\n/* Gets the average of the trend data. */",
        "name": "TrnGetTable",
        "params": [
            {
                "paramdescription": "The trend tag enclosed in quotation marks \"\" (can be prefixed by the name of the cluster that is ClusterName.Tag).",
                "paramname": "Tag"
            },
            {
                "paramdescription": "The end time and date (long integer) of the desired trend section. Once you have entered the end time and date (Time), period (Period), and number of trend tag values collected (Length), the start time and date will be calculated automatically. For example, if Time = StrToDate(\"21/07/20\") + StrToTime(\"09:00\"), Period = 30, and Length = 60, the start time would be 08:30. In other words, the trend values for the period between 8.30am and 9am (on July 21, 2020) would be tabulated.\nIf this argument is set to 0 (zero), the time used will be the current time.",
                "paramname": "Time"
            },
            {
                "paramdescription": "The time difference between tabulated trend values (in seconds). For example, if you set this period to 30 seconds, Plant SCADA will get the last trend value (sampled at the end of the trend section), then get the trend value that was sampled 30 seconds before that, and so on until it reaches the start time of the trend section.\nIf this period is different to the trend's sampling period, the trend values will be averaged or interpolated. Set to 0 (zero) to default to the actual trend period.",
                "paramname": "Period"
            },
            {
                "paramdescription": "The number of trend values to store in the trend table, from 1 to the maximum number of items in the table. This argument has a max of 4000 (in v6). Specifying a length of greater than 4000 results in a return value of 0 and IsError()=274 (INVALID_ARGUMENT). This limit can be configured using the citect.ini parameter [Trend]MaxRequestLength.",
                "paramname": "Length"
            },
            {
                "paramdescription": "Variable containing the Cicode array in which the trend data is stored. You can enter the name of an array here (see the example).",
                "paramname": "Table"
            },
            {
                "paramdescription": "The Display Mode parameters allow you to enter a single integer to specify the display options for a trend (for a maximum of eight trends).\nTo calculate the integer that you should enter for a particular trend, select the options you want to use from those listed below, adding their associated numbers together. The resulting integer is the DisplayMode parameter for that trend.\nInvalid/Gated trend options:\n0 - Convert invalid/gated trend samples to zero.\n1 - Leave invalid/gated trend samples as they are.\nOrdering trend sample options:\n0 - Order returned trend samples from newest to oldest.\n2 - Order returned trend samples from oldest to newest.\nCondense method options:\n0 - Set the condense method to use the mean of the samples.\n4 - Set the condense method to use the minimum of the samples.\n8 - Set the condense method to use the maximum of the samples.\n12 - Set the condense method to use the newest of the samples.\nStretch method options:\n0 - Set the stretch method to step.\n128 - Set the stretch method to use a ratio.\n256 - Set the stretch method to use raw samples.\nGap Fill Constant option:\nn - the number of missed samples that the user wants to gap fill) x 4096.\nSynchronize to Display Period options:\n0 - Synchronize the returned samples to the nearest display period.\n16777216 - Do not synchronize samples to the nearest display period.\nOptions listed in each group are mutually exclusive. The default value for each Display Mode is 258 (0 + 2 + 256).",
                "paramname": "DisplayMode"
            },
            {
                "paramdescription": "This argument allows you to set your sample request time with millisecond precision. After defining the time and date in seconds with the Time argument, you can then use this argument to define the milliseconds component of the time.\nFor example, if you wanted to request data from the 21/07/20, at 9am, 13 seconds, and 250 milliseconds you could set the Time and Milliseconds arguments as follows:",
                "paramname": "Milliseconds"
            },
            {
                "paramdescription": "If you don't enter a Milliseconds value, it defaults to 0 (zero). There is no range constraint, but as there are only 1000 milliseconds in a second, you should keep your entry between 0 (zero) and 999.",
                "paramname": "Time = StrToDate(\"21/07/20\") + StrToTime(\"09:00:13\")Milliseconds = 250"
            },
            {
                "paramdescription": "Name of the cluster in which the trend tag resides. This is optional if you have one cluster or are resolving the trend via the current cluster context. The argument is enclosed in quotation marks \"\".\nThe actual number of samples read. 0(zero) is returned if an error occurs. You can call the IsError() function to get the actual error code.",
                "paramname": "sClusterName"
            }
        ],
        "returnType": "The actual number of samples read. 0(zero) is returned if an error occurs. You can call the IsError() function to get the actual error code.",
        "syntax": "TrnGetTable(Tag, Time, Period, Length, Table, DisplayMode [, Milliseconds] [, sClusterName] )"
    },
    "trngettime": {
        "doc": "Gets the time and date of the trend (plotted by a specified pen) at a percentage along the trend, using the time and date of the right-most sample displayed. The time associated with the rightmost sample displayed is known as the end time. The start time is the time of the left-most sample displayed. Percent 0 (zero) will correspond to the end time, and Percent 100 will correspond to the start time.\nTrnGetTime(nAN, Pen, Percent)\nAN: \nPen: \nPercent: \nA time/date variable. 0 (zero) is returned if an error is detected.",
        "example": "! For the trend at AN20\nDspText(31,0,TimeToStr(TrnGetTime(20,0,0),2));\n! Displays the trend current date for the focus pen.\nDspText(32,0,TimeToStr(TrnGetTime(20,0,0),1));\n! Displays the trend current time for the focus pen.\nDspText(33,0,TimeToStr(TrnGetTime(20,0,50),1));\n! Displays the time 50% along the trend for the focus pen.",
        "name": "TrnGetTime",
        "params": [
            {
                "paramdescription": "The AN of the chosen trend.",
                "paramname": "AN"
            },
            {
                "paramdescription": "The trend pen number:\n0 - The pen currently in focus\n1...8 - Pen1. . .Pen8",
                "paramname": "Pen"
            },
            {
                "paramdescription": "The percentage of the trend from the time and date of the right-most sample displayed (end time), from 0 to 100.",
                "paramname": "Percent"
            }
        ],
        "returnType": "A time/date variable. 0 (zero) is returned if an error is detected.",
        "syntax": "TrnGetTime(nAN, Pen, Percent)"
    },
    "trngetunits": {
        "doc": "Gets the data units for the trend tag plotted by a specified Pen.",
        "example": "! For the trend at AN20\nDspText(31,0,TrnGetUnits(20,0));\n! Displays the data units for the focus pen.",
        "name": "TrnGetUnits",
        "params": [
            {
                "paramdescription": "The AN of the chosen trend.",
                "paramname": "AN"
            },
            {
                "paramdescription": "The trend pen number:\n0 - The pen currently in focus\n1...8 - Pen1. . .Pen8",
                "paramname": "Pen"
            }
        ],
        "returnType": "The data units for the trend tag plotted by Pen, otherwise an empty string is returned, and an error code is set. You can call the IsError() function to get the actual error code.",
        "syntax": "TrnGetUnits(nAN, Pen)"
    },
    "trninfo": {
        "doc": "Gets the configured values of a trend tag.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "! Get the file name of trend tag LT131\nsFileName = TrnInfo(\"LT131\", 3, \"ClusterXYZ\");",
        "name": "TrnInfo",
        "params": [
            {
                "paramdescription": "The name of the trend tag enclosed in quotation marks \"\" (can be prefixed by the name of the cluster that is ClusterName.Tag).",
                "paramname": "Tag"
            },
            {
                "paramdescription": "The type of information required:\n1 - Trend Type\n2 - Sample Period (to obtain the Display Period, use the TrnGetPeriod function)\n3 - Trend File Name (without file extension)\n4 - Area\n5 - Privilege\n6 - Current Event Number. Valid only for event type trends\n7 - Engineering Units\n8 - The storage method used for the tag. A returned value of 2 represents two byte storage (scaled), 8 represents eight byte storage (floating point).\n9 - The file period of the tag in seconds. If the file period is set to monthly or yearly, a file period cannot be calculated as months and years vary in length. Therefore, a file period of 0 will be returned for trends with such file periods.",
                "paramname": "nType"
            },
            {
                "paramdescription": "The name of the cluster in which the trend tag resides. This is optional if you have one cluster or are resolving the trend via the current cluster context. The argument is enclosed in quotation marks \"\".",
                "paramname": "sClusterName"
            }
        ],
        "returnType": "The value (as a string), otherwise an empty string is returned, and an error code is set. You can call the IsError() function to get the actual error code.",
        "syntax": "TrnInfo(Tag, Type [, sClusterName] )"
    },
    "trnisvalidvalue": {
        "doc": "Determines whether a logged trend value is:",
        "example": "INT\nFUNCTION\nDoubleArray()\n    INT i;\n    FOR i = 0 TO 99 DO\n        IF TrnIsValidValue(oldArray[i]) = 1 OR trigger = 0 THEN\n            newArray[i] = TrnGetGatedValue();\n            Prompt (\"This value is <GATED>\");\n        ELSE\n            IF i >= 90 OR TrnIsValidValue(oldArray[i]) = 2 THEN\n                newArray[i] = TrnGetInvalidValue();\n            ELSE\n                newArray[i] = oldArray[i] * 2;\n                Prompt (\"This value is <TRN_NO_VALUES>\");\n            END\n        END\n    END\n    RETURN i;\nEND",
        "name": "TrnIsValidValue",
        "params": [
            {
                "paramdescription": "A trend value (of type REAL).",
                "paramname": "TrendValue"
            }
        ],
        "returnType": "0 for <VALID>",
        "syntax": "TrnIsValidValue(TrendValue)"
    },
    "trnnew": {
        "doc": "Creates a new trend at run time. This function performs the same operation as an entry in the Page Trends database. After the trend is created by the TrnNew() function, all the other trend functions can access and control the trend.",
        "example": "TrnNew(20,\"trn002\",\"PV1\",\"OP1\", \"ClusterXYZ\");\n/* Creates a new trend at AN20 using trend definition 2, plotting \n\"PV1\" on Pen1 and \"OP1\" on Pen2. */",
        "name": "TrnNew",
        "params": [
            {
                "paramdescription": "The AN where the bottom right-hand corner of the trend is located.",
                "paramname": "AN"
            },
            {
                "paramdescription": "The trend definition number (as a STRING).",
                "paramname": "Trend"
            },
            {
                "paramdescription": "The trend tags. (These tags cannot be prefixed with cluster name, cluster should be specified with the ClusterName argument).",
                "paramname": "Tag1 . . .Tag8"
            },
            {
                "paramdescription": "The name of the cluster in which all the trend tags reside. This is optional if you have one cluster or are resolving the trends via the current cluster context. The argument is enclosed in quotation marks \"\".",
                "paramname": "sClusterName"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "TrnNew(nAN, Trend [, Tag1 ... Tag8] [, sClusterName] )"
    },
    "trnplot": {
        "doc": "Prints the trend line of one or more trend tags. Each trend line is drawn with a different pen style and marker as appropriate. The trend plot includes a comment and a legend, and you can specify the vertical high and low scales. The Mode defines the color mode of the printer. The default mode is black and white.\nFor more advanced trend plotting, you can use the low-level plot functions.",
        "example": "/* Prints a black and white plot to LPT1, containing the trend\nlines of two variable tags (PV1 & PV2). The trend lines have a\nstarting time of 9am, on 11/10/96, 200 sample points, and a period\nof 2 seconds. The trend line of PV1 will be on a vertical scale of\n0-200, and PV2 will be on a vertical scale of 0-400. */\nINT time;\nTime = StrToDate(\"11/10/96\") + StrToTime(\"09:00:00\");\nTrnPlot(\"LPT1:\",200,Time,2,\"Citect Trend\nPlot\",\"PV1\",\"PV2\",\"\",\"\",\"\",\"\",\"\",\"\",0,\"Process variable operation\nat shutdown\",0,200,0,400);",
        "name": "TrnPlot",
        "params": [
            {
                "paramdescription": "The name of the printer port to which the plot will beprinted. This name needs to be enclosed within quotationmarks. For example LPT1:, to print to the local printer, or\\\\Pserver\\canon1 using UNC to print to a network printer.",
                "paramname": "sPort"
            },
            {
                "paramdescription": "The number of data points on the plot.",
                "paramname": "nSamples"
            },
            {
                "paramdescription": "",
                "paramname": "iTime"
            },
            {
                "paramdescription": "The end point in time (the latest point) for the trendplot.",
                "paramname": "For periodic trend or event trends displayed as periodic"
            },
            {
                "paramdescription": " The event sample number (e.g. using TrnGetEvent)",
                "paramname": "For event trend type"
            },
            {
                "paramdescription": "The period (in seconds) of the trend plot. This can differ fromthe actual trend period.\nIf you omit the period, it defaults to the sample period of Tag1.",
                "paramname": "rPeriod"
            },
            {
                "paramdescription": "The title of the trend plot.",
                "paramname": "sTitle"
            },
            {
                "paramdescription": "The trend tags.",
                "paramname": "Tag1. . .Tag8"
            },
            {
                "paramdescription": "The AN of the chosen trend. If you enter 0 (zero), the displaymode will default to 258. (This is the display mode that ispassed into TrnGetTable() when it is called internally byTrnPlot().) If you call TrnPlot() from a report, you need to enter0 (zero) here.",
                "paramname": "AN"
            },
            {
                "paramdescription": "The color mode of the printer.",
                "paramname": "iMode"
            },
            {
                "paramdescription": "The comment that is to display beneath the title of the trendplot. You may pass an empty string if no comment isrequired.",
                "paramname": "sComment"
            },
            {
                "paramdescription": "The minimum and maximum on the vertical scale for the trend line of each of the tags (Tag1. . . Tag8). ",
                "paramname": "rLoScale1, HiScale1,......LoScale8, HiScale8"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "TrnPlot(sPort, nSamples, iTime, rPeriod, sTitle, AN, Tag1......Tag8, iMode, sComment, rLoScale1, rHiScale1, ......rLoScale8, rHiScale8)"
    },
    "trnprint": {
        "doc": "Prints the trend that is displayed on the screen (at nAN) using the current display mode for each trend. You can specify the trend title, the target printer, whether to print in color or black and white, and whether to display the Plot Setup form when the function is called.",
        "example": "TrnPrint(\"LPT1:\",\"Test Print\",40,0,0);\n/* Prints the trend plot displayed at AN40, without prompting for\nsetup details.*/",
        "name": "TrnPrint",
        "params": [
            {
                "paramdescription": "The name of the printer port to which the plot will beprinted. This name needs to be enclosed within quotation marks\"\". For example \"LPT1:\", to print to the local printer, or\"\\\\Pserver\\canon1\" using UNC to print to a networkprinter.\nIt is not necessary to enter a printer port. The first time the printer port is omitted, you will be prompted to select one at the Printer Setup form. The selection you make will then be used as the default.",
                "paramname": "sPort"
            },
            {
                "paramdescription": "The title to print at the top of the trend plot. If you omit the title in sTitle, the page title will be used.",
                "paramname": "sTitle"
            },
            {
                "paramdescription": "The AN where the trend plot is located.",
                "paramname": "AN"
            },
            {
                "paramdescription": "The color mode of the printer.\n-1 - Color to be decided (Default). Plant SCADA refers to the [GENERAL]PrinterColorMode parameter to determine print color. If there is no setting for this parameter, it will default to black and white.\n0 - Black and White\n1 - Color",
                "paramname": "iModeColor"
            },
            {
                "paramdescription": "Defines whether or not the Plot Setup form will displaywhen the function is called. This form allows you to enter thecolor mode of the printer, and define the printer setup etc.(See Printing Trend Data for more information on this form.)\n-1 - Plant SCADA refers to the [GENERAL]DisablePlotSetupForm parameter to determine if the form will display.\n0 - Do not display form\n1 - Display form",
                "paramname": "DisplayForm"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "TrnPrint(sPort, sTitle, AN, iModeColor, iDisplayForm)"
    },
    "trnsamplesconfigured": {
        "doc": "Gets the number of samples configured for the currently displayed trend.",
        "example": "/* For the trend at AN20, get and display the number of samples */\nINT nSamples;\nnSamples=TrnSamplesConfigured(20);\nDspStr(31,\"\",IntToStr(nSamples));",
        "name": "TrnSamplesConfigured",
        "params": [
            {
                "paramdescription": "The AN where the trend is located.",
                "paramname": "AN"
            }
        ],
        "returnType": "The number of samples configured for the trend, or 0 (zero) if an error is detected. You can call the IsError() function to get the actual error code.",
        "syntax": "TrnSamplesConfigured(nAN)"
    },
    "trnscroll": {
        "doc": "Scrolls the trend pen by a specified percentage (of span), or number of samples.",
        "example": "! Scroll all pens (of the trend at an20) 100% forwards.\nTrnScroll(20,-1,100); or TrnScroll(20,-1,100,1);\n! Scrolls all pens (of all trends on the current trend page) 300% backwards.\nTrnScroll(-1, -1, -300); or TrnScroll(20,-1.-300,1);\n!Scrolls all pens (of all trends on the current trend page) 3 samples forwards.\nTrnScroll(20,-1,3,2);\n!Scrolls all pens (of all trends on the current trend page) 1 sample backwards.\nTrnScroll(20,-1,-1,2);",
        "name": "TrnScroll",
        "params": [
            {
                "paramdescription": "The AN where the trend is located. Set to -1 for all trends on the current page.",
                "paramname": "AN"
            },
            {
                "paramdescription": "The trend pen number. Set to -1 for all pens.",
                "paramname": "Pen"
            },
            {
                "paramdescription": "The amount by which the trend will be scrolled. Use nMode to specify whether the trend will be scrolled by percentage or by number of samples.\nBecause the resolution of Client requests is 1 second, requests of millisecond accuracy are rounded to 1 second. For example, if requested to scroll 2 samples of 400 milliseconds (a total of 0.8 seconds), the trend will actually scroll 1 second.",
                "paramname": "nScroll"
            },
            {
                "paramdescription": "The type of scrolling to be performed.\n1 - The trend will be scrolled by a percentage of span. Default.\n2 - The trend will be scrolled by a number of samples. This mode is not available if the user puts the trend into the 'trend span' mode by setting the span. In this case no scrolling would take place; the user needs to use nMode 1.",
                "paramname": "nMode"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "TrnScroll(nAN, Pen, nScroll [, nMode] )"
    },
    "trnselect": {
        "doc": "Sets up a page for a trend. This function allows you to set up a trend before the trend page is displayed. You can therefore use a single trend page to display any trend in the project by selecting the trend first, and then displaying the trend page. The PageTrend() function uses this function to display the standard trend pages.\nCall this function and a set of TrnSetPen() functions before you display a trend page. When the trend page is displayed, all pens set by the TrnSetPen() functions are displayed. You can use the TrnSelect() function to configure different set of pens to be displayed on one generic trend page. The pen settings in the Page Trend database are overridden.",
        "example": "TrnSelect(WinNumber(), \"TrendPage\", 40, \"ClusterXYZ\");\nTrnSetPen(-2,1,\"PV1\");\nTrnSetPen(-2,2,\"PV2\");\nTrnSetPen(-2,3,\"PV3\");\nTrnSetPen(-2,4,\"PV4\");\nPageDisplay(\"TrendPage\");",
        "name": "TrnSelect",
        "params": [
            {
                "paramdescription": "The window number (returned from the WinNumber function).\n-3 - for the current window.\n-2 - for the next window displayed.",
                "paramname": "Window"
            },
            {
                "paramdescription": "The name of the page that displays the trend.",
                "paramname": "Page"
            },
            {
                "paramdescription": "The AN where the trend displays, or -3 for the first trend on the page.",
                "paramname": "AN"
            },
            {
                "paramdescription": "The name of the cluster that is associated with any trend tag for this trend graph. This is optional if you have one cluster or are resolving the trend via the current cluster context. The argument is enclosed in quotation marks \"\".",
                "paramname": "sClusterName"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "TrnSelect(Window, Page, AN [, sClusterName] )"
    },
    "trnsetcursor": {
        "doc": "Moves the trend cursor by a specified number of samples. If the trend cursor is disabled, this function enables it. If the cursor is enabled and the number of samples is 0 (zero), the cursor is disabled. If the cursor is moved off the current trend frame, the trend scrolls.",
        "example": "! For the trend at AN20\nTrnSetCursor(20,1);\n! Moves the trend cursor forwards 1 sample.\nTrnSetCursor(-1,-40);\n! Moves the trend cursor (of all trends on the current trend page) \nbackwards 40 samples.",
        "name": "TrnSetCursor",
        "params": [
            {
                "paramdescription": "The AN where the trend is located. Set to -1 for all trends on the current page.",
                "paramname": "AN"
            },
            {
                "paramdescription": "The number of samples to move the cursor.",
                "paramname": "Samples"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "TrnSetCursor(nAN, Samples)"
    },
    "trnsetcursorpos": {
        "doc": "Moves the trend cursor to a specified x-axis point, offset from the trend cursor origin. If the trend cursor is disabled, this function enables it. If the position is outside of the trend frame, it sets the trend cursor to half of the frame.",
        "example": "! For the trend at AN20, if the trend frame is 400 points\nTrnSetCursorPos(20,0);\n! Moves the trend cursor to its origin.\nTrnSetCursorPos(20,200);\n! Moves the trend cursor to half of its frame size (200 points).",
        "name": "TrnSetCursorPos",
        "params": [
            {
                "paramdescription": "The AN where the trend is located. Set to -1 for all trends on the current page.",
                "paramname": "AN"
            },
            {
                "paramdescription": "The x-axis point at which to position the trend cursor, offset from the trend cursor origin.",
                "paramname": "Position"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "TrnSetCursorPos(nAN, Position)"
    },
    "trnsetdisplaymode": {
        "doc": "Specifies how raw trend samples are displayed on the screen.",
        "example": "No example found",
        "name": "TrnSetDisplayMode",
        "params": [
            {
                "paramdescription": "The animation number of the chosen trend.",
                "paramname": "AN"
            },
            {
                "paramdescription": "The pen number of the chosen trend. Specify:\n0 - The current pen\n1-8 - Pens 1 through 8\n-1 - All pens",
                "paramname": "PenNumber"
            },
            {
                "paramdescription": "The Display Mode parameters allow you to enter a single integer to specify the display options for a trend (for a maximum of eight trends).\nTo calculate the integer you should enter, select the options you want to use from the list below, adding their associated numbers together. The resulting integer is the DisplayMode parameter for that trend.\nInvalid/Gated trend options:\n0 - Convert invalid/gated trend samples to zero.\n1 - Leave invalid/gated trend samples as they are.\nOrdering trend sample options:\n0 - Order returned trend samples from oldest to newest.\n2 - Order returned trend samples from newest to oldest.\nCondense method options:\n0 - Set the condense method to use the mean of the samples.\n4 - Set the condense method to use the minimum of the samples.\n8 - Set the condense method to use the maximum of the samples.\n12 - Set the condense method to use the newest of the samples.\nStretch method options:\n0 - Set the stretch method to step.\n128 - Set the stretch method to use a ratio.\n256 - Set the stretch method to use raw samples.\nGap Fill Constant option:\nn - the number of missed samples that the user wants to gap fill) x 4096.",
                "paramname": "DisplayMode"
            },
            {
                "paramdescription": "0 - Display according to trend type.\n1048576 - display as periodic regardless of trend type.\nSince the Display as Periodic options are read-only, they cannot be set using TrnSetDisplayMode. They can be retrieved using TrnGetDisplayMode() and also used with the TrnExport group of functions.",
                "paramname": "Display as Periodic options"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "TrnSetDisplayMode(nAN, PenNumber, DisplayMode)"
    },
    "trnsetevent": {
        "doc": "Sets the start event of a trend pen. This function only operates on an event-based trend.",
        "example": "! Sets pen1 to event number 123456\nTrnSetEvent(20,1,123456);\n! Scrolls pen1 back by 100 events\nTrnSetEvent(20,1,TrnGetBufEvent(20,1,0)-100);",
        "name": "TrnSetEvent",
        "params": [
            {
                "paramdescription": "The AN of the chosen trend.",
                "paramname": "AN"
            },
            {
                "paramdescription": "The trend pen number:\n0 - The pen currently in focus\n1...8 - Pen1. . .Pen8",
                "paramname": "Pen"
            },
            {
                "paramdescription": "The number of the start event.",
                "paramname": "Event"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "TrnSetEvent(nAN, Pen, Event)"
    },
    "trnsetpen": {
        "doc": "Sets the trend tag of a trend pen. The trend pen changes to the specified tag and the trend is refreshed. The trend pen needs to be in the operator's area to be displayed. If outside of the operator's area, data is not displayed. You cannot mix periodic trends and event trends in the same trend window.\nThis function may sometimes return before the pen is actually set when called on a PC which is not the trend server. This may create difficulties for following functions such as TrnSetScale. A wrapper function can be used to confirm the pen is set before returning. See example 2 below.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "! For the trend at AN20\nTrnSetPen(20,1,\"PV1\");\n! Sets the trend tag of Pen1 to \"PV1\".\n\nINT\nFUNCTION\nBlockedTrnSetPen(INT hAN, INT nPen, STRING sTrend)\n    INT timeout = 5000\n    INT sleepTime = 10\n    INT error = -1\n    INT elapsed = 0\n    INT currentTime\n    STRING sPenName\n    error = TrnSetPen(hAN, nPen, sTrend)\n    IF error = 0 THEN\n        error = -1\n        currentTime = SysTime()\n        WHILE error <> 0 AND elapsed < timeout DO\n            sPenName = TrnGetPen(hAN, nPen)\n            IF sPenName = sTrend THEN\n                error = 0\n            ELSE\n                SleepMS(sleepTime)\n                elapsed = elapsed + SysTimeDelta(currentTime)\n            END\n        END\n    END\n    RETURN error\nEND",
        "name": "TrnSetPen",
        "params": [
            {
                "paramdescription": "The AN where the trend is located.\n-1 - All trends on the current trend page.\n-2 - The function being called is using the special AN setup by the TrnSelect() function.",
                "paramname": "AN"
            },
            {
                "paramdescription": "The pen for which the trend tag will be changed.\n-2 - The first available pen (This value is automatically changed to 0 for SPC trends because they have only one pen per trend.)\n-1 - All pens on the trend. (Not allowed for SPC trends.)\n0 - The pen currently in focus.\n1...8 - Pen1....Pen8",
                "paramname": "Pen"
            },
            {
                "paramdescription": "The trend tag. If Tag = ! the pen is deleted.",
                "paramname": "Tag"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned. Be aware that if a mixture of periodic and event trends is detected, the return value is 0 (zero), but the hardware alarm #329 is set.",
        "syntax": "TrnSetPen(nAN, Pen, Tag)"
    },
    "trnsetpenfocus": {
        "doc": "Sets the focus to a specified pen. After the focus is set, the focus pen is used with other trend functions.",
        "example": "No example found",
        "name": "TrnSetPenFocus",
        "params": [
            {
                "paramdescription": "The AN of the chosen trend.",
                "paramname": "AN"
            },
            {
                "paramdescription": "The trend pen:\n-4 - Make the next pen the focus pen; without skipping blank pens.\n-3 - Make the previous pen the focus pen; without skipping blank pens.\n-2 - Make the next pen the focus pen; skip blank pens.\n-1 - Make the previous pen the focus pen; skip blank pens.\n0 - Keep the current focus.\n1...8 - Change Pen1. . .8 to be the focus pen.",
                "paramname": "Pen"
            }
        ],
        "returnType": "The old pen focus number, or -1 if an error is detected. You can call the IsError() function to get the actual error code.",
        "syntax": "TrnSetPenFocus(nAN, Pen)"
    },
    "trnsetperiod": {
        "doc": "Sets the display period (time base) of a trend. When the period is changed, Plant SCADA reads the historical data to reconstruct the trend data, and refreshes the trend. Every pen has the same display period.\nThis function clears the span set by the TrnSetSpan() function.",
        "example": "No example found",
        "name": "TrnSetPeriod",
        "params": [
            {
                "paramdescription": "The AN where the trend is located. Set to -1 for every trend onthe current page.",
                "paramname": "AN"
            },
            {
                "paramdescription": "The new sampling period (in seconds) of the trend. To set thedisplay period to the sampling period, set this argument to 0(zero),",
                "paramname": "Period"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "TrnSetPeriod(nAN, Period)"
    },
    "trnsetscale": {
        "doc": "Sets a new scale for a trend pen. In the automatic scaling mode, the zero and full scales are automatically generated.",
        "example": "! For the trend at AN20\nTrnSetScale(20,-1,100,5000.0);\n! Sets the full scale of all pens to 5000.0",
        "name": "TrnSetScale",
        "params": [
            {
                "paramdescription": "The AN where the trend is located. Set to -1 for all trends on the current page.",
                "paramname": "AN"
            },
            {
                "paramdescription": "The trend pen number:\n-1 - All pens\n0 - The pen currently in focus\n1...8 - Pen1...Pen8",
                "paramname": "Pen"
            },
            {
                "paramdescription": "The scale mode:\n-2 - Set both zero and full scales to the default scales.\n-1 - Place the trend into automatic scale mode.\n0 - Set the zero scale.\n100 - Set the full scale.",
                "paramname": "Percent"
            },
            {
                "paramdescription": "The new value of the scale. Scale is ignored if Percent is -2.",
                "paramname": "Scale"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "TrnSetScale(nAN, Pen, Percent, Scale)"
    },
    "trnsetspan": {
        "doc": "Sets the span time of a trend. The span time is the total time displayed in the trend window. You can set the period to contain fractions of a second. For example, if you set a trend with 240 samples to a span of 10 minutes, then each sample would be 2.5 seconds. Choose a span long enough to provide a sufficient sample rate to capture accurate real time data.",
        "example": "// Set a span of 2 hours.\nTrnSetSpan(40,StrToTime(\"2:00:00\"));\n// Then use TrnGetSpan function to display the span\nTime = TrnGetSpan(40);\nDspText(31,0,TimeToStr(Time,5));",
        "name": "TrnSetSpan",
        "params": [
            {
                "paramdescription": "The AN of the chosen trend.",
                "paramname": "AN"
            },
            {
                "paramdescription": "The span time (in seconds).",
                "paramname": "Span"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "TrnSetSpan(nAN, Span)"
    },
    "trnsettable": {
        "doc": "Writes trend tag data from a table to the trend logging system (starting at the top of the table, and continuing to the bottom). Each value is written with a time and date, as specified by Period. If Period differs from the trend sampling period (defined in the Trend Tags database), the trend's sample values will be calculated (averaged or interpolated) from the tabulated trend data.\nThe user needs to have the correct privilege (as specified in the database), otherwise the data is not written.\nThis function is a blocking function. It will block the calling Cicode task until the operation is complete.",
        "example": "REAL TrendTable1[100];\n/* Defines an array of a maximum of 100 entries. Assume that \nTrendTable1 has been storing data from a source. */\nTrnSetTable(\"OP1\",StrToDate(\"22/07/20\")\n+StrToTime(\"09:00\"),2,10,TrendTable1,0,\"ClusterXYZ\");\n/* A set of 10 trend data values are set for the OP1 trend tag. */",
        "name": "TrnSetTable",
        "params": [
            {
                "paramdescription": "The trend tag enclosed in quotation marks \"\" (can be prefixed by the name of the cluster that is ClusterName.Tag).",
                "paramname": "Tag"
            },
            {
                "paramdescription": "The time and date (long integer) to be associated with the first value in the table when it is set. Once you have entered the end time and date (Time), set period (Period), and number of trend tag values to be set (Length), the start time and date will be calculated automatically. For example, if Time = StrToDate(\"22/07/20\") + StrToTime(\"09:00\"), Period = 30, and Length = 60, the start time would be 08:30. In other words, the first value from the table would be set with time 9am, and the last would be set with time 8.30am (on July 22, 2020).\nIf this argument is set to 0 (zero), the time used will be the current time.",
                "paramname": "Time"
            },
            {
                "paramdescription": "This will be the interval (in seconds) between trend values when they are set (that is it will be the perceived sampling period for the trend). This period can differ from the actual trend period. Set to 0 (zero) to default to the actual trend period.",
                "paramname": "Period"
            },
            {
                "paramdescription": "The number of trend values in the trend table.",
                "paramname": "Length"
            },
            {
                "paramdescription": "Variable containing the table of floating-point values in which the trend data is stored. You can enter the name of an array here (see the example). Must be a Real type variable.",
                "paramname": "Table"
            },
            {
                "paramdescription": "This argument allows you to set the time of the first sample in the table with millisecond precision. After defining the time and date in seconds with the Time argument, you can then use this argument to define the milliseconds component of the time.\nFor example, if you wanted to set data from the 22/07/20, at 9am, 13 seconds, and 250 milliseconds you could set the Time and Milliseconds arguments as follows:",
                "paramname": "Milliseconds"
            },
            {
                "paramdescription": "If you don't enter a milliseconds value, it defaults to 0 (zero). There is no range constraint, but as there are only 1000 milliseconds in a second, you should keep your entry between 0 (zero) and 999.",
                "paramname": "Time = StrToDate(\"22/07/20\") + StrToTime(\"09:00:13\")Milliseconds = 250"
            },
            {
                "paramdescription": "The name of the cluster in which the trend tag resides. This is optional if you have one cluster or are resolving the trend via the current cluster context. The argument is enclosed in quotation marks \"\".\nThe actual number of samples written. The return value is 0 if an error is detected. You can call the IsError() function to get the actual error code.",
                "paramname": "sClusterName"
            }
        ],
        "returnType": "The actual number of samples written. The return value is 0 if an error is detected. You can call the IsError() function to get the actual error code.",
        "syntax": "TrnSetTable(Tag, Time, Period, Length, Table [, Milliseconds] [, sClusterName] )"
    },
    "trnsettime": {
        "doc": "Sets the end time and date of a trend pen. If you set a time less than the current time, the trend display is set to historical mode and samples taken after this time and date will not be displayed. If you set the time to the current time, for example by using the TimeCurrent or TrendZoom cicode functions, the trend is displayed in real-time mode and samples after this date and time will display.",
        "example": "TrnSetTime(20,1,TimeCurrent()-60*30);\n/* Sets Pen1 to 30 minutes before the current time (30 minutes ago). */\nTrnSetTime(20,1,0);\n/* Sets the trend to real-time mode. */",
        "name": "TrnSetTime",
        "params": [
            {
                "paramdescription": "The AN where the trend is located, or:\n-1 - All trends on the current page\n0 - The trend where the cursor is positioned",
                "paramname": "AN"
            },
            {
                "paramdescription": "The trend pen number:\n-1 - All pens\n0 - The pen currently in focus\n1...8 - Pen1. . .Pen8",
                "paramname": "Pen"
            },
            {
                "paramdescription": "The end time and date of the trend. Samples taken after this time and date will not be displayed. Set to 0 (zero) to set the trend to the current time (real-time mode).",
                "paramname": "Time"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "TrnSetTime(nAN, Pen, Time)"
    },
    "usercreate": {
        "doc": "This function is now deprecated and will be removed in the next release. Use the UserCreateByRole function instead.\nNot available for a Windows user.\nCreates a record for a new Plant SCADA user. The name of the user needs to be unique.\nThe user can be of a specified Type or assigned to a specified Role, depending on the current setting for the parameter [Security]CreateUserByRole.\nAn alarm server needs to be configured and running in the project, so that all clients are notified that an online change to the users configuration has been completed.\nIn order to perform user configuration changes online in a system with multiplecomputers running SCADA nodes using these functions, you will need to use theRUN and COPY parameters to check the updates are distributed throughout thesystem, and that the functions are called from the computer which uses the COPYpath as its RUN path.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "/* Create a new user */\nUserCreate(\"Fred\", \"Fred Jones\", \"secret\", \"Operator\");",
        "name": "UserCreate",
        "params": [
            {
                "paramdescription": "The name of the user.",
                "paramname": "sName"
            },
            {
                "paramdescription": "The full name of the user.",
                "paramname": "sFullName"
            },
            {
                "paramdescription": "The password of the user.\nThe sPassword argument is optional. If not passed, this argument defaults to an empty string which is subsequently ignored. It is included for the purposes of handling duplicate user names and separate password identification compatibility.",
                "paramname": "sPassword"
            },
            {
                "paramdescription": "The generic type of user. The type needs to be defined in the general properties for a user in Plant SCADA Studio's Security activity (see Add a Plant SCADA User). \nsRole: \nThe role to which the user will be assigned. The role needs to be defined in Plant SCADA Studio's Security activity (see Roles). ",
                "paramname": "sType"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "UserCreate(sName, sFullName, sPassword, sType/sRole )"
    },
    "usercreatebyrole": {
        "doc": "This function is not available for a Windows user.\nCreates a record for a new Plant SCADA user. The user can be assigned to a specified role. The name of the user needs to be unique.\nAn alarm server needs to be configured and running in the project, so that all clients are notified that an online change to the users configuration has been completed.\nIn order to perform user configuration changes online in a system with multiplecomputers running SCADA nodes using these functions, you will need to use theRUN and COPY parameters to check the updates are distributed throughout thesystem, and that the functions are called from the computer which uses the COPYpath as its RUN path.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "/* Create a new user */\nUserCreateByRole(\"Fred\", \"Fred Jones\", \"secret\", \"Operator\");",
        "name": "UserCreateByRole",
        "params": [
            {
                "paramdescription": "The name of the user.",
                "paramname": "sName"
            },
            {
                "paramdescription": "The full name of the user.",
                "paramname": "sFullName"
            },
            {
                "paramdescription": "The password of the user.\nThe sPassword argument is optional. If not passed, this argument defaults to an empty string which is subsequently ignored. It is included for the purposes of handling duplicate user names and separate password identification compatibility.",
                "paramname": "sPassword"
            },
            {
                "paramdescription": "The role to which the user will be assigned. The role needs to be defined in Plant SCADA Studio's Security activity (see Roles). ",
                "paramname": "sRole"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "UserCreateByRole(sName, sFullName, sPassword, sRole )"
    },
    "usercreateform": {
        "doc": "Not available for a Windows user.\nDisplays a form to create a record for a new Plant SCADA user. The name of the user needs to be unique. The form allows the user to be assigned to a specified role.\nAn alarm server needs to be configured and running in the project, so that all clients are notified that an online change to the users configuration has been completed.\nIn order to perform user configuration changes online in a system with multiplecomputers running SCADA nodes using these functions, you will need to use theRUN and COPY parameters to check the updates are distributed throughout thesystem, and that the functions are called from the computer which uses the COPYpath as its RUN path.",
        "example": "UserCreateForm()",
        "name": "UserCreateForm",
        "params": [],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "UserCreateForm()"
    },
    "userdelete": {
        "doc": "Not available for a Windows user.\nDeletes the record for a user. Changes are written to both the Users database and the runtime database in memory.\nAn alarm server needs to be configured and running in the project, so that all clients are notified that an online change to the users configuration has been completed.\nIn order to perform user configuration changes online in a system with multiplecomputers running SCADA nodes using these functions, you will need to use theRUN and COPY parameters to check the updates are distributed throughout thesystem, and that the functions are called from the computer which uses the COPYpath as it's RUN path.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "/* Delete Fred from the database */\nUserDelete(\"Fred\");",
        "name": "UserDelete",
        "params": [
            {
                "paramdescription": "The name of the user.",
                "paramname": "sName"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "UserDelete(sName)"
    },
    "usereditform": {
        "doc": "Not available for a Windows user.\nDisplays a form to allow the user to create or delete any user record in the database. This function should have restricted access. Changes are written to both the Users database and the runtime database in memory.\nAn alarm server needs to be configured and running in the project, so that all clients are notified that an online change to the users configuration has been completed.\nIn order to perform user configuration changes online in a system with multiplecomputers running SCADA nodes using these functions, you will need to use theRUN and COPY parameters to check the updates are distributed throughout thesystem, and that the functions are called from the computer which uses the COPYpath as it's RUN path.",
        "example": "/* Display a form for the user to create or delete user records. */\nUserEditForm();",
        "name": "UserEditForm",
        "params": [],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "UserEditForm()"
    },
    "userinfo": {
        "doc": "Gets information about the operator who is currently logged-in to the system.",
        "example": "/* Check if a user has logged on. If so, get the user's full name \nand the number of commands they have performed. */\nString sName;\nString sCount;\nIF UserInfo(0) = \"1\" THEN\n    sName = UserInfo(2);\n    sCount = UserInfo(5);\nEND",
        "name": "UserInfo",
        "params": [
            {
                "paramdescription": "The type of user information:\n0 - Flag to indicate whether any user other than a view-only user is loggedin\n1 - The login name of the user\n2 - The full name of the user\n3 - The time the user logged in\n4 - The time the user entered the last command\n5 - The number of commands entered by the user\n6 - The type of login:\n\"0\" indicates that the current user is a view-only user.\n\"1\"indicates there is Plant SCADA or Windows non-default user explicitly loggedin.\n \"2\" indicates the logged on user is a Plant SCADA default user (control clientauto login Plant SCADA user). \n\"3\" indicates the logged on user is a Windows default user (control clientauto login windows user).\nThe information (as a string). If an error is detected, an empty string is returned.",
                "paramname": "nType"
            }
        ],
        "returnType": "The information (as a string). If an error is detected, an empty string is returned.",
        "syntax": "UserInfo(nType)"
    },
    "userlogin": {
        "doc": "Logs a user into the Plant SCADA system, using either Windows integrated security or Plant SCADA security and gives users access to the areas and privileges assigned to them in the Users database, and uses the locale language defined for that user. Only one user can be logged into a computer at any one time. If a user is already logged in when a second user logs in, the first user is replaced by the newly logged on user. When a newly logged in user does not have access to view the current page (as defined by the page's area), the system returns to the home page as specified by the parameter[Page]HomePage, and if unsuccessful that returns to the startup page. When multiple pages are currently displayed, this occurs for each open window.\nTo call this function at user login, the password argument passed needs to be in secure string format.\nAt startup, or when the user logs out, a default user is active, with access to area 0 (zero) and privilege 0 (zero) only. Use the LoginForm() function to display a form for logging in to the system.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "\t/*\n\t** FUNCTION NAME:LoginForm\n\t**\n\t** This function displays the login form, get the user name, password and\n\t** the language of the user session and then trys to log the user in. \n\t** If the login does not succeed it will retry until login is ok or user \n\t** presses the cancel button.\n\t**\n\t*/\n\n\tINT\n\tFUNCTION\n\tLoginForm(STRING sName=\"\", STRING sPassword=\"\", STRING sLanguage=\"English\")\n\tINT\tbDone;\n\tINT\tnStatus;\n\tINT\thForm;\n\n\tbDone = FALSE;\n\tWHILE bDone = FALSE DO\n\t\tFormNew(\"@(Login Form)\", 35, 5, 5);\n\t\tFormPrompt(1, 0, \"@(Name)\");\n\t\tFormInput(16, 0, \"\", sName, 16);\n\t\tFormPrompt(1, 2, \"@(Password)\");\n\t\tFormSecurePassword(18, 2, \"\", sPassword, 16);\n\t\tFormPrompt(1, 4, \"@(Language)\");\n\t\tFormInput(16, 4, sLanguage, 16);\t\t\t\n\t\tFormButton(6, 6, \"  \" + \"@(OK)\" + \"  \", 0, 1);\n\t\tFormButton(20, 6, \"@(Cancel)\", 0, 2);\n\n\tIF FormRead(0) = 0 THEN\n\t\thForm = FormNew(\"@(User Login)\", 36, 1, 8 + 16 + 128 + 256);\n\t\tFormPrompt(1, 0, \"@(Authentication in progress ...)\");\n\t\tFormRead(1);\n\t\tSleepMs(200);\n\n\t\tIF UserLogin(sName, sPassword, sLanguage) = 0 THEN\n\t\t         bDone = TRUE\n\t\t         nStatus = 0;\n\t\tELSE\n\t\t         sPassword = \"\"; \n\tEND\n\n\t\tIF FormActive(hForm) THEN\n\t\t         FormDestroy(hForm);\n\t\t         END\n\t\tELSE\n\t\t         bDone = TRUE;\n\t\t\t\t nStatus = 298;\n\t\t  END\n\t\tEND\n\t\tRETURN nStatus;\n\tEND",
        "name": "UserLogin",
        "params": [
            {
                "paramdescription": " The user's name as defined in the Users database, or the Windows User account name, in plain text.",
                "paramname": "sUserName"
            },
            {
                "paramdescription": " The user's password, as defined in the Users database or Windows account formatted as a secure string.\nTo improve the user credentials protection provides a system built-in user login function that takes the user name and secure password as the arguments. This reduces the chance that the user's password can be exposed in plaint text from the runtime system",
                "paramname": "sPassword"
            },
            {
                "paramdescription": "The specified language needs to tagbe one of the languages defined in the Languages view in Plant SCADA Studio's Setup activity. If the specified language is undefined, the default language is used by the login user, and a message \"Undefined language\" is shown in the prompt line.\nAn empty string (i.e. \"\") can be specified to indicate that the default language is used by the login user. The default language defined by [Language]LocalLanguage INI parameter.\nThe default value of this parameter is \"\".",
                "paramname": "sLanguage"
            }
        ],
        "returnType": "0 (zero) if successful.",
        "syntax": "UserLogin(sUserName, sPassword, [sLanguage])"
    },
    "userpassword": {
        "doc": "Not available for a Windows user.\nChanges the password for the user. Changes are written to both the Users database and the runtime database in memory.\nAn alarm server needs to be configured and running in the project, so that all clients are notified that an online change to the users configuration has been completed.\nIf you use this function to perform user configuration changes across an online system with multiplecomputers running SCADA nodes, you will need to use the [CtEdit]Run and [CtEdit]Copy parameters to distribute the updated files throughout thesystem.\nYou will also need to execute the UserPassword function on:\nUserPassword can only work for users that are contained in the main project.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "/* Change Fred's password */\nUserPassword(\"Fred\", \"secret\");",
        "name": "UserPassword",
        "params": [
            {
                "paramdescription": "The name of the user.",
                "paramname": "sName"
            },
            {
                "paramdescription": "The password of the user.\nThe sPassword argument is optional. If not passed, this argument defaults to an empty string which is subsequently ignored. It is included for the purposes of handling duplicate user names and separate password identification compatibility.",
                "paramname": "sPassword"
            },
            {
                "paramdescription": "The password assigned to the user before the UserPassword() function is run.\nThe sOldPassword argument is optional. If passed, Plant SCADA will only permit the password change (and consequent re-setting of the expiry period) when the old password is correctly entered. If the sOldPassword parameter is not passed, the password change will proceed without restriction.",
                "paramname": "sOldPassword"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "UserPassword(sName [, sPassword] [, sOldPassword] )"
    },
    "userpasswordexpirydays": {
        "doc": "Not available for a Windows user.\nReturns the number of days left before the user's password is due to expire.\nTo use this function, you can build a form page by using cicode that takes the user name and password as inputs and output the number of days that return by UserPasswordExpiryDays().",
        "example": "No example found",
        "name": "UserPasswordExpiryDays",
        "params": [
            {
                "paramdescription": "The name of the user.",
                "paramname": "sUserName"
            },
            {
                "paramdescription": "The password of the user.\nThe sPassword argument is optional. If not passed, this argument defaults to an empty string which is subsequently ignored. It is included for the purposes of handling duplicate user names and separate password identification compatibility.",
                "paramname": "sPassword"
            }
        ],
        "returnType": "The return value contains either the number of days before password expiry, or one of two exception conditions:",
        "syntax": "UserPasswordExpiryDays(sUserName [, sPassword] )"
    },
    "userpasswordform": {
        "doc": "Not available for a Windows user.\nDisplay a form to allow users to change their own passwords. Changes are written to both the Users database and the runtime database in memory.\nAn alarm server needs to be configured and running in the project, so that all clients are notified that an online change to the users configuration has been completed.\nIn order to perform user configuration changes online in a system with multiplecomputers running SCADA nodes using these functions, you will need to use theRUN and COPY parameters to check the updates are distributed throughout thesystem, and that the functions are called from the computer which uses the COPYpath as it's RUN path.\nUserPassword can only work for users that are contained in the main project.",
        "example": "/* Allow users to change their own passwords */\nUserPasswordForm();",
        "name": "UserPasswordForm",
        "params": [],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "UserPasswordForm()"
    },
    "usersetstr": {
        "doc": "Sets the value of the given field for the given user record in the project configuration (users.dbf ) on the local machine.\nAfter this function has been called, use the function UserUpdateRecord to update the user record on the running system.\nAn alarm server needs to be configured and running in the project, so that all clients are notified that an online change to the users configuration has been completed.\nIn order to perform user configuration changes online in a system with multiplecomputers running SCADA nodes using these functions, you will need to use theRUN and COPY parameters to check the updates are distributed throughout thesystem, and that the functions are called from the computer which uses the COPYpath as it's RUN path.\nUserSetStr(sName, sField, sData)\nsName: \nsField: \nsData: \n0 (zero) if successful, otherwise an error code is returned.",
        "example": "UserSetStr(\"Fred\", \"Comment\", \"Fred is an engineer\");\nUserUpdateRecord();",
        "name": "UserSetStr",
        "params": [
            {
                "paramdescription": "The name of the user who's configuration record we wish to modify.",
                "paramname": "sName"
            },
            {
                "paramdescription": "The name of the field in users.dbf to modify.",
                "paramname": "sField"
            },
            {
                "paramdescription": "The new value of the field.",
                "paramname": "sData"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "UserSetStr(sName, sField, sData)"
    },
    "userupdaterecord": {
        "doc": "Triggers a recompile of the local project configuration, then notifies the running system that user configuration has been modified and needs to be reloaded.\nUse this function in conjunction with UserSetStr to modify user configuration online.\nAn alarm server needs to be configured and running in the project, so that all clients are notified that an online change to the users configuration has been completed.\nIn order to perform user configuration changes online in a system with multiple computers running SCADA nodes using these functions, you will need to use the RUN and COPY parameters to check the updates are distributed throughout the system, and that the functions are called from the computer which uses the COPY path as it's RUN path.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "UserSetStr(\"Fred\", \"Comment\", \"Fred is an engineer\");\nUserUpdateRecord();",
        "name": "UserUpdateRecord",
        "params": [],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "UserUpdateRecord()"
    },
    "userverify": {
        "doc": "Verifies a given user by authenticating the user's credential, verifies the user privileges and areas against those specified in the functions parameters. Successful verification however does not log the user into the Plant SCADA runtime system.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.",
        "example": "INT FUNCTION UserVerifyTest()\n\tSTRING  sName;\n\tSTRING  sPassword;\n\tINT     bDone;\n\tINT     nStatus;\n\tbDone = FALSE;\n\tWHILE bDone = FALSE DO\n\t\tFormNew(\"@(Login Form)\", 30, 5, 5);\n\t\tFormInput(1, 0, \"@(Name)\" + \"   \", sName, 16);\n\t\tFormSecurePassword(1, 2, \"@(Password)\" + \" \", sPassword, 16);\n\t\tFormButton( 1, 4, \"  \" + \"@(OK)\" + \"  \", 0, 1);\n\t\tFormButton(17, 4, \"@(Cancel)\", 0, 2);\n\t\tIF FormRead(0) = 0 THEN\n\t\t\tIF UserVerify(sName, sPassword) = 0 THEN\n\t\t\t\tbDone = TRUE;\n\t\t\t\tnStatus = 0;\n\t\t\t\tMessage(\"Info\", \"Verification successful\", 0)\n\t\t\tELSE\n\t\t\t\tsPassword = \"\";\n\t\t\t\tMessage(\"Info\", \"Verification not successful\", 0)\n\t\t\tEND\n\n\t\tELSE\n\t\t\tbDone = TRUE;\n\t\t\tnStatus = 298;\n\t\tEND\n\tEND\n\tRETURN nStatus;\nEND",
        "name": "UserVerify",
        "params": [
            {
                "paramdescription": "The name of the user.",
                "paramname": "sName"
            },
            {
                "paramdescription": "The password of the user. The sPassword argument needs to be passed as a secure string. ",
                "paramname": "sPassword"
            },
            {
                "paramdescription": "Specifies the required user's viewable areas.",
                "paramname": "sAccess"
            },
            {
                "paramdescription": "Specifies the required user's global privilege.",
                "paramname": "sPrivGlobal"
            },
            {
                "paramdescription": "Specifies the required areas for privileges 1 - 8. That is, sPriv1 contains the areas (1,2,3,4,...,255) where the user hasPrivilege 1.",
                "paramname": "sPriv1-8"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "UserVerify(sName, sPassword [, sAccess] [, sPrivGlobal] [, sPriv1..sPriv8] )"
    },
    "variablequality": {
        "doc": "Extracts the quality from a given variable.\nVariableQuality(Variable)\nVariable: \nThe QUALITY of the given variable. If Variable is NULL, it returns quality uncertain (0x40).\n Timestamps of uninitialized stack variables, uninitialized code variables andconstants are equal to 0 - invalid timestamp, while their qualities are GOOD",
        "example": "\tINT codeVariable = 1;\n\tINT\n\tFUNCTION\n\tMyFunction(REAL arg1)\n\tSTRING str = \"My string\";\n\tQUALITY q;\n\tq = VariableQuality(codeVariable); \t//code variable\n\tq = VariableQuality(arg1);\t\t\t//function argument\n\tq = VariableQuality(str);\t\t//stack variable\n\tq = VariableQuality(Tag1); \t\t//any tag/local variable\n \n\tRETURN 1;\n\tEND\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t",
        "name": "VariableQuality",
        "params": [
            {
                "paramdescription": "The variable from which the quality will be extracted.",
                "paramname": "Variable"
            }
        ],
        "returnType": "The QUALITY of the given variable. If Variable is NULL, it returns quality uncertain (0x40).",
        "syntax": "VariableQuality(Variable)"
    },
    "variabletimestamp": {
        "doc": "Extracts the timestamp from a given variable.\nVariableTimestamp(Variable, INT Type)\nVariable: \nnType: \nA TIMESTAMP of the given variable depending on the type. If Variable is NULL, returns INVALID_TIMESTAMP.\nTimestamps of uninitialized stack variables, uninitialized code variables andconstants are equal to 0 - invalid timestamp, while their qualities are GOOD",
        "example": "INT codeVariable = 1;",
        "name": "VariableTimestamp",
        "params": [
            {
                "paramdescription": "The variable from which the timestamp will be extracted.",
                "paramname": "Variable"
            },
            {
                "paramdescription": "The type of timestamp:\n0 – The element’s date/time (default)\n1 – The element’s quality date/time\n2 – The element’s value date/time",
                "paramname": "nType"
            }
        ],
        "returnType": "A TIMESTAMP of the given variable depending on the type. If Variable is NULL, returns INVALID_TIMESTAMP.",
        "syntax": "VariableTimestamp(Variable, INT Type)"
    },
    "verifyprivilegeform": {
        "doc": " Displays a form that allows a single user to enter their credentials.\t\tThese credentials are checked against a specified set to ensure the \t\tuser has the required privileges before allowing the operation to proceed.\n\t\tThe user can be a Plant SCADA or Windows user.   ",
        "example": "// This example generates a form to request a user to approve an operation.\n// This user needs the global privilege level of 8.\n// When approved, the operation is completed and a page string\n// is set to indicate the approval status.\nIF (VerifyPrivilegeForm(\"Shut Down Plant\", \"ApprovalLog\",\n \"PlantWide\", \"8\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\")<>\"\") THEN\n\t// Do operation\n\tPageSetStr(1, \"Operation approved\");\nELSE\n\tPageSetStr(1, \"Operation not approved\");\nEND",
        "name": "VerifyPrivilegeForm",
        "params": [
            {
                "paramdescription": "A description of the operation that requires approval.",
                "paramname": "sOperationDescription"
            },
            {
                "paramdescription": " The name of a log device if logging is required, otherwise pass an emptystring.",
                "paramname": "sLogDevice"
            },
            {
                "paramdescription": "The required user viewable areas, or pass an emptystring for none.",
                "paramname": "sAccess"
            },
            {
                "paramdescription": "The required global privilege, otherwise pass an emptystring.",
                "paramname": "sGlobalPriv"
            },
            {
                "paramdescription": "Specifies the required areas for privileges 1 - 8. That is, sPriv1 contains the areas (1,2,3,4,...,255) where the user hasPrivilege 1. Each argument needs to be either specified or an empty string for none.",
                "paramname": "sPriv1..8"
            }
        ],
        "returnType": "The name of the user  that met the required privileges, otherwise \"\"       ",
        "syntax": "VerifyPrivilegeForm(sOperationDescription,sLogDevice, sAccess, sGlobalPriv, sPriv1, sPriv2, sPriv3, sPriv4, sPriv5, sPriv6, sPriv7, sPriv8)"
    },
    "verifyprivilegetagwrite": {
        "doc": "Displays a form that allows any single user to enter their credentials in order\t\tto approve a write of a specific value to a specific tag.  These credentials are \t\tchecked against a specified set to ensure the user has the required privileges before \t\tallowing the operation to proceed.\n\t\tThe usernames can be Plant SCADA or Windows users.\t\t   ",
        "example": "// This example generates a form to request a user to approve the tag write operation.\n// This user needs privilege levels of 6 and 3.\n// When approved, the PLC_VAR1 tag is written with the value 123 and a page string\n// is set to indicate the approval status.\nIF (VerifyPrivilegeTagWrite(\"PLC_VAR1\", \"123\", \"ApprovalLog\",\n \"PlantWide\", \"\", \"6\", \"3\", \"\", \"\", \"\", \"\", \"\", \"\")<>\"\") THEN\n\tPageSetStr(1, \"TagWrite Successful\");\nELSE\n\tPageSetStr(1, \"TagWrite Not Successful\");\nEND",
        "name": "VerifyPrivilegeTagWrite",
        "params": [
            {
                "paramdescription": " The name of the tag to which a write needs to be approved.",
                "paramname": "sTagName"
            },
            {
                "paramdescription": "The value to write to the tag if approval succeeds.",
                "paramname": "sValuetoWrite"
            },
            {
                "paramdescription": " The name of a log device if logging is required, otherwise pass an emptystring.",
                "paramname": "sLogDevice"
            },
            {
                "paramdescription": "The required user viewable areas, or pass an emptystring for none.",
                "paramname": "sAccess"
            },
            {
                "paramdescription": "The required global privilege, otherwise pass an emptystring.",
                "paramname": "sGlobalPriv"
            },
            {
                "paramdescription": "Specifies the required areas for privileges 1 - 8. That is, sPriv1 contains the areas (1,2,3,4,...,255) where the user hasPrivilege 1. Each argument needs to be either specified or an empty string for none.",
                "paramname": "sPriv1..8"
            }
        ],
        "returnType": "Name of user that met the required privileges (and therefore the \n\t\tvalue was written to the specified tag), otherwise \"\"  ",
        "syntax": "VerifyPrivilegeTagWrite(sTagName, sValueToWrite, sLogDevice, sAccess, sGlobalPriv, sPriv1, sPriv2, sPriv3, sPriv4, sPriv5, sPriv6, sPriv7, sPriv8)"
    },
    "version": {
        "doc": "Gets the version number of the Plant SCADA software in use.",
        "example": "! If the \nPlant SCADA\n version number is 1.2:\nVersion(0);\n! Returns 1.\nVersion(1);\n! Returns 2.\nVersion(3);\n! Returns \"1.2\".",
        "name": "Version",
        "params": [
            {
                "paramdescription": "The type of version:\n0 - Major version number\n1 - Minor version number\n2 - Revision number\n3 - Version text",
                "paramname": "nType"
            }
        ],
        "returnType": "The version number as a string.",
        "syntax": "Version(nType)"
    },
    "whoami": {
        "doc": "Displays the user name and full name of the user currently logged-in to the system. When the current logged on user is Windows user this function returns the user’s full name in the format of <DomainName>\\<UserName>. The names are displayed at the prompt AN.",
        "example": "/* Display the user's full name and user name at the prompt AN. */\nWhoAmI();",
        "name": "WhoAmI",
        "params": [],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "WhoAmI()"
    },
    "wincopy": {
        "doc": "Copies the graphics image of the active window to the Windows Clipboard. You can paste this Clipboard image into other applications.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.\nNotes:",
        "example": "WinCopy();\n! Copies the active window to the Windows Clipboard.\nWinCopy(0.5,0.5);\n! Copies the active window to the Windows Clipboard at half the \ncurrent size.",
        "name": "WinCopy",
        "params": [
            {
                "paramdescription": "The x scaling factor for the item being copied. This argument is optional, as a default setting of 1 is used to maintain the current horizontal scaling of the image. The outcome is proportional to 1; for example, 0.5 halves the width of the image.",
                "paramname": "xScale"
            },
            {
                "paramdescription": "The y scaling factor for the item being copied. This argument is optional, as a default setting of 1 is used to maintain the current vertical scaling of the image. The outcome is proportional to 1; for example, 0.5 halves the height of the image.",
                "paramname": "yScale"
            },
            {
                "paramdescription": "Swaps the colors black and white for the purpose of printing pages with a lot of black content. Use the default value of 1 to swap black and white (optional).",
                "paramname": "bSwapBlackWhite"
            },
            {
                "paramdescription": "The file name or path of a text based map file used to specify colors to swap when printing. By default Plant SCADAwill look in the bin directory for the map file. The format for the map file is:\nWhere:\nRRRis a decimal red intensity value between 000 and 255. \nGGGis a decimal green intensity value between 000 to 255.\nBBBis a decimal blue intensity value between 000 to 255. \nHHH, SSS and LLL are optional tolerance values to enable swapping a range of colors. Default values are shown below.\nHHH is a decimal value representing the Hue tolerance. Valid range is 0 to 360. Default = 0.\nSSS is a decimal value representing the Saturation tolerance. Valid range is 0 to 255. Default = 2 * Hue tolerance.\nLLL is a decimal value representing the Luminance tolerance. Valid range is 0 to 255. Default = 2 * Hue tolerance.\nLeading zeros are not required, however they aid readability.\nThe first three RGB values specify the FROM color, and the second three RGB values specify the TO color. The tolerance values are applied to the FROM color when replacing individual pixels in the image.\nComments may be placed at the end of each line, or on individual lines, and needs to be proceeded with // or !.\nExample map file to swap the CSV_Include project:\n0 (zero) if successful, otherwise an error code is returned.",
                "paramname": "sMap"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "WinCopy( [xScale] [, yScale] [, bSwapBlackWhite] [, sMap] )"
    },
    "winfile": {
        "doc": "Writes the graphics image of the active window to a file. The file is saved in the Plant SCADA compressed .bmp format.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.\nNotes:",
        "example": "WinFile(\"DUMP\");\n/* Writes the active window to a file named DUMP in the current \ndirectory. */",
        "name": "WinFile",
        "params": [
            {
                "paramdescription": "The name of the file to be created. If no path information is specified, the function will try to create the file in the bin directory (the current directory of the runtime process). Write permission is required. \nPath operators such as [data] and [run] are also supported. For example to save the file in the [data] directory, you can specify:\nThe specified path needs to point to a writable folder. ",
                "paramname": "sFile"
            },
            {
                "paramdescription": "The x scaling factor for the item being printed. This argument is optional, as a default setting of 1 is used to maintain the horizontal scaling of the image. The outcome is proportional to 1; for example, 0.5 halves the width of the image .",
                "paramname": "xScale"
            },
            {
                "paramdescription": "The y scaling factor for the item being printed. This argument is optional, as a default setting of 1 is used to maintain the current vertical scaling of the image. The outcome is proportional to 1; for example, 0.5 halves the height of the image.",
                "paramname": "yScale"
            },
            {
                "paramdescription": "Swaps the colors black and white for the purpose of printing pages with a lot of black content. Use the default value of 1 to swap black and white (optional).",
                "paramname": "bSwapBlackWhite"
            },
            {
                "paramdescription": "The file name or path of a text based map file used to specify colors to swap when printing. By default Plant SCADAwill look in the bin directory for the map file. The format for the map file is:\nWhere:\nRRRis a decimal red intensity value between 000 and 255. \nGGGis a decimal green intensity value between 000 to 255.\nBBBis a decimal blue intensity value between 000 to 255. \nHHH, SSS and LLL are optional tolerance values to enable swapping a range of colors. Default values are shown below.\nHHH is a decimal value representing the Hue tolerance. Valid range is 0 to 360. Default = 0.\nSSS is a decimal value representing the Saturation tolerance. Valid range is 0 to 255. Default = 2 * Hue tolerance.\nLLL is a decimal value representing the Luminance tolerance. Valid range is 0 to 255. Default = 2 * Hue tolerance.\nLeading zeros are not required, however they aid readability.\nThe first three RGB values specify the FROM color, and the second three RGB values specify the TO color. The tolerance values are applied to the FROM color when replacing individual pixels in the image.\nComments may be placed at the end of each line, or on individual lines, and needs to be proceeded with // or !.\nExample map file to swap the CSV_Include project:\n0 (zero) if successful, otherwise an error code is returned.",
                "paramname": "sMap"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "WinFile(sFile [, xScale] [, yScale] [, bSwapBlackWhite] [, sMap] )"
    },
    "winfree": {
        "doc": "Removes the active display window. Be aware that the last window (and any child windows owned by the last window) cannot be removed. You cannot call this function as an exit command (see Page Properties) or from a Cicode Object.\nNotes",
        "example": "WinFree();\n! Removes the active display window.",
        "name": "WinFree",
        "params": [],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "WinFree()"
    },
    "winfreeex": {
        "doc": "Removes the active display window and allows you to pass a Windows handle to the function for closing the window. Note that the last window (and any child windows owned by the last window) cannot be removed. You cannot call this function as an exit command (see Page Properties) or from a Cicode Object.",
        "example": "FUNCTION Activate_Pinned()",
        "name": "WinFreeEx",
        "params": [
            {
                "paramdescription": "The window number (returned from the WinNumber() function). Note that this is not the same as the window handle, returned from the WndFind() function.",
                "paramname": "Window"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "WinFreeEx(Window)"
    },
    "wingetclicked": {
        "doc": "Gets the number of the Plant SCADA window that has most recently been clicked on using the left mouse button.",
        "example": "nCitectWin=WinGetClicked();\n! Gets the number of the \nPlant SCADA\n window that has most recently been clicked on using the left mouse button.",
        "name": "WinGetClicked",
        "params": [],
        "returnType": "The window number of the Plant SCADA window that has most recently been clicked on using the left mouse button. Be aware that this is not the same as the window handle, returned from the WndFind() function.",
        "syntax": "WinGetClicked()"
    },
    "wingetfirstchild": {
        "doc": "            Gets the window number of the first child of a parent window. This number can be used with other functions to control the window.",
        "example": "...\n// Get the active window number\niParentWindowNum = WinNumber();\niFirstChild = WinGetFirstChild(iParentWindowNum);\niSecondChild = WinGetNextChild(iFirstChild);\niThirdChild = WinGetNextChild(iSecondChild);\n...",
        "name": "WinGetFirstChild",
        "params": [
            {
                "paramdescription": "The window number of the parent window. ",
                "paramname": "Window"
            }
        ],
        "returnType": "The window number associated with the first child of the specified parent window. If a child window does not exist, -1 is returned.",
        "syntax": "WinGetFirstChild(Window)"
    },
    "wingetfocus": {
        "doc": "Gets the number of the Plant SCADA window that has the keyboard focus.",
        "example": "nCitectWin=WinGetFocus();\n! Gets the number of the \nPlant SCADA\n window that has \nthe keyboard focus",
        "name": "WinGetFocus",
        "params": [],
        "returnType": "The window number of the Plant SCADA window that has the keyboard focus. Be aware that this is not the same as the window handle, returned from the WndFind() function.",
        "syntax": "WinGetFocus()"
    },
    "wingetname": {
        "doc": "Gets the name previously associated with a particular window number using WinSetName. An association with a window is removed when the window is free-ed.",
        "example": "No example found",
        "name": "WinGetName",
        "params": [
            {
                "paramdescription": "An optional parameter which specifies the window number to lookup for the associated Name. If no number is specified, the name returned is the one associated with the currently selected window number. ",
                "paramname": "iWinNum"
            }
        ],
        "returnType": "String name associated with window number iWinNum, otherwise an empty string is returned.",
        "syntax": "WinGetName([iWinNum])"
    },
    "wingetnextchild": {
        "doc": "            Gets the window number of the next child in a child link. This number can be used with other functions to control the window.",
        "example": "...\n// Get the active window number\niParentWindowNum = WinNumber();\niFirstChild = WinGetFirstChild(iParentWindowNum);\niSecondChild = WinGetNextChild(iFirstChild);\niThirdChild = WinGetNextChild(iSecondChild);\n...",
        "name": "WinGetNextChild",
        "params": [
            {
                "paramdescription": "The window number of the previous child in the child link.",
                "paramname": "Window"
            }
        ],
        "returnType": "The window number associated with the next child in the child link. If a window does not exist, -1 is returned.",
        "syntax": "WinGetNextChild(Window)"
    },
    "wingetparent": {
        "doc": "Retrieves the window number of the specified window's parent or root window.",
        "example": "nParentWin=WinGetParent();\n! Gets the number of the parent window for the currently selected \nPlant SCADA\n window\n\n\n\n\nnRootWin=WinGetParent(WinGetFocus(), TRUE);\n! Gets the number of the root window for the window that has keyboard focus",
        "name": "WinGetParent",
        "params": [
            {
                "paramdescription": "An optional parameter which specifies the window number of the child window. If no number is specified, it retrieves the window number of the currently selected window's parent or root window.",
                "paramname": "WinNum"
            },
            {
                "paramdescription": "An optional parameter which determines whether to get the parent or root window. If false, it will retrieve the immediate parent window number (default). If true, it retrieves the root window number by walking the chain of parent windows.",
                "paramname": "GetRoot"
            }
        ],
        "returnType": "The window number of the parent or root window.",
        "syntax": "WinGetParent([WinNum], [GetRoot])"
    },
    "wingetwndhnd": {
        "doc": "Gets the window handle for the current window. The window handle may be used by 'C' programs and Plant SCADA Wnd... functions. You may pass the windows handle to a 'C' program by using the DLL functions.",
        "example": "INT hWnd;\nhWnd = WinGetWndHnd();\nWinShow(hWnd,6); //iconize the window",
        "name": "WinGetWndHnd",
        "params": [],
        "returnType": "The window handle if successful, otherwise 0 (zero) is returned. Be aware that this is not the same as a Plant SCADA window number returned from the WinNumber() function.",
        "syntax": "WinGetWndHnd()"
    },
    "wingoto": {
        "doc": "Changes the active window. The specified window is placed in front of all other windows and all keyboard commands will apply to this window. You cannot call this function as an exit command (see Page Properties) or from a Cicode Object.",
        "example": "! If two windows are displayed;\nWinGoto(1);\n! Changes the active window to Window 1.\nWinGoto(0);\n! Changes the active window to Window 0.",
        "name": "WinGoto",
        "params": [
            {
                "paramdescription": "The window number (returned from the WinNumber() function). Be aware that this is not the same as the window handle, returned from the WndFind() function.",
                "paramname": "Window"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "WinGoto(Window)"
    },
    "winmode": {
        "doc": "Sets the display mode of the active Plant SCADA window.",
        "example": "! Iconize the active \nPlant SCADA\n window.\nWinMode(7);",
        "name": "WinMode",
        "params": [
            {
                "paramdescription": "The mode:\n0 - Hide the window.\n2 - Activate the window in an iconized state.\n3 - Activate the window in a maximized state.\n4 - Display the window in its previous state without activating it.\n5 - Activate the window in its current state.\n6 - Iconize the window.\n7 - Display the window in an iconized state without activating it.\n8 - Display the window in its current state without activating it.\n9 - Activate the window in its previous state.",
                "paramname": "Mode"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "WinMode(Mode)"
    },
    "winmove": {
        "doc": "Moves the active window to a new location and sizes the window in a single operation. This is the same as calling the WinPos() and the WinSize() functions. You use PageInfo to get the current window position.\nWinMove(X, Y, Width, Height)\nX, Y: \nWidth: \nHeight: \n0 (zero) if successful, otherwise an error code is returned.",
        "example": "WinMove(100,50,500,300);\n/* Moves the top-left corner of the active window to the pixel \ncoordinate 100,50 and size the window to 500 x 300 pixels. */",
        "name": "WinMove",
        "params": [
            {
                "paramdescription": "The new x and y pixel coordinates for the top-left corner of the active window. \nIf the window is a pinned window, the new coordinates will specify a location for the window that is based on the unscaled version of the page that hosts it. ",
                "paramname": "X, Y"
            },
            {
                "paramdescription": "The width of the window, in pixels.\n If the target is a pinned window, the new width will be measured against the original window size as it is on the unscaled version of the page that hosts it.",
                "paramname": "Width"
            },
            {
                "paramdescription": "The height of the window, in pixels.\n If the target is a pinned window, the new height will be measured against the original window size as it is on the unscaled version of the page that hosts it.",
                "paramname": "Height"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "WinMove(X, Y, Width, Height)"
    },
    "winnew": {
        "doc": "Opens a new display window, with a specified page displayed. The window can later be destroyed with the WinFree() function.\nYou can also specify if the displayed page operates within the context of a particular cluster in a multiple cluster project. When the page is displayed during runtime, the ClusterName argument is used to resolve any tags that do not have a cluster explicitly defined.",
        "example": "! If the display window being opened is window number 2:\nWindow=WinNew(\"Alarm\");\n! Displays the Alarm page and sets Window to 2.",
        "name": "WinNew",
        "params": [
            {
                "paramdescription": "The name or page number of the page to display (in quotation marks \"\"). Can be prefixed by the name of a host cluster, that is \"ClusterName.Page\". This will take precedence over the use of the ClusterName parameter if the two differ.",
                "paramname": "Page"
            },
            {
                "paramdescription": "The name of the cluster that will accommodate the page at runtime. This is optional if you have one cluster or are resolving the page via the current cluster context. The argument is enclosed in quotation marks \"\". If the Page parameter is prefixed with the name of a cluster, this parameter will not be used.",
                "paramname": "sClusterName"
            }
        ],
        "returnType": "The window number of the window, or -1 if the window cannot be opened. Be aware that this is not the same as the window handle returned from the WndFind() function.",
        "syntax": "WinNew(Page,ClusterName)"
    },
    "winnewat": {
        "doc": "Opens a new display window at a specified location, with a selected page displayed. The window can later be removed with the WinFree() function.\nYou can also specify if the displayed page operates within the context of a particular cluster in a multiple cluster project. When the page is displayed during runtime, the ClusterName argument is used to resolve any tags that have a cluster omitted.",
        "example": "No example found",
        "name": "WinNewAt",
        "params": [
            {
                "paramdescription": " The name or page number of the page to display (inquotation marks \"\"). Can be prefixed by the name of a hostcluster, that is \"ClusterName.Page\". This will take precedenceover the use of the ClusterName parameter if the two differ.",
                "paramname": "Page"
            },
            {
                "paramdescription": "The x pixel coordinate of the top left corner of the window.",
                "paramname": "X"
            },
            {
                "paramdescription": "The y pixel coordinate of the top left corner of the window.",
                "paramname": "Y"
            },
            {
                "paramdescription": "The mode of the window:\n0 - Normal page.\n1 - Page child window. The window is closed when a new page is displayed, for example, when the PageDisplay() or PageGoto() function is called. The parent is the current active window.\n2 - Window child window. The window is closed automatically when the parent window is freed with the WinFree() function. The parent is the current active window.\n4 - No re-size. The window is displayed with thin borders and no maximize/minimize icons. The window cannot be re-sized.\n8 - No icons. The window is displayed with thin borders and no maximize/minimize or system menu icons. The window cannot be re-sized.\n16 - No caption. The window is displayed with thin borders, no caption, and no maximize/minimize or system menu icons. The window cannot be re-sized.\n32 - Echo enabled. When enabled, keyboard echo, prompts, and error messages are displayed on the parent window. This mode should only be used with child windows (for example, Mode 1 and 2).\n64 - Always on top.\n128 - Open a unique window. This mode helps to prevent this window from being opened more than once.\n256 - Display the entire window. This mode commands that no parts of the window will appear off the screen\n512 - Open a unique Super Genie. This mode helps to prevent a Super Genie from being opened more than once (at the same time). However, the same Super Genie with different associations can be opened.\n1024 - Disables dynamic resizing of the new window, overriding the setting of the [Page]DynamicSizing parameter.\n4096 - Allows the window to be resized without maintaining the current aspect ratio. The aspect ratio defines the relationship between the width and the height of the window, which means this setting allows you to stretch or compress the window to any proportions. This option overrides the setting of the [Page]MaintainAspectRatio parameter.\n8192 - Text on a page will be resized in proportion with the maximum scale change for a resized window. For example, consider a page that is resized to three times the original width, and half the original height. If this mode is set, the font size of the text on the page will be tripled (in proportion with the maximum scale). This option overrides the setting of the [Page] ScaleTextToMax parameter.\n16384 - Hide the horizontal scroll bar.\n32768 - Hide the vertical scroll bar.\n65536 - Disable horizontal scrolling.\n131072 - Disable vertical scrolling.\nYou can select multiple modes by adding modes together (for example, set Mode to 9 to open a page child window without maximize, minimize, or system menu icons).",
                "paramname": "Mode"
            },
            {
                "paramdescription": "The name of the cluster that will accommodate the page atruntime. This is optional if you have one cluster or areresolving the page via the current cluster context. Theargument is enclosed in quotation marks \"\". If the Pageparameter is prefixed with the name of a cluster, thisparameter will not be used.",
                "paramname": "sClusterName"
            }
        ],
        "returnType": "The window number of the window, or -1 if the window cannot be opened. Be aware that this is not the same as the window handle returned from the WndFind() function.",
        "syntax": "WinNewAt(Page, X, Y, Mode[, sClusterName])"
    },
    "winnewpinat": {
        "doc": "Allows for windows to be \"pinned\" at specified locations within a main window or within other pinned windows. This function opens a new display window at a specified location, relative to the current active window, with a selected page displayed. The window can later be removed with the WinFree() function. \nThe pinned windows become child windows of the parent window, and maintain their size and position relative to the parent window.\nPinned windows do not have a border, title bar or title. They cannot be maximized or minimized. Pinned windows are automatically closed when the main window is closed. They can be created in one of the following modes (as detailed in the Syntax section below). \nThe content of pinned windows can be manipulated using most Windows Cicode functions except the following:\nYou can also specify if the displayed page operates within the context of a particular cluster in a multiple cluster project. When the page is displayed during runtime, the ClusterName argument is used to resolve any tags that have a cluster omitted.\nWinNewPinAt(Page, X, Y[, Mode][, Width][, Height][, sClusterName])\nPage: \nX: \nY: \nMode: \nWidth:\nHeight:\nsClusterName: \nThe window number of the window, or -1 if the window cannot be opened. Be aware that this is not the same as the window handle returned from the WndFind() function.\nWinFree, WinNew, WinNewAt",
        "example": "No example found",
        "name": "WinNewPinAt",
        "params": [
            {
                "paramdescription": " The name or page number of the page to display (inquotation marks \"\"). Can be prefixed by the name of a hostcluster, that is \"ClusterName.Page\". This will take precedenceover the use of the ClusterName parameter if the two differ.",
                "paramname": "Page"
            },
            {
                "paramdescription": "The x pixel coordinate of the top left corner of the window.",
                "paramname": "X"
            },
            {
                "paramdescription": "The y pixel coordinate of the top left corner of the window.",
                "paramname": "Y"
            },
            {
                "paramdescription": "The mode of the window:\n0 - Set by default. Normal page, maintain aspect ratio when resized. The aspect ratio defines the relationship between the width and the height of the window.\n1024 - Disables dynamic resizing of the new window.\n4096 - Allows the window to be resized without maintaining the current aspect ratio. The aspect ratio defines the relationship between the width and the height of the window, which means this setting allows you to stretch or compress the window to any proportions.\n8192 - Text on a page will be resized in proportion with the maximum scale change for a resized window. This option overrides the setting of the [Page] ScaleTextToMax parameter.\nYou can select multiple modes by adding modes together.",
                "paramname": "Mode"
            },
            {
                "paramdescription": "The pixel width of the window, scaled relative to the current active window.\nDefault value - The width of the page associated with argument 'Page'.",
                "paramname": "Width"
            },
            {
                "paramdescription": "The pixel height of the window, scaled relative to the current active window.\nDefault value - The height of the page associated with argument 'Page'.",
                "paramname": "Height"
            },
            {
                "paramdescription": "The name of the cluster that will accommodate the page atruntime. This is optional if you have one cluster or areresolving the page via the current cluster context. Theargument is enclosed in quotation marks \"\". If the Pageparameter is prefixed with the name of a cluster, thisparameter will not be used.",
                "paramname": "sClusterName"
            }
        ],
        "returnType": "The window number of the window, or -1 if the window cannot be opened. Be aware that this is not the same as the window handle returned from the WndFind() function.",
        "syntax": "WinNewPinAt(Page, X, Y[, Mode][, Width][, Height][, sClusterName])"
    },
    "winnext": {
        "doc": "Makes the next window (in order of creation) active.",
        "example": "! If the display window being made active is window number 2:\nWindow=WinNext();\n! Makes the next window active and sets Window to 2.",
        "name": "WinNext",
        "params": [],
        "returnType": "The window number of the window, or -1 if there is no next window. Be aware that this is not the same as the window handle returned from the WndFind() function.",
        "syntax": "WinNext()"
    },
    "winnumber": {
        "doc": "Gets the window number of the active Plant SCADA window. This number can be used with other functions to control the window.",
        "example": "! Create a new window, but keep the active window the same:\nWindow=WinNumber();\nWinNew(\"Alarm\");\nWinGoto(Window);",
        "name": "WinNumber",
        "params": [
            {
                "paramdescription": "String name previously associated with a window number using WinSetName().",
                "paramname": "sName"
            }
        ],
        "returnType": "Window Number associated with the Name provided. If no Name is specified then the active window number is returned. If there isn't a valid window number associated with the name provided then -1 is returned.",
        "syntax": "WinNumber([sName])"
    },
    "winpos": {
        "doc": "Moves the active window to a new location. You use PageInfo() to get the current window position.",
        "example": "WinPos(100,50);\n/* Moves the top-left corner of the active window to the pixel \ncoordinate 100,50. */",
        "name": "WinPos",
        "params": [
            {
                "paramdescription": "The new x and y pixel coordinates of the top-left corner of the active window.\nIf the window is a pinned window, the new coordinates will specify a location for the window that is based on the unscaled version of the page that hosts it. ",
                "paramname": "X, Y"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "WinPos(X, Y)"
    },
    "winprev": {
        "doc": "Makes the previous window (in order of creation) active.",
        "example": "! If the display window being made active is window number 2:\nWindow=WinPrev();\n! Makes the previous window active and sets Window to 2.",
        "name": "WinPrev",
        "params": [],
        "returnType": "The window number of the window, or -1 if there is no next window. Be aware that this is not the same as the window handle returned from the WndFind() function.",
        "syntax": "WinPrev()"
    },
    "winprint": {
        "doc": "Sends the graphics image of the active window to a printer.\nThis function is a blocking function. It blocks the calling Cicode task until the operation is complete.\nNotes:",
        "example": "WinPrint(\"LPT3:\",0,0,0);\n! Prints the active window on printer \"LPT3\". The print will be \nscaled to fit the largest possible page area and will retain the \norientation of the printer, aspect ratio and colors that are \ndisplayed on screen.\n\nWinPrint(\"LPT3:\");\n!Prints the page as in the first example, but swaps black and \nwhite on the printout.",
        "name": "WinPrint",
        "params": [
            {
                "paramdescription": "The name of the printer port to which the window will be printed. This name needs to be enclosed within quotation marks \"\". For example \"LPT1:\", to print to the local printer, or \"\\\\Pserver\\canon1\" using UNC to print to a network printer. sPort may not contain spaces.",
                "paramname": "sPort"
            },
            {
                "paramdescription": "The x scaling factor for the print. The default value of 0 (zero) automatically scales the print to fit the page. A value of 1 is used to maintain the current horizontal scaling of the image. The outcome is proportional to 1; for example, 0.5 halves the width of the image (optional).",
                "paramname": "xScale"
            },
            {
                "paramdescription": "The y scaling factor for the print. The default value of 0 (zero) automatically scales the print to fit the page. A value of 1 is used to maintain the current horizontal scaling of the image. The outcome is proportional to 1; for example, 0.5 halves the width of the image (optional).",
                "paramname": "yScale"
            },
            {
                "paramdescription": "Swaps the colors black and white for the purpose of printing pages with a lot of black content. Use the default value of 1 to swap black and white (optional).",
                "paramname": "bSwapBlackWhite"
            },
            {
                "paramdescription": "The file name or path of a text based map file used to specify colors to swap when printing. By default Plant SCADAwill look in the bin directory for the map file. The format for the map file is:\nWhere:\nRRRis a decimal red intensity value between 000 and 255. \nGGGis a decimal green intensity value between 000 to 255.\nBBBis a decimal blue intensity value between 000 to 255. \nHHH, SSS and LLL are optional tolerance values to enable swapping a range of colors. Default values are shown below.\nHHH is a decimal value representing the Hue tolerance. Valid range is 0 to 360. Default = 0.\nSSS is a decimal value representing the Saturation tolerance. Valid range is 0 to 255. Default = 2 * Hue tolerance.\nLLL is a decimal value representing the Luminance tolerance. Valid range is 0 to 255. Default = 2 * Hue tolerance.\nLeading zeros are not required, however they aid readability.\nThe first three RGB values specify the FROM color, and the second three RGB values specify the TO color. The tolerance values are applied to the FROM color when replacing individual pixels in the image.\nComments may be placed at the end of each line, or on individual lines, and needs to be proceeded with // or !.\nExample map file to swap the CSV_Include project:\n0 (zero) if successful, otherwise an error code is returned.",
                "paramname": "sMap"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "WinPrint(sPort [, xScale] [, yScale] [, bSwapBlackWhite] [, sMap] )"
    },
    "winprintfile": {
        "doc": "Prints a file to the system printer. The file needs to be saved with the WinFile() function.",
        "example": "! Save image to disk then print.\nWinFile(\"temp\");\nWinPrintFile(\"temp\", \"LPT3:\",0,0,0);\n! Prints the file \"temp\" on printer \"LPT3\". The print will be \nscaled to fit the largest possible page area and will retain the \norientation of the printer, aspect ratio and colors that are \ndisplayed on screen.\nWinPrintFile(\"temp\",\"LPT3:\");\n! Prints the page as in the first example, but swaps black and \nwhite on the printout.\nWinPrintFile(\"temp\",\"LPT3:\",0,0,0,0x00FF00,0xFF0000);\n! Changes green to red.\nWinPrintFile(\"temp\",\"LPT3:\",0,0,1,0x00FF00,0xFF0000);\n! Changes green to red and black to white.",
        "name": "WinPrintFile",
        "params": [
            {
                "paramdescription": "The file name.",
                "paramname": "sFile"
            },
            {
                "paramdescription": "The name of the printer port to which the window will be printed. This name needs to be enclosed within quotation marks \"\". For example \"LPT1:\", to print to the local printer, or \"\\\\Pserver\\canon1\" using UNC to print to a network printer. sPort may not contain spaces",
                "paramname": "sPort"
            },
            {
                "paramdescription": "The x scaling factor for the print. The default value of 0 (zero) automatically scales the print to fit the page. A value of 1 is used to maintain the current horizontal scaling of the image. The outcome is proportional to 1; for example, 0.5 halves the width of the image (optional).",
                "paramname": "xScale"
            },
            {
                "paramdescription": "The y scaling factor for the print. The default value 0 (zero) automatically scales the print to fit the page. A value of 1 is used to maintain the current horizontal scaling of the image. The outcome is proportional to 1; for example, 0.5 halves the width of the image (optional).",
                "paramname": "yScale"
            },
            {
                "paramdescription": "Swaps the colors black and white for the purpose of printing pages with a lot of black content. Use the default value of 1 to swap black and white (optional).",
                "paramname": "bSwapBlackWhite"
            },
            {
                "paramdescription": "The hex RGB color value (0xRRGGBB) to change into toColor. The default value of -1 results in no color change (optional).",
                "paramname": "fromColor"
            },
            {
                "paramdescription": "The hex RGB color value (0xRRGGBB) into which fromColor is changed. The default value of -1 results in no color change (optional).\n0 (zero) if successful, otherwise an error code is returned.",
                "paramname": "toColor"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "WinPrintFile(sFile, sPort [, xScale] [, yScale] [, bSwapBlackWhite] [, fromColor] [, toColor] )"
    },
    "winselect": {
        "doc": "Selects a window to make active. This function only affects the output of Cicode functions. It does not change the screen focus of the windows, or move a background window to the foreground.\nAlways re-select the original window if it is called from a Page database (Page Numbers, Page Symbols, and so on), because other Cicode tasks will assume it is the correct window. This function only changes the active window for the Cicode task that called it.",
        "example": "OldWindow=WinSelect(1);\n! Selects window number 1.\nPrompt(\"Message to Window 1\");\n! Sends message to window number 1.\nWinSelect(2);\n! Selects window number 2.\nPrompt(\"Message to Window 2\");\n! Sends message to window number 2.\nWinSelect(OldWindow);\n! Selects original window.",
        "name": "WinSelect",
        "params": [
            {
                "paramdescription": "The window number to select. Be aware that this is not the same as the window handle returned from the WndFind() function.",
                "paramname": "Window"
            }
        ],
        "returnType": "The old window number.",
        "syntax": "WinSelect(Window)"
    },
    "winsetname": {
        "doc": "Associates a name with a particular window by its window number. An association with a window is removed when the window is free.",
        "example": "No example found",
        "name": "WinSetName",
        "params": [
            {
                "paramdescription": "String name to associate with window number iWinNum.",
                "paramname": "sName"
            },
            {
                "paramdescription": "An optional parameter which specifies the window number with which to associate Name. If no number is specified the name is associated with the currently selected window number..",
                "paramname": "iWinNum"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "WinSetName(sName [, iWinNum] )"
    },
    "winsize": {
        "doc": "Sizes the active window. The origin of the window does not move.",
        "example": "WinSize(200,100);\n! Sizes the active window to 200 pixels wide x 100 pixels high.",
        "name": "WinSize",
        "params": [
            {
                "paramdescription": "The new width and height of the window, in pixels.\n If the target is a pinned window, the new width and height will be measured against the original window size as it is on the unscaled version of the page that hosts it.\nMode:\nSpecifies if the size refers to the viewable area or the total window.\n0 - the size to refer to the viewable area.\n1 - the size to refer to the total window size.\nDefault - 1",
                "paramname": "Width, Height"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "WinSize(Width, Height, Mode)"
    },
    "winstyle": {
        "doc": "Switches on and off scrolling and scrollbar features for existing windows.",
        "example": "WinStyle(1, 1);\nWinStyle(2, 1);",
        "name": "WinStyle",
        "params": [
            {
                "paramdescription": "One of the following:\n1 - Hide horizontal scroll bars.\n2 - Hide vertical scroll bars.\n3 - Disable horizontal scrolling.\n4 - Disable vertical scrolling.",
                "paramname": "Style"
            },
            {
                "paramdescription": "The mode of the option:\n0 - Turn option off.\n1 - Turn option on.",
                "paramname": "Mode"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "WinStyle(Style, Mode)"
    },
    "wintitle": {
        "doc": "Sets the title of the active window.\nIf a window title has been set with the [Page]WinTitle parameter, Plant SCADA uses this title when it refreshes the page (overriding the window title set with the WinTitle() function). To minimize the likelihood of Plant SCADA from overriding the title, set the parameter [Page]WinTitle to *.",
        "example": "WinTitle(Time()+\" \"+Date());\n! Places the current time and date into the window title.",
        "name": "WinTitle",
        "params": [
            {
                "paramdescription": "The new title for the window.",
                "paramname": "sTitle"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "WinTitle(sTitle)"
    },
    "wndfind": {
        "doc": "Gets the Windows handle of any window of any application, so that the window can be manipulated. The window handle is not the same as the Plant SCADA window number and cannot be used with functions that expect the Plant SCADA window number (the Win... functions).\nThe window title (caption) needs to be an exact match of the window name (including any blank spaces) for this function to find the window. You should therefore check that the other application does not change the title of the window during execution.\nBe aware that if the title banner of a Plant SCADA window is set with the Plant SCADA parameter [Page] WinTitle, you should not specify justification (for example, use {TITLE,32,N}). If justification is not disabled (that is the N is omitted), you need to pass the full title of the window (including leading and trailing blanks) to this function.",
        "example": "hWndExcel=WndFind(\"Microsoft Excel - Book1\");\n! Gets the Windows number of the window titled \"Microsoft Excel - \nBook1\"",
        "name": "WndFind",
        "params": [
            {
                "paramdescription": "The title (caption) of the window.",
                "paramname": "sTitle"
            }
        ],
        "returnType": "The window handle. Be aware that this is not the same as a Plant SCADA window number returned from the WinNumber() function.",
        "syntax": "WndFind(sTitle)"
    },
    "wndgetfileprofile": {
        "doc": "Gets a profile string from any .ini file.",
        "example": "! get this user startup page from USER.INI File\nsStartup = \nWndGetFileProfile(Name(),\"Startup\",\"menu\",\"[Run]:\\USER.INI\");\nPageDisplay(sStartup);",
        "name": "WndGetFileProfile",
        "params": [
            {
                "paramdescription": "The name of the [group].",
                "paramname": "sGroup"
            },
            {
                "paramdescription": "The name of the variable.",
                "paramname": "sName"
            },
            {
                "paramdescription": "The default value.",
                "paramname": "sDefault"
            },
            {
                "paramdescription": "The .ini file name.",
                "paramname": "sFile"
            }
        ],
        "returnType": "The profile string from sFile. ",
        "syntax": "WndGetFileProfile(sGroup, sName, sDefault, sFile)"
    },
    "wndhelp": {
        "doc": "Invokes the Windows Help application (WinHlp32.EXE) to display a specific topic from a specific help file.",
        "example": "WndHelp(\"MyHelp.HLP\", 3, 1);\n! Displays the \"MyHelp\" Contents page.\nWndHelp(\"C:\\Help\\Process.HLP\", 8, 239);\n! Displays topic labelled \"239\" in the \"Process\" help file.",
        "name": "WndHelp",
        "params": [
            {
                "paramdescription": "The help file to display.",
                "paramname": "sHelpFile"
            },
            {
                "paramdescription": "The type of help:\n1 - Displays the help topic identified by the context string/number in the Data field. The context string/number needs to be defined in the [MAP] section of the help's .HPJ file.\n2 - Closes the Help application. Enter an empty string for the Data argument.\n3 - Displays the help contents topic defined by the CONTENTS option in the [OPTIONS] section of the .HPJ file.\n4 - Displays the contents topic of the designated How to Use Help file. The context string/number (specified in the Data field) needs to be defined in the [MAP] section of the .HPJ file.\n5 - Changes the current help contents topic to match the context string/number specified in the Data field. This topic is used instead of the one defined by the CONTENTS option in the [OPTIONS] section of the .HPJ file. This will affect Command 3 (see above). The context string/number needs to be defined in the [MAP] section of the help's .HPJ file, and the help file needs to already be open. The change will last only until the help file is closed.\n8 - Displays, in a pop-up window, the help topic identified by the context string/number in the Data field. The context string/number needs to be defined in the [MAP] section of the .HPJ file.\n9 - Tests that the correct help file is displayed. If the correct help file is currently displayed, this command merely makes the help the active window. If the incorrect help file is displayed, WinHelp opens the correct file, and displays the help contents topic defined by the CONTENTS option in the [OPTIONS] section of the .HPJ file. \n11 - Displays the Plant SCADA Help Topics with either the Contents, the Index, or the Find tab selected, depending on which one was last used. Enter an empty string for the Data argument.\n257 - Searches the help index for your keyword (as specified in the Data field) and displays the first topic in the index with an identical match. If there is no match, displays the index with your keyword already entered. To display the index without passing a keyword, enter an empty string for the Data argument.\n258 - Executes the Help macro string specified in the Data field. Help needs to be running and the help file needs to be open, or the message is ignored.\n260 - Displays, in a pop-up window, the help topic identified by the context string/number in the Data field.\n261 - Searches the help index for your keyword (as specified in the Data field) and displays the first topic in the index with an identical match. If there is no match, displays the index with your keyword already entered. To display the index without passing a keyword, enter an empty string for the Data argument.",
                "paramname": "Command"
            },
            {
                "paramdescription": "The context string/number or keyword of the help topic that is requested.",
                "paramname": "Data"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "WndHelp(sHelpFile, Command, Data)"
    },
    "wndinfo": {
        "doc": "Gets information on the window system (such as the width and height of the various elements displayed by Windows). WndInfo() can also return flags that indicate whether the current version of the Windows operating system is a debugging version, whether a mouse is present, or whether the functions of the left and right mouse buttons have been exchanged.",
        "example": "width = WndInfo(0);        ! get width of screen\nheight = WndInfo(1);    ! get height of screen\nWinPos(width/2, height/2);    ! move window to centre of screen\nmonitors = WndInfo(80);     ! get number of monitors available",
        "name": "WndInfo",
        "params": [
            {
                "paramdescription": "The system measurement to be retrieved. Measurementsare in pixels. The system measurement needs to be one of thefollowing values:\n0 - Width of the screen.\n1 - Height of the screen.\n2 - Width of the arrow bitmap on a vertical scroll bar.\n3 - Height of the arrow bitmap on a horizontal scroll bar.\n4 - Height of the window title. This is the title height plus the height of the window frame that cannot be sized (SM_CYBORDER).\n5 - Width of the window frame that cannot be sized.\n6 - Height of the window frame that cannot be sized.\n7 - Width of the frame when the window has the WS_DLGFRAME style.\n8 - Height of the frame when the window has the WS_DLGFRAME style.\n9 - Height of the scroll box on vertical scroll bar.\n10 - Width of the scroll box (thumb) on horizontal scroll bar.\n12 - Height of the icon.\n13 - Width of the cursor.\n14 - Height of the cursor.\n15 - Height of a single-line menu bar. This is the menu height minus the height of the window frame that cannot be sized (SM_CYBORDER).\n16 - Width of the window client area for a fullscreen window.\n17 - Height of the window client area for a fullscreen window (equivalent to the height of the screen minus the height of the window title).\n18 - Height of a Kanji window.\n19 - Non-zero if the mouse hardware is installed.\n20 - Height of arrow bitmap on a vertical scroll bar.\n21 - Width of arrow bitmap on a horizontal scroll bar.\n22 - Non-zero if the Windows version is a debugging version.\n23 - Non-zero if the left and right mouse buttons are swapped.\n24-27 - Not Used\n28 - Minimum width of the window.\n29 - Minimum height of the window.\n30 - Width of bitmaps contained in the title bar.\n31 - Height of bitmaps contained in the title bar.\n32 - Width of the window frame that can be sized.\n33 - Height of the window frame that can be sized.\n34 - Minimum tracking width of the window.\n35 - Minimum tracking height of the window.\n76 - x co-ordinate of upper left corner of virtual screen\n77 - y co-ordinate of upper left corner of virtual screen\n78 - width of virtual screen\n79 - height of virtual screen\n80 - number of monitors available",
                "paramname": "iType"
            }
        ],
        "returnType": "The system metric information.",
        "syntax": "WndInfo(iType)"
    },
    "wndmonitorinfo": {
        "doc": "Returns information about a particular monitor.",
        "example": "No example found",
        "name": "WndMonitorInfo",
        "params": [
            {
                "paramdescription": "Monitor Number 1 to n, where n is the number of monitors returned from WndInfo(80). Using 0 will return the value for the virtual screen. Using an unsupported monitor number (0 or n) will return -1 for all values.",
                "paramname": "iMonitor"
            },
            {
                "paramdescription": "Type The monitor measurement to be retrieved:\n0 - x co-ordinate of upper left corner of monitor.\n1 - y co-ordinate of upper left corner of monitor.\n2 - width of monitor.\n3 - height of monitor.\n4 - x co-ordinate of upper left corner of monitor working area.\n5 - y co-ordinate of upper left corner of monitor working area.\n6 - width of monitor working area.\n7 - height of monitor working area.",
                "paramname": "iType"
            }
        ],
        "returnType": "Requested information about the selected monitor. ",
        "syntax": "WndMonitorInfo(iMonitor, iType)"
    },
    "wndmonitorinfoex": {
        "doc": "Returns information about a particular monitor using the screen name of the screen profile.",
        "example": "No example found",
        "name": "WndMonitorInfoEx",
        "params": [
            {
                "paramdescription": "Screen profile's screen name. ",
                "paramname": "sMonitor"
            },
            {
                "paramdescription": "Type The monitor measurement to be retrieved:\n0 - x co-ordinate of upper left corner of monitor.\n1 - y co-ordinate of upper left corner of monitor.\n2 - width of monitor.\n3 - height of monitor.\n4 - x co-ordinate of upper left corner of monitor working area.\n5 - y co-ordinate of upper left corner of monitor working area.\n6 - width of monitor working area.\n7 - height of monitor working area.",
                "paramname": "iType"
            }
        ],
        "returnType": "Requested information about the selected monitor. ",
        "syntax": "WndMonitorInfoEx(sMonitor, iType)"
    },
    "wndputfileprofile": {
        "doc": "Puts a profile string into any .INI file.",
        "example": "WndPutFileProfile(Name(), \"What\", \"100\", \"USER.INI\");",
        "name": "WndPutFileProfile",
        "params": [
            {
                "paramdescription": "The name of the [group].",
                "paramname": "sGroup"
            },
            {
                "paramdescription": "The name of the variable.",
                "paramname": "sName"
            },
            {
                "paramdescription": "The variable data.",
                "paramname": "sData"
            },
            {
                "paramdescription": "The .INI file name.",
                "paramname": "sFile"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "WndPutFileProfile(sGroup, sName, sData, sFile)"
    },
    "wndshow": {
        "doc": "Sets the display mode of any window of any application.",
        "example": "WndShow(WndFind(\"Microsoft Excel\"), 0);\n! Hides the \"Microsoft Excel\" window.",
        "name": "WndShow",
        "params": [
            {
                "paramdescription": "The Windows handle of the window (returned from the WndFind() function). Be aware that this is not the same as a Plant SCADA window number returned from the WinNumber() function.",
                "paramname": "hWnd"
            },
            {
                "paramdescription": "The window mode:\n0 - Hide the window.\n1 - Activate the window in normal mode.\n2 - Activate the window in an iconized state.\n3 - Activate the window in a maximized state.\n4 - Display the window in its previous state without activating it.\n5 - Activate the window in its current state.\n6 - Iconize the window.\n7 - Display the window in an iconized state without activating it.\n8 - Display the window in its current state without activating it.\n9 - Activate the window in its previous state.",
                "paramname": "nMode"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "WndShow(hWnd, nMode)"
    },
    "wndviewer": {
        "doc": "Invokes the Microsoft Multimedia application.",
        "example": "WndViewer(\"MyFile.MVB\",1, \"Contents\");\n! Displays the contents topic in the Multimedia file \"MyFile.MVB\".\nWndViewer(\"HelpFile.MVB\",2, \"HelpTip\");\n! Displays the HelpTip topic in the Multimedia file \"HelpFile.MVB\" \nin a popup.",
        "name": "WndViewer",
        "params": [
            {
                "paramdescription": "The Multimedia Viewer file to display.",
                "paramname": "sViewerFile"
            },
            {
                "paramdescription": "The type of help:\n1 - Displays a Viewer topic (specified in the Data field) in the main Viewer window.\n2 - Displays a Viewer topic (specified in the Data field) in a pop-up window.",
                "paramname": "Command"
            },
            {
                "paramdescription": "The context string of the Multimedia Viewer topic.",
                "paramname": "Data"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "WndViewer(sViewerFile, Command, Data)"
    },
    "xmlclose": {
        "doc": "Use this function to delete an XML document in memory.",
        "example": "INT hDoc=XMLCreate(\"shapes\",\"http://mycompany.com/shapes/v1\");\nXMLClose(hDoc);\t\t",
        "name": "XMLClose",
        "params": [
            {
                "paramdescription": "Handle of the XML document. Returned by XMLCreate or XMLOpen.",
                "paramname": "hDoc"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "INT XMLClose(INT hDoc)"
    },
    "xmlcreate": {
        "doc": "Use this function to create  a new XML document in memory.",
        "example": "INT hDoc=XMLCreate(\"shapes\",\"http://mycompany.com/shapes/v1\");\n\t\t",
        "name": "XMLCreate",
        "params": [
            {
                "paramdescription": "Root element of the XML document.",
                "paramname": "sRootElement"
            },
            {
                "paramdescription": "Optional. Namespace URI of root element.",
                "paramname": "sNamespace"
            }
        ],
        "returnType": "Handle of XML document, or returns -1 on error",
        "syntax": "INT XMLCreate(STRING sRootElement, STRING sNamespace = \"\")"
    },
    "xmlgetattribute": {
        "doc": "Retrieves the attribute value of the node from an XML document in memory.",
        "example": "INT hDoc, hNode;\nSTRING sValue;\nhDoc=XMLOpen(\"H:\\Data\\books.xml\");\nIF hDoc <> -1 THEN\n\thNode = XMLNodeFind(hDoc,\"/bookstore/book/\");\t\t\n\tIF hDoc <> -1 THEN\n\t\tsValue=XMLGetAttribute(hDoc,hNode,\"Language\");\n\tEnd\nEnd\t\t",
        "name": "XMLGetAttribute",
        "params": [
            {
                "paramdescription": "Handle of the XML document. Returned by XMLCreate or XMLOpen.",
                "paramname": "hDoc"
            },
            {
                "paramdescription": "Handle of the node. Returned by XMLGetRoot, XMLGetChild, XMLGetParent or XMLNodeFind.",
                "paramname": "hNode"
            },
            {
                "paramdescription": "Name of attribute.",
                "paramname": "sAttributeName"
            }
        ],
        "returnType": "Value of specified node's attribute",
        "syntax": "INT XMLGetAttribute(INT hDoc, INT hNode, STRING sAttributeName)\t\t"
    },
    "xmlgetattributecount": {
        "doc": "Gets number of attribute of specified XML node.",
        "example": "INT hDoc, hNode;\nINT nCount;\nhDoc=XMLOpen(\"H:\\Data\\books.xml\");\nIF hDoc <> -1 THEN\n\thNode = XMLNodeFind(hDoc,\"/bookstore/book/\");\t\t\n\tIF hDoc <> -1 THEN\n\t\tnCount=XMLGetAttributeCount(hDoc,hNode);\n\tEnd\nEnd\t\t",
        "name": "XMLGetAttributeCount",
        "params": [
            {
                "paramdescription": "Handle of the XML document. Returned by XMLCreate or XMLOpen.",
                "paramname": "hDoc"
            },
            {
                "paramdescription": "Handle of the node. Returned by XMLGetRoot, XMLGetChild, XMLGetParent or XMLNodeFind.",
                "paramname": "hNode"
            }
        ],
        "returnType": "Number of attribute of specified node.",
        "syntax": "INT XMLGetAttributeCount(INT hDoc, INT hNode)\t\t"
    },
    "xmlgetattributename": {
        "doc": "Gets name of specified XML Node’s attribute by using attribute index.",
        "example": "INT hDoc, hNode;\nSTRING sName;\nhDoc=XMLOpen(\"H:\\Data\\books.xml\");\nIF hDoc <> -1 THEN\n\thNode = XMLNodeFind(hDoc,\"/bookstore/book/\");\t\t\n\tIF hNode <> -1 THEN\n\t\tsName=XMLGetAttributeName(hDoc,hNode,0);\n\tEnd\nEnd\t\t",
        "name": "XMLGetAttributeName",
        "params": [
            {
                "paramdescription": "Handle of the XML document. Returned by XMLCreate or XMLOpen.",
                "paramname": "hDoc"
            },
            {
                "paramdescription": "Handle of the node. Returned by XMLGetRoot, XMLGetChild, XMLGetParent or XMLNodeFind.",
                "paramname": "hNode"
            },
            {
                "paramdescription": "The attribute index.",
                "paramname": "iAttribute"
            }
        ],
        "returnType": "Name of specified node's attribute",
        "syntax": "STRING XMLGetAttributeName(INT hDoc, INT hNode, INT iAttribute)\t\t"
    },
    "xmlgetattributevalue": {
        "doc": "Gets the value of the specified XML node's attribute by using attribute index.",
        "example": "INT hDoc, hNode;\nSTRING sValue;\nhDoc=XMLOpen(\"H:\\Data\\books.xml\");\nIF hDoc <> -1 THEN\n\thNode = XMLNodeFind(hDoc,\"/bookstore/book/\");\t\t\n\tIF hNode <> -1 THEN\n\t\tsValue=XMLGetAttributeValue(hDoc,hNode,0);\n\tEnd\nEnd\t\t",
        "name": "XMLGetAttributeValue",
        "params": [
            {
                "paramdescription": "Handle of the XML document. Returned by XMLCreate or XMLOpen.",
                "paramname": "hDoc"
            },
            {
                "paramdescription": "Handle of the node. Returned by XMLGetRoot, XMLGetChild, XMLGetParent or XMLNodeFind.",
                "paramname": "hNode"
            },
            {
                "paramdescription": "The attribute index.",
                "paramname": "iAttribute"
            }
        ],
        "returnType": "Value of specified node’s attribute.",
        "syntax": "STRING  XMLGetAttributeValue(INT hDoc, INT hNode, INT iAttribute)\t\t"
    },
    "xmlgetchild": {
        "doc": "Retrieves the child node for the specified parent node in XML document in memory.",
        "example": "\tINT hDoc, hRoot, hChild;\n\thDoc = XMLOpen(\"H:\\Data\\books.xml\");\n\tIF hDoc <> -1 THEN\n\t\thRoot = XMLGetRoot(hDoc);\n\t\tIF hRoot <> -1 THEN\n\t\t\thChild = XMLGetChild(hDoc,hRoot,0);\n\t\tEnd\n\tEnd  \n\t\t\t",
        "name": "XMLGetChild",
        "params": [
            {
                "paramdescription": "Handle of the XML document the parent node belongs to. Returned by XMLCreate or XMLOpen.",
                "paramname": "hDoc"
            },
            {
                "paramdescription": "Handle of the parent node. Returned by XMLGetRoot, XMLGetChild, XMLGetParent or XMLNodeFind.",
                "paramname": "hNode"
            },
            {
                "paramdescription": "The child index. ",
                "paramname": "iChild"
            }
        ],
        "returnType": "Handle of child node, or -1 on error",
        "syntax": "INT XMLGetChild(INT hDoc, INT hNode, INT iChild)\t\t"
    },
    "xmlgetchildcount": {
        "doc": "Retrieves the total number of child nodes for the specified parent node in an XML document in memory.",
        "example": "INT hDoc, hNode;\nINT nCount;\nhDoc=XMLOpen(\"H:\\Data\\books.xml\");\nIF hDoc <> -1 THEN\n\thNode = XMLNodeFind(hDoc,\"/bookstore/book/\");\t\t\n\tIF hDoc <> -1 THEN\n\t\tnCount=XMLGetChildCount(hDoc,hNode);\n\tEnd\nEnd\t\t",
        "name": "XMLGetChildCount",
        "params": [
            {
                "paramdescription": "Handle of the XML document the parent node belongs to. Returned by XMLCreate or XMLOpen.",
                "paramname": "hDoc"
            },
            {
                "paramdescription": "Handle of the parent node. Returned by XMLGetRoot, XMLGetChild, XMLGetParent or XMLNodeFind.",
                "paramname": "hNode"
            }
        ],
        "returnType": "Number of child nodes, or -1 on error",
        "syntax": "INT XMLGetChildCount(INT hDoc, INT hNode)\t\t"
    },
    "xmlgetparent": {
        "doc": "Gets the parent of specified node. If specified node is the root node in the tree, the parent is the document node.",
        "example": "INT hDoc, hNode, hParent;\nhDoc=XMLOpen(\"H:\\Data\\books.xml\");\nIf hDoc <> -1 THEN\n\thNode=XMLNodeFind(hDoc,\"/bookstore/book/\");",
        "name": "XMLGetParent",
        "params": [
            {
                "paramdescription": "Handle of the XML document. Returned by XMLCreate or XMLOpen.",
                "paramname": "hDoc"
            },
            {
                "paramdescription": "Handle of the node. Returned by XMLGetRoot, XMLGetChild, XMLGetParent or XMLNodeFind.",
                "paramname": "hNode"
            }
        ],
        "returnType": "Handle of parent node, or error will be returned",
        "syntax": "INT XMLGetParent(INT hDoc, INT hNode)\t\t"
    },
    "xmlgetroot": {
        "doc": "Gets the root element of the specified XML document.",
        "example": "INT hDoc, hRoot;\nhDoc=XMLOpen(\"H:\\Data\\books.xml\");\nIf hDoc <> -1 THEN\n\thRoot=XMLGetRoot(hDoc);\nEnd\t\t\n\t",
        "name": "XMLGetRoot",
        "params": [
            {
                "paramdescription": "Handle of the XML document. Returned by XMLCreate or XMLOpen.",
                "paramname": "hDoc"
            }
        ],
        "returnType": "Handle of root element, or-1 on error.",
        "syntax": "INT XMLGetRoot(INT hDoc)\t\t"
    },
    "xmlnodeaddchild": {
        "doc": "Creates an element node with the specified Name and Namespace and appends the node to the end of the list of child nodes of specified parent node in the XML document.",
        "example": "\t\tINT hDoc, hRoot, hNode;\n\t\thDoc = XMLCreate(\"shapes\",  \"http://mycompany.com/shapes/v1\");\n\t\tIF hDoc <> -1 THEN\n\t\t\thRoot = XMLGetRoot(hDoc);\n\t\t\tIF hRoot <> -1 THEN\n\t\t\t\thNode = XMLNodeAddChild(hDoc, hRoot, \"polygons\");\n\t\t\t\tIF hNode <> -1 THEN\n\t\t\t\t\tXMLNodeAddChild(hDoc, hNode, \"polygon\");\n\t\t\t\t\tXMLNodeAddChild(hDoc, hNode, \"polygon\");\n\t\t\t\tEND\n\t\t\tEND\n\t\tEND\n\n\t\t\t",
        "name": "XMLNodeAddChild",
        "params": [
            {
                "paramdescription": "Handle of the XML document the parent node belongs to. Returned by XMLCreate or XMLOpen.",
                "paramname": "hDoc"
            },
            {
                "paramdescription": "Handle of the parent node.e.g. <shapes>, <polygons>, <polygon>. Returned by XMLGetRoot, XMLGetChild, XMLGetParent or XMLNodeFind.",
                "paramname": "hNode"
            },
            {
                "paramdescription": "The qualified name of the new element node.",
                "paramname": "sName"
            },
            {
                "paramdescription": "Optional parameter. The namespace URI of the new node. For example, <shapes xmlns=\"http://mycompany.com/shapes/v1\">.",
                "paramname": "sNamespace"
            }
        ],
        "returnType": "Handle of the newly created node, or -1 on error.",
        "syntax": "INT XMLNodeAddChild(INT hDoc, INT hNode, STRING sName[, STRING sNamespace = \"\"])"
    },
    "xmlnodefind": {
        "doc": "Use this function to select the first XML node that matches the XPath expression.",
        "example": " \nINT hDoc, hNode;\nhDoc=XMLOpen(\"H:\\data\\books.xml\");\nIF hDoc <> -1 THEN\n\thNode=XMLNodeFind(hDoc,\"/bookstore/book/\");\nEnd\n\t\t\t",
        "name": "XMLNodeFind",
        "params": [
            {
                "paramdescription": "Handle of the XML document. Returned by XMLCreate or XMLOpen.",
                "paramname": "hDoc"
            },
            {
                "paramdescription": "XPath Expression",
                "paramname": "sQuery"
            }
        ],
        "returnType": "Handle of the first XML node that matches the XPath expression, or BAD HANDLE on error.",
        "syntax": "INT XMLNodeFind(INT hDoc, STRING sQuery)\t\t"
    },
    "xmlnodegetname": {
        "doc": "Gets the name of the specified node.",
        "example": "INT hDoc, hNode;\nSTRING sName;\nhDoc=XMLOpen(\"H:\\Data\\books.xml\");\nIF hDoc <> -1 THEN\n\thNode = XMLNodeFind(hDoc,\"/bookstore/book/\");\t\t\n\tIF hDoc <> -1 THEN\n\t\tsName=XMLNodeGetName(hDoc,hNode);\n\tEnd\nEnd\t\t",
        "name": "XMLNodeGetName",
        "params": [
            {
                "paramdescription": "Handle of the XML document. Returned by XMLCreate or XMLOpen.",
                "paramname": "hDoc"
            },
            {
                "paramdescription": "Handle of the node. Returned by XMLGetRoot, XMLGetChild, XMLGetParent or XMLNodeFind.",
                "paramname": "hNode"
            }
        ],
        "returnType": "Name of specified node.",
        "syntax": "STRING XMLNodeGetName(INT hDoc, INT hNode)\t\t"
    },
    "xmlnodegetvalue": {
        "doc": "Gets the value of the specified node.",
        "example": "INT hDoc, hNode;\nSTRING sValue;\nhDoc=XMLOpen(\"H:\\Data\\books.xml\");\nIF hDoc <> -1 THEN\n\thNode = XMLNodeFind(hDoc,\"/bookstore/book/\");\t\t\n\tIF hDoc <> -1 THEN\n\t\tsValue=XMLNodeGetValue(hDoc,hNode);\n\tEnd\nEnd\t\t",
        "name": "XMLNodeGetValue",
        "params": [
            {
                "paramdescription": "Handle of the XML document. Returned by XMLCreate or XMLOpen.",
                "paramname": "hDoc"
            },
            {
                "paramdescription": "Handle of the node. Returned by XMLGetRoot, XMLGetChild, XMLGetParent or XMLNodeFind.",
                "paramname": "hNode"
            }
        ],
        "returnType": "Value of specified node",
        "syntax": "STRING XMLNodeGetValue(INT hDoc, INT hNode)\t\t"
    },
    "xmlnoderemove": {
        "doc": "Removes the specified XML node from its parent and XML document.",
        "example": "INT hDoc, hNode;\nhDoc=XMLOpen(\"H:\\Data\\books.xml\");\nIF hDoc <> -1 THEN\n\thNode = XMLNodeFind(hDoc,\"/bookstore/book/\");\t\t\n\tIF hDoc <> -1 THEN\n\t\tXMLNodeRemove(hDoc,hNode);\n\tEnd\nEnd\t\t",
        "name": "XMLNodeRemove",
        "params": [
            {
                "paramdescription": "Handle of the XML document. Returned by XMLCreate or XMLOpen.",
                "paramname": "hDoc"
            },
            {
                "paramdescription": "Handle of the node. Returned by XMLGetRoot, XMLGetChild, XMLGetParent or XMLNodeFind.",
                "paramname": "hNode"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "INT XMLNodeRemove(INT hDoc, INT hNode)\t\t"
    },
    "xmlnodesetvalue": {
        "doc": "Sets the value of the specified node.",
        "example": "\t\t\t\t \n\tINT hDoc, hNode;\n\thDoc = XMLOpen(\"H:\\Data\\books.xml\");\t \n\tIF hDoc <> -1 THEN\n\t\thNode=XMLNodeFind(hDoc,\"/bookstore/book/title\");\t\n\t\tIF hNode <>-1 THEN\n\t\t\tXMLNodeSetValue(hDoc,hNode,\"Harry Potter\");\n\t\tEnd\n\tEnd\t",
        "name": "XMLNodeSetValue",
        "params": [
            {
                "paramdescription": "Handle of the XML document the parent node belongs to. Returned by XMLCreate or XMLOpen.",
                "paramname": "hDoc"
            },
            {
                "paramdescription": "Handle of the node. Returned by XMLGetRoot, XMLGetChild, XMLGetParent, XMLNodeFind.",
                "paramname": "hNode"
            },
            {
                "paramdescription": "Value of the element node. ",
                "paramname": "sValue"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "INT XMLNodeSetValue(INT hDoc, INT hNode, STRING sValue)\t\t"
    },
    "xmlopen": {
        "doc": "Reads an XML file from disk to create XML document.",
        "example": "INT hDoc, hNode;\nhDoc=XMLOpen(\"H:\\Data\\books.xml\");",
        "name": "XMLOpen",
        "params": [
            {
                "paramdescription": "Absolute path of XML file",
                "paramname": "sFilePath"
            }
        ],
        "returnType": "Handle of the XML document, or -1 on error.",
        "syntax": "INT XMLOpen(STRING sFilePath)\t\t"
    },
    "xmlsave": {
        "doc": "Use this function to save  XML document on disk.",
        "example": "INT hDoc, hNode;\nhdoc=XMLOpen(\"H:\\Data_Backup\\books.xml\");\nIF hDoc <> -1 THEN\n\tXMLSave(hDoc, \"H:\\Data_Backup\\books.xml\");\nEND\n\t\t\t",
        "name": "XMLSave",
        "params": [
            {
                "paramdescription": "Handle of the XML document. Returned by XMLCreate or XMLOpen.",
                "paramname": "hDoc"
            },
            {
                "paramdescription": "Absolute path of the disk file that XML document is written to.",
                "paramname": "sQuery"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "INT XMLSave(INT hDoc, STRING sFilePath)\t\t"
    },
    "xmlsetattribute": {
        "doc": "Use this function to set the value of specified attribute of the node in the XML document. If the attribute does not exist, it will be created.",
        "example": "\t\tINT hDoc, hNode;\n\t\thDoc = XMLOpen(\"H:\\Data\\books.xml\");\n\t\tIF hDoc less -1 THEN\n\t\t\thNode = XMLNodeFind(hDoc,\"/bookstore/book/\");\n\t\t\tIF hNode less -1 THEN\n\t\t\t\tXMLSetAttribute(hDoc,  hNode, \"Language\", \"English\");\t\n\t\t\tEND\n\t\tEND  \n\n\t\t\t",
        "name": "XMLSetAttribute",
        "params": [
            {
                "paramdescription": "Handle of the XML document. Returned by XMLCreate or XMLOpen.",
                "paramname": "hDoc"
            },
            {
                "paramdescription": "Handle of the node. Returned by XMLGetRoot, XMLGetChild, XMLGetParent or XMLNodeFind.",
                "paramname": "hNode"
            },
            {
                "paramdescription": "The name of the attribute.",
                "paramname": "sName"
            },
            {
                "paramdescription": "The value of the attribute ",
                "paramname": "sValue"
            }
        ],
        "returnType": "0 (zero) if successful, otherwise an error code is returned.",
        "syntax": "INT XMLSetAttribute(INT hDoc, INT hNode, STRING sName, STRING sValue)\t\t"
    }
}
